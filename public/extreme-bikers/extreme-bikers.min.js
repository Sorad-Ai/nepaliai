"use strict";
! function(t) {
    function e() {
        for (var t = 0; t < C.length; t++) C[t][0](C[t][1]);
        C = [], y = !1
    }

    function i(t, i) {
        C.push([t, i]), y || (y = !0, x(e, 0))
    }

    function s(t, e) {
        function i(t) {
            h(e, t)
        }
        try {
            t(function(t) {
                a(e, t)
            }, i)
        } catch (t) {
            i(t)
        }
    }

    function o(t) {
        var e = (i = t.owner).state_,
            i = i.data_,
            s = t[e];
        if (t = t.then, "function" == typeof s) {
            e = _;
            try {
                i = s(i)
            } catch (e) {
                h(t, e)
            }
        }
        n(t, i) || (e === _ && a(t, i), e === v && h(t, i))
    }

    function n(t, e) {
        var i;
        try {
            if (t === e) throw new TypeError("A promises callback cannot return that same promise.");
            if (e && ("function" == typeof e || "object" == typeof e)) {
                var s = e.then;
                if ("function" == typeof s) return s.call(e, function(s) {
                    i || (i = !0, e !== s ? a(t, s) : r(t, s))
                }, function(e) {
                    i || (i = !0, h(t, e))
                }), !0
            }
        } catch (e) {
            return i || h(t, e), !0
        }
        return !1
    }

    function a(t, e) {
        t !== e && n(t, e) || r(t, e)
    }

    function r(t, e) {
        t.state_ === f && (t.state_ = g, t.data_ = e, i(c, t))
    }

    function h(t, e) {
        t.state_ === f && (t.state_ = g, t.data_ = e, i(p, t))
    }

    function l(t) {
        var e = t.then_;
        for (t.then_ = void 0, t = 0; t < e.length; t++) o(e[t])
    }

    function c(t) {
        t.state_ = _, l(t)
    }

    function p(t) {
        t.state_ = v, l(t)
    }

    function u(t) {
        if ("function" != typeof t) throw new TypeError("Promise constructor takes a function argument");
        if (!1 == this instanceof u) throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
        this.then_ = [], s(t, this)
    }
    var d = t.Promise,
        m = d && "resolve" in d && "reject" in d && "all" in d && "race" in d && function() {
            var t;
            return new d(function(e) {
                t = e
            }), "function" == typeof t
        }();
    "undefined" != typeof exports && exports ? (exports.Promise = m ? d : u, exports.Polyfill = u) : "function" == typeof define && define.amd ? define(function() {
        return m ? d : u
    }) : m || (t.Promise = u);
    var y, f = "pending",
        g = "sealed",
        _ = "fulfilled",
        v = "rejected",
        b = function() {},
        x = "undefined" != typeof setImmediate ? setImmediate : setTimeout,
        C = [];
    u.prototype = {
        constructor: u,
        state_: f,
        then_: null,
        data_: void 0,
        then: function(t, e) {
            var s = {
                owner: this,
                then: new this.constructor(b),
                fulfilled: t,
                rejected: e
            };
            return this.state_ === _ || this.state_ === v ? i(o, s) : this.then_.push(s), s.then
        },
        catch: function(t) {
            return this.then(null, t)
        }
    }, u.all = function(t) {
        if ("[object Array]" !== Object.prototype.toString.call(t)) throw new TypeError("You must pass an array to Promise.all().");
        return new this(function(e, i) {
            for (var s, o = [], n = 0, a = 0; a < t.length; a++)(s = t[a]) && "function" == typeof s.then ? s.then(function(t) {
                return n++,
                    function(i) {
                        o[t] = i, --n || e(o)
                    }
            }(a), i) : o[a] = s;
            n || e(o)
        })
    }, u.race = function(t) {
        if ("[object Array]" !== Object.prototype.toString.call(t)) throw new TypeError("You must pass an array to Promise.race().");
        return new this(function(e, i) {
            for (var s, o = 0; o < t.length; o++)(s = t[o]) && "function" == typeof s.then ? s.then(e, i) : e(s)
        })
    }, u.resolve = function(t) {
        return t && "object" == typeof t && t.constructor === this ? t : new this(function(e) {
            e(t)
        })
    }, u.reject = function(t) {
        return new this(function(e, i) {
            i(t)
        })
    }
}("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this);
var Box2D = {};
! function(t, e) {
    function i() {}
    t.inherit = function(t, e) {
        var s = t;
        i.prototype = e.prototype, t.prototype = new i, t.prototype.constructor = s
    }, t.generateCallback = function(t, e) {
        return function() {
            e.apply(t, arguments)
        }
    }, t.NVector = function(t) {
        void 0 === t && (t = 0);
        for (var e = new Array(t || 0), i = 0; i < t; ++i) e[i] = 0;
        return e
    }, t.is = function(t, e) {
        return null !== t && (e instanceof Function && t instanceof e || !(void 0 == t.constructor.__implements || !t.constructor.__implements[e]))
    }, t.parseUInt = function(t) {
        return Math.abs(parseInt(t))
    }
}(Box2D);
var Vector = Array,
    Vector_a2j_Number = Box2D.NVector;
void 0 === Box2D && (Box2D = {}), void 0 === Box2D.Collision && (Box2D.Collision = {}), void 0 === Box2D.Collision.Shapes && (Box2D.Collision.Shapes = {}), void 0 === Box2D.Common && (Box2D.Common = {}), void 0 === Box2D.Common.Math && (Box2D.Common.Math = {}), void 0 === Box2D.Dynamics && (Box2D.Dynamics = {}), void 0 === Box2D.Dynamics.Contacts && (Box2D.Dynamics.Contacts = {}), void 0 === Box2D.Dynamics.Controllers && (Box2D.Dynamics.Controllers = {}), void 0 === Box2D.Dynamics.Joints && (Box2D.Dynamics.Joints = {}),
    function() {
        function t() {
            t.b2AABB.apply(this, arguments)
        }

        function e() {
            e.b2Bound.apply(this, arguments)
        }

        function i() {
            i.b2BoundValues.apply(this, arguments), this.constructor === i && this.b2BoundValues.apply(this, arguments)
        }

        function s() {
            s.b2Collision.apply(this, arguments)
        }

        function o() {
            o.b2ContactID.apply(this, arguments), this.constructor === o && this.b2ContactID.apply(this, arguments)
        }

        function n() {
            n.b2ContactPoint.apply(this, arguments)
        }

        function a() {
            a.b2Distance.apply(this, arguments)
        }

        function r() {
            r.b2DistanceInput.apply(this, arguments)
        }

        function h() {
            h.b2DistanceOutput.apply(this, arguments)
        }

        function l() {
            l.b2DistanceProxy.apply(this, arguments)
        }

        function c() {
            c.b2DynamicTree.apply(this, arguments), this.constructor === c && this.b2DynamicTree.apply(this, arguments)
        }

        function p() {
            p.b2DynamicTreeBroadPhase.apply(this, arguments)
        }

        function u() {
            u.b2DynamicTreeNode.apply(this, arguments)
        }

        function d() {
            d.b2DynamicTreePair.apply(this, arguments)
        }

        function m() {
            m.b2Manifold.apply(this, arguments), this.constructor === m && this.b2Manifold.apply(this, arguments)
        }

        function y() {
            y.b2ManifoldPoint.apply(this, arguments), this.constructor === y && this.b2ManifoldPoint.apply(this, arguments)
        }

        function f() {
            f.b2Point.apply(this, arguments)
        }

        function g() {
            g.b2RayCastInput.apply(this, arguments), this.constructor === g && this.b2RayCastInput.apply(this, arguments)
        }

        function _() {
            _.b2RayCastOutput.apply(this, arguments)
        }

        function v() {
            v.b2Segment.apply(this, arguments)
        }

        function b() {
            b.b2SeparationFunction.apply(this, arguments)
        }

        function x() {
            x.b2Simplex.apply(this, arguments), this.constructor === x && this.b2Simplex.apply(this, arguments)
        }

        function C() {
            C.b2SimplexCache.apply(this, arguments)
        }

        function S() {
            S.b2SimplexVertex.apply(this, arguments)
        }

        function w() {
            w.b2TimeOfImpact.apply(this, arguments)
        }

        function A() {
            A.b2TOIInput.apply(this, arguments)
        }

        function T() {
            T.b2WorldManifold.apply(this, arguments), this.constructor === T && this.b2WorldManifold.apply(this, arguments)
        }

        function B() {
            B.ClipVertex.apply(this, arguments)
        }

        function P() {
            P.Features.apply(this, arguments)
        }

        function D() {
            D.b2CircleShape.apply(this, arguments), this.constructor === D && this.b2CircleShape.apply(this, arguments)
        }

        function I() {
            I.b2EdgeChainDef.apply(this, arguments), this.constructor === I && this.b2EdgeChainDef.apply(this, arguments)
        }

        function E() {
            E.b2EdgeShape.apply(this, arguments), this.constructor === E && this.b2EdgeShape.apply(this, arguments)
        }

        function L() {
            L.b2MassData.apply(this, arguments)
        }

        function M() {
            M.b2PolygonShape.apply(this, arguments), this.constructor === M && this.b2PolygonShape.apply(this, arguments)
        }

        function G() {
            G.b2Shape.apply(this, arguments), this.constructor === G && this.b2Shape.apply(this, arguments)
        }

        function O() {
            O.b2Color.apply(this, arguments), this.constructor === O && this.b2Color.apply(this, arguments)
        }

        function R() {
            R.b2Settings.apply(this, arguments)
        }

        function k() {
            k.b2Mat22.apply(this, arguments), this.constructor === k && this.b2Mat22.apply(this, arguments)
        }

        function F() {
            F.b2Mat33.apply(this, arguments), this.constructor === F && this.b2Mat33.apply(this, arguments)
        }

        function N() {
            N.b2Math.apply(this, arguments)
        }

        function V() {
            V.b2Sweep.apply(this, arguments)
        }

        function U() {
            U.b2Transform.apply(this, arguments), this.constructor === U && this.b2Transform.apply(this, arguments)
        }

        function W() {
            W.b2Vec2.apply(this, arguments), this.constructor === W && this.b2Vec2.apply(this, arguments)
        }

        function j() {
            j.b2Vec3.apply(this, arguments), this.constructor === j && this.b2Vec3.apply(this, arguments)
        }

        function X() {
            X.b2Body.apply(this, arguments), this.constructor === X && this.b2Body.apply(this, arguments)
        }

        function K() {
            K.b2BodyDef.apply(this, arguments), this.constructor === K && this.b2BodyDef.apply(this, arguments)
        }

        function H() {
            H.b2ContactFilter.apply(this, arguments)
        }

        function q() {
            q.b2ContactImpulse.apply(this, arguments)
        }

        function J() {
            J.b2ContactListener.apply(this, arguments)
        }

        function z() {
            z.b2ContactManager.apply(this, arguments), this.constructor === z && this.b2ContactManager.apply(this, arguments)
        }

        function Y() {
            Y.b2DebugDraw.apply(this, arguments), this.constructor === Y && this.b2DebugDraw.apply(this, arguments)
        }

        function Z() {
            Z.b2DestructionListener.apply(this, arguments)
        }

        function Q() {
            Q.b2FilterData.apply(this, arguments)
        }

        function $() {
            $.b2Fixture.apply(this, arguments), this.constructor === $ && this.b2Fixture.apply(this, arguments)
        }

        function tt() {
            tt.b2FixtureDef.apply(this, arguments), this.constructor === tt && this.b2FixtureDef.apply(this, arguments)
        }

        function et() {
            et.b2Island.apply(this, arguments), this.constructor === et && this.b2Island.apply(this, arguments)
        }

        function it() {
            it.b2TimeStep.apply(this, arguments)
        }

        function st() {
            st.b2World.apply(this, arguments), this.constructor === st && this.b2World.apply(this, arguments)
        }

        function ot() {
            ot.b2CircleContact.apply(this, arguments)
        }

        function nt() {
            nt.b2Contact.apply(this, arguments), this.constructor === nt && this.b2Contact.apply(this, arguments)
        }

        function at() {
            at.b2ContactConstraint.apply(this, arguments), this.constructor === at && this.b2ContactConstraint.apply(this, arguments)
        }

        function rt() {
            rt.b2ContactConstraintPoint.apply(this, arguments)
        }

        function ht() {
            ht.b2ContactEdge.apply(this, arguments)
        }

        function lt() {
            lt.b2ContactFactory.apply(this, arguments), this.constructor === lt && this.b2ContactFactory.apply(this, arguments)
        }

        function ct() {
            ct.b2ContactRegister.apply(this, arguments)
        }

        function pt() {
            pt.b2ContactResult.apply(this, arguments)
        }

        function ut() {
            ut.b2ContactSolver.apply(this, arguments), this.constructor === ut && this.b2ContactSolver.apply(this, arguments)
        }

        function dt() {
            dt.b2EdgeAndCircleContact.apply(this, arguments)
        }

        function mt() {
            mt.b2NullContact.apply(this, arguments), this.constructor === mt && this.b2NullContact.apply(this, arguments)
        }

        function yt() {
            yt.b2PolyAndCircleContact.apply(this, arguments)
        }

        function ft() {
            ft.b2PolyAndEdgeContact.apply(this, arguments)
        }

        function gt() {
            gt.b2PolygonContact.apply(this, arguments)
        }

        function _t() {
            _t.b2PositionSolverManifold.apply(this, arguments), this.constructor === _t && this.b2PositionSolverManifold.apply(this, arguments)
        }

        function vt() {
            vt.b2BuoyancyController.apply(this, arguments)
        }

        function bt() {
            bt.b2ConstantAccelController.apply(this, arguments)
        }

        function xt() {
            xt.b2ConstantForceController.apply(this, arguments)
        }

        function Ct() {
            Ct.b2Controller.apply(this, arguments)
        }

        function St() {
            St.b2ControllerEdge.apply(this, arguments)
        }

        function wt() {
            wt.b2GravityController.apply(this, arguments)
        }

        function At() {
            At.b2TensorDampingController.apply(this, arguments)
        }

        function Tt() {
            Tt.b2DistanceJoint.apply(this, arguments), this.constructor === Tt && this.b2DistanceJoint.apply(this, arguments)
        }

        function Bt() {
            Bt.b2DistanceJointDef.apply(this, arguments), this.constructor === Bt && this.b2DistanceJointDef.apply(this, arguments)
        }

        function Pt() {
            Pt.b2FrictionJoint.apply(this, arguments), this.constructor === Pt && this.b2FrictionJoint.apply(this, arguments)
        }

        function Dt() {
            Dt.b2FrictionJointDef.apply(this, arguments), this.constructor === Dt && this.b2FrictionJointDef.apply(this, arguments)
        }

        function It() {
            It.b2GearJoint.apply(this, arguments), this.constructor === It && this.b2GearJoint.apply(this, arguments)
        }

        function Et() {
            Et.b2GearJointDef.apply(this, arguments), this.constructor === Et && this.b2GearJointDef.apply(this, arguments)
        }

        function Lt() {
            Lt.b2Jacobian.apply(this, arguments)
        }

        function Mt() {
            Mt.b2Joint.apply(this, arguments), this.constructor === Mt && this.b2Joint.apply(this, arguments)
        }

        function Gt() {
            Gt.b2JointDef.apply(this, arguments), this.constructor === Gt && this.b2JointDef.apply(this, arguments)
        }

        function Ot() {
            Ot.b2JointEdge.apply(this, arguments)
        }

        function Rt() {
            Rt.b2LineJoint.apply(this, arguments), this.constructor === Rt && this.b2LineJoint.apply(this, arguments)
        }

        function kt() {
            kt.b2LineJointDef.apply(this, arguments), this.constructor === kt && this.b2LineJointDef.apply(this, arguments)
        }

        function Ft() {
            Ft.b2MouseJoint.apply(this, arguments), this.constructor === Ft && this.b2MouseJoint.apply(this, arguments)
        }

        function Nt() {
            Nt.b2MouseJointDef.apply(this, arguments), this.constructor === Nt && this.b2MouseJointDef.apply(this, arguments)
        }

        function Vt() {
            Vt.b2PrismaticJoint.apply(this, arguments), this.constructor === Vt && this.b2PrismaticJoint.apply(this, arguments)
        }

        function Ut() {
            Ut.b2PrismaticJointDef.apply(this, arguments), this.constructor === Ut && this.b2PrismaticJointDef.apply(this, arguments)
        }

        function Wt() {
            Wt.b2PulleyJoint.apply(this, arguments), this.constructor === Wt && this.b2PulleyJoint.apply(this, arguments)
        }

        function jt() {
            jt.b2PulleyJointDef.apply(this, arguments), this.constructor === jt && this.b2PulleyJointDef.apply(this, arguments)
        }

        function Xt() {
            Xt.b2RevoluteJoint.apply(this, arguments), this.constructor === Xt && this.b2RevoluteJoint.apply(this, arguments)
        }

        function Kt() {
            Kt.b2RevoluteJointDef.apply(this, arguments), this.constructor === Kt && this.b2RevoluteJointDef.apply(this, arguments)
        }

        function Ht() {
            Ht.b2WeldJoint.apply(this, arguments), this.constructor === Ht && this.b2WeldJoint.apply(this, arguments)
        }

        function qt() {
            qt.b2WeldJointDef.apply(this, arguments), this.constructor === qt && this.b2WeldJointDef.apply(this, arguments)
        }
        Box2D.Collision.IBroadPhase = "Box2D.Collision.IBroadPhase", Box2D.Collision.b2AABB = t, Box2D.Collision.b2Bound = e, Box2D.Collision.b2BoundValues = i, Box2D.Collision.b2Collision = s, Box2D.Collision.b2ContactID = o, Box2D.Collision.b2ContactPoint = n, Box2D.Collision.b2Distance = a, Box2D.Collision.b2DistanceInput = r, Box2D.Collision.b2DistanceOutput = h, Box2D.Collision.b2DistanceProxy = l, Box2D.Collision.b2DynamicTree = c, Box2D.Collision.b2DynamicTreeBroadPhase = p, Box2D.Collision.b2DynamicTreeNode = u, Box2D.Collision.b2DynamicTreePair = d, Box2D.Collision.b2Manifold = m, Box2D.Collision.b2ManifoldPoint = y, Box2D.Collision.b2Point = f, Box2D.Collision.b2RayCastInput = g, Box2D.Collision.b2RayCastOutput = _, Box2D.Collision.b2Segment = v, Box2D.Collision.b2SeparationFunction = b, Box2D.Collision.b2Simplex = x, Box2D.Collision.b2SimplexCache = C, Box2D.Collision.b2SimplexVertex = S, Box2D.Collision.b2TimeOfImpact = w, Box2D.Collision.b2TOIInput = A, Box2D.Collision.b2WorldManifold = T, Box2D.Collision.ClipVertex = B, Box2D.Collision.Features = P, Box2D.Collision.Shapes.b2CircleShape = D, Box2D.Collision.Shapes.b2EdgeChainDef = I, Box2D.Collision.Shapes.b2EdgeShape = E, Box2D.Collision.Shapes.b2MassData = L, Box2D.Collision.Shapes.b2PolygonShape = M, Box2D.Collision.Shapes.b2Shape = G, Box2D.Common.b2internal = "Box2D.Common.b2internal", Box2D.Common.b2Color = O, Box2D.Common.b2Settings = R, Box2D.Common.Math.b2Mat22 = k, Box2D.Common.Math.b2Mat33 = F, Box2D.Common.Math.b2Math = N, Box2D.Common.Math.b2Sweep = V, Box2D.Common.Math.b2Transform = U, Box2D.Common.Math.b2Vec2 = W, Box2D.Common.Math.b2Vec3 = j, Box2D.Dynamics.b2Body = X, Box2D.Dynamics.b2BodyDef = K, Box2D.Dynamics.b2ContactFilter = H, Box2D.Dynamics.b2ContactImpulse = q, Box2D.Dynamics.b2ContactListener = J, Box2D.Dynamics.b2ContactManager = z, Box2D.Dynamics.b2DebugDraw = Y, Box2D.Dynamics.b2DestructionListener = Z, Box2D.Dynamics.b2FilterData = Q, Box2D.Dynamics.b2Fixture = $, Box2D.Dynamics.b2FixtureDef = tt, Box2D.Dynamics.b2Island = et, Box2D.Dynamics.b2TimeStep = it, Box2D.Dynamics.b2World = st, Box2D.Dynamics.Contacts.b2CircleContact = ot, Box2D.Dynamics.Contacts.b2Contact = nt, Box2D.Dynamics.Contacts.b2ContactConstraint = at, Box2D.Dynamics.Contacts.b2ContactConstraintPoint = rt, Box2D.Dynamics.Contacts.b2ContactEdge = ht, Box2D.Dynamics.Contacts.b2ContactFactory = lt, Box2D.Dynamics.Contacts.b2ContactRegister = ct, Box2D.Dynamics.Contacts.b2ContactResult = pt, Box2D.Dynamics.Contacts.b2ContactSolver = ut, Box2D.Dynamics.Contacts.b2EdgeAndCircleContact = dt, Box2D.Dynamics.Contacts.b2NullContact = mt, Box2D.Dynamics.Contacts.b2PolyAndCircleContact = yt, Box2D.Dynamics.Contacts.b2PolyAndEdgeContact = ft, Box2D.Dynamics.Contacts.b2PolygonContact = gt, Box2D.Dynamics.Contacts.b2PositionSolverManifold = _t, Box2D.Dynamics.Controllers.b2BuoyancyController = vt, Box2D.Dynamics.Controllers.b2ConstantAccelController = bt, Box2D.Dynamics.Controllers.b2ConstantForceController = xt, Box2D.Dynamics.Controllers.b2Controller = Ct, Box2D.Dynamics.Controllers.b2ControllerEdge = St, Box2D.Dynamics.Controllers.b2GravityController = wt, Box2D.Dynamics.Controllers.b2TensorDampingController = At, Box2D.Dynamics.Joints.b2DistanceJoint = Tt, Box2D.Dynamics.Joints.b2DistanceJointDef = Bt, Box2D.Dynamics.Joints.b2FrictionJoint = Pt, Box2D.Dynamics.Joints.b2FrictionJointDef = Dt, Box2D.Dynamics.Joints.b2GearJoint = It, Box2D.Dynamics.Joints.b2GearJointDef = Et, Box2D.Dynamics.Joints.b2Jacobian = Lt, Box2D.Dynamics.Joints.b2Joint = Mt, Box2D.Dynamics.Joints.b2JointDef = Gt, Box2D.Dynamics.Joints.b2JointEdge = Ot, Box2D.Dynamics.Joints.b2LineJoint = Rt, Box2D.Dynamics.Joints.b2LineJointDef = kt, Box2D.Dynamics.Joints.b2MouseJoint = Ft, Box2D.Dynamics.Joints.b2MouseJointDef = Nt, Box2D.Dynamics.Joints.b2PrismaticJoint = Vt, Box2D.Dynamics.Joints.b2PrismaticJointDef = Ut, Box2D.Dynamics.Joints.b2PulleyJoint = Wt, Box2D.Dynamics.Joints.b2PulleyJointDef = jt, Box2D.Dynamics.Joints.b2RevoluteJoint = Xt, Box2D.Dynamics.Joints.b2RevoluteJointDef = Kt, Box2D.Dynamics.Joints.b2WeldJoint = Ht, Box2D.Dynamics.Joints.b2WeldJointDef = qt
    }(), Box2D.postDefs = [],
    function() {
        var t = Box2D.Collision.Shapes.b2CircleShape,
            e = (Box2D.Collision.Shapes.b2EdgeChainDef, Box2D.Collision.Shapes.b2EdgeShape, Box2D.Collision.Shapes.b2MassData, Box2D.Collision.Shapes.b2PolygonShape),
            i = Box2D.Collision.Shapes.b2Shape,
            s = (Box2D.Common.b2Color, Box2D.Common.b2internal, Box2D.Common.b2Settings),
            o = (Box2D.Common.Math.b2Mat22, Box2D.Common.Math.b2Mat33, Box2D.Common.Math.b2Math),
            n = Box2D.Common.Math.b2Sweep,
            a = Box2D.Common.Math.b2Transform,
            r = Box2D.Common.Math.b2Vec2,
            h = (Box2D.Common.Math.b2Vec3, Box2D.Collision.b2AABB),
            l = Box2D.Collision.b2Bound,
            c = Box2D.Collision.b2BoundValues,
            p = Box2D.Collision.b2Collision,
            u = Box2D.Collision.b2ContactID,
            d = Box2D.Collision.b2ContactPoint,
            m = Box2D.Collision.b2Distance,
            y = Box2D.Collision.b2DistanceInput,
            f = Box2D.Collision.b2DistanceOutput,
            g = Box2D.Collision.b2DistanceProxy,
            _ = Box2D.Collision.b2DynamicTree,
            v = Box2D.Collision.b2DynamicTreeBroadPhase,
            b = Box2D.Collision.b2DynamicTreeNode,
            x = Box2D.Collision.b2DynamicTreePair,
            C = Box2D.Collision.b2Manifold,
            S = Box2D.Collision.b2ManifoldPoint,
            w = Box2D.Collision.b2Point,
            A = Box2D.Collision.b2RayCastInput,
            T = Box2D.Collision.b2RayCastOutput,
            B = Box2D.Collision.b2Segment,
            P = Box2D.Collision.b2SeparationFunction,
            D = Box2D.Collision.b2Simplex,
            I = Box2D.Collision.b2SimplexCache,
            E = Box2D.Collision.b2SimplexVertex,
            L = Box2D.Collision.b2TimeOfImpact,
            M = Box2D.Collision.b2TOIInput,
            G = Box2D.Collision.b2WorldManifold,
            O = Box2D.Collision.ClipVertex,
            R = Box2D.Collision.Features,
            k = Box2D.Collision.IBroadPhase;
        h.b2AABB = function() {
            this.lowerBound = new r, this.upperBound = new r
        }, h.prototype.IsValid = function() {
            var t = this.upperBound.x - this.lowerBound.x,
                e = this.upperBound.y - this.lowerBound.y,
                i = t >= 0 && e >= 0;
            return i = i && this.lowerBound.IsValid() && this.upperBound.IsValid()
        }, h.prototype.GetCenter = function() {
            return new r((this.lowerBound.x + this.upperBound.x) / 2, (this.lowerBound.y + this.upperBound.y) / 2)
        }, h.prototype.GetExtents = function() {
            return new r((this.upperBound.x - this.lowerBound.x) / 2, (this.upperBound.y - this.lowerBound.y) / 2)
        }, h.prototype.Contains = function(t) {
            var e = !0;
            return e = e && this.lowerBound.x <= t.lowerBound.x, e = e && this.lowerBound.y <= t.lowerBound.y, e = e && t.upperBound.x <= this.upperBound.x, e = e && t.upperBound.y <= this.upperBound.y
        }, h.prototype.RayCast = function(t, e) {
            var i = -Number.MAX_VALUE,
                s = Number.MAX_VALUE,
                o = e.p1.x,
                n = e.p1.y,
                a = e.p2.x - e.p1.x,
                r = e.p2.y - e.p1.y,
                h = Math.abs(a),
                l = Math.abs(r),
                c = t.normal,
                p = 0,
                u = 0,
                d = 0,
                m = 0,
                y = 0;
            if (h < Number.MIN_VALUE) {
                if (o < this.lowerBound.x || this.upperBound.x < o) return !1
            } else if (p = 1 / a, u = (this.lowerBound.x - o) * p, d = (this.upperBound.x - o) * p, y = -1, u > d && (m = u, u = d, d = m, y = 1), u > i && (c.x = y, c.y = 0, i = u), s = Math.min(s, d), i > s) return !1;
            if (l < Number.MIN_VALUE) {
                if (n < this.lowerBound.y || this.upperBound.y < n) return !1
            } else if (p = 1 / r, u = (this.lowerBound.y - n) * p, d = (this.upperBound.y - n) * p, y = -1, u > d && (m = u, u = d, d = m, y = 1), u > i && (c.y = y, c.x = 0, i = u), s = Math.min(s, d), i > s) return !1;
            return t.fraction = i, !0
        }, h.prototype.TestOverlap = function(t) {
            var e = t.lowerBound.x - this.upperBound.x,
                i = t.lowerBound.y - this.upperBound.y,
                s = this.lowerBound.x - t.upperBound.x,
                o = this.lowerBound.y - t.upperBound.y;
            return !(e > 0 || i > 0) && !(s > 0 || o > 0)
        }, h.Combine = function(t, e) {
            var i = new h;
            return i.Combine(t, e), i
        }, h.prototype.Combine = function(t, e) {
            this.lowerBound.x = Math.min(t.lowerBound.x, e.lowerBound.x), this.lowerBound.y = Math.min(t.lowerBound.y, e.lowerBound.y), this.upperBound.x = Math.max(t.upperBound.x, e.upperBound.x), this.upperBound.y = Math.max(t.upperBound.y, e.upperBound.y)
        }, l.b2Bound = function() {}, l.prototype.IsLower = function() {
            return 0 == (1 & this.value)
        }, l.prototype.IsUpper = function() {
            return 1 == (1 & this.value)
        }, l.prototype.Swap = function(t) {
            var e = this.value,
                i = this.proxy,
                s = this.stabbingCount;
            this.value = t.value, this.proxy = t.proxy, this.stabbingCount = t.stabbingCount, t.value = e, t.proxy = i, t.stabbingCount = s
        }, c.b2BoundValues = function() {}, c.prototype.b2BoundValues = function() {
            this.lowerValues = new Vector_a2j_Number, this.lowerValues[0] = 0, this.lowerValues[1] = 0, this.upperValues = new Vector_a2j_Number, this.upperValues[0] = 0, this.upperValues[1] = 0
        }, p.b2Collision = function() {}, p.ClipSegmentToLine = function(t, e, i, s) {
            void 0 === s && (s = 0);
            var o, n = 0,
                a = (o = e[0]).v,
                r = (o = e[1]).v,
                h = i.x * a.x + i.y * a.y - s,
                l = i.x * r.x + i.y * r.y - s;
            if (h <= 0 && t[n++].Set(e[0]), l <= 0 && t[n++].Set(e[1]), h * l < 0) {
                var c = h / (h - l),
                    p = (o = t[n]).v;
                p.x = a.x + c * (r.x - a.x), p.y = a.y + c * (r.y - a.y), o = t[n];
                var u;
                h > 0 ? (u = e[0], o.id = u.id) : (u = e[1], o.id = u.id), ++n
            }
            return n
        }, p.EdgeSeparation = function(t, e, i, s, o) {
            void 0 === i && (i = 0);
            parseInt(t.m_vertexCount);
            var n, a, r = t.m_vertices,
                h = t.m_normals,
                l = parseInt(s.m_vertexCount),
                c = s.m_vertices;
            n = e.R, a = h[i];
            for (var p = n.col1.x * a.x + n.col2.x * a.y, u = n.col1.y * a.x + n.col2.y * a.y, d = (n = o.R).col1.x * p + n.col1.y * u, m = n.col2.x * p + n.col2.y * u, y = 0, f = Number.MAX_VALUE, g = 0; g < l; ++g) {
                var _ = (a = c[g]).x * d + a.y * m;
                _ < f && (f = _, y = g)
            }
            a = r[i], n = e.R;
            var v = e.position.x + (n.col1.x * a.x + n.col2.x * a.y),
                b = e.position.y + (n.col1.y * a.x + n.col2.y * a.y);
            a = c[y], n = o.R;
            var x = o.position.x + (n.col1.x * a.x + n.col2.x * a.y),
                C = o.position.y + (n.col1.y * a.x + n.col2.y * a.y);
            return (x -= v) * p + (C -= b) * u
        }, p.FindMaxSeparation = function(t, e, i, s, o) {
            var n, a, r = parseInt(e.m_vertexCount),
                h = e.m_normals;
            a = o.R, n = s.m_centroid;
            var l = o.position.x + (a.col1.x * n.x + a.col2.x * n.y),
                c = o.position.y + (a.col1.y * n.x + a.col2.y * n.y);
            a = i.R, n = e.m_centroid, l -= i.position.x + (a.col1.x * n.x + a.col2.x * n.y), c -= i.position.y + (a.col1.y * n.x + a.col2.y * n.y);
            for (var u = l * i.R.col1.x + c * i.R.col1.y, d = l * i.R.col2.x + c * i.R.col2.y, m = 0, y = -Number.MAX_VALUE, f = 0; f < r; ++f) {
                var g = (n = h[f]).x * u + n.y * d;
                g > y && (y = g, m = f)
            }
            var _ = p.EdgeSeparation(e, i, m, s, o),
                v = parseInt(m - 1 >= 0 ? m - 1 : r - 1),
                b = p.EdgeSeparation(e, i, v, s, o),
                x = parseInt(m + 1 < r ? m + 1 : 0),
                C = p.EdgeSeparation(e, i, x, s, o),
                S = 0,
                w = 0,
                A = 0;
            if (b > _ && b > C) A = -1, S = v, w = b;
            else {
                if (!(C > _)) return t[0] = m, _;
                A = 1, S = x, w = C
            }
            for (;;) {
                if (m = -1 == A ? S - 1 >= 0 ? S - 1 : r - 1 : S + 1 < r ? S + 1 : 0, !((_ = p.EdgeSeparation(e, i, m, s, o)) > w)) break;
                S = m, w = _
            }
            return t[0] = S, w
        }, p.FindIncidentEdge = function(t, e, i, s, o, n) {
            void 0 === s && (s = 0);
            parseInt(e.m_vertexCount);
            var a, r, h = e.m_normals,
                l = parseInt(o.m_vertexCount),
                c = o.m_vertices,
                p = o.m_normals;
            a = i.R, r = h[s];
            var u = a.col1.x * r.x + a.col2.x * r.y,
                d = a.col1.y * r.x + a.col2.y * r.y,
                m = (a = n.R).col1.x * u + a.col1.y * d;
            d = a.col2.x * u + a.col2.y * d, u = m;
            for (var y = 0, f = Number.MAX_VALUE, g = 0; g < l; ++g) {
                var _ = u * (r = p[g]).x + d * r.y;
                _ < f && (f = _, y = g)
            }
            var v, b = parseInt(y),
                x = parseInt(b + 1 < l ? b + 1 : 0);
            v = t[0], r = c[b], a = n.R, v.v.x = n.position.x + (a.col1.x * r.x + a.col2.x * r.y), v.v.y = n.position.y + (a.col1.y * r.x + a.col2.y * r.y), v.id.features.referenceEdge = s, v.id.features.incidentEdge = b, v.id.features.incidentVertex = 0, v = t[1], r = c[x], a = n.R, v.v.x = n.position.x + (a.col1.x * r.x + a.col2.x * r.y), v.v.y = n.position.y + (a.col1.y * r.x + a.col2.y * r.y), v.id.features.referenceEdge = s, v.id.features.incidentEdge = x, v.id.features.incidentVertex = 1
        }, p.MakeClipPointVector = function() {
            var t = new Vector(2);
            return t[0] = new O, t[1] = new O, t
        }, p.CollidePolygons = function(t, e, i, o, n) {
            var a;
            t.m_pointCount = 0;
            var r = e.m_radius + o.m_radius,
                h = 0;
            p.s_edgeAO[0] = h;
            var l = p.FindMaxSeparation(p.s_edgeAO, e, i, o, n);
            if (h = p.s_edgeAO[0], !(l > r)) {
                var c = 0;
                p.s_edgeBO[0] = c;
                var u = p.FindMaxSeparation(p.s_edgeBO, o, n, e, i);
                if (c = p.s_edgeBO[0], !(u > r)) {
                    var d, m, y, f, g, _ = 0,
                        v = 0;
                    u > .98 * l + .001 ? (d = o, m = e, y = n, f = i, _ = c, t.m_type = C.e_faceB, v = 1) : (d = e, m = o, y = i, f = n, _ = h, t.m_type = C.e_faceA, v = 0);
                    var b = p.s_incidentEdge;
                    p.FindIncidentEdge(b, d, y, _, m, f);
                    var x, S = parseInt(d.m_vertexCount),
                        w = d.m_vertices,
                        A = w[_];
                    x = _ + 1 < S ? w[parseInt(_ + 1)] : w[0];
                    var T = p.s_localTangent;
                    T.Set(x.x - A.x, x.y - A.y), T.Normalize();
                    var B = p.s_localNormal;
                    B.x = T.y, B.y = -T.x;
                    var P = p.s_planePoint;
                    P.Set(.5 * (A.x + x.x), .5 * (A.y + x.y));
                    var D = p.s_tangent;
                    g = y.R, D.x = g.col1.x * T.x + g.col2.x * T.y, D.y = g.col1.y * T.x + g.col2.y * T.y;
                    var I = p.s_tangent2;
                    I.x = -D.x, I.y = -D.y;
                    var E = p.s_normal;
                    E.x = D.y, E.y = -D.x;
                    var L = p.s_v11,
                        M = p.s_v12;
                    L.x = y.position.x + (g.col1.x * A.x + g.col2.x * A.y), L.y = y.position.y + (g.col1.y * A.x + g.col2.y * A.y), M.x = y.position.x + (g.col1.x * x.x + g.col2.x * x.y), M.y = y.position.y + (g.col1.y * x.x + g.col2.y * x.y);
                    var G = E.x * L.x + E.y * L.y,
                        O = -D.x * L.x - D.y * L.y + r,
                        R = D.x * M.x + D.y * M.y + r,
                        k = p.s_clipPoints1,
                        F = p.s_clipPoints2;
                    if (!(p.ClipSegmentToLine(k, b, I, O) < 2 || p.ClipSegmentToLine(F, k, D, R) < 2)) {
                        t.m_localPlaneNormal.SetV(B), t.m_localPoint.SetV(P);
                        for (var N = 0, V = 0; V < s.b2_maxManifoldPoints; ++V)
                            if (a = F[V], E.x * a.v.x + E.y * a.v.y - G <= r) {
                                var U = t.m_points[N];
                                g = f.R;
                                var W = a.v.x - f.position.x,
                                    j = a.v.y - f.position.y;
                                U.m_localPoint.x = W * g.col1.x + j * g.col1.y, U.m_localPoint.y = W * g.col2.x + j * g.col2.y, U.m_id.Set(a.id), U.m_id.features.flip = v, ++N
                            }
                        t.m_pointCount = N
                    }
                }
            }
        }, p.CollideCircles = function(t, e, i, s, o) {
            t.m_pointCount = 0;
            var n, a;
            n = i.R, a = e.m_p;
            var r = i.position.x + (n.col1.x * a.x + n.col2.x * a.y),
                h = i.position.y + (n.col1.y * a.x + n.col2.y * a.y);
            n = o.R, a = s.m_p;
            var l = o.position.x + (n.col1.x * a.x + n.col2.x * a.y) - r,
                c = o.position.y + (n.col1.y * a.x + n.col2.y * a.y) - h,
                p = l * l + c * c,
                u = e.m_radius + s.m_radius;
            p > u * u || (t.m_type = C.e_circles, t.m_localPoint.SetV(e.m_p), t.m_localPlaneNormal.SetZero(), t.m_pointCount = 1, t.m_points[0].m_localPoint.SetV(s.m_p), t.m_points[0].m_id.key = 0)
        }, p.CollidePolygonAndCircle = function(t, e, i, s, o) {
            t.m_pointCount = 0;
            var n, a, r = 0,
                h = 0;
            a = o.R, n = s.m_p;
            var l = o.position.x + (a.col1.x * n.x + a.col2.x * n.y),
                c = o.position.y + (a.col1.y * n.x + a.col2.y * n.y);
            r = l - i.position.x, h = c - i.position.y;
            for (var p = r * (a = i.R).col1.x + h * a.col1.y, u = r * a.col2.x + h * a.col2.y, d = 0, m = -Number.MAX_VALUE, y = e.m_radius + s.m_radius, f = parseInt(e.m_vertexCount), g = e.m_vertices, _ = e.m_normals, v = 0; v < f; ++v) {
                r = p - (n = g[v]).x, h = u - n.y;
                var b = (n = _[v]).x * r + n.y * h;
                if (b > y) return;
                b > m && (m = b, d = v)
            }
            var x = parseInt(d),
                S = parseInt(x + 1 < f ? x + 1 : 0),
                w = g[x],
                A = g[S];
            if (m < Number.MIN_VALUE) return t.m_pointCount = 1, t.m_type = C.e_faceA, t.m_localPlaneNormal.SetV(_[d]), t.m_localPoint.x = .5 * (w.x + A.x), t.m_localPoint.y = .5 * (w.y + A.y), t.m_points[0].m_localPoint.SetV(s.m_p), void(t.m_points[0].m_id.key = 0);
            var T = (p - w.x) * (A.x - w.x) + (u - w.y) * (A.y - w.y),
                B = (p - A.x) * (w.x - A.x) + (u - A.y) * (w.y - A.y);
            if (T <= 0) {
                if ((p - w.x) * (p - w.x) + (u - w.y) * (u - w.y) > y * y) return;
                t.m_pointCount = 1, t.m_type = C.e_faceA, t.m_localPlaneNormal.x = p - w.x, t.m_localPlaneNormal.y = u - w.y, t.m_localPlaneNormal.Normalize(), t.m_localPoint.SetV(w), t.m_points[0].m_localPoint.SetV(s.m_p), t.m_points[0].m_id.key = 0
            } else if (B <= 0) {
                if ((p - A.x) * (p - A.x) + (u - A.y) * (u - A.y) > y * y) return;
                t.m_pointCount = 1, t.m_type = C.e_faceA, t.m_localPlaneNormal.x = p - A.x, t.m_localPlaneNormal.y = u - A.y, t.m_localPlaneNormal.Normalize(), t.m_localPoint.SetV(A), t.m_points[0].m_localPoint.SetV(s.m_p), t.m_points[0].m_id.key = 0
            } else {
                var P = .5 * (w.x + A.x),
                    D = .5 * (w.y + A.y);
                if ((m = (p - P) * _[x].x + (u - D) * _[x].y) > y) return;
                t.m_pointCount = 1, t.m_type = C.e_faceA, t.m_localPlaneNormal.x = _[x].x, t.m_localPlaneNormal.y = _[x].y, t.m_localPlaneNormal.Normalize(), t.m_localPoint.Set(P, D), t.m_points[0].m_localPoint.SetV(s.m_p), t.m_points[0].m_id.key = 0
            }
        }, p.TestOverlap = function(t, e) {
            var i = e.lowerBound,
                s = t.upperBound,
                o = i.x - s.x,
                n = i.y - s.y;
            i = t.lowerBound, s = e.upperBound;
            var a = i.x - s.x,
                r = i.y - s.y;
            return !(o > 0 || n > 0) && !(a > 0 || r > 0)
        }, Box2D.postDefs.push(function() {
            Box2D.Collision.b2Collision.s_incidentEdge = p.MakeClipPointVector(), Box2D.Collision.b2Collision.s_clipPoints1 = p.MakeClipPointVector(), Box2D.Collision.b2Collision.s_clipPoints2 = p.MakeClipPointVector(), Box2D.Collision.b2Collision.s_edgeAO = new Vector_a2j_Number(1), Box2D.Collision.b2Collision.s_edgeBO = new Vector_a2j_Number(1), Box2D.Collision.b2Collision.s_localTangent = new r, Box2D.Collision.b2Collision.s_localNormal = new r, Box2D.Collision.b2Collision.s_planePoint = new r, Box2D.Collision.b2Collision.s_normal = new r, Box2D.Collision.b2Collision.s_tangent = new r, Box2D.Collision.b2Collision.s_tangent2 = new r, Box2D.Collision.b2Collision.s_v11 = new r, Box2D.Collision.b2Collision.s_v12 = new r, Box2D.Collision.b2Collision.b2CollidePolyTempVec = new r, Box2D.Collision.b2Collision.b2_nullFeature = 255
        }), u.b2ContactID = function() {
            this.features = new R
        }, u.prototype.b2ContactID = function() {
            this.features._m_id = this
        }, u.prototype.Set = function(t) {
            this.key = t._key
        }, u.prototype.Copy = function() {
            var t = new u;
            return t.key = this.key, t
        }, Object.defineProperty(u.prototype, "key", {
            enumerable: !1,
            configurable: !0,
            get: function() {
                return this._key
            }
        }), Object.defineProperty(u.prototype, "key", {
            enumerable: !1,
            configurable: !0,
            set: function(t) {
                void 0 === t && (t = 0), this._key = t, this.features._referenceEdge = 255 & this._key, this.features._incidentEdge = (65280 & this._key) >> 8 & 255, this.features._incidentVertex = (16711680 & this._key) >> 16 & 255, this.features._flip = (4278190080 & this._key) >> 24 & 255
            }
        }), d.b2ContactPoint = function() {
            this.position = new r, this.velocity = new r, this.normal = new r, this.id = new u
        }, m.b2Distance = function() {}, m.Distance = function(t, e, i) {
            ++m.b2_gjkCalls;
            var n = i.proxyA,
                a = i.proxyB,
                h = i.transformA,
                l = i.transformB,
                c = m.s_simplex;
            c.ReadCache(e, n, h, a, l);
            for (var p, u = c.m_vertices, d = m.s_saveA, y = m.s_saveB, f = 0, g = (c.GetClosestPoint().LengthSquared(), 0), _ = 0; _ < 20;) {
                for (f = c.m_count, g = 0; g < f; g++) d[g] = u[g].indexA, y[g] = u[g].indexB;
                switch (c.m_count) {
                    case 1:
                        break;
                    case 2:
                        c.Solve2();
                        break;
                    case 3:
                        c.Solve3();
                        break;
                    default:
                        s.b2Assert(!1)
                }
                if (3 == c.m_count) break;
                (p = c.GetClosestPoint()).LengthSquared();
                var v = c.GetSearchDirection();
                if (v.LengthSquared() < Number.MIN_VALUE * Number.MIN_VALUE) break;
                var b = u[c.m_count];
                b.indexA = n.GetSupport(o.MulTMV(h.R, v.GetNegative())), b.wA = o.MulX(h, n.GetVertex(b.indexA)), b.indexB = a.GetSupport(o.MulTMV(l.R, v)), b.wB = o.MulX(l, a.GetVertex(b.indexB)), b.w = o.SubtractVV(b.wB, b.wA), ++_, ++m.b2_gjkIters;
                var x = !1;
                for (g = 0; g < f; g++)
                    if (b.indexA == d[g] && b.indexB == y[g]) {
                        x = !0;
                        break
                    }
                if (x) break;
                ++c.m_count
            }
            if (m.b2_gjkMaxIters = o.Max(m.b2_gjkMaxIters, _), c.GetWitnessPoints(t.pointA, t.pointB), t.distance = o.SubtractVV(t.pointA, t.pointB).Length(), t.iterations = _, c.WriteCache(e), i.useRadii) {
                var C = n.m_radius,
                    S = a.m_radius;
                if (t.distance > C + S && t.distance > Number.MIN_VALUE) {
                    t.distance -= C + S;
                    var w = o.SubtractVV(t.pointB, t.pointA);
                    w.Normalize(), t.pointA.x += C * w.x, t.pointA.y += C * w.y, t.pointB.x -= S * w.x, t.pointB.y -= S * w.y
                } else(p = new r).x = .5 * (t.pointA.x + t.pointB.x), p.y = .5 * (t.pointA.y + t.pointB.y), t.pointA.x = t.pointB.x = p.x, t.pointA.y = t.pointB.y = p.y, t.distance = 0
            }
        }, Box2D.postDefs.push(function() {
            Box2D.Collision.b2Distance.s_simplex = new D, Box2D.Collision.b2Distance.s_saveA = new Vector_a2j_Number(3), Box2D.Collision.b2Distance.s_saveB = new Vector_a2j_Number(3)
        }), y.b2DistanceInput = function() {}, f.b2DistanceOutput = function() {
            this.pointA = new r, this.pointB = new r
        }, g.b2DistanceProxy = function() {}, g.prototype.Set = function(o) {
            switch (o.GetType()) {
                case i.e_circleShape:
                    var n = o instanceof t ? o : null;
                    this.m_vertices = new Vector(1, !0), this.m_vertices[0] = n.m_p, this.m_count = 1, this.m_radius = n.m_radius;
                    break;
                case i.e_polygonShape:
                    var a = o instanceof e ? o : null;
                    this.m_vertices = a.m_vertices, this.m_count = a.m_vertexCount, this.m_radius = a.m_radius;
                    break;
                default:
                    s.b2Assert(!1)
            }
        }, g.prototype.GetSupport = function(t) {
            for (var e = 0, i = this.m_vertices[0].x * t.x + this.m_vertices[0].y * t.y, s = 1; s < this.m_count; ++s) {
                var o = this.m_vertices[s].x * t.x + this.m_vertices[s].y * t.y;
                o > i && (e = s, i = o)
            }
            return e
        }, g.prototype.GetSupportVertex = function(t) {
            for (var e = 0, i = this.m_vertices[0].x * t.x + this.m_vertices[0].y * t.y, s = 1; s < this.m_count; ++s) {
                var o = this.m_vertices[s].x * t.x + this.m_vertices[s].y * t.y;
                o > i && (e = s, i = o)
            }
            return this.m_vertices[e]
        }, g.prototype.GetVertexCount = function() {
            return this.m_count
        }, g.prototype.GetVertex = function(t) {
            return void 0 === t && (t = 0), s.b2Assert(0 <= t && t < this.m_count), this.m_vertices[t]
        }, _.b2DynamicTree = function() {}, _.prototype.b2DynamicTree = function() {
            this.m_root = null, this.m_freeList = null, this.m_path = 0, this.m_insertionCount = 0
        }, _.prototype.CreateProxy = function(t, e) {
            var i = this.AllocateNode(),
                o = s.b2_aabbExtension,
                n = s.b2_aabbExtension;
            return i.aabb.lowerBound.x = t.lowerBound.x - o, i.aabb.lowerBound.y = t.lowerBound.y - n, i.aabb.upperBound.x = t.upperBound.x + o, i.aabb.upperBound.y = t.upperBound.y + n, i.userData = e, this.InsertLeaf(i), i
        }, _.prototype.DestroyProxy = function(t) {
            this.RemoveLeaf(t), this.FreeNode(t)
        }, _.prototype.MoveProxy = function(t, e, i) {
            if (s.b2Assert(t.IsLeaf()), t.aabb.Contains(e)) return !1;
            this.RemoveLeaf(t);
            var o = s.b2_aabbExtension + s.b2_aabbMultiplier * (i.x > 0 ? i.x : -i.x),
                n = s.b2_aabbExtension + s.b2_aabbMultiplier * (i.y > 0 ? i.y : -i.y);
            return t.aabb.lowerBound.x = e.lowerBound.x - o, t.aabb.lowerBound.y = e.lowerBound.y - n, t.aabb.upperBound.x = e.upperBound.x + o, t.aabb.upperBound.y = e.upperBound.y + n, this.InsertLeaf(t), !0
        }, _.prototype.Rebalance = function(t) {
            if (void 0 === t && (t = 0), null != this.m_root)
                for (var e = 0; e < t; e++) {
                    for (var i = this.m_root, s = 0; 0 == i.IsLeaf();) i = this.m_path >> s & 1 ? i.child2 : i.child1, s = s + 1 & 31;
                    ++this.m_path, this.RemoveLeaf(i), this.InsertLeaf(i)
                }
        }, _.prototype.GetFatAABB = function(t) {
            return t.aabb
        }, _.prototype.GetUserData = function(t) {
            return t.userData
        }, _.prototype.Query = function(t, e) {
            if (null != this.m_root) {
                var i = new Vector,
                    s = 0;
                for (i[s++] = this.m_root; s > 0;) {
                    var o = i[--s];
                    if (o.aabb.TestOverlap(e))
                        if (o.IsLeaf()) {
                            if (!t(o)) return
                        } else i[s++] = o.child1, i[s++] = o.child2
                }
            }
        }, _.prototype.RayCast = function(t, e) {
            if (null != this.m_root) {
                var i = e.p1,
                    s = e.p2,
                    n = o.SubtractVV(i, s);
                n.Normalize();
                var a = o.CrossFV(1, n),
                    r = o.AbsV(a),
                    l = e.maxFraction,
                    c = new h,
                    p = 0,
                    u = 0;
                p = i.x + l * (s.x - i.x), u = i.y + l * (s.y - i.y), c.lowerBound.x = Math.min(i.x, p), c.lowerBound.y = Math.min(i.y, u), c.upperBound.x = Math.max(i.x, p), c.upperBound.y = Math.max(i.y, u);
                var d = new Vector,
                    m = 0;
                for (d[m++] = this.m_root; m > 0;) {
                    var y = d[--m];
                    if (0 != y.aabb.TestOverlap(c)) {
                        var f = y.aabb.GetCenter(),
                            g = y.aabb.GetExtents();
                        if (!(Math.abs(a.x * (i.x - f.x) + a.y * (i.y - f.y)) - r.x * g.x - r.y * g.y > 0))
                            if (y.IsLeaf()) {
                                var _ = new A;
                                if (_.p1 = e.p1, _.p2 = e.p2, _.maxFraction = e.maxFraction, 0 == (l = t(_, y))) return;
                                l > 0 && (p = i.x + l * (s.x - i.x), u = i.y + l * (s.y - i.y), c.lowerBound.x = Math.min(i.x, p), c.lowerBound.y = Math.min(i.y, u), c.upperBound.x = Math.max(i.x, p), c.upperBound.y = Math.max(i.y, u))
                            } else d[m++] = y.child1, d[m++] = y.child2
                    }
                }
            }
        }, _.prototype.AllocateNode = function() {
            if (this.m_freeList) {
                var t = this.m_freeList;
                return this.m_freeList = t.parent, t.parent = null, t.child1 = null, t.child2 = null, t
            }
            return new b
        }, _.prototype.FreeNode = function(t) {
            t.parent = this.m_freeList, this.m_freeList = t
        }, _.prototype.InsertLeaf = function(t) {
            if (++this.m_insertionCount, null == this.m_root) return this.m_root = t, void(this.m_root.parent = null);
            var e = t.aabb.GetCenter(),
                i = this.m_root;
            if (0 == i.IsLeaf())
                do {
                    var s = i.child1,
                        o = i.child2;
                    i = Math.abs((s.aabb.lowerBound.x + s.aabb.upperBound.x) / 2 - e.x) + Math.abs((s.aabb.lowerBound.y + s.aabb.upperBound.y) / 2 - e.y) < Math.abs((o.aabb.lowerBound.x + o.aabb.upperBound.x) / 2 - e.x) + Math.abs((o.aabb.lowerBound.y + o.aabb.upperBound.y) / 2 - e.y) ? s : o
                } while (0 == i.IsLeaf());
            var n = i.parent,
                a = this.AllocateNode();
            if (a.parent = n, a.userData = null, a.aabb.Combine(t.aabb, i.aabb), n) {
                i.parent.child1 == i ? n.child1 = a : n.child2 = a, a.child1 = i, a.child2 = t, i.parent = a, t.parent = a;
                do {
                    if (n.aabb.Contains(a.aabb)) break;
                    n.aabb.Combine(n.child1.aabb, n.child2.aabb), a = n, n = n.parent
                } while (n)
            } else a.child1 = i, a.child2 = t, i.parent = a, t.parent = a, this.m_root = a
        }, _.prototype.RemoveLeaf = function(t) {
            if (t != this.m_root) {
                var e, i = t.parent,
                    s = i.parent;
                if (e = i.child1 == t ? i.child2 : i.child1, s)
                    for (s.child1 == i ? s.child1 = e : s.child2 = e, e.parent = s, this.FreeNode(i); s;) {
                        var o = s.aabb;
                        if (s.aabb = h.Combine(s.child1.aabb, s.child2.aabb), o.Contains(s.aabb)) break;
                        s = s.parent
                    } else this.m_root = e, e.parent = null, this.FreeNode(i)
            } else this.m_root = null
        }, v.b2DynamicTreeBroadPhase = function() {
            this.m_tree = new _, this.m_moveBuffer = new Vector, this.m_pairBuffer = new Vector, this.m_pairCount = 0
        }, v.prototype.CreateProxy = function(t, e) {
            var i = this.m_tree.CreateProxy(t, e);
            return ++this.m_proxyCount, this.BufferMove(i), i
        }, v.prototype.DestroyProxy = function(t) {
            this.UnBufferMove(t), --this.m_proxyCount, this.m_tree.DestroyProxy(t)
        }, v.prototype.MoveProxy = function(t, e, i) {
            this.m_tree.MoveProxy(t, e, i) && this.BufferMove(t)
        }, v.prototype.TestOverlap = function(t, e) {
            var i = this.m_tree.GetFatAABB(t),
                s = this.m_tree.GetFatAABB(e);
            return i.TestOverlap(s)
        }, v.prototype.GetUserData = function(t) {
            return this.m_tree.GetUserData(t)
        }, v.prototype.GetFatAABB = function(t) {
            return this.m_tree.GetFatAABB(t)
        }, v.prototype.GetProxyCount = function() {
            return this.m_proxyCount
        }, v.prototype.UpdatePairs = function(t) {
            var e = this;
            e.m_pairCount = 0;
            var i, s = 0;
            for (s = 0; s < e.m_moveBuffer.length; ++s) {
                i = e.m_moveBuffer[s];
                var o = e.m_tree.GetFatAABB(i);
                e.m_tree.Query(function(t) {
                    if (t == i) return !0;
                    e.m_pairCount == e.m_pairBuffer.length && (e.m_pairBuffer[e.m_pairCount] = new x);
                    var s = e.m_pairBuffer[e.m_pairCount];
                    return s.proxyA = t < i ? t : i, s.proxyB = t >= i ? t : i, ++e.m_pairCount, !0
                }, o)
            }
            e.m_moveBuffer.length = 0;
            for (s = 0; s < e.m_pairCount;) {
                var n = e.m_pairBuffer[s];
                for (t(e.m_tree.GetUserData(n.proxyA), e.m_tree.GetUserData(n.proxyB)), ++s; s < e.m_pairCount;) {
                    var a = e.m_pairBuffer[s];
                    if (a.proxyA != n.proxyA || a.proxyB != n.proxyB) break;
                    ++s
                }
            }
        }, v.prototype.Query = function(t, e) {
            this.m_tree.Query(t, e)
        }, v.prototype.RayCast = function(t, e) {
            this.m_tree.RayCast(t, e)
        }, v.prototype.Validate = function() {}, v.prototype.Rebalance = function(t) {
            void 0 === t && (t = 0), this.m_tree.Rebalance(t)
        }, v.prototype.BufferMove = function(t) {
            this.m_moveBuffer[this.m_moveBuffer.length] = t
        }, v.prototype.UnBufferMove = function(t) {
            var e = parseInt(this.m_moveBuffer.indexOf(t));
            this.m_moveBuffer.splice(e, 1)
        }, v.prototype.ComparePairs = function(t, e) {
            return 0
        }, v.__implements = {}, v.__implements[k] = !0, b.b2DynamicTreeNode = function() {
            this.aabb = new h
        }, b.prototype.IsLeaf = function() {
            return null == this.child1
        }, x.b2DynamicTreePair = function() {}, C.b2Manifold = function() {
            this.m_pointCount = 0
        }, C.prototype.b2Manifold = function() {
            this.m_points = new Vector(s.b2_maxManifoldPoints);
            for (var t = 0; t < s.b2_maxManifoldPoints; t++) this.m_points[t] = new S;
            this.m_localPlaneNormal = new r, this.m_localPoint = new r
        }, C.prototype.Reset = function() {
            for (var t = 0; t < s.b2_maxManifoldPoints; t++)(this.m_points[t] instanceof S ? this.m_points[t] : null).Reset();
            this.m_localPlaneNormal.SetZero(), this.m_localPoint.SetZero(), this.m_type = 0, this.m_pointCount = 0
        }, C.prototype.Set = function(t) {
            this.m_pointCount = t.m_pointCount;
            for (var e = 0; e < s.b2_maxManifoldPoints; e++)(this.m_points[e] instanceof S ? this.m_points[e] : null).Set(t.m_points[e]);
            this.m_localPlaneNormal.SetV(t.m_localPlaneNormal), this.m_localPoint.SetV(t.m_localPoint), this.m_type = t.m_type
        }, C.prototype.Copy = function() {
            var t = new C;
            return t.Set(this), t
        }, Box2D.postDefs.push(function() {
            Box2D.Collision.b2Manifold.e_circles = 1, Box2D.Collision.b2Manifold.e_faceA = 2, Box2D.Collision.b2Manifold.e_faceB = 4
        }), S.b2ManifoldPoint = function() {
            this.m_localPoint = new r, this.m_id = new u
        }, S.prototype.b2ManifoldPoint = function() {
            this.Reset()
        }, S.prototype.Reset = function() {
            this.m_localPoint.SetZero(), this.m_normalImpulse = 0, this.m_tangentImpulse = 0, this.m_id.key = 0
        }, S.prototype.Set = function(t) {
            this.m_localPoint.SetV(t.m_localPoint), this.m_normalImpulse = t.m_normalImpulse, this.m_tangentImpulse = t.m_tangentImpulse, this.m_id.Set(t.m_id)
        }, w.b2Point = function() {
            this.p = new r
        }, w.prototype.Support = function(t, e, i) {
            return void 0 === e && (e = 0), void 0 === i && (i = 0), this.p
        }, w.prototype.GetFirstVertex = function(t) {
            return this.p
        }, A.b2RayCastInput = function() {
            this.p1 = new r, this.p2 = new r
        }, A.prototype.b2RayCastInput = function(t, e, i) {
            void 0 === t && (t = null), void 0 === e && (e = null), void 0 === i && (i = 1), t && this.p1.SetV(t), e && this.p2.SetV(e), this.maxFraction = i
        }, T.b2RayCastOutput = function() {
            this.normal = new r
        }, B.b2Segment = function() {
            this.p1 = new r, this.p2 = new r
        }, B.prototype.TestSegment = function(t, e, i, s) {
            void 0 === s && (s = 0);
            var o = i.p1,
                n = i.p2.x - o.x,
                a = i.p2.y - o.y,
                r = this.p2.x - this.p1.x,
                h = this.p2.y - this.p1.y,
                l = -r,
                c = 100 * Number.MIN_VALUE,
                p = -(n * h + a * l);
            if (p > c) {
                var u = o.x - this.p1.x,
                    d = o.y - this.p1.y,
                    m = u * h + d * l;
                if (0 <= m && m <= s * p) {
                    var y = -n * d + a * u;
                    if (-c * p <= y && y <= p * (1 + c)) {
                        m /= p;
                        var f = Math.sqrt(h * h + l * l);
                        return h /= f, l /= f, t[0] = m, e.Set(h, l), !0
                    }
                }
            }
            return !1
        }, B.prototype.Extend = function(t) {
            this.ExtendForward(t), this.ExtendBackward(t)
        }, B.prototype.ExtendForward = function(t) {
            var e = this.p2.x - this.p1.x,
                i = this.p2.y - this.p1.y,
                s = Math.min(e > 0 ? (t.upperBound.x - this.p1.x) / e : e < 0 ? (t.lowerBound.x - this.p1.x) / e : Number.POSITIVE_INFINITY, i > 0 ? (t.upperBound.y - this.p1.y) / i : i < 0 ? (t.lowerBound.y - this.p1.y) / i : Number.POSITIVE_INFINITY);
            this.p2.x = this.p1.x + e * s, this.p2.y = this.p1.y + i * s
        }, B.prototype.ExtendBackward = function(t) {
            var e = -this.p2.x + this.p1.x,
                i = -this.p2.y + this.p1.y,
                s = Math.min(e > 0 ? (t.upperBound.x - this.p2.x) / e : e < 0 ? (t.lowerBound.x - this.p2.x) / e : Number.POSITIVE_INFINITY, i > 0 ? (t.upperBound.y - this.p2.y) / i : i < 0 ? (t.lowerBound.y - this.p2.y) / i : Number.POSITIVE_INFINITY);
            this.p1.x = this.p2.x + e * s, this.p1.y = this.p2.y + i * s
        }, P.b2SeparationFunction = function() {
            this.m_localPoint = new r, this.m_axis = new r
        }, P.prototype.Initialize = function(t, e, i, n, a) {
            this.m_proxyA = e, this.m_proxyB = n;
            var h = parseInt(t.count);
            s.b2Assert(0 < h && h < 3);
            var l, c, p, u, d, m, y, f, g = 0,
                _ = 0,
                v = 0,
                b = 0,
                x = 0,
                C = 0,
                S = 0;
            if (1 == h) this.m_type = P.e_points, l = this.m_proxyA.GetVertex(t.indexA[0]), u = this.m_proxyB.GetVertex(t.indexB[0]), f = l, y = i.R, g = i.position.x + (y.col1.x * f.x + y.col2.x * f.y), _ = i.position.y + (y.col1.y * f.x + y.col2.y * f.y), f = u, y = a.R, v = a.position.x + (y.col1.x * f.x + y.col2.x * f.y), b = a.position.y + (y.col1.y * f.x + y.col2.y * f.y), this.m_axis.x = v - g, this.m_axis.y = b - _, this.m_axis.Normalize();
            else if (t.indexB[0] == t.indexB[1]) this.m_type = P.e_faceA, c = this.m_proxyA.GetVertex(t.indexA[0]), p = this.m_proxyA.GetVertex(t.indexA[1]), u = this.m_proxyB.GetVertex(t.indexB[0]), this.m_localPoint.x = .5 * (c.x + p.x), this.m_localPoint.y = .5 * (c.y + p.y), this.m_axis = o.CrossVF(o.SubtractVV(p, c), 1), this.m_axis.Normalize(), f = this.m_axis, x = (y = i.R).col1.x * f.x + y.col2.x * f.y, C = y.col1.y * f.x + y.col2.y * f.y, f = this.m_localPoint, y = i.R, g = i.position.x + (y.col1.x * f.x + y.col2.x * f.y), _ = i.position.y + (y.col1.y * f.x + y.col2.y * f.y), f = u, y = a.R, (S = ((v = a.position.x + (y.col1.x * f.x + y.col2.x * f.y)) - g) * x + ((b = a.position.y + (y.col1.y * f.x + y.col2.y * f.y)) - _) * C) < 0 && this.m_axis.NegativeSelf();
            else if (t.indexA[0] == t.indexA[0]) this.m_type = P.e_faceB, d = this.m_proxyB.GetVertex(t.indexB[0]), m = this.m_proxyB.GetVertex(t.indexB[1]), l = this.m_proxyA.GetVertex(t.indexA[0]), this.m_localPoint.x = .5 * (d.x + m.x), this.m_localPoint.y = .5 * (d.y + m.y), this.m_axis = o.CrossVF(o.SubtractVV(m, d), 1), this.m_axis.Normalize(), f = this.m_axis, x = (y = a.R).col1.x * f.x + y.col2.x * f.y, C = y.col1.y * f.x + y.col2.y * f.y, f = this.m_localPoint, y = a.R, v = a.position.x + (y.col1.x * f.x + y.col2.x * f.y), b = a.position.y + (y.col1.y * f.x + y.col2.y * f.y), f = l, y = i.R, (S = ((g = i.position.x + (y.col1.x * f.x + y.col2.x * f.y)) - v) * x + ((_ = i.position.y + (y.col1.y * f.x + y.col2.y * f.y)) - b) * C) < 0 && this.m_axis.NegativeSelf();
            else {
                c = this.m_proxyA.GetVertex(t.indexA[0]), p = this.m_proxyA.GetVertex(t.indexA[1]), d = this.m_proxyB.GetVertex(t.indexB[0]), m = this.m_proxyB.GetVertex(t.indexB[1]);
                o.MulX(i, l);
                var w = o.MulMV(i.R, o.SubtractVV(p, c)),
                    A = (o.MulX(a, u), o.MulMV(a.R, o.SubtractVV(m, d))),
                    T = w.x * w.x + w.y * w.y,
                    B = A.x * A.x + A.y * A.y,
                    D = o.SubtractVV(A, w),
                    I = w.x * D.x + w.y * D.y,
                    E = A.x * D.x + A.y * D.y,
                    L = w.x * A.x + w.y * A.y,
                    M = T * B - L * L;
                S = 0, 0 != M && (S = o.Clamp((L * E - I * B) / M, 0, 1));
                var G = (L * S + E) / B;
                G < 0 && (G = 0, S = o.Clamp((L - I) / T, 0, 1)), (l = new r).x = c.x + S * (p.x - c.x), l.y = c.y + S * (p.y - c.y), (u = new r).x = d.x + S * (m.x - d.x), u.y = d.y + S * (m.y - d.y), 0 == S || 1 == S ? (this.m_type = P.e_faceB, this.m_axis = o.CrossVF(o.SubtractVV(m, d), 1), this.m_axis.Normalize(), this.m_localPoint = u, f = this.m_axis, x = (y = a.R).col1.x * f.x + y.col2.x * f.y, C = y.col1.y * f.x + y.col2.y * f.y, f = this.m_localPoint, y = a.R, v = a.position.x + (y.col1.x * f.x + y.col2.x * f.y), b = a.position.y + (y.col1.y * f.x + y.col2.y * f.y), f = l, y = i.R, ((g = i.position.x + (y.col1.x * f.x + y.col2.x * f.y)) - v) * x + ((_ = i.position.y + (y.col1.y * f.x + y.col2.y * f.y)) - b) * C, S < 0 && this.m_axis.NegativeSelf()) : (this.m_type = P.e_faceA, this.m_axis = o.CrossVF(o.SubtractVV(p, c), 1), this.m_localPoint = l, f = this.m_axis, x = (y = i.R).col1.x * f.x + y.col2.x * f.y, C = y.col1.y * f.x + y.col2.y * f.y, f = this.m_localPoint, y = i.R, g = i.position.x + (y.col1.x * f.x + y.col2.x * f.y), _ = i.position.y + (y.col1.y * f.x + y.col2.y * f.y), f = u, y = a.R, ((v = a.position.x + (y.col1.x * f.x + y.col2.x * f.y)) - g) * x + ((b = a.position.y + (y.col1.y * f.x + y.col2.y * f.y)) - _) * C, S < 0 && this.m_axis.NegativeSelf())
            }
        }, P.prototype.Evaluate = function(t, e) {
            var i, n, a, r, h, l, c;
            switch (this.m_type) {
                case P.e_points:
                    return i = o.MulTMV(t.R, this.m_axis), n = o.MulTMV(e.R, this.m_axis.GetNegative()), a = this.m_proxyA.GetSupportVertex(i), r = this.m_proxyB.GetSupportVertex(n), h = o.MulX(t, a), l = o.MulX(e, r), (l.x - h.x) * this.m_axis.x + (l.y - h.y) * this.m_axis.y;
                case P.e_faceA:
                    return c = o.MulMV(t.R, this.m_axis), h = o.MulX(t, this.m_localPoint), n = o.MulTMV(e.R, c.GetNegative()), r = this.m_proxyB.GetSupportVertex(n), l = o.MulX(e, r), (l.x - h.x) * c.x + (l.y - h.y) * c.y;
                case P.e_faceB:
                    return c = o.MulMV(e.R, this.m_axis), l = o.MulX(e, this.m_localPoint), i = o.MulTMV(t.R, c.GetNegative()), a = this.m_proxyA.GetSupportVertex(i), h = o.MulX(t, a), (h.x - l.x) * c.x + (h.y - l.y) * c.y;
                default:
                    return s.b2Assert(!1), 0
            }
        }, Box2D.postDefs.push(function() {
            Box2D.Collision.b2SeparationFunction.e_points = 1, Box2D.Collision.b2SeparationFunction.e_faceA = 2, Box2D.Collision.b2SeparationFunction.e_faceB = 4
        }), D.b2Simplex = function() {
            this.m_v1 = new E, this.m_v2 = new E, this.m_v3 = new E, this.m_vertices = new Vector(3)
        }, D.prototype.b2Simplex = function() {
            this.m_vertices[0] = this.m_v1, this.m_vertices[1] = this.m_v2, this.m_vertices[2] = this.m_v3
        }, D.prototype.ReadCache = function(t, e, i, n, a) {
            s.b2Assert(0 <= t.count && t.count <= 3);
            var r, h;
            this.m_count = t.count;
            for (var l = this.m_vertices, c = 0; c < this.m_count; c++) {
                var p = l[c];
                p.indexA = t.indexA[c], p.indexB = t.indexB[c], r = e.GetVertex(p.indexA), h = n.GetVertex(p.indexB), p.wA = o.MulX(i, r), p.wB = o.MulX(a, h), p.w = o.SubtractVV(p.wB, p.wA), p.a = 0
            }
            if (this.m_count > 1) {
                var u = t.metric,
                    d = this.GetMetric();
                (d < .5 * u || 2 * u < d || d < Number.MIN_VALUE) && (this.m_count = 0)
            }
            0 == this.m_count && ((p = l[0]).indexA = 0, p.indexB = 0, r = e.GetVertex(0), h = n.GetVertex(0), p.wA = o.MulX(i, r), p.wB = o.MulX(a, h), p.w = o.SubtractVV(p.wB, p.wA), this.m_count = 1)
        }, D.prototype.WriteCache = function(t) {
            t.metric = this.GetMetric(), t.count = Box2D.parseUInt(this.m_count);
            for (var e = this.m_vertices, i = 0; i < this.m_count; i++) t.indexA[i] = Box2D.parseUInt(e[i].indexA), t.indexB[i] = Box2D.parseUInt(e[i].indexB)
        }, D.prototype.GetSearchDirection = function() {
            switch (this.m_count) {
                case 1:
                    return this.m_v1.w.GetNegative();
                case 2:
                    var t = o.SubtractVV(this.m_v2.w, this.m_v1.w);
                    return o.CrossVV(t, this.m_v1.w.GetNegative()) > 0 ? o.CrossFV(1, t) : o.CrossVF(t, 1);
                default:
                    return s.b2Assert(!1), new r
            }
        }, D.prototype.GetClosestPoint = function() {
            switch (this.m_count) {
                case 0:
                    return s.b2Assert(!1), new r;
                case 1:
                    return this.m_v1.w;
                case 2:
                    return new r(this.m_v1.a * this.m_v1.w.x + this.m_v2.a * this.m_v2.w.x, this.m_v1.a * this.m_v1.w.y + this.m_v2.a * this.m_v2.w.y);
                default:
                    return s.b2Assert(!1), new r
            }
        }, D.prototype.GetWitnessPoints = function(t, e) {
            switch (this.m_count) {
                case 0:
                    s.b2Assert(!1);
                    break;
                case 1:
                    t.SetV(this.m_v1.wA), e.SetV(this.m_v1.wB);
                    break;
                case 2:
                    t.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x, t.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y, e.x = this.m_v1.a * this.m_v1.wB.x + this.m_v2.a * this.m_v2.wB.x, e.y = this.m_v1.a * this.m_v1.wB.y + this.m_v2.a * this.m_v2.wB.y;
                    break;
                case 3:
                    e.x = t.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x + this.m_v3.a * this.m_v3.wA.x, e.y = t.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y + this.m_v3.a * this.m_v3.wA.y;
                    break;
                default:
                    s.b2Assert(!1)
            }
        }, D.prototype.GetMetric = function() {
            switch (this.m_count) {
                case 0:
                    return s.b2Assert(!1), 0;
                case 1:
                    return 0;
                case 2:
                    return o.SubtractVV(this.m_v1.w, this.m_v2.w).Length();
                case 3:
                    return o.CrossVV(o.SubtractVV(this.m_v2.w, this.m_v1.w), o.SubtractVV(this.m_v3.w, this.m_v1.w));
                default:
                    return s.b2Assert(!1), 0
            }
        }, D.prototype.Solve2 = function() {
            var t = this.m_v1.w,
                e = this.m_v2.w,
                i = o.SubtractVV(e, t),
                s = -(t.x * i.x + t.y * i.y);
            if (s <= 0) return this.m_v1.a = 1, void(this.m_count = 1);
            var n = e.x * i.x + e.y * i.y;
            if (n <= 0) return this.m_v2.a = 1, this.m_count = 1, void this.m_v1.Set(this.m_v2);
            var a = 1 / (n + s);
            this.m_v1.a = n * a, this.m_v2.a = s * a, this.m_count = 2
        }, D.prototype.Solve3 = function() {
            var t = this.m_v1.w,
                e = this.m_v2.w,
                i = this.m_v3.w,
                s = o.SubtractVV(e, t),
                n = o.Dot(t, s),
                a = o.Dot(e, s),
                r = -n,
                h = o.SubtractVV(i, t),
                l = o.Dot(t, h),
                c = o.Dot(i, h),
                p = -l,
                u = o.SubtractVV(i, e),
                d = o.Dot(e, u),
                m = o.Dot(i, u),
                y = -d,
                f = o.CrossVV(s, h),
                g = f * o.CrossVV(e, i),
                _ = f * o.CrossVV(i, t),
                v = f * o.CrossVV(t, e);
            if (r <= 0 && p <= 0) return this.m_v1.a = 1, void(this.m_count = 1);
            if (a > 0 && r > 0 && v <= 0) {
                var b = 1 / (a + r);
                return this.m_v1.a = a * b, this.m_v2.a = r * b, void(this.m_count = 2)
            }
            if (c > 0 && p > 0 && _ <= 0) {
                var x = 1 / (c + p);
                return this.m_v1.a = c * x, this.m_v3.a = p * x, this.m_count = 2, void this.m_v2.Set(this.m_v3)
            }
            if (a <= 0 && y <= 0) return this.m_v2.a = 1, this.m_count = 1, void this.m_v1.Set(this.m_v2);
            if (c <= 0 && m <= 0) return this.m_v3.a = 1, this.m_count = 1, void this.m_v1.Set(this.m_v3);
            if (m > 0 && y > 0 && g <= 0) {
                var C = 1 / (m + y);
                return this.m_v2.a = m * C, this.m_v3.a = y * C, this.m_count = 2, void this.m_v1.Set(this.m_v3)
            }
            var S = 1 / (g + _ + v);
            this.m_v1.a = g * S, this.m_v2.a = _ * S, this.m_v3.a = v * S, this.m_count = 3
        }, I.b2SimplexCache = function() {
            this.indexA = new Vector_a2j_Number(3), this.indexB = new Vector_a2j_Number(3)
        }, E.b2SimplexVertex = function() {}, E.prototype.Set = function(t) {
            this.wA.SetV(t.wA), this.wB.SetV(t.wB), this.w.SetV(t.w), this.a = t.a, this.indexA = t.indexA, this.indexB = t.indexB
        }, L.b2TimeOfImpact = function() {}, L.TimeOfImpact = function(t) {
            ++L.b2_toiCalls;
            var e = t.proxyA,
                i = t.proxyB,
                n = t.sweepA,
                a = t.sweepB;
            s.b2Assert(n.t0 == a.t0), s.b2Assert(1 - n.t0 > Number.MIN_VALUE);
            var r = e.m_radius + i.m_radius,
                h = t.tolerance,
                l = 0,
                c = 0,
                p = 0;
            for (L.s_cache.count = 0, L.s_distanceInput.useRadii = !1;;) {
                if (n.GetTransform(L.s_xfA, l), a.GetTransform(L.s_xfB, l), L.s_distanceInput.proxyA = e, L.s_distanceInput.proxyB = i, L.s_distanceInput.transformA = L.s_xfA, L.s_distanceInput.transformB = L.s_xfB, m.Distance(L.s_distanceOutput, L.s_cache, L.s_distanceInput), L.s_distanceOutput.distance <= 0) {
                    l = 1;
                    break
                }
                L.s_fcn.Initialize(L.s_cache, e, L.s_xfA, i, L.s_xfB);
                var u = L.s_fcn.Evaluate(L.s_xfA, L.s_xfB);
                if (u <= 0) {
                    l = 1;
                    break
                }
                if (0 == c && (p = u > r ? o.Max(r - h, .75 * r) : o.Max(u - h, .02 * r)), u - p < .5 * h) {
                    if (0 == c) {
                        l = 1;
                        break
                    }
                    break
                }
                var d = l,
                    y = l,
                    f = 1,
                    g = u;
                n.GetTransform(L.s_xfA, f), a.GetTransform(L.s_xfB, f);
                var _ = L.s_fcn.Evaluate(L.s_xfA, L.s_xfB);
                if (_ >= p) {
                    l = 1;
                    break
                }
                for (var v = 0;;) {
                    var b = 0;
                    b = 1 & v ? y + (p - g) * (f - y) / (_ - g) : .5 * (y + f), n.GetTransform(L.s_xfA, b), a.GetTransform(L.s_xfB, b);
                    var x = L.s_fcn.Evaluate(L.s_xfA, L.s_xfB);
                    if (o.Abs(x - p) < .025 * h) {
                        d = b;
                        break
                    }
                    if (x > p ? (y = b, g = x) : (f = b, _ = x), ++v, ++L.b2_toiRootIters, 50 == v) break
                }
                if (L.b2_toiMaxRootIters = o.Max(L.b2_toiMaxRootIters, v), d < (1 + 100 * Number.MIN_VALUE) * l) break;
                if (l = d, c++, ++L.b2_toiIters, 1e3 == c) break
            }
            return L.b2_toiMaxIters = o.Max(L.b2_toiMaxIters, c), l
        }, Box2D.postDefs.push(function() {
            Box2D.Collision.b2TimeOfImpact.b2_toiCalls = 0, Box2D.Collision.b2TimeOfImpact.b2_toiIters = 0, Box2D.Collision.b2TimeOfImpact.b2_toiMaxIters = 0, Box2D.Collision.b2TimeOfImpact.b2_toiRootIters = 0, Box2D.Collision.b2TimeOfImpact.b2_toiMaxRootIters = 0, Box2D.Collision.b2TimeOfImpact.s_cache = new I, Box2D.Collision.b2TimeOfImpact.s_distanceInput = new y, Box2D.Collision.b2TimeOfImpact.s_xfA = new a, Box2D.Collision.b2TimeOfImpact.s_xfB = new a, Box2D.Collision.b2TimeOfImpact.s_fcn = new P, Box2D.Collision.b2TimeOfImpact.s_distanceOutput = new f
        }), M.b2TOIInput = function() {
            this.proxyA = new g, this.proxyB = new g, this.sweepA = new n, this.sweepB = new n
        }, G.b2WorldManifold = function() {
            this.m_normal = new r
        }, G.prototype.b2WorldManifold = function() {
            this.m_points = new Vector(s.b2_maxManifoldPoints);
            for (var t = 0; t < s.b2_maxManifoldPoints; t++) this.m_points[t] = new r
        }, G.prototype.Initialize = function(t, e, i, s, o) {
            if (void 0 === i && (i = 0), void 0 === o && (o = 0), 0 != t.m_pointCount) {
                var n, a, r = 0,
                    h = 0,
                    l = 0,
                    c = 0,
                    p = 0,
                    u = 0,
                    d = 0;
                switch (t.m_type) {
                    case C.e_circles:
                        a = e.R, n = t.m_localPoint;
                        var m = e.position.x + a.col1.x * n.x + a.col2.x * n.y,
                            y = e.position.y + a.col1.y * n.x + a.col2.y * n.y;
                        a = s.R, n = t.m_points[0].m_localPoint;
                        var f = s.position.x + a.col1.x * n.x + a.col2.x * n.y,
                            g = s.position.y + a.col1.y * n.x + a.col2.y * n.y,
                            _ = f - m,
                            v = g - y,
                            b = _ * _ + v * v;
                        if (b > Number.MIN_VALUE * Number.MIN_VALUE) {
                            var x = Math.sqrt(b);
                            this.m_normal.x = _ / x, this.m_normal.y = v / x
                        } else this.m_normal.x = 1, this.m_normal.y = 0;
                        var S = m + i * this.m_normal.x,
                            w = y + i * this.m_normal.y,
                            A = f - o * this.m_normal.x,
                            T = g - o * this.m_normal.y;
                        this.m_points[0].x = .5 * (S + A), this.m_points[0].y = .5 * (w + T);
                        break;
                    case C.e_faceA:
                        for (a = e.R, n = t.m_localPlaneNormal, h = a.col1.x * n.x + a.col2.x * n.y, l = a.col1.y * n.x + a.col2.y * n.y, a = e.R, n = t.m_localPoint, c = e.position.x + a.col1.x * n.x + a.col2.x * n.y, p = e.position.y + a.col1.y * n.x + a.col2.y * n.y, this.m_normal.x = h, this.m_normal.y = l, r = 0; r < t.m_pointCount; r++) a = s.R, n = t.m_points[r].m_localPoint, u = s.position.x + a.col1.x * n.x + a.col2.x * n.y, d = s.position.y + a.col1.y * n.x + a.col2.y * n.y, this.m_points[r].x = u + .5 * (i - (u - c) * h - (d - p) * l - o) * h, this.m_points[r].y = d + .5 * (i - (u - c) * h - (d - p) * l - o) * l;
                        break;
                    case C.e_faceB:
                        for (a = s.R, n = t.m_localPlaneNormal, h = a.col1.x * n.x + a.col2.x * n.y, l = a.col1.y * n.x + a.col2.y * n.y, a = s.R, n = t.m_localPoint, c = s.position.x + a.col1.x * n.x + a.col2.x * n.y, p = s.position.y + a.col1.y * n.x + a.col2.y * n.y, this.m_normal.x = -h, this.m_normal.y = -l, r = 0; r < t.m_pointCount; r++) a = e.R, n = t.m_points[r].m_localPoint, u = e.position.x + a.col1.x * n.x + a.col2.x * n.y, d = e.position.y + a.col1.y * n.x + a.col2.y * n.y, this.m_points[r].x = u + .5 * (o - (u - c) * h - (d - p) * l - i) * h, this.m_points[r].y = d + .5 * (o - (u - c) * h - (d - p) * l - i) * l
                }
            }
        }, O.ClipVertex = function() {
            this.v = new r, this.id = new u
        }, O.prototype.Set = function(t) {
            this.v.SetV(t.v), this.id.Set(t.id)
        }, R.Features = function() {}, Object.defineProperty(R.prototype, "referenceEdge", {
            enumerable: !1,
            configurable: !0,
            get: function() {
                return this._referenceEdge
            }
        }), Object.defineProperty(R.prototype, "referenceEdge", {
            enumerable: !1,
            configurable: !0,
            set: function(t) {
                void 0 === t && (t = 0), this._referenceEdge = t, this._m_id._key = 4294967040 & this._m_id._key | 255 & this._referenceEdge
            }
        }), Object.defineProperty(R.prototype, "incidentEdge", {
            enumerable: !1,
            configurable: !0,
            get: function() {
                return this._incidentEdge
            }
        }), Object.defineProperty(R.prototype, "incidentEdge", {
            enumerable: !1,
            configurable: !0,
            set: function(t) {
                void 0 === t && (t = 0), this._incidentEdge = t, this._m_id._key = 4294902015 & this._m_id._key | this._incidentEdge << 8 & 65280
            }
        }), Object.defineProperty(R.prototype, "incidentVertex", {
            enumerable: !1,
            configurable: !0,
            get: function() {
                return this._incidentVertex
            }
        }), Object.defineProperty(R.prototype, "incidentVertex", {
            enumerable: !1,
            configurable: !0,
            set: function(t) {
                void 0 === t && (t = 0), this._incidentVertex = t, this._m_id._key = 4278255615 & this._m_id._key | this._incidentVertex << 16 & 16711680
            }
        }), Object.defineProperty(R.prototype, "flip", {
            enumerable: !1,
            configurable: !0,
            get: function() {
                return this._flip
            }
        }), Object.defineProperty(R.prototype, "flip", {
            enumerable: !1,
            configurable: !0,
            set: function(t) {
                void 0 === t && (t = 0), this._flip = t, this._m_id._key = 16777215 & this._m_id._key | this._flip << 24 & 4278190080
            }
        })
    }(),
    function() {
        Box2D.Common.b2Color, Box2D.Common.b2internal;
        var t = Box2D.Common.b2Settings,
            e = Box2D.Collision.Shapes.b2CircleShape,
            i = Box2D.Collision.Shapes.b2EdgeChainDef,
            s = Box2D.Collision.Shapes.b2EdgeShape,
            o = Box2D.Collision.Shapes.b2MassData,
            n = Box2D.Collision.Shapes.b2PolygonShape,
            a = Box2D.Collision.Shapes.b2Shape,
            r = Box2D.Common.Math.b2Mat22,
            h = (Box2D.Common.Math.b2Mat33, Box2D.Common.Math.b2Math),
            l = (Box2D.Common.Math.b2Sweep, Box2D.Common.Math.b2Transform),
            c = Box2D.Common.Math.b2Vec2,
            p = (Box2D.Common.Math.b2Vec3, Box2D.Dynamics.b2Body, Box2D.Dynamics.b2BodyDef, Box2D.Dynamics.b2ContactFilter, Box2D.Dynamics.b2ContactImpulse, Box2D.Dynamics.b2ContactListener, Box2D.Dynamics.b2ContactManager, Box2D.Dynamics.b2DebugDraw, Box2D.Dynamics.b2DestructionListener, Box2D.Dynamics.b2FilterData, Box2D.Dynamics.b2Fixture, Box2D.Dynamics.b2FixtureDef, Box2D.Dynamics.b2Island, Box2D.Dynamics.b2TimeStep, Box2D.Dynamics.b2World, Box2D.Collision.b2AABB, Box2D.Collision.b2Bound, Box2D.Collision.b2BoundValues, Box2D.Collision.b2Collision, Box2D.Collision.b2ContactID, Box2D.Collision.b2ContactPoint, Box2D.Collision.b2Distance),
            u = Box2D.Collision.b2DistanceInput,
            d = Box2D.Collision.b2DistanceOutput,
            m = Box2D.Collision.b2DistanceProxy,
            y = (Box2D.Collision.b2DynamicTree, Box2D.Collision.b2DynamicTreeBroadPhase, Box2D.Collision.b2DynamicTreeNode, Box2D.Collision.b2DynamicTreePair, Box2D.Collision.b2Manifold, Box2D.Collision.b2ManifoldPoint, Box2D.Collision.b2Point, Box2D.Collision.b2RayCastInput, Box2D.Collision.b2RayCastOutput, Box2D.Collision.b2Segment, Box2D.Collision.b2SeparationFunction, Box2D.Collision.b2Simplex, Box2D.Collision.b2SimplexCache);
        Box2D.Collision.b2SimplexVertex, Box2D.Collision.b2TimeOfImpact, Box2D.Collision.b2TOIInput, Box2D.Collision.b2WorldManifold, Box2D.Collision.ClipVertex, Box2D.Collision.Features, Box2D.Collision.IBroadPhase;
        Box2D.inherit(e, Box2D.Collision.Shapes.b2Shape), e.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype, e.b2CircleShape = function() {
            Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments), this.m_p = new c
        }, e.prototype.Copy = function() {
            var t = new e;
            return t.Set(this), t
        }, e.prototype.Set = function(t) {
            if (this.__super.Set.call(this, t), Box2D.is(t, e)) {
                var i = t instanceof e ? t : null;
                this.m_p.SetV(i.m_p)
            }
        }, e.prototype.TestPoint = function(t, e) {
            var i = t.R,
                s = t.position.x + (i.col1.x * this.m_p.x + i.col2.x * this.m_p.y),
                o = t.position.y + (i.col1.y * this.m_p.x + i.col2.y * this.m_p.y);
            return s = e.x - s, o = e.y - o, s * s + o * o <= this.m_radius * this.m_radius
        }, e.prototype.RayCast = function(t, e, i) {
            var s = i.R,
                o = i.position.x + (s.col1.x * this.m_p.x + s.col2.x * this.m_p.y),
                n = i.position.y + (s.col1.y * this.m_p.x + s.col2.y * this.m_p.y),
                a = e.p1.x - o,
                r = e.p1.y - n,
                h = a * a + r * r - this.m_radius * this.m_radius,
                l = e.p2.x - e.p1.x,
                c = e.p2.y - e.p1.y,
                p = a * l + r * c,
                u = l * l + c * c,
                d = p * p - u * h;
            if (d < 0 || u < Number.MIN_VALUE) return !1;
            var m = -(p + Math.sqrt(d));
            return 0 <= m && m <= e.maxFraction * u && (m /= u, t.fraction = m, t.normal.x = a + m * l, t.normal.y = r + m * c, t.normal.Normalize(), !0)
        }, e.prototype.ComputeAABB = function(t, e) {
            var i = e.R,
                s = e.position.x + (i.col1.x * this.m_p.x + i.col2.x * this.m_p.y),
                o = e.position.y + (i.col1.y * this.m_p.x + i.col2.y * this.m_p.y);
            t.lowerBound.Set(s - this.m_radius, o - this.m_radius), t.upperBound.Set(s + this.m_radius, o + this.m_radius)
        }, e.prototype.ComputeMass = function(e, i) {
            void 0 === i && (i = 0), e.mass = i * t.b2_pi * this.m_radius * this.m_radius, e.center.SetV(this.m_p), e.I = e.mass * (.5 * this.m_radius * this.m_radius + (this.m_p.x * this.m_p.x + this.m_p.y * this.m_p.y))
        }, e.prototype.ComputeSubmergedArea = function(t, e, i, s) {
            void 0 === e && (e = 0);
            var o = h.MulX(i, this.m_p),
                n = -(h.Dot(t, o) - e);
            if (n < -this.m_radius + Number.MIN_VALUE) return 0;
            if (n > this.m_radius) return s.SetV(o), Math.PI * this.m_radius * this.m_radius;
            var a = this.m_radius * this.m_radius,
                r = n * n,
                l = a * (Math.asin(n / this.m_radius) + Math.PI / 2) + n * Math.sqrt(a - r),
                c = -2 / 3 * Math.pow(a - r, 1.5) / l;
            return s.x = o.x + t.x * c, s.y = o.y + t.y * c, l
        }, e.prototype.GetLocalPosition = function() {
            return this.m_p
        }, e.prototype.SetLocalPosition = function(t) {
            this.m_p.SetV(t)
        }, e.prototype.GetRadius = function() {
            return this.m_radius
        }, e.prototype.SetRadius = function(t) {
            void 0 === t && (t = 0), this.m_radius = t
        }, e.prototype.b2CircleShape = function(t) {
            void 0 === t && (t = 0), this.__super.b2Shape.call(this), this.m_type = a.e_circleShape, this.m_radius = t
        }, i.b2EdgeChainDef = function() {}, i.prototype.b2EdgeChainDef = function() {
            this.vertexCount = 0, this.isALoop = !0, this.vertices = []
        }, Box2D.inherit(s, Box2D.Collision.Shapes.b2Shape), s.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype, s.b2EdgeShape = function() {
            Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments), this.s_supportVec = new c, this.m_v1 = new c, this.m_v2 = new c, this.m_coreV1 = new c, this.m_coreV2 = new c, this.m_normal = new c, this.m_direction = new c, this.m_cornerDir1 = new c, this.m_cornerDir2 = new c
        }, s.prototype.TestPoint = function(t, e) {
            return !1
        }, s.prototype.RayCast = function(t, e, i) {
            var s, o = e.p2.x - e.p1.x,
                n = e.p2.y - e.p1.y;
            s = i.R;
            var a = i.position.x + (s.col1.x * this.m_v1.x + s.col2.x * this.m_v1.y),
                r = i.position.y + (s.col1.y * this.m_v1.x + s.col2.y * this.m_v1.y),
                h = i.position.y + (s.col1.y * this.m_v2.x + s.col2.y * this.m_v2.y) - r,
                l = -(i.position.x + (s.col1.x * this.m_v2.x + s.col2.x * this.m_v2.y) - a),
                c = 100 * Number.MIN_VALUE,
                p = -(o * h + n * l);
            if (p > c) {
                var u = e.p1.x - a,
                    d = e.p1.y - r,
                    m = u * h + d * l;
                if (0 <= m && m <= e.maxFraction * p) {
                    var y = -o * d + n * u;
                    if (-c * p <= y && y <= p * (1 + c)) {
                        m /= p, t.fraction = m;
                        var f = Math.sqrt(h * h + l * l);
                        return t.normal.x = h / f, t.normal.y = l / f, !0
                    }
                }
            }
            return !1
        }, s.prototype.ComputeAABB = function(t, e) {
            var i = e.R,
                s = e.position.x + (i.col1.x * this.m_v1.x + i.col2.x * this.m_v1.y),
                o = e.position.y + (i.col1.y * this.m_v1.x + i.col2.y * this.m_v1.y),
                n = e.position.x + (i.col1.x * this.m_v2.x + i.col2.x * this.m_v2.y),
                a = e.position.y + (i.col1.y * this.m_v2.x + i.col2.y * this.m_v2.y);
            s < n ? (t.lowerBound.x = s, t.upperBound.x = n) : (t.lowerBound.x = n, t.upperBound.x = s), o < a ? (t.lowerBound.y = o, t.upperBound.y = a) : (t.lowerBound.y = a, t.upperBound.y = o)
        }, s.prototype.ComputeMass = function(t, e) {
            void 0 === e && (e = 0), t.mass = 0, t.center.SetV(this.m_v1), t.I = 0
        }, s.prototype.ComputeSubmergedArea = function(t, e, i, s) {
            void 0 === e && (e = 0);
            var o = new c(t.x * e, t.y * e),
                n = h.MulX(i, this.m_v1),
                a = h.MulX(i, this.m_v2),
                r = h.Dot(t, n) - e,
                l = h.Dot(t, a) - e;
            if (r > 0) {
                if (l > 0) return 0;
                n.x = -l / (r - l) * n.x + r / (r - l) * a.x, n.y = -l / (r - l) * n.y + r / (r - l) * a.y
            } else l > 0 && (a.x = -l / (r - l) * n.x + r / (r - l) * a.x, a.y = -l / (r - l) * n.y + r / (r - l) * a.y);
            return s.x = (o.x + n.x + a.x) / 3, s.y = (o.y + n.y + a.y) / 3, .5 * ((n.x - o.x) * (a.y - o.y) - (n.y - o.y) * (a.x - o.x))
        }, s.prototype.GetLength = function() {
            return this.m_length
        }, s.prototype.GetVertex1 = function() {
            return this.m_v1
        }, s.prototype.GetVertex2 = function() {
            return this.m_v2
        }, s.prototype.GetCoreVertex1 = function() {
            return this.m_coreV1
        }, s.prototype.GetCoreVertex2 = function() {
            return this.m_coreV2
        }, s.prototype.GetNormalVector = function() {
            return this.m_normal
        }, s.prototype.GetDirectionVector = function() {
            return this.m_direction
        }, s.prototype.GetCorner1Vector = function() {
            return this.m_cornerDir1
        }, s.prototype.GetCorner2Vector = function() {
            return this.m_cornerDir2
        }, s.prototype.Corner1IsConvex = function() {
            return this.m_cornerConvex1
        }, s.prototype.Corner2IsConvex = function() {
            return this.m_cornerConvex2
        }, s.prototype.GetFirstVertex = function(t) {
            var e = t.R;
            return new c(t.position.x + (e.col1.x * this.m_coreV1.x + e.col2.x * this.m_coreV1.y), t.position.y + (e.col1.y * this.m_coreV1.x + e.col2.y * this.m_coreV1.y))
        }, s.prototype.GetNextEdge = function() {
            return this.m_nextEdge
        }, s.prototype.GetPrevEdge = function() {
            return this.m_prevEdge
        }, s.prototype.Support = function(t, e, i) {
            void 0 === e && (e = 0), void 0 === i && (i = 0);
            var s = t.R,
                o = t.position.x + (s.col1.x * this.m_coreV1.x + s.col2.x * this.m_coreV1.y),
                n = t.position.y + (s.col1.y * this.m_coreV1.x + s.col2.y * this.m_coreV1.y),
                a = t.position.x + (s.col1.x * this.m_coreV2.x + s.col2.x * this.m_coreV2.y),
                r = t.position.y + (s.col1.y * this.m_coreV2.x + s.col2.y * this.m_coreV2.y);
            return o * e + n * i > a * e + r * i ? (this.s_supportVec.x = o, this.s_supportVec.y = n) : (this.s_supportVec.x = a, this.s_supportVec.y = r), this.s_supportVec
        }, s.prototype.b2EdgeShape = function(e, i) {
            this.__super.b2Shape.call(this), this.m_type = a.e_edgeShape, this.m_prevEdge = null, this.m_nextEdge = null, this.m_v1 = e, this.m_v2 = i, this.m_direction.Set(this.m_v2.x - this.m_v1.x, this.m_v2.y - this.m_v1.y), this.m_length = this.m_direction.Normalize(), this.m_normal.Set(this.m_direction.y, -this.m_direction.x), this.m_coreV1.Set(-t.b2_toiSlop * (this.m_normal.x - this.m_direction.x) + this.m_v1.x, -t.b2_toiSlop * (this.m_normal.y - this.m_direction.y) + this.m_v1.y), this.m_coreV2.Set(-t.b2_toiSlop * (this.m_normal.x + this.m_direction.x) + this.m_v2.x, -t.b2_toiSlop * (this.m_normal.y + this.m_direction.y) + this.m_v2.y), this.m_cornerDir1 = this.m_normal, this.m_cornerDir2.Set(-this.m_normal.x, -this.m_normal.y)
        }, s.prototype.SetPrevEdge = function(t, e, i, s) {
            this.m_prevEdge = t, this.m_coreV1 = e, this.m_cornerDir1 = i, this.m_cornerConvex1 = s
        }, s.prototype.SetNextEdge = function(t, e, i, s) {
            this.m_nextEdge = t, this.m_coreV2 = e, this.m_cornerDir2 = i, this.m_cornerConvex2 = s
        }, o.b2MassData = function() {
            this.mass = 0, this.center = new c(0, 0), this.I = 0
        }, Box2D.inherit(n, Box2D.Collision.Shapes.b2Shape), n.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype, n.b2PolygonShape = function() {
            Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments)
        }, n.prototype.Copy = function() {
            var t = new n;
            return t.Set(this), t
        }, n.prototype.Set = function(t) {
            if (this.__super.Set.call(this, t), Box2D.is(t, n)) {
                var e = t instanceof n ? t : null;
                this.m_centroid.SetV(e.m_centroid), this.m_vertexCount = e.m_vertexCount, this.Reserve(this.m_vertexCount);
                for (var i = 0; i < this.m_vertexCount; i++) this.m_vertices[i].SetV(e.m_vertices[i]), this.m_normals[i].SetV(e.m_normals[i])
            }
        }, n.prototype.SetAsArray = function(t, e) {
            void 0 === e && (e = 0);
            var i, s = new Vector,
                o = 0;
            for (o = 0; o < t.length; ++o) i = t[o], s.push(i);
            this.SetAsVector(s, e)
        }, n.AsArray = function(t, e) {
            void 0 === e && (e = 0);
            var i = new n;
            return i.SetAsArray(t, e), i
        }, n.prototype.SetAsVector = function(e, i) {
            void 0 === i && (i = 0), 0 == i && (i = e.length), t.b2Assert(2 <= i), this.m_vertexCount = i, this.Reserve(i);
            var s = 0;
            for (s = 0; s < this.m_vertexCount; s++) this.m_vertices[s].SetV(e[s]);
            for (s = 0; s < this.m_vertexCount; ++s) {
                var o = parseInt(s),
                    a = parseInt(s + 1 < this.m_vertexCount ? s + 1 : 0),
                    r = h.SubtractVV(this.m_vertices[a], this.m_vertices[o]);
                t.b2Assert(r.LengthSquared() > Number.MIN_VALUE), this.m_normals[s].SetV(h.CrossVF(r, 1)), this.m_normals[s].Normalize()
            }
            this.m_centroid = n.ComputeCentroid(this.m_vertices, this.m_vertexCount)
        }, n.AsVector = function(t, e) {
            void 0 === e && (e = 0);
            var i = new n;
            return i.SetAsVector(t, e), i
        }, n.prototype.SetAsBox = function(t, e) {
            void 0 === t && (t = 0), void 0 === e && (e = 0), this.m_vertexCount = 4, this.Reserve(4), this.m_vertices[0].Set(-t, -e), this.m_vertices[1].Set(t, -e), this.m_vertices[2].Set(t, e), this.m_vertices[3].Set(-t, e), this.m_normals[0].Set(0, -1), this.m_normals[1].Set(1, 0), this.m_normals[2].Set(0, 1), this.m_normals[3].Set(-1, 0), this.m_centroid.SetZero()
        }, n.AsBox = function(t, e) {
            void 0 === t && (t = 0), void 0 === e && (e = 0);
            var i = new n;
            return i.SetAsBox(t, e), i
        }, n.prototype.SetAsOrientedBox = function(t, e, i, s) {
            void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = null), void 0 === s && (s = 0), this.m_vertexCount = 4, this.Reserve(4), this.m_vertices[0].Set(-t, -e), this.m_vertices[1].Set(t, -e), this.m_vertices[2].Set(t, e), this.m_vertices[3].Set(-t, e), this.m_normals[0].Set(0, -1), this.m_normals[1].Set(1, 0), this.m_normals[2].Set(0, 1), this.m_normals[3].Set(-1, 0), this.m_centroid = i;
            var o = new l;
            o.position = i, o.R.Set(s);
            for (var n = 0; n < this.m_vertexCount; ++n) this.m_vertices[n] = h.MulX(o, this.m_vertices[n]), this.m_normals[n] = h.MulMV(o.R, this.m_normals[n])
        }, n.AsOrientedBox = function(t, e, i, s) {
            void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = null), void 0 === s && (s = 0);
            var o = new n;
            return o.SetAsOrientedBox(t, e, i, s), o
        }, n.prototype.SetAsEdge = function(t, e) {
            this.m_vertexCount = 2, this.Reserve(2), this.m_vertices[0].SetV(t), this.m_vertices[1].SetV(e), this.m_centroid.x = .5 * (t.x + e.x), this.m_centroid.y = .5 * (t.y + e.y), this.m_normals[0] = h.CrossVF(h.SubtractVV(e, t), 1), this.m_normals[0].Normalize(), this.m_normals[1].x = -this.m_normals[0].x, this.m_normals[1].y = -this.m_normals[0].y
        }, n.AsEdge = function(t, e) {
            var i = new n;
            return i.SetAsEdge(t, e), i
        }, n.prototype.TestPoint = function(t, e) {
            for (var i, s = t.R, o = e.x - t.position.x, n = e.y - t.position.y, a = o * s.col1.x + n * s.col1.y, r = o * s.col2.x + n * s.col2.y, h = 0; h < this.m_vertexCount; ++h)
                if (o = a - (i = this.m_vertices[h]).x, n = r - i.y, (i = this.m_normals[h]).x * o + i.y * n > 0) return !1;
            return !0
        }, n.prototype.RayCast = function(t, e, i) {
            var s, o, n = 0,
                a = e.maxFraction,
                r = 0,
                h = 0;
            r = e.p1.x - i.position.x, h = e.p1.y - i.position.y;
            var l = r * (s = i.R).col1.x + h * s.col1.y,
                c = r * s.col2.x + h * s.col2.y;
            r = e.p2.x - i.position.x, h = e.p2.y - i.position.y;
            for (var p = r * (s = i.R).col1.x + h * s.col1.y - l, u = r * s.col2.x + h * s.col2.y - c, d = parseInt(-1), m = 0; m < this.m_vertexCount; ++m) {
                r = (o = this.m_vertices[m]).x - l, h = o.y - c;
                var y = (o = this.m_normals[m]).x * r + o.y * h,
                    f = o.x * p + o.y * u;
                if (0 == f) {
                    if (y < 0) return !1
                } else f < 0 && y < n * f ? (n = y / f, d = m) : f > 0 && y < a * f && (a = y / f);
                if (a < n - Number.MIN_VALUE) return !1
            }
            return d >= 0 && (t.fraction = n, s = i.R, o = this.m_normals[d], t.normal.x = s.col1.x * o.x + s.col2.x * o.y, t.normal.y = s.col1.y * o.x + s.col2.y * o.y, !0)
        }, n.prototype.ComputeAABB = function(t, e) {
            for (var i = e.R, s = this.m_vertices[0], o = e.position.x + (i.col1.x * s.x + i.col2.x * s.y), n = e.position.y + (i.col1.y * s.x + i.col2.y * s.y), a = o, r = n, h = 1; h < this.m_vertexCount; ++h) {
                s = this.m_vertices[h];
                var l = e.position.x + (i.col1.x * s.x + i.col2.x * s.y),
                    c = e.position.y + (i.col1.y * s.x + i.col2.y * s.y);
                o = o < l ? o : l, n = n < c ? n : c, a = a > l ? a : l, r = r > c ? r : c
            }
            t.lowerBound.x = o - this.m_radius, t.lowerBound.y = n - this.m_radius, t.upperBound.x = a + this.m_radius, t.upperBound.y = r + this.m_radius
        }, n.prototype.ComputeMass = function(t, e) {
            if (void 0 === e && (e = 0), 2 == this.m_vertexCount) return t.center.x = .5 * (this.m_vertices[0].x + this.m_vertices[1].x), t.center.y = .5 * (this.m_vertices[0].y + this.m_vertices[1].y), t.mass = 0, void(t.I = 0);
            for (var i = 0, s = 0, o = 0, n = 0, a = 0; a < this.m_vertexCount; ++a) {
                var r = this.m_vertices[a],
                    h = a + 1 < this.m_vertexCount ? this.m_vertices[parseInt(a + 1)] : this.m_vertices[0],
                    l = r.x - 0,
                    c = r.y - 0,
                    p = h.x - 0,
                    u = h.y - 0,
                    d = l * u - c * p,
                    m = .5 * d;
                o += m, i += m * (1 / 3) * (0 + r.x + h.x), s += m * (1 / 3) * (0 + r.y + h.y);
                var y = l,
                    f = c,
                    g = p,
                    _ = u;
                n += d * (1 / 3 * (.25 * (y * y + g * y + g * g) + (0 * y + 0 * g)) + 0 + (1 / 3 * (.25 * (f * f + _ * f + _ * _) + (0 * f + 0 * _)) + 0))
            }
            t.mass = e * o, i *= 1 / o, s *= 1 / o, t.center.Set(i, s), t.I = e * n
        }, n.prototype.ComputeSubmergedArea = function(t, e, i, s) {
            void 0 === e && (e = 0);
            var n = h.MulTMV(i.R, t),
                a = e - h.Dot(t, i.position),
                r = new Vector_a2j_Number,
                l = 0,
                p = parseInt(-1),
                u = parseInt(-1),
                d = !1,
                m = 0;
            for (m = 0; m < this.m_vertexCount; ++m) {
                r[m] = h.Dot(n, this.m_vertices[m]) - a;
                var y = r[m] < -Number.MIN_VALUE;
                m > 0 && (y ? d || (p = m - 1, l++) : d && (u = m - 1, l++)), d = y
            }
            switch (l) {
                case 0:
                    if (d) {
                        var f = new o;
                        return this.ComputeMass(f, 1), s.SetV(h.MulX(i, f.center)), f.mass
                    }
                    return 0;
                case 1:
                    -1 == p ? p = this.m_vertexCount - 1 : u = this.m_vertexCount - 1
            }
            var g, _ = parseInt((p + 1) % this.m_vertexCount),
                v = parseInt((u + 1) % this.m_vertexCount),
                b = (0 - r[p]) / (r[_] - r[p]),
                x = (0 - r[u]) / (r[v] - r[u]),
                C = new c(this.m_vertices[p].x * (1 - b) + this.m_vertices[_].x * b, this.m_vertices[p].y * (1 - b) + this.m_vertices[_].y * b),
                S = new c(this.m_vertices[u].x * (1 - x) + this.m_vertices[v].x * x, this.m_vertices[u].y * (1 - x) + this.m_vertices[v].y * x),
                w = 0,
                A = new c,
                T = this.m_vertices[_];
            for (m = _; m != v;) {
                g = (m = (m + 1) % this.m_vertexCount) == v ? S : this.m_vertices[m];
                var B = .5 * ((T.x - C.x) * (g.y - C.y) - (T.y - C.y) * (g.x - C.x));
                w += B, A.x += B * (C.x + T.x + g.x) / 3, A.y += B * (C.y + T.y + g.y) / 3, T = g
            }
            return A.Multiply(1 / w), s.SetV(h.MulX(i, A)), w
        }, n.prototype.GetVertexCount = function() {
            return this.m_vertexCount
        }, n.prototype.GetVertices = function() {
            return this.m_vertices
        }, n.prototype.GetNormals = function() {
            return this.m_normals
        }, n.prototype.GetSupport = function(t) {
            for (var e = 0, i = this.m_vertices[0].x * t.x + this.m_vertices[0].y * t.y, s = 1; s < this.m_vertexCount; ++s) {
                var o = this.m_vertices[s].x * t.x + this.m_vertices[s].y * t.y;
                o > i && (e = s, i = o)
            }
            return e
        }, n.prototype.GetSupportVertex = function(t) {
            for (var e = 0, i = this.m_vertices[0].x * t.x + this.m_vertices[0].y * t.y, s = 1; s < this.m_vertexCount; ++s) {
                var o = this.m_vertices[s].x * t.x + this.m_vertices[s].y * t.y;
                o > i && (e = s, i = o)
            }
            return this.m_vertices[e]
        }, n.prototype.Validate = function() {
            return !1
        }, n.prototype.b2PolygonShape = function() {
            this.__super.b2Shape.call(this), this.m_type = a.e_polygonShape, this.m_centroid = new c, this.m_vertices = new Vector, this.m_normals = new Vector
        }, n.prototype.Reserve = function(t) {
            void 0 === t && (t = 0);
            for (var e = parseInt(this.m_vertices.length); e < t; e++) this.m_vertices[e] = new c, this.m_normals[e] = new c
        }, n.ComputeCentroid = function(t, e) {
            void 0 === e && (e = 0);
            for (var i = new c, s = 0, o = 0; o < e; ++o) {
                var n = t[o],
                    a = o + 1 < e ? t[parseInt(o + 1)] : t[0],
                    r = n.x - 0,
                    h = n.y - 0,
                    l = a.x - 0,
                    p = .5 * (r * (a.y - 0) - h * l);
                s += p, i.x += p * (1 / 3) * (0 + n.x + a.x), i.y += p * (1 / 3) * (0 + n.y + a.y)
            }
            return i.x *= 1 / s, i.y *= 1 / s, i
        }, n.ComputeOBB = function(t, e, i) {
            void 0 === i && (i = 0);
            var s = 0,
                o = new Vector(i + 1);
            for (s = 0; s < i; ++s) o[s] = e[s];
            o[i] = o[0];
            var n = Number.MAX_VALUE;
            for (s = 1; s <= i; ++s) {
                for (var a = o[parseInt(s - 1)], r = o[s].x - a.x, h = o[s].y - a.y, l = Math.sqrt(r * r + h * h), c = -(h /= l), p = r /= l, u = Number.MAX_VALUE, d = Number.MAX_VALUE, m = -Number.MAX_VALUE, y = -Number.MAX_VALUE, f = 0; f < i; ++f) {
                    var g = o[f].x - a.x,
                        _ = o[f].y - a.y,
                        v = r * g + h * _,
                        b = c * g + p * _;
                    v < u && (u = v), b < d && (d = b), v > m && (m = v), b > y && (y = b)
                }
                var x = (m - u) * (y - d);
                if (x < .95 * n) {
                    n = x, t.R.col1.x = r, t.R.col1.y = h, t.R.col2.x = c, t.R.col2.y = p;
                    var C = .5 * (u + m),
                        S = .5 * (d + y),
                        w = t.R;
                    t.center.x = a.x + (w.col1.x * C + w.col2.x * S), t.center.y = a.y + (w.col1.y * C + w.col2.y * S), t.extents.x = .5 * (m - u), t.extents.y = .5 * (y - d)
                }
            }
        }, Box2D.postDefs.push(function() {
            Box2D.Collision.Shapes.b2PolygonShape.s_mat = new r
        }), a.b2Shape = function() {}, a.prototype.Copy = function() {
            return null
        }, a.prototype.Set = function(t) {
            this.m_radius = t.m_radius
        }, a.prototype.GetType = function() {
            return this.m_type
        }, a.prototype.TestPoint = function(t, e) {
            return !1
        }, a.prototype.RayCast = function(t, e, i) {
            return !1
        }, a.prototype.ComputeAABB = function(t, e) {}, a.prototype.ComputeMass = function(t, e) {
            void 0 === e && (e = 0)
        }, a.prototype.ComputeSubmergedArea = function(t, e, i, s) {
            return void 0 === e && (e = 0), 0
        }, a.TestOverlap = function(t, e, i, s) {
            var o = new u;
            o.proxyA = new m, o.proxyA.Set(t), o.proxyB = new m, o.proxyB.Set(i), o.transformA = e, o.transformB = s, o.useRadii = !0;
            var n = new y;
            n.count = 0;
            var a = new d;
            return p.Distance(a, n, o), a.distance < 10 * Number.MIN_VALUE
        }, a.prototype.b2Shape = function() {
            this.m_type = a.e_unknownShape, this.m_radius = t.b2_linearSlop
        }, Box2D.postDefs.push(function() {
            Box2D.Collision.Shapes.b2Shape.e_unknownShape = parseInt(-1), Box2D.Collision.Shapes.b2Shape.e_circleShape = 0, Box2D.Collision.Shapes.b2Shape.e_polygonShape = 1, Box2D.Collision.Shapes.b2Shape.e_edgeShape = 2, Box2D.Collision.Shapes.b2Shape.e_shapeTypeCount = 3, Box2D.Collision.Shapes.b2Shape.e_hitCollide = 1, Box2D.Collision.Shapes.b2Shape.e_missCollide = 0, Box2D.Collision.Shapes.b2Shape.e_startsInsideCollide = parseInt(-1)
        })
    }(),
    function() {
        var t = Box2D.Common.b2Color,
            e = (Box2D.Common.b2internal, Box2D.Common.b2Settings),
            i = (Box2D.Common.Math.b2Mat22, Box2D.Common.Math.b2Mat33, Box2D.Common.Math.b2Math);
        Box2D.Common.Math.b2Sweep, Box2D.Common.Math.b2Transform, Box2D.Common.Math.b2Vec2, Box2D.Common.Math.b2Vec3;
        t.b2Color = function() {
            this._r = 0, this._g = 0, this._b = 0
        }, t.prototype.b2Color = function(t, e, s) {
            void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === s && (s = 0), this._r = Box2D.parseUInt(255 * i.Clamp(t, 0, 1)), this._g = Box2D.parseUInt(255 * i.Clamp(e, 0, 1)), this._b = Box2D.parseUInt(255 * i.Clamp(s, 0, 1))
        }, t.prototype.Set = function(t, e, s) {
            void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === s && (s = 0), this._r = Box2D.parseUInt(255 * i.Clamp(t, 0, 1)), this._g = Box2D.parseUInt(255 * i.Clamp(e, 0, 1)), this._b = Box2D.parseUInt(255 * i.Clamp(s, 0, 1))
        }, Object.defineProperty(t.prototype, "r", {
            enumerable: !1,
            configurable: !0,
            set: function(t) {
                void 0 === t && (t = 0), this._r = Box2D.parseUInt(255 * i.Clamp(t, 0, 1))
            }
        }), Object.defineProperty(t.prototype, "g", {
            enumerable: !1,
            configurable: !0,
            set: function(t) {
                void 0 === t && (t = 0), this._g = Box2D.parseUInt(255 * i.Clamp(t, 0, 1))
            }
        }), Object.defineProperty(t.prototype, "b", {
            enumerable: !1,
            configurable: !0,
            set: function(t) {
                void 0 === t && (t = 0), this._b = Box2D.parseUInt(255 * i.Clamp(t, 0, 1))
            }
        }), Object.defineProperty(t.prototype, "color", {
            enumerable: !1,
            configurable: !0,
            get: function() {
                return this._r << 16 | this._g << 8 | this._b
            }
        }), e.b2Settings = function() {}, e.b2MixFriction = function(t, e) {
            return void 0 === t && (t = 0), void 0 === e && (e = 0), Math.sqrt(t * e)
        }, e.b2MixRestitution = function(t, e) {
            return void 0 === t && (t = 0), void 0 === e && (e = 0), t > e ? t : e
        }, e.b2Assert = function(t) {
            if (!t) throw "Assertion Failed"
        }, Box2D.postDefs.push(function() {
            Box2D.Common.b2Settings.VERSION = "2.1alpha", Box2D.Common.b2Settings.USHRT_MAX = 65535, Box2D.Common.b2Settings.b2_pi = Math.PI, Box2D.Common.b2Settings.b2_maxManifoldPoints = 2, Box2D.Common.b2Settings.b2_aabbExtension = .1, Box2D.Common.b2Settings.b2_aabbMultiplier = 2, Box2D.Common.b2Settings.b2_polygonRadius = 2 * e.b2_linearSlop, Box2D.Common.b2Settings.b2_linearSlop = .005, Box2D.Common.b2Settings.b2_angularSlop = 2 / 180 * e.b2_pi, Box2D.Common.b2Settings.b2_toiSlop = 8 * e.b2_linearSlop, Box2D.Common.b2Settings.b2_maxTOIContactsPerIsland = 32, Box2D.Common.b2Settings.b2_maxTOIJointsPerIsland = 32, Box2D.Common.b2Settings.b2_velocityThreshold = 1, Box2D.Common.b2Settings.b2_maxLinearCorrection = .2, Box2D.Common.b2Settings.b2_maxAngularCorrection = 8 / 180 * e.b2_pi, Box2D.Common.b2Settings.b2_maxTranslation = 2, Box2D.Common.b2Settings.b2_maxTranslationSquared = e.b2_maxTranslation * e.b2_maxTranslation, Box2D.Common.b2Settings.b2_maxRotation = .5 * e.b2_pi, Box2D.Common.b2Settings.b2_maxRotationSquared = e.b2_maxRotation * e.b2_maxRotation, Box2D.Common.b2Settings.b2_contactBaumgarte = .2, Box2D.Common.b2Settings.b2_timeToSleep = .5, Box2D.Common.b2Settings.b2_linearSleepTolerance = .01, Box2D.Common.b2Settings.b2_angularSleepTolerance = 2 / 180 * e.b2_pi
        })
    }(),
    function() {
        Box2D.Collision.b2AABB, Box2D.Common.b2Color, Box2D.Common.b2internal, Box2D.Common.b2Settings;
        var t = Box2D.Common.Math.b2Mat22,
            e = Box2D.Common.Math.b2Mat33,
            i = Box2D.Common.Math.b2Math,
            s = Box2D.Common.Math.b2Sweep,
            o = Box2D.Common.Math.b2Transform,
            n = Box2D.Common.Math.b2Vec2,
            a = Box2D.Common.Math.b2Vec3;
        t.b2Mat22 = function() {
            this.col1 = new n, this.col2 = new n
        }, t.prototype.b2Mat22 = function() {
            this.SetIdentity()
        }, t.FromAngle = function(e) {
            void 0 === e && (e = 0);
            var i = new t;
            return i.Set(e), i
        }, t.FromVV = function(e, i) {
            var s = new t;
            return s.SetVV(e, i), s
        }, t.prototype.Set = function(t) {
            void 0 === t && (t = 0);
            var e = Math.cos(t),
                i = Math.sin(t);
            this.col1.x = e, this.col2.x = -i, this.col1.y = i, this.col2.y = e
        }, t.prototype.SetVV = function(t, e) {
            this.col1.SetV(t), this.col2.SetV(e)
        }, t.prototype.Copy = function() {
            var e = new t;
            return e.SetM(this), e
        }, t.prototype.SetM = function(t) {
            this.col1.SetV(t.col1), this.col2.SetV(t.col2)
        }, t.prototype.AddM = function(t) {
            this.col1.x += t.col1.x, this.col1.y += t.col1.y, this.col2.x += t.col2.x, this.col2.y += t.col2.y
        }, t.prototype.SetIdentity = function() {
            this.col1.x = 1, this.col2.x = 0, this.col1.y = 0, this.col2.y = 1
        }, t.prototype.SetZero = function() {
            this.col1.x = 0, this.col2.x = 0, this.col1.y = 0, this.col2.y = 0
        }, t.prototype.GetAngle = function() {
            return Math.atan2(this.col1.y, this.col1.x)
        }, t.prototype.GetInverse = function(t) {
            var e = this.col1.x,
                i = this.col2.x,
                s = this.col1.y,
                o = this.col2.y,
                n = e * o - i * s;
            return 0 != n && (n = 1 / n), t.col1.x = n * o, t.col2.x = -n * i, t.col1.y = -n * s, t.col2.y = n * e, t
        }, t.prototype.Solve = function(t, e, i) {
            void 0 === e && (e = 0), void 0 === i && (i = 0);
            var s = this.col1.x,
                o = this.col2.x,
                n = this.col1.y,
                a = this.col2.y,
                r = s * a - o * n;
            return 0 != r && (r = 1 / r), t.x = r * (a * e - o * i), t.y = r * (s * i - n * e), t
        }, t.prototype.Abs = function() {
            this.col1.Abs(), this.col2.Abs()
        }, e.b2Mat33 = function() {
            this.col1 = new a, this.col2 = new a, this.col3 = new a
        }, e.prototype.b2Mat33 = function(t, e, i) {
            void 0 === t && (t = null), void 0 === e && (e = null), void 0 === i && (i = null), t || e || i ? (this.col1.SetV(t), this.col2.SetV(e), this.col3.SetV(i)) : (this.col1.SetZero(), this.col2.SetZero(), this.col3.SetZero())
        }, e.prototype.SetVVV = function(t, e, i) {
            this.col1.SetV(t), this.col2.SetV(e), this.col3.SetV(i)
        }, e.prototype.Copy = function() {
            return new e(this.col1, this.col2, this.col3)
        }, e.prototype.SetM = function(t) {
            this.col1.SetV(t.col1), this.col2.SetV(t.col2), this.col3.SetV(t.col3)
        }, e.prototype.AddM = function(t) {
            this.col1.x += t.col1.x, this.col1.y += t.col1.y, this.col1.z += t.col1.z, this.col2.x += t.col2.x, this.col2.y += t.col2.y, this.col2.z += t.col2.z, this.col3.x += t.col3.x, this.col3.y += t.col3.y, this.col3.z += t.col3.z
        }, e.prototype.SetIdentity = function() {
            this.col1.x = 1, this.col2.x = 0, this.col3.x = 0, this.col1.y = 0, this.col2.y = 1, this.col3.y = 0, this.col1.z = 0, this.col2.z = 0, this.col3.z = 1
        }, e.prototype.SetZero = function() {
            this.col1.x = 0, this.col2.x = 0, this.col3.x = 0, this.col1.y = 0, this.col2.y = 0, this.col3.y = 0, this.col1.z = 0, this.col2.z = 0, this.col3.z = 0
        }, e.prototype.Solve22 = function(t, e, i) {
            void 0 === e && (e = 0), void 0 === i && (i = 0);
            var s = this.col1.x,
                o = this.col2.x,
                n = this.col1.y,
                a = this.col2.y,
                r = s * a - o * n;
            return 0 != r && (r = 1 / r), t.x = r * (a * e - o * i), t.y = r * (s * i - n * e), t
        }, e.prototype.Solve33 = function(t, e, i, s) {
            void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = 0);
            var o = this.col1.x,
                n = this.col1.y,
                a = this.col1.z,
                r = this.col2.x,
                h = this.col2.y,
                l = this.col2.z,
                c = this.col3.x,
                p = this.col3.y,
                u = this.col3.z,
                d = o * (h * u - l * p) + n * (l * c - r * u) + a * (r * p - h * c);
            return 0 != d && (d = 1 / d), t.x = d * (e * (h * u - l * p) + i * (l * c - r * u) + s * (r * p - h * c)), t.y = d * (o * (i * u - s * p) + n * (s * c - e * u) + a * (e * p - i * c)), t.z = d * (o * (h * s - l * i) + n * (l * e - r * s) + a * (r * i - h * e)), t
        }, i.b2Math = function() {}, i.IsValid = function(t) {
            return void 0 === t && (t = 0), isFinite(t)
        }, i.Dot = function(t, e) {
            return t.x * e.x + t.y * e.y
        }, i.CrossVV = function(t, e) {
            return t.x * e.y - t.y * e.x
        }, i.CrossVF = function(t, e) {
            return void 0 === e && (e = 0), new n(e * t.y, -e * t.x)
        }, i.CrossFV = function(t, e) {
            return void 0 === t && (t = 0), new n(-t * e.y, t * e.x)
        }, i.MulMV = function(t, e) {
            return new n(t.col1.x * e.x + t.col2.x * e.y, t.col1.y * e.x + t.col2.y * e.y)
        }, i.MulTMV = function(t, e) {
            return new n(i.Dot(e, t.col1), i.Dot(e, t.col2))
        }, i.MulX = function(t, e) {
            var s = i.MulMV(t.R, e);
            return s.x += t.position.x, s.y += t.position.y, s
        }, i.MulXT = function(t, e) {
            var s = i.SubtractVV(e, t.position),
                o = s.x * t.R.col1.x + s.y * t.R.col1.y;
            return s.y = s.x * t.R.col2.x + s.y * t.R.col2.y, s.x = o, s
        }, i.AddVV = function(t, e) {
            return new n(t.x + e.x, t.y + e.y)
        }, i.SubtractVV = function(t, e) {
            return new n(t.x - e.x, t.y - e.y)
        }, i.Distance = function(t, e) {
            var i = t.x - e.x,
                s = t.y - e.y;
            return Math.sqrt(i * i + s * s)
        }, i.DistanceSquared = function(t, e) {
            var i = t.x - e.x,
                s = t.y - e.y;
            return i * i + s * s
        }, i.MulFV = function(t, e) {
            return void 0 === t && (t = 0), new n(t * e.x, t * e.y)
        }, i.AddMM = function(e, s) {
            return t.FromVV(i.AddVV(e.col1, s.col1), i.AddVV(e.col2, s.col2))
        }, i.MulMM = function(e, s) {
            return t.FromVV(i.MulMV(e, s.col1), i.MulMV(e, s.col2))
        }, i.MulTMM = function(e, s) {
            var o = new n(i.Dot(e.col1, s.col1), i.Dot(e.col2, s.col1)),
                a = new n(i.Dot(e.col1, s.col2), i.Dot(e.col2, s.col2));
            return t.FromVV(o, a)
        }, i.Abs = function(t) {
            return void 0 === t && (t = 0), t > 0 ? t : -t
        }, i.AbsV = function(t) {
            return new n(i.Abs(t.x), i.Abs(t.y))
        }, i.AbsM = function(e) {
            return t.FromVV(i.AbsV(e.col1), i.AbsV(e.col2))
        }, i.Min = function(t, e) {
            return void 0 === t && (t = 0), void 0 === e && (e = 0), t < e ? t : e
        }, i.MinV = function(t, e) {
            return new n(i.Min(t.x, e.x), i.Min(t.y, e.y))
        }, i.Max = function(t, e) {
            return void 0 === t && (t = 0), void 0 === e && (e = 0), t > e ? t : e
        }, i.MaxV = function(t, e) {
            return new n(i.Max(t.x, e.x), i.Max(t.y, e.y))
        }, i.Clamp = function(t, e, i) {
            return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), t < e ? e : t > i ? i : t
        }, i.ClampV = function(t, e, s) {
            return i.MaxV(e, i.MinV(t, s))
        }, i.Swap = function(t, e) {
            var i = t[0];
            t[0] = e[0], e[0] = i
        }, i.Random = function() {
            return 2 * Math.random() - 1
        }, i.RandomRange = function(t, e) {
            void 0 === t && (t = 0), void 0 === e && (e = 0);
            var i = Math.random();
            return i = (e - t) * i + t
        }, i.NextPowerOfTwo = function(t) {
            return void 0 === t && (t = 0), t |= t >> 1 & 2147483647, t |= t >> 2 & 1073741823, t |= t >> 4 & 268435455, t |= t >> 8 & 16777215, (t |= t >> 16 & 65535) + 1
        }, i.IsPowerOfTwo = function(t) {
            return void 0 === t && (t = 0), t > 0 && 0 == (t & t - 1)
        }, Box2D.postDefs.push(function() {
            Box2D.Common.Math.b2Math.b2Vec2_zero = new n(0, 0), Box2D.Common.Math.b2Math.b2Mat22_identity = t.FromVV(new n(1, 0), new n(0, 1)), Box2D.Common.Math.b2Math.b2Transform_identity = new o(i.b2Vec2_zero, i.b2Mat22_identity)
        }), s.b2Sweep = function() {
            this.localCenter = new n, this.c0 = new n, this.c = new n
        }, s.prototype.Set = function(t) {
            this.localCenter.SetV(t.localCenter), this.c0.SetV(t.c0), this.c.SetV(t.c), this.a0 = t.a0, this.a = t.a, this.t0 = t.t0
        }, s.prototype.Copy = function() {
            var t = new s;
            return t.localCenter.SetV(this.localCenter), t.c0.SetV(this.c0), t.c.SetV(this.c), t.a0 = this.a0, t.a = this.a, t.t0 = this.t0, t
        }, s.prototype.GetTransform = function(t, e) {
            void 0 === e && (e = 0), t.position.x = (1 - e) * this.c0.x + e * this.c.x, t.position.y = (1 - e) * this.c0.y + e * this.c.y;
            var i = (1 - e) * this.a0 + e * this.a;
            t.R.Set(i);
            var s = t.R;
            t.position.x -= s.col1.x * this.localCenter.x + s.col2.x * this.localCenter.y, t.position.y -= s.col1.y * this.localCenter.x + s.col2.y * this.localCenter.y
        }, s.prototype.Advance = function(t) {
            if (void 0 === t && (t = 0), this.t0 < t && 1 - this.t0 > Number.MIN_VALUE) {
                var e = (t - this.t0) / (1 - this.t0);
                this.c0.x = (1 - e) * this.c0.x + e * this.c.x, this.c0.y = (1 - e) * this.c0.y + e * this.c.y, this.a0 = (1 - e) * this.a0 + e * this.a, this.t0 = t
            }
        }, o.b2Transform = function() {
            this.position = new n, this.R = new t
        }, o.prototype.b2Transform = function(t, e) {
            void 0 === t && (t = null), void 0 === e && (e = null), t && (this.position.SetV(t), this.R.SetM(e))
        }, o.prototype.Initialize = function(t, e) {
            this.position.SetV(t), this.R.SetM(e)
        }, o.prototype.SetIdentity = function() {
            this.position.SetZero(), this.R.SetIdentity()
        }, o.prototype.Set = function(t) {
            this.position.SetV(t.position), this.R.SetM(t.R)
        }, o.prototype.GetAngle = function() {
            return Math.atan2(this.R.col1.y, this.R.col1.x)
        }, n.b2Vec2 = function() {}, n.prototype.b2Vec2 = function(t, e) {
            void 0 === t && (t = 0), void 0 === e && (e = 0), this.x = t, this.y = e
        }, n.prototype.SetZero = function() {
            this.x = 0, this.y = 0
        }, n.prototype.Set = function(t, e) {
            void 0 === t && (t = 0), void 0 === e && (e = 0), this.x = t, this.y = e
        }, n.prototype.SetV = function(t) {
            this.x = t.x, this.y = t.y
        }, n.prototype.GetNegative = function() {
            return new n(-this.x, -this.y)
        }, n.prototype.NegativeSelf = function() {
            this.x = -this.x, this.y = -this.y
        }, n.Make = function(t, e) {
            return void 0 === t && (t = 0), void 0 === e && (e = 0), new n(t, e)
        }, n.prototype.Copy = function() {
            return new n(this.x, this.y)
        }, n.prototype.Add = function(t) {
            this.x += t.x, this.y += t.y
        }, n.prototype.Subtract = function(t) {
            this.x -= t.x, this.y -= t.y
        }, n.prototype.Multiply = function(t) {
            void 0 === t && (t = 0), this.x *= t, this.y *= t
        }, n.prototype.MulM = function(t) {
            var e = this.x;
            this.x = t.col1.x * e + t.col2.x * this.y, this.y = t.col1.y * e + t.col2.y * this.y
        }, n.prototype.MulTM = function(t) {
            var e = i.Dot(this, t.col1);
            this.y = i.Dot(this, t.col2), this.x = e
        }, n.prototype.CrossVF = function(t) {
            void 0 === t && (t = 0);
            var e = this.x;
            this.x = t * this.y, this.y = -t * e
        }, n.prototype.CrossFV = function(t) {
            void 0 === t && (t = 0);
            var e = this.x;
            this.x = -t * this.y, this.y = t * e
        }, n.prototype.MinV = function(t) {
            this.x = this.x < t.x ? this.x : t.x, this.y = this.y < t.y ? this.y : t.y
        }, n.prototype.MaxV = function(t) {
            this.x = this.x > t.x ? this.x : t.x, this.y = this.y > t.y ? this.y : t.y
        }, n.prototype.Abs = function() {
            this.x < 0 && (this.x = -this.x), this.y < 0 && (this.y = -this.y)
        }, n.prototype.Length = function() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        }, n.prototype.LengthSquared = function() {
            return this.x * this.x + this.y * this.y
        }, n.prototype.Normalize = function() {
            var t = Math.sqrt(this.x * this.x + this.y * this.y);
            if (t < Number.MIN_VALUE) return 0;
            var e = 1 / t;
            return this.x *= e, this.y *= e, t
        }, n.prototype.IsValid = function() {
            return i.IsValid(this.x) && i.IsValid(this.y)
        }, a.b2Vec3 = function() {}, a.prototype.b2Vec3 = function(t, e, i) {
            void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), this.x = t, this.y = e, this.z = i
        }, a.prototype.SetZero = function() {
            this.x = this.y = this.z = 0
        }, a.prototype.Set = function(t, e, i) {
            void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), this.x = t, this.y = e, this.z = i
        }, a.prototype.SetV = function(t) {
            this.x = t.x, this.y = t.y, this.z = t.z
        }, a.prototype.GetNegative = function() {
            return new a(-this.x, -this.y, -this.z)
        }, a.prototype.NegativeSelf = function() {
            this.x = -this.x, this.y = -this.y, this.z = -this.z
        }, a.prototype.Copy = function() {
            return new a(this.x, this.y, this.z)
        }, a.prototype.Add = function(t) {
            this.x += t.x, this.y += t.y, this.z += t.z
        }, a.prototype.Subtract = function(t) {
            this.x -= t.x, this.y -= t.y, this.z -= t.z
        }, a.prototype.Multiply = function(t) {
            void 0 === t && (t = 0), this.x *= t, this.y *= t, this.z *= t
        }
    }(),
    function() {
        Box2D.Dynamics.Controllers.b2ControllerEdge, Box2D.Common.Math.b2Mat22, Box2D.Common.Math.b2Mat33;
        var t = Box2D.Common.Math.b2Math,
            e = Box2D.Common.Math.b2Sweep,
            i = Box2D.Common.Math.b2Transform,
            s = Box2D.Common.Math.b2Vec2,
            o = (Box2D.Common.Math.b2Vec3, Box2D.Common.b2Color),
            n = (Box2D.Common.b2internal, Box2D.Common.b2Settings),
            a = Box2D.Collision.b2AABB,
            r = (Box2D.Collision.b2Bound, Box2D.Collision.b2BoundValues, Box2D.Collision.b2Collision, Box2D.Collision.b2ContactID, Box2D.Collision.b2ContactPoint),
            h = (Box2D.Collision.b2Distance, Box2D.Collision.b2DistanceInput, Box2D.Collision.b2DistanceOutput, Box2D.Collision.b2DistanceProxy, Box2D.Collision.b2DynamicTree, Box2D.Collision.b2DynamicTreeBroadPhase),
            l = (Box2D.Collision.b2DynamicTreeNode, Box2D.Collision.b2DynamicTreePair, Box2D.Collision.b2Manifold, Box2D.Collision.b2ManifoldPoint, Box2D.Collision.b2Point, Box2D.Collision.b2RayCastInput),
            c = Box2D.Collision.b2RayCastOutput,
            p = (Box2D.Collision.b2Segment, Box2D.Collision.b2SeparationFunction, Box2D.Collision.b2Simplex, Box2D.Collision.b2SimplexCache, Box2D.Collision.b2SimplexVertex, Box2D.Collision.b2TimeOfImpact, Box2D.Collision.b2TOIInput, Box2D.Collision.b2WorldManifold, Box2D.Collision.ClipVertex, Box2D.Collision.Features, Box2D.Collision.IBroadPhase, Box2D.Collision.Shapes.b2CircleShape),
            u = (Box2D.Collision.Shapes.b2EdgeChainDef, Box2D.Collision.Shapes.b2EdgeShape),
            d = Box2D.Collision.Shapes.b2MassData,
            m = Box2D.Collision.Shapes.b2PolygonShape,
            y = Box2D.Collision.Shapes.b2Shape,
            f = Box2D.Dynamics.b2Body,
            g = Box2D.Dynamics.b2BodyDef,
            _ = Box2D.Dynamics.b2ContactFilter,
            v = Box2D.Dynamics.b2ContactImpulse,
            b = Box2D.Dynamics.b2ContactListener,
            x = Box2D.Dynamics.b2ContactManager,
            C = Box2D.Dynamics.b2DebugDraw,
            S = Box2D.Dynamics.b2DestructionListener,
            w = Box2D.Dynamics.b2FilterData,
            A = Box2D.Dynamics.b2Fixture,
            T = Box2D.Dynamics.b2FixtureDef,
            B = Box2D.Dynamics.b2Island,
            P = Box2D.Dynamics.b2TimeStep,
            D = Box2D.Dynamics.b2World,
            I = (Box2D.Dynamics.Contacts.b2CircleContact, Box2D.Dynamics.Contacts.b2Contact),
            E = (Box2D.Dynamics.Contacts.b2ContactConstraint, Box2D.Dynamics.Contacts.b2ContactConstraintPoint, Box2D.Dynamics.Contacts.b2ContactEdge, Box2D.Dynamics.Contacts.b2ContactFactory),
            L = (Box2D.Dynamics.Contacts.b2ContactRegister, Box2D.Dynamics.Contacts.b2ContactResult, Box2D.Dynamics.Contacts.b2ContactSolver),
            M = (Box2D.Dynamics.Contacts.b2EdgeAndCircleContact, Box2D.Dynamics.Contacts.b2NullContact, Box2D.Dynamics.Contacts.b2PolyAndCircleContact, Box2D.Dynamics.Contacts.b2PolyAndEdgeContact, Box2D.Dynamics.Contacts.b2PolygonContact, Box2D.Dynamics.Contacts.b2PositionSolverManifold, Box2D.Dynamics.Controllers.b2Controller, Box2D.Dynamics.Joints.b2DistanceJoint, Box2D.Dynamics.Joints.b2DistanceJointDef, Box2D.Dynamics.Joints.b2FrictionJoint, Box2D.Dynamics.Joints.b2FrictionJointDef, Box2D.Dynamics.Joints.b2GearJoint, Box2D.Dynamics.Joints.b2GearJointDef, Box2D.Dynamics.Joints.b2Jacobian, Box2D.Dynamics.Joints.b2Joint),
            G = (Box2D.Dynamics.Joints.b2JointDef, Box2D.Dynamics.Joints.b2JointEdge, Box2D.Dynamics.Joints.b2LineJoint, Box2D.Dynamics.Joints.b2LineJointDef, Box2D.Dynamics.Joints.b2MouseJoint, Box2D.Dynamics.Joints.b2MouseJointDef, Box2D.Dynamics.Joints.b2PrismaticJoint, Box2D.Dynamics.Joints.b2PrismaticJointDef, Box2D.Dynamics.Joints.b2PulleyJoint);
        Box2D.Dynamics.Joints.b2PulleyJointDef, Box2D.Dynamics.Joints.b2RevoluteJoint, Box2D.Dynamics.Joints.b2RevoluteJointDef, Box2D.Dynamics.Joints.b2WeldJoint, Box2D.Dynamics.Joints.b2WeldJointDef;
        f.b2Body = function() {
            this.m_xf = new i, this.m_sweep = new e, this.m_linearVelocity = new s, this.m_force = new s
        }, f.prototype.connectEdges = function(e, i, s) {
            void 0 === s && (s = 0);
            var o = Math.atan2(i.GetDirectionVector().y, i.GetDirectionVector().x),
                a = Math.tan(.5 * (o - s)),
                r = t.MulFV(a, i.GetDirectionVector());
            r = t.SubtractVV(r, i.GetNormalVector()), r = t.MulFV(n.b2_toiSlop, r), r = t.AddVV(r, i.GetVertex1());
            var h = t.AddVV(e.GetDirectionVector(), i.GetDirectionVector());
            h.Normalize();
            var l = t.Dot(e.GetDirectionVector(), i.GetNormalVector()) > 0;
            return e.SetNextEdge(i, r, h, l), i.SetPrevEdge(e, r, h, l), o
        }, f.prototype.CreateFixture = function(t) {
            if (1 == this.m_world.IsLocked()) return null;
            var e = new A;
            if (e.Create(this, this.m_xf, t), this.m_flags & f.e_activeFlag) {
                var i = this.m_world.m_contactManager.m_broadPhase;
                e.CreateProxy(i, this.m_xf)
            }
            return e.m_next = this.m_fixtureList, this.m_fixtureList = e, ++this.m_fixtureCount, e.m_body = this, e.m_density > 0 && this.ResetMassData(), this.m_world.m_flags |= D.e_newFixture, e
        }, f.prototype.CreateFixture2 = function(t, e) {
            void 0 === e && (e = 0);
            var i = new T;
            return i.shape = t, i.density = e, this.CreateFixture(i)
        }, f.prototype.DestroyFixture = function(t) {
            if (1 != this.m_world.IsLocked()) {
                for (var e = this.m_fixtureList, i = null; null != e;) {
                    if (e == t) {
                        i ? i.m_next = t.m_next : this.m_fixtureList = t.m_next, !0;
                        break
                    }
                    i = e, e = e.m_next
                }
                for (var s = this.m_contactList; s;) {
                    var o = s.contact;
                    s = s.next;
                    var n = o.GetFixtureA(),
                        a = o.GetFixtureB();
                    t != n && t != a || this.m_world.m_contactManager.Destroy(o)
                }
                if (this.m_flags & f.e_activeFlag) {
                    var r = this.m_world.m_contactManager.m_broadPhase;
                    t.DestroyProxy(r)
                }
                t.Destroy(), t.m_body = null, t.m_next = null, --this.m_fixtureCount, this.ResetMassData()
            }
        }, f.prototype.SetPositionAndAngle = function(t, e) {
            void 0 === e && (e = 0);
            var i;
            if (1 != this.m_world.IsLocked()) {
                this.m_xf.R.Set(e), this.m_xf.position.SetV(t);
                var s = this.m_xf.R,
                    o = this.m_sweep.localCenter;
                this.m_sweep.c.x = s.col1.x * o.x + s.col2.x * o.y, this.m_sweep.c.y = s.col1.y * o.x + s.col2.y * o.y, this.m_sweep.c.x += this.m_xf.position.x, this.m_sweep.c.y += this.m_xf.position.y, this.m_sweep.c0.SetV(this.m_sweep.c), this.m_sweep.a0 = this.m_sweep.a = e;
                var n = this.m_world.m_contactManager.m_broadPhase;
                for (i = this.m_fixtureList; i; i = i.m_next) i.Synchronize(n, this.m_xf, this.m_xf);
                this.m_world.m_contactManager.FindNewContacts()
            }
        }, f.prototype.SetTransform = function(t) {
            this.SetPositionAndAngle(t.position, t.GetAngle())
        }, f.prototype.GetTransform = function() {
            return this.m_xf
        }, f.prototype.GetPosition = function() {
            return this.m_xf.position
        }, f.prototype.SetPosition = function(t) {
            this.SetPositionAndAngle(t, this.GetAngle())
        }, f.prototype.GetAngle = function() {
            return this.m_sweep.a
        }, f.prototype.SetAngle = function(t) {
            void 0 === t && (t = 0), this.SetPositionAndAngle(this.GetPosition(), t)
        }, f.prototype.GetWorldCenter = function() {
            return this.m_sweep.c
        }, f.prototype.GetLocalCenter = function() {
            return this.m_sweep.localCenter
        }, f.prototype.SetLinearVelocity = function(t) {
            this.m_type != f.b2_staticBody && this.m_linearVelocity.SetV(t)
        }, f.prototype.GetLinearVelocity = function() {
            return this.m_linearVelocity
        }, f.prototype.SetAngularVelocity = function(t) {
            void 0 === t && (t = 0), this.m_type != f.b2_staticBody && (this.m_angularVelocity = t)
        }, f.prototype.GetAngularVelocity = function() {
            return this.m_angularVelocity
        }, f.prototype.GetDefinition = function() {
            var t = new g;
            return t.type = this.GetType(), t.allowSleep = (this.m_flags & f.e_allowSleepFlag) == f.e_allowSleepFlag, t.angle = this.GetAngle(), t.angularDamping = this.m_angularDamping, t.angularVelocity = this.m_angularVelocity, t.fixedRotation = (this.m_flags & f.e_fixedRotationFlag) == f.e_fixedRotationFlag, t.bullet = (this.m_flags & f.e_bulletFlag) == f.e_bulletFlag, t.awake = (this.m_flags & f.e_awakeFlag) == f.e_awakeFlag, t.linearDamping = this.m_linearDamping, t.linearVelocity.SetV(this.GetLinearVelocity()), t.position = this.GetPosition(), t.userData = this.GetUserData(), t
        }, f.prototype.ApplyForce = function(t, e) {
            this.m_type == f.b2_dynamicBody && (0 == this.IsAwake() && this.SetAwake(!0), this.m_force.x += t.x, this.m_force.y += t.y, this.m_torque += (e.x - this.m_sweep.c.x) * t.y - (e.y - this.m_sweep.c.y) * t.x)
        }, f.prototype.ApplyTorque = function(t) {
            void 0 === t && (t = 0), this.m_type == f.b2_dynamicBody && (0 == this.IsAwake() && this.SetAwake(!0), this.m_torque += t)
        }, f.prototype.ApplyImpulse = function(t, e) {
            this.m_type == f.b2_dynamicBody && (0 == this.IsAwake() && this.SetAwake(!0), this.m_linearVelocity.x += this.m_invMass * t.x, this.m_linearVelocity.y += this.m_invMass * t.y, this.m_angularVelocity += this.m_invI * ((e.x - this.m_sweep.c.x) * t.y - (e.y - this.m_sweep.c.y) * t.x))
        }, f.prototype.Split = function(e) {
            for (var i, s = this.GetLinearVelocity().Copy(), o = this.GetAngularVelocity(), n = this.GetWorldCenter(), a = this, r = this.m_world.CreateBody(this.GetDefinition()), h = a.m_fixtureList; h;)
                if (e(h)) {
                    var l = h.m_next;
                    i ? i.m_next = l : a.m_fixtureList = l, a.m_fixtureCount--, h.m_next = r.m_fixtureList, r.m_fixtureList = h, r.m_fixtureCount++, h.m_body = r, h = l
                } else i = h, h = h.m_next;
            a.ResetMassData(), r.ResetMassData();
            var c = a.GetWorldCenter(),
                p = r.GetWorldCenter(),
                u = t.AddVV(s, t.CrossFV(o, t.SubtractVV(c, n))),
                d = t.AddVV(s, t.CrossFV(o, t.SubtractVV(p, n)));
            return a.SetLinearVelocity(u), r.SetLinearVelocity(d), a.SetAngularVelocity(o), r.SetAngularVelocity(o), a.SynchronizeFixtures(), r.SynchronizeFixtures(), r
        }, f.prototype.Merge = function(t) {
            var e;
            for (e = t.m_fixtureList; e;) {
                var i = e.m_next;
                t.m_fixtureCount--, e.m_next = this.m_fixtureList, this.m_fixtureList = e, this.m_fixtureCount++, e.m_body = o, e = i
            }
            s.m_fixtureCount = 0;
            var s = this,
                o = t;
            s.GetWorldCenter(), o.GetWorldCenter(), s.GetLinearVelocity().Copy(), o.GetLinearVelocity().Copy(), s.GetAngularVelocity(), o.GetAngularVelocity();
            s.ResetMassData(), this.SynchronizeFixtures()
        }, f.prototype.GetMass = function() {
            return this.m_mass
        }, f.prototype.GetInertia = function() {
            return this.m_I
        }, f.prototype.GetMassData = function(t) {
            t.mass = this.m_mass, t.I = this.m_I, t.center.SetV(this.m_sweep.localCenter)
        }, f.prototype.SetMassData = function(e) {
            if (n.b2Assert(0 == this.m_world.IsLocked()), 1 != this.m_world.IsLocked() && this.m_type == f.b2_dynamicBody) {
                this.m_invMass = 0, this.m_I = 0, this.m_invI = 0, this.m_mass = e.mass, this.m_mass <= 0 && (this.m_mass = 1), this.m_invMass = 1 / this.m_mass, e.I > 0 && 0 == (this.m_flags & f.e_fixedRotationFlag) && (this.m_I = e.I - this.m_mass * (e.center.x * e.center.x + e.center.y * e.center.y), this.m_invI = 1 / this.m_I);
                var i = this.m_sweep.c.Copy();
                this.m_sweep.localCenter.SetV(e.center), this.m_sweep.c0.SetV(t.MulX(this.m_xf, this.m_sweep.localCenter)), this.m_sweep.c.SetV(this.m_sweep.c0), this.m_linearVelocity.x += this.m_angularVelocity * -(this.m_sweep.c.y - i.y), this.m_linearVelocity.y += this.m_angularVelocity * +(this.m_sweep.c.x - i.x)
            }
        }, f.prototype.ResetMassData = function() {
            if (this.m_mass = 0, this.m_invMass = 0, this.m_I = 0, this.m_invI = 0, this.m_sweep.localCenter.SetZero(), this.m_type != f.b2_staticBody && this.m_type != f.b2_kinematicBody) {
                for (var e = s.Make(0, 0), i = this.m_fixtureList; i; i = i.m_next)
                    if (0 != i.m_density) {
                        var o = i.GetMassData();
                        this.m_mass += o.mass, e.x += o.center.x * o.mass, e.y += o.center.y * o.mass, this.m_I += o.I
                    }
                this.m_mass > 0 ? (this.m_invMass = 1 / this.m_mass, e.x *= this.m_invMass, e.y *= this.m_invMass) : (this.m_mass = 1, this.m_invMass = 1), this.m_I > 0 && 0 == (this.m_flags & f.e_fixedRotationFlag) ? (this.m_I -= this.m_mass * (e.x * e.x + e.y * e.y), this.m_I *= this.m_inertiaScale, n.b2Assert(this.m_I > 0), this.m_invI = 1 / this.m_I) : (this.m_I = 0, this.m_invI = 0);
                var a = this.m_sweep.c.Copy();
                this.m_sweep.localCenter.SetV(e), this.m_sweep.c0.SetV(t.MulX(this.m_xf, this.m_sweep.localCenter)), this.m_sweep.c.SetV(this.m_sweep.c0), this.m_linearVelocity.x += this.m_angularVelocity * -(this.m_sweep.c.y - a.y), this.m_linearVelocity.y += this.m_angularVelocity * +(this.m_sweep.c.x - a.x)
            }
        }, f.prototype.GetWorldPoint = function(t) {
            var e = this.m_xf.R,
                i = new s(e.col1.x * t.x + e.col2.x * t.y, e.col1.y * t.x + e.col2.y * t.y);
            return i.x += this.m_xf.position.x, i.y += this.m_xf.position.y, i
        }, f.prototype.GetWorldVector = function(e) {
            return t.MulMV(this.m_xf.R, e)
        }, f.prototype.GetLocalPoint = function(e) {
            return t.MulXT(this.m_xf, e)
        }, f.prototype.GetLocalVector = function(e) {
            return t.MulTMV(this.m_xf.R, e)
        }, f.prototype.GetLinearVelocityFromWorldPoint = function(t) {
            return new s(this.m_linearVelocity.x - this.m_angularVelocity * (t.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (t.x - this.m_sweep.c.x))
        }, f.prototype.GetLinearVelocityFromLocalPoint = function(t) {
            var e = this.m_xf.R,
                i = new s(e.col1.x * t.x + e.col2.x * t.y, e.col1.y * t.x + e.col2.y * t.y);
            return i.x += this.m_xf.position.x, i.y += this.m_xf.position.y, new s(this.m_linearVelocity.x - this.m_angularVelocity * (i.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (i.x - this.m_sweep.c.x))
        }, f.prototype.GetLinearDamping = function() {
            return this.m_linearDamping
        }, f.prototype.SetLinearDamping = function(t) {
            void 0 === t && (t = 0), this.m_linearDamping = t
        }, f.prototype.GetAngularDamping = function() {
            return this.m_angularDamping
        }, f.prototype.SetAngularDamping = function(t) {
            void 0 === t && (t = 0), this.m_angularDamping = t
        }, f.prototype.SetType = function(t) {
            if (void 0 === t && (t = 0), this.m_type != t) {
                this.m_type = t, this.ResetMassData(), this.m_type == f.b2_staticBody && (this.m_linearVelocity.SetZero(), this.m_angularVelocity = 0), this.SetAwake(!0), this.m_force.SetZero(), this.m_torque = 0;
                for (var e = this.m_contactList; e; e = e.next) e.contact.FlagForFiltering()
            }
        }, f.prototype.GetType = function() {
            return this.m_type
        }, f.prototype.SetBullet = function(t) {
            t ? this.m_flags |= f.e_bulletFlag : this.m_flags &= ~f.e_bulletFlag
        }, f.prototype.IsBullet = function() {
            return (this.m_flags & f.e_bulletFlag) == f.e_bulletFlag
        }, f.prototype.SetSleepingAllowed = function(t) {
            t ? this.m_flags |= f.e_allowSleepFlag : (this.m_flags &= ~f.e_allowSleepFlag, this.SetAwake(!0))
        }, f.prototype.SetAwake = function(t) {
            t ? (this.m_flags |= f.e_awakeFlag, this.m_sleepTime = 0) : (this.m_flags &= ~f.e_awakeFlag, this.m_sleepTime = 0, this.m_linearVelocity.SetZero(), this.m_angularVelocity = 0, this.m_force.SetZero(), this.m_torque = 0)
        }, f.prototype.IsAwake = function() {
            return (this.m_flags & f.e_awakeFlag) == f.e_awakeFlag
        }, f.prototype.SetFixedRotation = function(t) {
            t ? this.m_flags |= f.e_fixedRotationFlag : this.m_flags &= ~f.e_fixedRotationFlag, this.ResetMassData()
        }, f.prototype.IsFixedRotation = function() {
            return (this.m_flags & f.e_fixedRotationFlag) == f.e_fixedRotationFlag
        }, f.prototype.SetActive = function(t) {
            if (t != this.IsActive()) {
                var e, i;
                if (t)
                    for (this.m_flags |= f.e_activeFlag, e = this.m_world.m_contactManager.m_broadPhase, i = this.m_fixtureList; i; i = i.m_next) i.CreateProxy(e, this.m_xf);
                else {
                    for (this.m_flags &= ~f.e_activeFlag, e = this.m_world.m_contactManager.m_broadPhase, i = this.m_fixtureList; i; i = i.m_next) i.DestroyProxy(e);
                    for (var s = this.m_contactList; s;) {
                        var o = s;
                        s = s.next, this.m_world.m_contactManager.Destroy(o.contact)
                    }
                    this.m_contactList = null
                }
            }
        }, f.prototype.IsActive = function() {
            return (this.m_flags & f.e_activeFlag) == f.e_activeFlag
        }, f.prototype.IsSleepingAllowed = function() {
            return (this.m_flags & f.e_allowSleepFlag) == f.e_allowSleepFlag
        }, f.prototype.GetFixtureList = function() {
            return this.m_fixtureList
        }, f.prototype.GetJointList = function() {
            return this.m_jointList
        }, f.prototype.GetControllerList = function() {
            return this.m_controllerList
        }, f.prototype.GetContactList = function() {
            return this.m_contactList
        }, f.prototype.GetNext = function() {
            return this.m_next
        }, f.prototype.GetUserData = function() {
            return this.m_userData
        }, f.prototype.SetUserData = function(t) {
            this.m_userData = t
        }, f.prototype.GetWorld = function() {
            return this.m_world
        }, f.prototype.b2Body = function(t, e) {
            this.m_flags = 0, t.bullet && (this.m_flags |= f.e_bulletFlag), t.fixedRotation && (this.m_flags |= f.e_fixedRotationFlag), t.allowSleep && (this.m_flags |= f.e_allowSleepFlag), t.awake && (this.m_flags |= f.e_awakeFlag), t.active && (this.m_flags |= f.e_activeFlag), this.m_world = e, this.m_xf.position.SetV(t.position), this.m_xf.R.Set(t.angle), this.m_sweep.localCenter.SetZero(), this.m_sweep.t0 = 1, this.m_sweep.a0 = this.m_sweep.a = t.angle;
            var i = this.m_xf.R,
                s = this.m_sweep.localCenter;
            this.m_sweep.c.x = i.col1.x * s.x + i.col2.x * s.y, this.m_sweep.c.y = i.col1.y * s.x + i.col2.y * s.y, this.m_sweep.c.x += this.m_xf.position.x, this.m_sweep.c.y += this.m_xf.position.y, this.m_sweep.c0.SetV(this.m_sweep.c), this.m_jointList = null, this.m_controllerList = null, this.m_contactList = null, this.m_controllerCount = 0, this.m_prev = null, this.m_next = null, this.m_linearVelocity.SetV(t.linearVelocity), this.m_angularVelocity = t.angularVelocity, this.m_linearDamping = t.linearDamping, this.m_angularDamping = t.angularDamping, this.m_force.Set(0, 0), this.m_torque = 0, this.m_sleepTime = 0, this.m_type = t.type, this.m_type == f.b2_dynamicBody ? (this.m_mass = 1, this.m_invMass = 1) : (this.m_mass = 0, this.m_invMass = 0), this.m_I = 0, this.m_invI = 0, this.m_inertiaScale = t.inertiaScale, this.m_userData = t.userData, this.m_fixtureList = null, this.m_fixtureCount = 0
        }, f.prototype.SynchronizeFixtures = function() {
            var t = f.s_xf1;
            t.R.Set(this.m_sweep.a0);
            var e = t.R,
                i = this.m_sweep.localCenter;
            t.position.x = this.m_sweep.c0.x - (e.col1.x * i.x + e.col2.x * i.y), t.position.y = this.m_sweep.c0.y - (e.col1.y * i.x + e.col2.y * i.y);
            var s, o = this.m_world.m_contactManager.m_broadPhase;
            for (s = this.m_fixtureList; s; s = s.m_next) s.Synchronize(o, t, this.m_xf)
        }, f.prototype.SynchronizeTransform = function() {
            this.m_xf.R.Set(this.m_sweep.a);
            var t = this.m_xf.R,
                e = this.m_sweep.localCenter;
            this.m_xf.position.x = this.m_sweep.c.x - (t.col1.x * e.x + t.col2.x * e.y), this.m_xf.position.y = this.m_sweep.c.y - (t.col1.y * e.x + t.col2.y * e.y)
        }, f.prototype.ShouldCollide = function(t) {
            if (this.m_type != f.b2_dynamicBody && t.m_type != f.b2_dynamicBody) return !1;
            for (var e = this.m_jointList; e; e = e.next)
                if (e.other == t && 0 == e.joint.m_collideConnected) return !1;
            return !0
        }, f.prototype.Advance = function(t) {
            void 0 === t && (t = 0), this.m_sweep.Advance(t), this.m_sweep.c.SetV(this.m_sweep.c0), this.m_sweep.a = this.m_sweep.a0, this.SynchronizeTransform()
        }, Box2D.postDefs.push(function() {
            Box2D.Dynamics.b2Body.s_xf1 = new i, Box2D.Dynamics.b2Body.e_islandFlag = 1, Box2D.Dynamics.b2Body.e_awakeFlag = 2, Box2D.Dynamics.b2Body.e_allowSleepFlag = 4, Box2D.Dynamics.b2Body.e_bulletFlag = 8, Box2D.Dynamics.b2Body.e_fixedRotationFlag = 16, Box2D.Dynamics.b2Body.e_activeFlag = 32, Box2D.Dynamics.b2Body.b2_staticBody = 0, Box2D.Dynamics.b2Body.b2_kinematicBody = 1, Box2D.Dynamics.b2Body.b2_dynamicBody = 2
        }), g.b2BodyDef = function() {
            this.position = new s, this.linearVelocity = new s
        }, g.prototype.b2BodyDef = function() {
            this.userData = null, this.position.Set(0, 0), this.angle = 0, this.linearVelocity.Set(0, 0), this.angularVelocity = 0, this.linearDamping = 0, this.angularDamping = 0, this.allowSleep = !0, this.awake = !0, this.fixedRotation = !1, this.bullet = !1, this.type = f.b2_staticBody, this.active = !0, this.inertiaScale = 1
        }, _.b2ContactFilter = function() {}, _.prototype.ShouldCollide = function(t, e) {
            var i = t.GetFilterData(),
                s = e.GetFilterData();
            return i.groupIndex == s.groupIndex && 0 != i.groupIndex ? i.groupIndex > 0 : 0 != (i.maskBits & s.categoryBits) && 0 != (i.categoryBits & s.maskBits)
        }, _.prototype.RayCollide = function(t, e) {
            return !t || this.ShouldCollide(t instanceof A ? t : null, e)
        }, Box2D.postDefs.push(function() {
            Box2D.Dynamics.b2ContactFilter.b2_defaultFilter = new _
        }), v.b2ContactImpulse = function() {
            this.normalImpulses = new Vector_a2j_Number(n.b2_maxManifoldPoints), this.tangentImpulses = new Vector_a2j_Number(n.b2_maxManifoldPoints)
        }, b.b2ContactListener = function() {}, b.prototype.BeginContact = function(t) {}, b.prototype.EndContact = function(t) {}, b.prototype.PreSolve = function(t, e) {}, b.prototype.PostSolve = function(t, e) {}, Box2D.postDefs.push(function() {
            Box2D.Dynamics.b2ContactListener.b2_defaultListener = new b
        }), x.b2ContactManager = function() {}, x.prototype.b2ContactManager = function() {
            this.m_world = null, this.m_contactCount = 0, this.m_contactFilter = _.b2_defaultFilter, this.m_contactListener = b.b2_defaultListener, this.m_contactFactory = new E(this.m_allocator), this.m_broadPhase = new h
        }, x.prototype.AddPair = function(t, e) {
            var i = t instanceof A ? t : null,
                s = e instanceof A ? e : null,
                o = i.GetBody(),
                n = s.GetBody();
            if (o != n) {
                for (var a = n.GetContactList(); a;) {
                    if (a.other == o) {
                        var r = a.contact.GetFixtureA(),
                            h = a.contact.GetFixtureB();
                        if (r == i && h == s) return;
                        if (r == s && h == i) return
                    }
                    a = a.next
                }
                if (0 != n.ShouldCollide(o) && 0 != this.m_contactFilter.ShouldCollide(i, s)) {
                    var l = this.m_contactFactory.Create(i, s);
                    i = l.GetFixtureA(), s = l.GetFixtureB(), o = i.m_body, n = s.m_body, l.m_prev = null, l.m_next = this.m_world.m_contactList, null != this.m_world.m_contactList && (this.m_world.m_contactList.m_prev = l), this.m_world.m_contactList = l, l.m_nodeA.contact = l, l.m_nodeA.other = n, l.m_nodeA.prev = null, l.m_nodeA.next = o.m_contactList, null != o.m_contactList && (o.m_contactList.prev = l.m_nodeA), o.m_contactList = l.m_nodeA, l.m_nodeB.contact = l, l.m_nodeB.other = o, l.m_nodeB.prev = null, l.m_nodeB.next = n.m_contactList, null != n.m_contactList && (n.m_contactList.prev = l.m_nodeB), n.m_contactList = l.m_nodeB, ++this.m_world.m_contactCount
                }
            }
        }, x.prototype.FindNewContacts = function() {
            this.m_broadPhase.UpdatePairs(Box2D.generateCallback(this, this.AddPair))
        }, x.prototype.Destroy = function(t) {
            var e = t.GetFixtureA(),
                i = t.GetFixtureB(),
                s = e.GetBody(),
                o = i.GetBody();
            t.IsTouching() && this.m_contactListener.EndContact(t), t.m_prev && (t.m_prev.m_next = t.m_next), t.m_next && (t.m_next.m_prev = t.m_prev), t == this.m_world.m_contactList && (this.m_world.m_contactList = t.m_next), t.m_nodeA.prev && (t.m_nodeA.prev.next = t.m_nodeA.next), t.m_nodeA.next && (t.m_nodeA.next.prev = t.m_nodeA.prev), t.m_nodeA == s.m_contactList && (s.m_contactList = t.m_nodeA.next), t.m_nodeB.prev && (t.m_nodeB.prev.next = t.m_nodeB.next), t.m_nodeB.next && (t.m_nodeB.next.prev = t.m_nodeB.prev), t.m_nodeB == o.m_contactList && (o.m_contactList = t.m_nodeB.next), this.m_contactFactory.Destroy(t), --this.m_contactCount
        }, x.prototype.Collide = function() {
            for (var t = this.m_world.m_contactList; t;) {
                var e = t.GetFixtureA(),
                    i = t.GetFixtureB(),
                    s = e.GetBody(),
                    o = i.GetBody();
                if (0 != s.IsAwake() || 0 != o.IsAwake()) {
                    if (t.m_flags & I.e_filterFlag) {
                        if (0 == o.ShouldCollide(s)) {
                            var n = t;
                            t = n.GetNext(), this.Destroy(n);
                            continue
                        }
                        if (0 == this.m_contactFilter.ShouldCollide(e, i)) {
                            t = (n = t).GetNext(), this.Destroy(n);
                            continue
                        }
                        t.m_flags &= ~I.e_filterFlag
                    }
                    var a = e.m_proxy,
                        r = i.m_proxy;
                    0 != this.m_broadPhase.TestOverlap(a, r) ? (t.Update(this.m_contactListener), t = t.GetNext()) : (t = (n = t).GetNext(), this.Destroy(n))
                } else t = t.GetNext()
            }
        }, Box2D.postDefs.push(function() {
            Box2D.Dynamics.b2ContactManager.s_evalCP = new r
        }), C.b2DebugDraw = function() {}, C.prototype.b2DebugDraw = function() {}, C.prototype.SetFlags = function(t) {
            void 0 === t && (t = 0)
        }, C.prototype.GetFlags = function() {}, C.prototype.AppendFlags = function(t) {
            void 0 === t && (t = 0)
        }, C.prototype.ClearFlags = function(t) {
            void 0 === t && (t = 0)
        }, C.prototype.SetSprite = function(t) {}, C.prototype.GetSprite = function() {}, C.prototype.SetDrawScale = function(t) {
            void 0 === t && (t = 0)
        }, C.prototype.GetDrawScale = function() {}, C.prototype.SetLineThickness = function(t) {
            void 0 === t && (t = 0)
        }, C.prototype.GetLineThickness = function() {}, C.prototype.SetAlpha = function(t) {
            void 0 === t && (t = 0)
        }, C.prototype.GetAlpha = function() {}, C.prototype.SetFillAlpha = function(t) {
            void 0 === t && (t = 0)
        }, C.prototype.GetFillAlpha = function() {}, C.prototype.SetXFormScale = function(t) {
            void 0 === t && (t = 0)
        }, C.prototype.GetXFormScale = function() {}, C.prototype.DrawPolygon = function(t, e, i) {
            void 0 === e && (e = 0)
        }, C.prototype.DrawSolidPolygon = function(t, e, i) {
            void 0 === e && (e = 0)
        }, C.prototype.DrawCircle = function(t, e, i) {
            void 0 === e && (e = 0)
        }, C.prototype.DrawSolidCircle = function(t, e, i, s) {
            void 0 === e && (e = 0)
        }, C.prototype.DrawSegment = function(t, e, i) {}, C.prototype.DrawTransform = function(t) {}, Box2D.postDefs.push(function() {
            Box2D.Dynamics.b2DebugDraw.e_shapeBit = 1, Box2D.Dynamics.b2DebugDraw.e_jointBit = 2, Box2D.Dynamics.b2DebugDraw.e_aabbBit = 4, Box2D.Dynamics.b2DebugDraw.e_pairBit = 8, Box2D.Dynamics.b2DebugDraw.e_centerOfMassBit = 16, Box2D.Dynamics.b2DebugDraw.e_controllerBit = 32
        }), S.b2DestructionListener = function() {}, S.prototype.SayGoodbyeJoint = function(t) {}, S.prototype.SayGoodbyeFixture = function(t) {}, w.b2FilterData = function() {
            this.categoryBits = 1, this.maskBits = 65535, this.groupIndex = 0
        }, w.prototype.Copy = function() {
            var t = new w;
            return t.categoryBits = this.categoryBits, t.maskBits = this.maskBits, t.groupIndex = this.groupIndex, t
        }, A.b2Fixture = function() {
            this.m_filter = new w
        }, A.prototype.GetType = function() {
            return this.m_shape.GetType()
        }, A.prototype.GetShape = function() {
            return this.m_shape
        }, A.prototype.SetSensor = function(t) {
            if (this.m_isSensor != t && (this.m_isSensor = t, null != this.m_body))
                for (var e = this.m_body.GetContactList(); e;) {
                    var i = e.contact,
                        s = i.GetFixtureA(),
                        o = i.GetFixtureB();
                    s != this && o != this || i.SetSensor(s.IsSensor() || o.IsSensor()), e = e.next
                }
        }, A.prototype.IsSensor = function() {
            return this.m_isSensor
        }, A.prototype.SetFilterData = function(t) {
            if (this.m_filter = t.Copy(), !this.m_body)
                for (var e = this.m_body.GetContactList(); e;) {
                    var i = e.contact,
                        s = i.GetFixtureA(),
                        o = i.GetFixtureB();
                    s != this && o != this || i.FlagForFiltering(), e = e.next
                }
        }, A.prototype.GetFilterData = function() {
            return this.m_filter.Copy()
        }, A.prototype.GetBody = function() {
            return this.m_body
        }, A.prototype.GetNext = function() {
            return this.m_next
        }, A.prototype.GetUserData = function() {
            return this.m_userData
        }, A.prototype.SetUserData = function(t) {
            this.m_userData = t
        }, A.prototype.TestPoint = function(t) {
            return this.m_shape.TestPoint(this.m_body.GetTransform(), t)
        }, A.prototype.RayCast = function(t, e) {
            return this.m_shape.RayCast(t, e, this.m_body.GetTransform())
        }, A.prototype.GetMassData = function(t) {
            return void 0 === t && (t = null), null == t && (t = new d), this.m_shape.ComputeMass(t, this.m_density), t
        }, A.prototype.SetDensity = function(t) {
            void 0 === t && (t = 0), this.m_density = t
        }, A.prototype.GetDensity = function() {
            return this.m_density
        }, A.prototype.GetFriction = function() {
            return this.m_friction
        }, A.prototype.SetFriction = function(t) {
            void 0 === t && (t = 0), this.m_friction = t
        }, A.prototype.GetRestitution = function() {
            return this.m_restitution
        }, A.prototype.SetRestitution = function(t) {
            void 0 === t && (t = 0), this.m_restitution = t
        }, A.prototype.GetAABB = function() {
            return this.m_aabb
        }, A.prototype.b2Fixture = function() {
            this.m_aabb = new a, this.m_userData = null, this.m_body = null, this.m_next = null, this.m_shape = null, this.m_density = 0, this.m_friction = 0, this.m_restitution = 0
        }, A.prototype.Create = function(t, e, i) {
            this.m_userData = i.userData, this.m_friction = i.friction, this.m_restitution = i.restitution, this.m_body = t, this.m_next = null, this.m_filter = i.filter.Copy(), this.m_isSensor = i.isSensor, this.m_shape = i.shape.Copy(), this.m_density = i.density
        }, A.prototype.Destroy = function() {
            this.m_shape = null
        }, A.prototype.CreateProxy = function(t, e) {
            this.m_shape.ComputeAABB(this.m_aabb, e), this.m_proxy = t.CreateProxy(this.m_aabb, this)
        }, A.prototype.DestroyProxy = function(t) {
            null != this.m_proxy && (t.DestroyProxy(this.m_proxy), this.m_proxy = null)
        }, A.prototype.Synchronize = function(e, i, s) {
            if (this.m_proxy) {
                var o = new a,
                    n = new a;
                this.m_shape.ComputeAABB(o, i), this.m_shape.ComputeAABB(n, s), this.m_aabb.Combine(o, n);
                var r = t.SubtractVV(s.position, i.position);
                e.MoveProxy(this.m_proxy, this.m_aabb, r)
            }
        }, T.b2FixtureDef = function() {
            this.filter = new w
        }, T.prototype.b2FixtureDef = function() {
            this.shape = null, this.userData = null, this.friction = .2, this.restitution = 0, this.density = 0, this.filter.categoryBits = 1, this.filter.maskBits = 65535, this.filter.groupIndex = 0, this.isSensor = !1
        }, B.b2Island = function() {}, B.prototype.b2Island = function() {
            this.m_bodies = new Vector, this.m_contacts = new Vector, this.m_joints = new Vector
        }, B.prototype.Initialize = function(t, e, i, s, o, n) {
            void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0);
            var a = 0;
            for (this.m_bodyCapacity = t, this.m_contactCapacity = e, this.m_jointCapacity = i, this.m_bodyCount = 0, this.m_contactCount = 0, this.m_jointCount = 0, this.m_allocator = s, this.m_listener = o, this.m_contactSolver = n, a = this.m_bodies.length; a < t; a++) this.m_bodies[a] = null;
            for (a = this.m_contacts.length; a < e; a++) this.m_contacts[a] = null;
            for (a = this.m_joints.length; a < i; a++) this.m_joints[a] = null
        }, B.prototype.Clear = function() {
            this.m_bodyCount = 0, this.m_contactCount = 0, this.m_jointCount = 0
        }, B.prototype.Solve = function(e, i, s) {
            var o, a, r = 0,
                h = 0;
            for (r = 0; r < this.m_bodyCount; ++r)(o = this.m_bodies[r]).GetType() == f.b2_dynamicBody && (o.m_linearVelocity.x += e.dt * (i.x + o.m_invMass * o.m_force.x), o.m_linearVelocity.y += e.dt * (i.y + o.m_invMass * o.m_force.y), o.m_angularVelocity += e.dt * o.m_invI * o.m_torque, o.m_linearVelocity.Multiply(t.Clamp(1 - e.dt * o.m_linearDamping, 0, 1)), o.m_angularVelocity *= t.Clamp(1 - e.dt * o.m_angularDamping, 0, 1));
            this.m_contactSolver.Initialize(e, this.m_contacts, this.m_contactCount, this.m_allocator);
            var l = this.m_contactSolver;
            for (l.InitVelocityConstraints(e), r = 0; r < this.m_jointCount; ++r)(a = this.m_joints[r]).InitVelocityConstraints(e);
            for (r = 0; r < e.velocityIterations; ++r) {
                for (h = 0; h < this.m_jointCount; ++h)(a = this.m_joints[h]).SolveVelocityConstraints(e);
                l.SolveVelocityConstraints()
            }
            for (r = 0; r < this.m_jointCount; ++r)(a = this.m_joints[r]).FinalizeVelocityConstraints();
            for (l.FinalizeVelocityConstraints(), r = 0; r < this.m_bodyCount; ++r)
                if ((o = this.m_bodies[r]).GetType() != f.b2_staticBody) {
                    var c = e.dt * o.m_linearVelocity.x,
                        p = e.dt * o.m_linearVelocity.y;
                    c * c + p * p > n.b2_maxTranslationSquared && (o.m_linearVelocity.Normalize(), o.m_linearVelocity.x *= n.b2_maxTranslation * e.inv_dt, o.m_linearVelocity.y *= n.b2_maxTranslation * e.inv_dt);
                    var u = e.dt * o.m_angularVelocity;
                    u * u > n.b2_maxRotationSquared && (o.m_angularVelocity < 0 ? o.m_angularVelocity = -n.b2_maxRotation * e.inv_dt : o.m_angularVelocity = n.b2_maxRotation * e.inv_dt), o.m_sweep.c0.SetV(o.m_sweep.c), o.m_sweep.a0 = o.m_sweep.a, o.m_sweep.c.x += e.dt * o.m_linearVelocity.x, o.m_sweep.c.y += e.dt * o.m_linearVelocity.y, o.m_sweep.a += e.dt * o.m_angularVelocity, o.SynchronizeTransform()
                }
            for (r = 0; r < e.positionIterations; ++r) {
                var d = l.SolvePositionConstraints(n.b2_contactBaumgarte),
                    m = !0;
                for (h = 0; h < this.m_jointCount; ++h) {
                    var y = (a = this.m_joints[h]).SolvePositionConstraints(n.b2_contactBaumgarte);
                    m = m && y
                }
                if (d && m) break
            }
            if (this.Report(l.m_constraints), s) {
                var g = Number.MAX_VALUE,
                    _ = n.b2_linearSleepTolerance * n.b2_linearSleepTolerance,
                    v = n.b2_angularSleepTolerance * n.b2_angularSleepTolerance;
                for (r = 0; r < this.m_bodyCount; ++r)(o = this.m_bodies[r]).GetType() != f.b2_staticBody && (0 == (o.m_flags & f.e_allowSleepFlag) && (o.m_sleepTime = 0, g = 0), 0 == (o.m_flags & f.e_allowSleepFlag) || o.m_angularVelocity * o.m_angularVelocity > v || t.Dot(o.m_linearVelocity, o.m_linearVelocity) > _ ? (o.m_sleepTime = 0, g = 0) : (o.m_sleepTime += e.dt, g = t.Min(g, o.m_sleepTime)));
                if (g >= n.b2_timeToSleep)
                    for (r = 0; r < this.m_bodyCount; ++r)(o = this.m_bodies[r]).SetAwake(!1)
            }
        }, B.prototype.SolveTOI = function(t) {
            var e = 0,
                i = 0;
            this.m_contactSolver.Initialize(t, this.m_contacts, this.m_contactCount, this.m_allocator);
            var s = this.m_contactSolver;
            for (e = 0; e < this.m_jointCount; ++e) this.m_joints[e].InitVelocityConstraints(t);
            for (e = 0; e < t.velocityIterations; ++e)
                for (s.SolveVelocityConstraints(), i = 0; i < this.m_jointCount; ++i) this.m_joints[i].SolveVelocityConstraints(t);
            for (e = 0; e < this.m_bodyCount; ++e) {
                var o = this.m_bodies[e];
                if (o.GetType() != f.b2_staticBody) {
                    var a = t.dt * o.m_linearVelocity.x,
                        r = t.dt * o.m_linearVelocity.y;
                    a * a + r * r > n.b2_maxTranslationSquared && (o.m_linearVelocity.Normalize(), o.m_linearVelocity.x *= n.b2_maxTranslation * t.inv_dt, o.m_linearVelocity.y *= n.b2_maxTranslation * t.inv_dt);
                    var h = t.dt * o.m_angularVelocity;
                    h * h > n.b2_maxRotationSquared && (o.m_angularVelocity < 0 ? o.m_angularVelocity = -n.b2_maxRotation * t.inv_dt : o.m_angularVelocity = n.b2_maxRotation * t.inv_dt), o.m_sweep.c0.SetV(o.m_sweep.c), o.m_sweep.a0 = o.m_sweep.a, o.m_sweep.c.x += t.dt * o.m_linearVelocity.x, o.m_sweep.c.y += t.dt * o.m_linearVelocity.y, o.m_sweep.a += t.dt * o.m_angularVelocity, o.SynchronizeTransform()
                }
            }
            for (e = 0; e < t.positionIterations; ++e) {
                var l = s.SolvePositionConstraints(.75),
                    c = !0;
                for (i = 0; i < this.m_jointCount; ++i) {
                    var p = this.m_joints[i].SolvePositionConstraints(n.b2_contactBaumgarte);
                    c = c && p
                }
                if (l && c) break
            }
            this.Report(s.m_constraints)
        }, B.prototype.Report = function(t) {
            if (null != this.m_listener)
                for (var e = 0; e < this.m_contactCount; ++e) {
                    for (var i = this.m_contacts[e], s = t[e], o = 0; o < s.pointCount; ++o) B.s_impulse.normalImpulses[o] = s.points[o].normalImpulse, B.s_impulse.tangentImpulses[o] = s.points[o].tangentImpulse;
                    this.m_listener.PostSolve(i, B.s_impulse)
                }
        }, B.prototype.AddBody = function(t) {
            t.m_islandIndex = this.m_bodyCount, this.m_bodies[this.m_bodyCount++] = t
        }, B.prototype.AddContact = function(t) {
            this.m_contacts[this.m_contactCount++] = t
        }, B.prototype.AddJoint = function(t) {
            this.m_joints[this.m_jointCount++] = t
        }, Box2D.postDefs.push(function() {
            Box2D.Dynamics.b2Island.s_impulse = new v
        }), P.b2TimeStep = function() {}, P.prototype.Set = function(t) {
            this.dt = t.dt, this.inv_dt = t.inv_dt, this.positionIterations = t.positionIterations, this.velocityIterations = t.velocityIterations, this.warmStarting = t.warmStarting
        }, D.b2World = function() {
            this.s_stack = new Vector, this.m_contactManager = new x, this.m_contactSolver = new L, this.m_island = new B
        }, D.prototype.b2World = function(t, e) {
            this.m_destructionListener = null, this.m_debugDraw = null, this.m_bodyList = null, this.m_contactList = null, this.m_jointList = null, this.m_controllerList = null, this.m_bodyCount = 0, this.m_contactCount = 0, this.m_jointCount = 0, this.m_controllerCount = 0, D.m_warmStarting = !0, D.m_continuousPhysics = !0, this.m_allowSleep = e, this.m_gravity = t, this.m_inv_dt0 = 0, this.m_contactManager.m_world = this;
            var i = new g;
            this.m_groundBody = this.CreateBody(i)
        }, D.prototype.SetDestructionListener = function(t) {
            this.m_destructionListener = t
        }, D.prototype.SetContactFilter = function(t) {
            this.m_contactManager.m_contactFilter = t
        }, D.prototype.SetContactListener = function(t) {
            this.m_contactManager.m_contactListener = t
        }, D.prototype.SetDebugDraw = function(t) {
            this.m_debugDraw = t
        }, D.prototype.SetBroadPhase = function(t) {
            var e = this.m_contactManager.m_broadPhase;
            this.m_contactManager.m_broadPhase = t;
            for (var i = this.m_bodyList; i; i = i.m_next)
                for (var s = i.m_fixtureList; s; s = s.m_next) s.m_proxy = t.CreateProxy(e.GetFatAABB(s.m_proxy), s)
        }, D.prototype.Validate = function() {
            this.m_contactManager.m_broadPhase.Validate()
        }, D.prototype.GetProxyCount = function() {
            return this.m_contactManager.m_broadPhase.GetProxyCount()
        }, D.prototype.CreateBody = function(t) {
            if (1 == this.IsLocked()) return null;
            var e = new f(t, this);
            return e.m_prev = null, e.m_next = this.m_bodyList, this.m_bodyList && (this.m_bodyList.m_prev = e), this.m_bodyList = e, ++this.m_bodyCount, e
        }, D.prototype.DestroyBody = function(t) {
            if (1 != this.IsLocked()) {
                for (var e = t.m_jointList; e;) {
                    var i = e;
                    e = e.next, this.m_destructionListener && this.m_destructionListener.SayGoodbyeJoint(i.joint), this.DestroyJoint(i.joint)
                }
                for (var s = t.m_controllerList; s;) {
                    var o = s;
                    s = s.nextController, o.controller.RemoveBody(t)
                }
                for (var n = t.m_contactList; n;) {
                    var a = n;
                    n = n.next, this.m_contactManager.Destroy(a.contact)
                }
                t.m_contactList = null;
                for (var r = t.m_fixtureList; r;) {
                    var h = r;
                    r = r.m_next, this.m_destructionListener && this.m_destructionListener.SayGoodbyeFixture(h), h.DestroyProxy(this.m_contactManager.m_broadPhase), h.Destroy()
                }
                t.m_fixtureList = null, t.m_fixtureCount = 0, t.m_prev && (t.m_prev.m_next = t.m_next), t.m_next && (t.m_next.m_prev = t.m_prev), t == this.m_bodyList && (this.m_bodyList = t.m_next), --this.m_bodyCount
            }
        }, D.prototype.CreateJoint = function(t) {
            var e = M.Create(t, null);
            e.m_prev = null, e.m_next = this.m_jointList, this.m_jointList && (this.m_jointList.m_prev = e), this.m_jointList = e, ++this.m_jointCount, e.m_edgeA.joint = e, e.m_edgeA.other = e.m_bodyB, e.m_edgeA.prev = null, e.m_edgeA.next = e.m_bodyA.m_jointList, e.m_bodyA.m_jointList && (e.m_bodyA.m_jointList.prev = e.m_edgeA), e.m_bodyA.m_jointList = e.m_edgeA, e.m_edgeB.joint = e, e.m_edgeB.other = e.m_bodyA, e.m_edgeB.prev = null, e.m_edgeB.next = e.m_bodyB.m_jointList, e.m_bodyB.m_jointList && (e.m_bodyB.m_jointList.prev = e.m_edgeB), e.m_bodyB.m_jointList = e.m_edgeB;
            var i = t.bodyA,
                s = t.bodyB;
            if (0 == t.collideConnected)
                for (var o = s.GetContactList(); o;) o.other == i && o.contact.FlagForFiltering(), o = o.next;
            return e
        }, D.prototype.DestroyJoint = function(t) {
            var e = t.m_collideConnected;
            t.m_prev && (t.m_prev.m_next = t.m_next), t.m_next && (t.m_next.m_prev = t.m_prev), t == this.m_jointList && (this.m_jointList = t.m_next);
            var i = t.m_bodyA,
                s = t.m_bodyB;
            if (i.SetAwake(!0), s.SetAwake(!0), t.m_edgeA.prev && (t.m_edgeA.prev.next = t.m_edgeA.next), t.m_edgeA.next && (t.m_edgeA.next.prev = t.m_edgeA.prev), t.m_edgeA == i.m_jointList && (i.m_jointList = t.m_edgeA.next), t.m_edgeA.prev = null, t.m_edgeA.next = null, t.m_edgeB.prev && (t.m_edgeB.prev.next = t.m_edgeB.next), t.m_edgeB.next && (t.m_edgeB.next.prev = t.m_edgeB.prev), t.m_edgeB == s.m_jointList && (s.m_jointList = t.m_edgeB.next), t.m_edgeB.prev = null, t.m_edgeB.next = null, M.Destroy(t, null), --this.m_jointCount, 0 == e)
                for (var o = s.GetContactList(); o;) o.other == i && o.contact.FlagForFiltering(), o = o.next
        }, D.prototype.AddController = function(t) {
            return t.m_next = this.m_controllerList, t.m_prev = null, this.m_controllerList = t, t.m_world = this, this.m_controllerCount++, t
        }, D.prototype.RemoveController = function(t) {
            t.m_prev && (t.m_prev.m_next = t.m_next), t.m_next && (t.m_next.m_prev = t.m_prev), this.m_controllerList == t && (this.m_controllerList = t.m_next), this.m_controllerCount--
        }, D.prototype.CreateController = function(t) {
            if (t.m_world != this) throw new Error("Controller can only be a member of one world");
            return t.m_next = this.m_controllerList, t.m_prev = null, this.m_controllerList && (this.m_controllerList.m_prev = t), this.m_controllerList = t, ++this.m_controllerCount, t.m_world = this, t
        }, D.prototype.DestroyController = function(t) {
            t.Clear(), t.m_next && (t.m_next.m_prev = t.m_prev), t.m_prev && (t.m_prev.m_next = t.m_next), t == this.m_controllerList && (this.m_controllerList = t.m_next), --this.m_controllerCount
        }, D.prototype.SetWarmStarting = function(t) {
            D.m_warmStarting = t
        }, D.prototype.SetContinuousPhysics = function(t) {
            D.m_continuousPhysics = t
        }, D.prototype.GetBodyCount = function() {
            return this.m_bodyCount
        }, D.prototype.GetJointCount = function() {
            return this.m_jointCount
        }, D.prototype.GetContactCount = function() {
            return this.m_contactCount
        }, D.prototype.SetGravity = function(t) {
            this.m_gravity = t
        }, D.prototype.GetGravity = function() {
            return this.m_gravity
        }, D.prototype.GetGroundBody = function() {
            return this.m_groundBody
        }, D.prototype.Step = function(t, e, i) {
            void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), this.m_flags & D.e_newFixture && (this.m_contactManager.FindNewContacts(), this.m_flags &= ~D.e_newFixture), this.m_flags |= D.e_locked;
            var s = D.s_timestep2;
            s.dt = t, s.velocityIterations = e, s.positionIterations = i, s.inv_dt = t > 0 ? 1 / t : 0, s.dtRatio = this.m_inv_dt0 * t, s.warmStarting = D.m_warmStarting, this.m_contactManager.Collide(), s.dt > 0 && this.Solve(s), D.m_continuousPhysics && s.dt > 0 && this.SolveTOI(s), s.dt > 0 && (this.m_inv_dt0 = s.inv_dt), this.m_flags &= ~D.e_locked
        }, D.prototype.ClearForces = function() {
            for (var t = this.m_bodyList; t; t = t.m_next) t.m_force.SetZero(), t.m_torque = 0
        }, D.prototype.DrawDebugData = function() {
            if (null != this.m_debugDraw) {
                this.m_debugDraw.m_sprite.graphics.clear();
                var t, e, i, n, r, h, l = this.m_debugDraw.GetFlags(),
                    c = (new s, new s, new s, new a, new a, [new s, new s, new s, new s]),
                    p = new o(0, 0, 0);
                if (l & C.e_shapeBit)
                    for (t = this.m_bodyList; t; t = t.m_next)
                        for (h = t.m_xf, e = t.GetFixtureList(); e; e = e.m_next) i = e.GetShape(), 0 == t.IsActive() ? (p.Set(.5, .5, .3), this.DrawShape(i, h, p)) : t.GetType() == f.b2_staticBody ? (p.Set(.5, .9, .5), this.DrawShape(i, h, p)) : t.GetType() == f.b2_kinematicBody ? (p.Set(.5, .5, .9), this.DrawShape(i, h, p)) : 0 == t.IsAwake() ? (p.Set(.6, .6, .6), this.DrawShape(i, h, p)) : (p.Set(.9, .7, .7), this.DrawShape(i, h, p));
                if (l & C.e_jointBit)
                    for (n = this.m_jointList; n; n = n.m_next) this.DrawJoint(n);
                if (l & C.e_controllerBit)
                    for (var u = this.m_controllerList; u; u = u.m_next) u.Draw(this.m_debugDraw);
                if (l & C.e_pairBit) {
                    p.Set(.3, .9, .9);
                    for (var d = this.m_contactManager.m_contactList; d; d = d.GetNext()) {
                        var m = d.GetFixtureA(),
                            y = d.GetFixtureB(),
                            g = m.GetAABB().GetCenter(),
                            _ = y.GetAABB().GetCenter();
                        this.m_debugDraw.DrawSegment(g, _, p)
                    }
                }
                if (l & C.e_aabbBit)
                    for (r = this.m_contactManager.m_broadPhase, c = [new s, new s, new s, new s], t = this.m_bodyList; t; t = t.GetNext())
                        if (0 != t.IsActive())
                            for (e = t.GetFixtureList(); e; e = e.GetNext()) {
                                var v = r.GetFatAABB(e.m_proxy);
                                c[0].Set(v.lowerBound.x, v.lowerBound.y), c[1].Set(v.upperBound.x, v.lowerBound.y), c[2].Set(v.upperBound.x, v.upperBound.y), c[3].Set(v.lowerBound.x, v.upperBound.y), this.m_debugDraw.DrawPolygon(c, 4, p)
                            }
                if (l & C.e_centerOfMassBit)
                    for (t = this.m_bodyList; t; t = t.m_next)(h = D.s_xf).R = t.m_xf.R, h.position = t.GetWorldCenter(), this.m_debugDraw.DrawTransform(h)
            }
        }, D.prototype.QueryAABB = function(t, e) {
            var i = this.m_contactManager.m_broadPhase;
            i.Query(function(e) {
                return t(i.GetUserData(e))
            }, e)
        }, D.prototype.QueryShape = function(t, e, s) {
            var o = this;
            void 0 === s && (s = null), null == s && (s = new i).SetIdentity();
            var n = o.m_contactManager.m_broadPhase,
                r = new a;
            e.ComputeAABB(r, s), n.Query(function(i) {
                var o = n.GetUserData(i) instanceof A ? n.GetUserData(i) : null;
                return !y.TestOverlap(e, s, o.GetShape(), o.GetBody().GetTransform()) || t(o)
            }, r)
        }, D.prototype.QueryPoint = function(t, e) {
            var i = this.m_contactManager.m_broadPhase,
                s = new a;
            s.lowerBound.Set(e.x - n.b2_linearSlop, e.y - n.b2_linearSlop), s.upperBound.Set(e.x + n.b2_linearSlop, e.y + n.b2_linearSlop), i.Query(function(s) {
                var o = i.GetUserData(s) instanceof A ? i.GetUserData(s) : null;
                return !o.TestPoint(e) || t(o)
            }, s)
        }, D.prototype.RayCast = function(t, e, i) {
            var o = this.m_contactManager.m_broadPhase,
                n = new c,
                a = new l(e, i);
            o.RayCast(function(a, r) {
                var h = o.GetUserData(r),
                    l = h instanceof A ? h : null;
                if (l.RayCast(n, a)) {
                    var c = n.fraction,
                        p = new s((1 - c) * e.x + c * i.x, (1 - c) * e.y + c * i.y);
                    return t(l, p, n.normal, c)
                }
                return a.maxFraction
            }, a)
        }, D.prototype.RayCastOne = function(t, e) {
            var i;
            return this.RayCast(function(t, e, s, o) {
                return void 0 === o && (o = 0), i = t, o
            }, t, e), i
        }, D.prototype.RayCastAll = function(t, e) {
            var i = this,
                s = new Vector;
            return i.RayCast(function(t, e, i, o) {
                return void 0 === o && (o = 0), s[s.length] = t, 1
            }, t, e), s
        }, D.prototype.GetBodyList = function() {
            return this.m_bodyList
        }, D.prototype.GetJointList = function() {
            return this.m_jointList
        }, D.prototype.GetContactList = function() {
            return this.m_contactList
        }, D.prototype.IsLocked = function() {
            return (this.m_flags & D.e_locked) > 0
        }, D.prototype.Solve = function(t) {
            for (var e, i = this.m_controllerList; i; i = i.m_next) i.Step(t);
            var s = this.m_island;
            for (s.Initialize(this.m_bodyCount, this.m_contactCount, this.m_jointCount, null, this.m_contactManager.m_contactListener, this.m_contactSolver), e = this.m_bodyList; e; e = e.m_next) e.m_flags &= ~f.e_islandFlag;
            for (var o = this.m_contactList; o; o = o.m_next) o.m_flags &= ~I.e_islandFlag;
            for (var n = this.m_jointList; n; n = n.m_next) n.m_islandFlag = !1;
            parseInt(this.m_bodyCount);
            for (var a = this.s_stack, r = this.m_bodyList; r; r = r.m_next)
                if (!(r.m_flags & f.e_islandFlag) && 0 != r.IsAwake() && 0 != r.IsActive() && r.GetType() != f.b2_staticBody) {
                    s.Clear();
                    var h = 0;
                    for (a[h++] = r, r.m_flags |= f.e_islandFlag; h > 0;)
                        if (e = a[--h], s.AddBody(e), 0 == e.IsAwake() && e.SetAwake(!0), e.GetType() != f.b2_staticBody) {
                            for (var l, c = e.m_contactList; c; c = c.next) c.contact.m_flags & I.e_islandFlag || 1 != c.contact.IsSensor() && 0 != c.contact.IsEnabled() && 0 != c.contact.IsTouching() && (s.AddContact(c.contact), c.contact.m_flags |= I.e_islandFlag, (l = c.other).m_flags & f.e_islandFlag || (a[h++] = l, l.m_flags |= f.e_islandFlag));
                            for (var p = e.m_jointList; p; p = p.next) 1 != p.joint.m_islandFlag && 0 != (l = p.other).IsActive() && (s.AddJoint(p.joint), p.joint.m_islandFlag = !0, l.m_flags & f.e_islandFlag || (a[h++] = l, l.m_flags |= f.e_islandFlag))
                        }
                    s.Solve(t, this.m_gravity, this.m_allowSleep);
                    for (var u = 0; u < s.m_bodyCount; ++u)(e = s.m_bodies[u]).GetType() == f.b2_staticBody && (e.m_flags &= ~f.e_islandFlag)
                }
            for (u = 0; u < a.length && a[u]; ++u) a[u] = null;
            for (e = this.m_bodyList; e; e = e.m_next) 0 != e.IsAwake() && 0 != e.IsActive() && e.GetType() != f.b2_staticBody && e.SynchronizeFixtures();
            this.m_contactManager.FindNewContacts()
        }, D.prototype.SolveTOI = function(t) {
            var e, i, s, o, a, r, h, l = this.m_island;
            l.Initialize(this.m_bodyCount, n.b2_maxTOIContactsPerIsland, n.b2_maxTOIJointsPerIsland, null, this.m_contactManager.m_contactListener, this.m_contactSolver);
            var c = D.s_queue;
            for (e = this.m_bodyList; e; e = e.m_next) e.m_flags &= ~f.e_islandFlag, e.m_sweep.t0 = 0;
            var p;
            for (p = this.m_contactList; p; p = p.m_next) p.m_flags &= ~(I.e_toiFlag | I.e_islandFlag);
            for (h = this.m_jointList; h; h = h.m_next) h.m_islandFlag = !1;
            for (;;) {
                var u = null,
                    d = 1;
                for (p = this.m_contactList; p; p = p.m_next)
                    if (1 != p.IsSensor() && 0 != p.IsEnabled() && 0 != p.IsContinuous()) {
                        var m = 1;
                        if (p.m_flags & I.e_toiFlag) m = p.m_toi;
                        else {
                            if (i = p.m_fixtureA, s = p.m_fixtureB, o = i.m_body, a = s.m_body, !(o.GetType() == f.b2_dynamicBody && 0 != o.IsAwake() || a.GetType() == f.b2_dynamicBody && 0 != a.IsAwake())) continue;
                            var y = o.m_sweep.t0;
                            o.m_sweep.t0 < a.m_sweep.t0 ? (y = a.m_sweep.t0, o.m_sweep.Advance(y)) : a.m_sweep.t0 < o.m_sweep.t0 && (y = o.m_sweep.t0, a.m_sweep.Advance(y)), m = p.ComputeTOI(o.m_sweep, a.m_sweep), n.b2Assert(0 <= m && m <= 1), m > 0 && m < 1 && (m = (1 - m) * y + m) > 1 && (m = 1), p.m_toi = m, p.m_flags |= I.e_toiFlag
                        }
                        Number.MIN_VALUE < m && m < d && (u = p, d = m)
                    }
                if (null == u || 1 - 100 * Number.MIN_VALUE < d) break;
                if (i = u.m_fixtureA, s = u.m_fixtureB, o = i.m_body, a = s.m_body, D.s_backupA.Set(o.m_sweep), D.s_backupB.Set(a.m_sweep), o.Advance(d), a.Advance(d), u.Update(this.m_contactManager.m_contactListener), u.m_flags &= ~I.e_toiFlag, 1 != u.IsSensor() && 0 != u.IsEnabled()) {
                    if (0 != u.IsTouching()) {
                        var g = o;
                        g.GetType() != f.b2_dynamicBody && (g = a), l.Clear();
                        var _ = 0,
                            v = 0;
                        for (c[_ + v++] = g, g.m_flags |= f.e_islandFlag; v > 0;)
                            if (e = c[_++], --v, l.AddBody(e), 0 == e.IsAwake() && e.SetAwake(!0), e.GetType() == f.b2_dynamicBody) {
                                for (r = e.m_contactList; r && l.m_contactCount != l.m_contactCapacity; r = r.next)
                                    if (!(r.contact.m_flags & I.e_islandFlag) && 1 != r.contact.IsSensor() && 0 != r.contact.IsEnabled() && 0 != r.contact.IsTouching()) {
                                        l.AddContact(r.contact), r.contact.m_flags |= I.e_islandFlag;
                                        var b = r.other;
                                        b.m_flags & f.e_islandFlag || (b.GetType() != f.b2_staticBody && (b.Advance(d), b.SetAwake(!0)), c[_ + v] = b, ++v, b.m_flags |= f.e_islandFlag)
                                    }
                                for (var x = e.m_jointList; x; x = x.next) l.m_jointCount != l.m_jointCapacity && 1 != x.joint.m_islandFlag && 0 != (b = x.other).IsActive() && (l.AddJoint(x.joint), x.joint.m_islandFlag = !0, b.m_flags & f.e_islandFlag || (b.GetType() != f.b2_staticBody && (b.Advance(d), b.SetAwake(!0)), c[_ + v] = b, ++v, b.m_flags |= f.e_islandFlag))
                            }
                        var C = D.s_timestep;
                        C.warmStarting = !1, C.dt = (1 - d) * t.dt, C.inv_dt = 1 / C.dt, C.dtRatio = 0, C.velocityIterations = t.velocityIterations, C.positionIterations = t.positionIterations, l.SolveTOI(C);
                        var S = 0;
                        for (S = 0; S < l.m_bodyCount; ++S)
                            if (e = l.m_bodies[S], e.m_flags &= ~f.e_islandFlag, 0 != e.IsAwake() && e.GetType() == f.b2_dynamicBody)
                                for (e.SynchronizeFixtures(), r = e.m_contactList; r; r = r.next) r.contact.m_flags &= ~I.e_toiFlag;
                        for (S = 0; S < l.m_contactCount; ++S)(p = l.m_contacts[S]).m_flags &= ~(I.e_toiFlag | I.e_islandFlag);
                        for (S = 0; S < l.m_jointCount; ++S)(h = l.m_joints[S]).m_islandFlag = !1;
                        this.m_contactManager.FindNewContacts()
                    }
                } else o.m_sweep.Set(D.s_backupA), a.m_sweep.Set(D.s_backupB), o.SynchronizeTransform(), a.SynchronizeTransform()
            }
        }, D.prototype.DrawJoint = function(t) {
            var e = t.GetBodyA(),
                i = t.GetBodyB(),
                s = e.m_xf,
                o = i.m_xf,
                n = s.position,
                a = o.position,
                r = t.GetAnchorA(),
                h = t.GetAnchorB(),
                l = D.s_jointColor;
            switch (t.m_type) {
                case M.e_distanceJoint:
                    this.m_debugDraw.DrawSegment(r, h, l);
                    break;
                case M.e_pulleyJoint:
                    var c = t instanceof G ? t : null,
                        p = c.GetGroundAnchorA(),
                        u = c.GetGroundAnchorB();
                    this.m_debugDraw.DrawSegment(p, r, l), this.m_debugDraw.DrawSegment(u, h, l), this.m_debugDraw.DrawSegment(p, u, l);
                    break;
                case M.e_mouseJoint:
                    this.m_debugDraw.DrawSegment(r, h, l);
                    break;
                default:
                    e != this.m_groundBody && this.m_debugDraw.DrawSegment(n, r, l), this.m_debugDraw.DrawSegment(r, h, l), i != this.m_groundBody && this.m_debugDraw.DrawSegment(a, h, l)
            }
        }, D.prototype.DrawShape = function(e, i, s) {
            switch (e.m_type) {
                case y.e_circleShape:
                    var o = e instanceof p ? e : null,
                        n = t.MulX(i, o.m_p),
                        a = o.m_radius,
                        r = i.R.col1;
                    this.m_debugDraw.DrawSolidCircle(n, a, r, s);
                    break;
                case y.e_polygonShape:
                    var h = 0,
                        l = e instanceof m ? e : null,
                        c = parseInt(l.GetVertexCount()),
                        d = l.GetVertices(),
                        f = new Vector(c);
                    for (h = 0; h < c; ++h) f[h] = t.MulX(i, d[h]);
                    this.m_debugDraw.DrawSolidPolygon(f, c, s);
                    break;
                case y.e_edgeShape:
                    var g = e instanceof u ? e : null;
                    this.m_debugDraw.DrawSegment(t.MulX(i, g.GetVertex1()), t.MulX(i, g.GetVertex2()), s)
            }
        }, Box2D.postDefs.push(function() {
            Box2D.Dynamics.b2World.s_timestep2 = new P, Box2D.Dynamics.b2World.s_xf = new i, Box2D.Dynamics.b2World.s_backupA = new e, Box2D.Dynamics.b2World.s_backupB = new e, Box2D.Dynamics.b2World.s_timestep = new P, Box2D.Dynamics.b2World.s_queue = new Vector, Box2D.Dynamics.b2World.s_jointColor = new o(.5, .8, .8), Box2D.Dynamics.b2World.e_newFixture = 1, Box2D.Dynamics.b2World.e_locked = 2
        })
    }(),
    function() {
        var t = Box2D.Collision.Shapes.b2CircleShape,
            e = (Box2D.Collision.Shapes.b2EdgeChainDef, Box2D.Collision.Shapes.b2EdgeShape),
            i = (Box2D.Collision.Shapes.b2MassData, Box2D.Collision.Shapes.b2PolygonShape),
            s = Box2D.Collision.Shapes.b2Shape,
            o = Box2D.Dynamics.Contacts.b2CircleContact,
            n = Box2D.Dynamics.Contacts.b2Contact,
            a = Box2D.Dynamics.Contacts.b2ContactConstraint,
            r = Box2D.Dynamics.Contacts.b2ContactConstraintPoint,
            h = Box2D.Dynamics.Contacts.b2ContactEdge,
            l = Box2D.Dynamics.Contacts.b2ContactFactory,
            c = Box2D.Dynamics.Contacts.b2ContactRegister,
            p = Box2D.Dynamics.Contacts.b2ContactResult,
            u = Box2D.Dynamics.Contacts.b2ContactSolver,
            d = Box2D.Dynamics.Contacts.b2EdgeAndCircleContact,
            m = Box2D.Dynamics.Contacts.b2NullContact,
            y = Box2D.Dynamics.Contacts.b2PolyAndCircleContact,
            f = Box2D.Dynamics.Contacts.b2PolyAndEdgeContact,
            g = Box2D.Dynamics.Contacts.b2PolygonContact,
            _ = Box2D.Dynamics.Contacts.b2PositionSolverManifold,
            v = Box2D.Dynamics.b2Body,
            b = (Box2D.Dynamics.b2BodyDef, Box2D.Dynamics.b2ContactFilter, Box2D.Dynamics.b2ContactImpulse, Box2D.Dynamics.b2ContactListener, Box2D.Dynamics.b2ContactManager, Box2D.Dynamics.b2DebugDraw, Box2D.Dynamics.b2DestructionListener, Box2D.Dynamics.b2FilterData, Box2D.Dynamics.b2Fixture, Box2D.Dynamics.b2FixtureDef, Box2D.Dynamics.b2Island, Box2D.Dynamics.b2TimeStep),
            x = (Box2D.Dynamics.b2World, Box2D.Common.b2Color, Box2D.Common.b2internal, Box2D.Common.b2Settings),
            C = Box2D.Common.Math.b2Mat22,
            S = (Box2D.Common.Math.b2Mat33, Box2D.Common.Math.b2Math),
            w = (Box2D.Common.Math.b2Sweep, Box2D.Common.Math.b2Transform, Box2D.Common.Math.b2Vec2),
            A = (Box2D.Common.Math.b2Vec3, Box2D.Collision.b2AABB, Box2D.Collision.b2Bound, Box2D.Collision.b2BoundValues, Box2D.Collision.b2Collision),
            T = Box2D.Collision.b2ContactID,
            B = (Box2D.Collision.b2ContactPoint, Box2D.Collision.b2Distance, Box2D.Collision.b2DistanceInput, Box2D.Collision.b2DistanceOutput, Box2D.Collision.b2DistanceProxy, Box2D.Collision.b2DynamicTree, Box2D.Collision.b2DynamicTreeBroadPhase, Box2D.Collision.b2DynamicTreeNode, Box2D.Collision.b2DynamicTreePair, Box2D.Collision.b2Manifold),
            P = (Box2D.Collision.b2ManifoldPoint, Box2D.Collision.b2Point, Box2D.Collision.b2RayCastInput, Box2D.Collision.b2RayCastOutput, Box2D.Collision.b2Segment, Box2D.Collision.b2SeparationFunction, Box2D.Collision.b2Simplex, Box2D.Collision.b2SimplexCache, Box2D.Collision.b2SimplexVertex, Box2D.Collision.b2TimeOfImpact),
            D = Box2D.Collision.b2TOIInput,
            I = Box2D.Collision.b2WorldManifold;
        Box2D.Collision.ClipVertex, Box2D.Collision.Features, Box2D.Collision.IBroadPhase;
        Box2D.inherit(o, Box2D.Dynamics.Contacts.b2Contact), o.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype, o.b2CircleContact = function() {
            Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments)
        }, o.Create = function(t) {
            return new o
        }, o.Destroy = function(t, e) {}, o.prototype.Reset = function(t, e) {
            this.__super.Reset.call(this, t, e)
        }, o.prototype.Evaluate = function() {
            var e = this.m_fixtureA.GetBody(),
                i = this.m_fixtureB.GetBody();
            A.CollideCircles(this.m_manifold, this.m_fixtureA.GetShape() instanceof t ? this.m_fixtureA.GetShape() : null, e.m_xf, this.m_fixtureB.GetShape() instanceof t ? this.m_fixtureB.GetShape() : null, i.m_xf)
        }, n.b2Contact = function() {
            this.m_nodeA = new h, this.m_nodeB = new h, this.m_manifold = new B, this.m_oldManifold = new B
        }, n.prototype.GetManifold = function() {
            return this.m_manifold
        }, n.prototype.GetWorldManifold = function(t) {
            var e = this.m_fixtureA.GetBody(),
                i = this.m_fixtureB.GetBody(),
                s = this.m_fixtureA.GetShape(),
                o = this.m_fixtureB.GetShape();
            t.Initialize(this.m_manifold, e.GetTransform(), s.m_radius, i.GetTransform(), o.m_radius)
        }, n.prototype.IsTouching = function() {
            return (this.m_flags & n.e_touchingFlag) == n.e_touchingFlag
        }, n.prototype.IsContinuous = function() {
            return (this.m_flags & n.e_continuousFlag) == n.e_continuousFlag
        }, n.prototype.SetSensor = function(t) {
            t ? this.m_flags |= n.e_sensorFlag : this.m_flags &= ~n.e_sensorFlag
        }, n.prototype.IsSensor = function() {
            return (this.m_flags & n.e_sensorFlag) == n.e_sensorFlag
        }, n.prototype.SetEnabled = function(t) {
            t ? this.m_flags |= n.e_enabledFlag : this.m_flags &= ~n.e_enabledFlag
        }, n.prototype.IsEnabled = function() {
            return (this.m_flags & n.e_enabledFlag) == n.e_enabledFlag
        }, n.prototype.GetNext = function() {
            return this.m_next
        }, n.prototype.GetFixtureA = function() {
            return this.m_fixtureA
        }, n.prototype.GetFixtureB = function() {
            return this.m_fixtureB
        }, n.prototype.FlagForFiltering = function() {
            this.m_flags |= n.e_filterFlag
        }, n.prototype.b2Contact = function() {}, n.prototype.Reset = function(t, e) {
            if (void 0 === t && (t = null), void 0 === e && (e = null), this.m_flags = n.e_enabledFlag, !t || !e) return this.m_fixtureA = null, void(this.m_fixtureB = null);
            (t.IsSensor() || e.IsSensor()) && (this.m_flags |= n.e_sensorFlag);
            var i = t.GetBody(),
                s = e.GetBody();
            (i.GetType() != v.b2_dynamicBody || i.IsBullet() || s.GetType() != v.b2_dynamicBody || s.IsBullet()) && (this.m_flags |= n.e_continuousFlag), this.m_fixtureA = t, this.m_fixtureB = e, this.m_manifold.m_pointCount = 0, this.m_prev = null, this.m_next = null, this.m_nodeA.contact = null, this.m_nodeA.prev = null, this.m_nodeA.next = null, this.m_nodeA.other = null, this.m_nodeB.contact = null, this.m_nodeB.prev = null, this.m_nodeB.next = null, this.m_nodeB.other = null
        }, n.prototype.Update = function(t) {
            var e = this.m_oldManifold;
            this.m_oldManifold = this.m_manifold, this.m_manifold = e, this.m_flags |= n.e_enabledFlag;
            var i = !1,
                o = (this.m_flags & n.e_touchingFlag) == n.e_touchingFlag,
                a = this.m_fixtureA.m_body,
                r = this.m_fixtureB.m_body,
                h = this.m_fixtureA.m_aabb.TestOverlap(this.m_fixtureB.m_aabb);
            if (this.m_flags & n.e_sensorFlag) {
                if (h) {
                    var l = this.m_fixtureA.GetShape(),
                        c = this.m_fixtureB.GetShape(),
                        p = a.GetTransform(),
                        u = r.GetTransform();
                    i = s.TestOverlap(l, p, c, u)
                }
                this.m_manifold.m_pointCount = 0
            } else {
                if (a.GetType() != v.b2_dynamicBody || a.IsBullet() || r.GetType() != v.b2_dynamicBody || r.IsBullet() ? this.m_flags |= n.e_continuousFlag : this.m_flags &= ~n.e_continuousFlag, h) {
                    this.Evaluate(), i = this.m_manifold.m_pointCount > 0;
                    for (var d = 0; d < this.m_manifold.m_pointCount; ++d) {
                        var m = this.m_manifold.m_points[d];
                        m.m_normalImpulse = 0, m.m_tangentImpulse = 0;
                        for (var y = m.m_id, f = 0; f < this.m_oldManifold.m_pointCount; ++f) {
                            var g = this.m_oldManifold.m_points[f];
                            if (g.m_id.key == y.key) {
                                m.m_normalImpulse = g.m_normalImpulse, m.m_tangentImpulse = g.m_tangentImpulse;
                                break
                            }
                        }
                    }
                } else this.m_manifold.m_pointCount = 0;
                i != o && (a.SetAwake(!0), r.SetAwake(!0))
            }
            i ? this.m_flags |= n.e_touchingFlag : this.m_flags &= ~n.e_touchingFlag, 0 == o && 1 == i && t.BeginContact(this), 1 == o && 0 == i && t.EndContact(this), 0 == (this.m_flags & n.e_sensorFlag) && t.PreSolve(this, this.m_oldManifold)
        }, n.prototype.Evaluate = function() {}, n.prototype.ComputeTOI = function(t, e) {
            return n.s_input.proxyA.Set(this.m_fixtureA.GetShape()), n.s_input.proxyB.Set(this.m_fixtureB.GetShape()), n.s_input.sweepA = t, n.s_input.sweepB = e, n.s_input.tolerance = x.b2_linearSlop, P.TimeOfImpact(n.s_input)
        }, Box2D.postDefs.push(function() {
            Box2D.Dynamics.Contacts.b2Contact.e_sensorFlag = 1, Box2D.Dynamics.Contacts.b2Contact.e_continuousFlag = 2, Box2D.Dynamics.Contacts.b2Contact.e_islandFlag = 4, Box2D.Dynamics.Contacts.b2Contact.e_toiFlag = 8, Box2D.Dynamics.Contacts.b2Contact.e_touchingFlag = 16, Box2D.Dynamics.Contacts.b2Contact.e_enabledFlag = 32, Box2D.Dynamics.Contacts.b2Contact.e_filterFlag = 64, Box2D.Dynamics.Contacts.b2Contact.s_input = new D
        }), a.b2ContactConstraint = function() {
            this.localPlaneNormal = new w, this.localPoint = new w, this.normal = new w, this.normalMass = new C, this.K = new C
        }, a.prototype.b2ContactConstraint = function() {
            this.points = new Vector(x.b2_maxManifoldPoints);
            for (var t = 0; t < x.b2_maxManifoldPoints; t++) this.points[t] = new r
        }, r.b2ContactConstraintPoint = function() {
            this.localPoint = new w, this.rA = new w, this.rB = new w
        }, h.b2ContactEdge = function() {}, l.b2ContactFactory = function() {}, l.prototype.b2ContactFactory = function(t) {
            this.m_allocator = t, this.InitializeRegisters()
        }, l.prototype.AddType = function(t, e, i, s) {
            void 0 === i && (i = 0), void 0 === s && (s = 0), this.m_registers[i][s].createFcn = t, this.m_registers[i][s].destroyFcn = e, this.m_registers[i][s].primary = !0, i != s && (this.m_registers[s][i].createFcn = t, this.m_registers[s][i].destroyFcn = e, this.m_registers[s][i].primary = !1)
        }, l.prototype.InitializeRegisters = function() {
            this.m_registers = new Vector(s.e_shapeTypeCount);
            for (var t = 0; t < s.e_shapeTypeCount; t++) {
                this.m_registers[t] = new Vector(s.e_shapeTypeCount);
                for (var e = 0; e < s.e_shapeTypeCount; e++) this.m_registers[t][e] = new c
            }
            this.AddType(o.Create, o.Destroy, s.e_circleShape, s.e_circleShape), this.AddType(y.Create, y.Destroy, s.e_polygonShape, s.e_circleShape), this.AddType(g.Create, g.Destroy, s.e_polygonShape, s.e_polygonShape), this.AddType(d.Create, d.Destroy, s.e_edgeShape, s.e_circleShape), this.AddType(f.Create, f.Destroy, s.e_polygonShape, s.e_edgeShape)
        }, l.prototype.Create = function(t, e) {
            var i, s = parseInt(t.GetType()),
                o = parseInt(e.GetType()),
                n = this.m_registers[s][o];
            if (n.pool) return i = n.pool, n.pool = i.m_next, n.poolCount--, i.Reset(t, e), i;
            var a = n.createFcn;
            return null != a ? n.primary ? ((i = a(this.m_allocator)).Reset(t, e), i) : ((i = a(this.m_allocator)).Reset(e, t), i) : null
        }, l.prototype.Destroy = function(t) {
            t.m_manifold.m_pointCount > 0 && (t.m_fixtureA.m_body.SetAwake(!0), t.m_fixtureB.m_body.SetAwake(!0));
            var e = parseInt(t.m_fixtureA.GetType()),
                i = parseInt(t.m_fixtureB.GetType()),
                s = this.m_registers[e][i];
            s.poolCount++, t.m_next = s.pool, s.pool = t, (0, s.destroyFcn)(t, this.m_allocator)
        }, c.b2ContactRegister = function() {}, p.b2ContactResult = function() {
            this.position = new w, this.normal = new w, this.id = new T
        }, u.b2ContactSolver = function() {
            this.m_step = new b, this.m_constraints = new Vector
        }, u.prototype.b2ContactSolver = function() {}, u.prototype.Initialize = function(t, e, i, s) {
            void 0 === i && (i = 0);
            var o;
            this.m_step.Set(t), this.m_allocator = s;
            var n = 0;
            for (this.m_constraintCount = i; this.m_constraints.length < this.m_constraintCount;) this.m_constraints[this.m_constraints.length] = new a;
            for (n = 0; n < i; ++n) {
                var r = (o = e[n]).m_fixtureA,
                    h = o.m_fixtureB,
                    l = r.m_shape,
                    c = h.m_shape,
                    p = l.m_radius,
                    d = c.m_radius,
                    m = r.m_body,
                    y = h.m_body,
                    f = o.GetManifold(),
                    g = x.b2MixFriction(r.GetFriction(), h.GetFriction()),
                    _ = x.b2MixRestitution(r.GetRestitution(), h.GetRestitution()),
                    v = m.m_linearVelocity.x,
                    b = m.m_linearVelocity.y,
                    C = y.m_linearVelocity.x,
                    S = y.m_linearVelocity.y,
                    w = m.m_angularVelocity,
                    A = y.m_angularVelocity;
                x.b2Assert(f.m_pointCount > 0), u.s_worldManifold.Initialize(f, m.m_xf, p, y.m_xf, d);
                var T = u.s_worldManifold.m_normal.x,
                    B = u.s_worldManifold.m_normal.y,
                    P = this.m_constraints[n];
                P.bodyA = m, P.bodyB = y, P.manifold = f, P.normal.x = T, P.normal.y = B, P.pointCount = f.m_pointCount, P.friction = g, P.restitution = _, P.localPlaneNormal.x = f.m_localPlaneNormal.x, P.localPlaneNormal.y = f.m_localPlaneNormal.y, P.localPoint.x = f.m_localPoint.x, P.localPoint.y = f.m_localPoint.y, P.radius = p + d, P.type = f.m_type;
                for (var D = 0; D < P.pointCount; ++D) {
                    var I = f.m_points[D],
                        E = P.points[D];
                    E.normalImpulse = I.m_normalImpulse, E.tangentImpulse = I.m_tangentImpulse, E.localPoint.SetV(I.m_localPoint);
                    var L = E.rA.x = u.s_worldManifold.m_points[D].x - m.m_sweep.c.x,
                        M = E.rA.y = u.s_worldManifold.m_points[D].y - m.m_sweep.c.y,
                        G = E.rB.x = u.s_worldManifold.m_points[D].x - y.m_sweep.c.x,
                        O = E.rB.y = u.s_worldManifold.m_points[D].y - y.m_sweep.c.y,
                        R = L * B - M * T,
                        k = G * B - O * T;
                    R *= R, k *= k;
                    var F = m.m_invMass + y.m_invMass + m.m_invI * R + y.m_invI * k;
                    E.normalMass = 1 / F;
                    var N = m.m_mass * m.m_invMass + y.m_mass * y.m_invMass;
                    N += m.m_mass * m.m_invI * R + y.m_mass * y.m_invI * k, E.equalizedMass = 1 / N;
                    var V = B,
                        U = -T,
                        W = L * U - M * V,
                        j = G * U - O * V;
                    W *= W, j *= j;
                    var X = m.m_invMass + y.m_invMass + m.m_invI * W + y.m_invI * j;
                    E.tangentMass = 1 / X, E.velocityBias = 0;
                    var K = C + -A * O - v - -w * M,
                        H = S + A * G - b - w * L,
                        q = P.normal.x * K + P.normal.y * H;
                    q < -x.b2_velocityThreshold && (E.velocityBias += -P.restitution * q)
                }
                if (2 == P.pointCount) {
                    var J = P.points[0],
                        z = P.points[1],
                        Y = m.m_invMass,
                        Z = m.m_invI,
                        Q = y.m_invMass,
                        $ = y.m_invI,
                        tt = J.rA.x * B - J.rA.y * T,
                        et = J.rB.x * B - J.rB.y * T,
                        it = z.rA.x * B - z.rA.y * T,
                        st = z.rB.x * B - z.rB.y * T,
                        ot = Y + Q + Z * tt * tt + $ * et * et,
                        nt = Y + Q + Z * it * it + $ * st * st,
                        at = Y + Q + Z * tt * it + $ * et * st;
                    ot * ot < 100 * (ot * nt - at * at) ? (P.K.col1.Set(ot, at), P.K.col2.Set(at, nt), P.K.GetInverse(P.normalMass)) : P.pointCount = 1
                }
            }
        }, u.prototype.InitVelocityConstraints = function(t) {
            for (var e = 0; e < this.m_constraintCount; ++e) {
                var i = this.m_constraints[e],
                    s = i.bodyA,
                    o = i.bodyB,
                    n = s.m_invMass,
                    a = s.m_invI,
                    r = o.m_invMass,
                    h = o.m_invI,
                    l = i.normal.x,
                    c = i.normal.y,
                    p = c,
                    u = -l,
                    d = 0,
                    m = 0;
                if (t.warmStarting)
                    for (m = i.pointCount, d = 0; d < m; ++d) {
                        var y = i.points[d];
                        y.normalImpulse *= t.dtRatio, y.tangentImpulse *= t.dtRatio;
                        var f = y.normalImpulse * l + y.tangentImpulse * p,
                            g = y.normalImpulse * c + y.tangentImpulse * u;
                        s.m_angularVelocity -= a * (y.rA.x * g - y.rA.y * f), s.m_linearVelocity.x -= n * f, s.m_linearVelocity.y -= n * g, o.m_angularVelocity += h * (y.rB.x * g - y.rB.y * f), o.m_linearVelocity.x += r * f, o.m_linearVelocity.y += r * g
                    } else
                        for (m = i.pointCount, d = 0; d < m; ++d) {
                            var _ = i.points[d];
                            _.normalImpulse = 0, _.tangentImpulse = 0
                        }
            }
        }, u.prototype.SolveVelocityConstraints = function() {
            for (var t, e, i = 0, s = 0, o = 0, n = 0, a = 0, r = 0, h = 0, l = 0, c = 0, p = 0, u = 0, d = 0, m = 0, y = 0, f = 0; f < this.m_constraintCount; ++f) {
                var g = this.m_constraints[f],
                    _ = g.bodyA,
                    v = g.bodyB,
                    b = _.m_angularVelocity,
                    x = v.m_angularVelocity,
                    C = _.m_linearVelocity,
                    w = v.m_linearVelocity,
                    A = _.m_invMass,
                    T = _.m_invI,
                    B = v.m_invMass,
                    P = v.m_invI,
                    D = g.normal.x,
                    I = g.normal.y,
                    E = I,
                    L = -D,
                    M = g.friction;
                for (i = 0; i < g.pointCount; i++) t = g.points[i], o = (w.x - x * t.rB.y - C.x + b * t.rA.y) * E + (w.y + x * t.rB.x - C.y - b * t.rA.x) * L, n = t.tangentMass * -o, a = M * t.normalImpulse, h = (n = (r = S.Clamp(t.tangentImpulse + n, -a, a)) - t.tangentImpulse) * E, l = n * L, C.x -= A * h, C.y -= A * l, b -= T * (t.rA.x * l - t.rA.y * h), w.x += B * h, w.y += B * l, x += P * (t.rB.x * l - t.rB.y * h), t.tangentImpulse = r;
                parseInt(g.pointCount);
                if (1 == g.pointCount) t = g.points[0], s = (w.x + -x * t.rB.y - C.x - -b * t.rA.y) * D + (w.y + x * t.rB.x - C.y - b * t.rA.x) * I, n = -t.normalMass * (s - t.velocityBias), h = (n = (r = (r = t.normalImpulse + n) > 0 ? r : 0) - t.normalImpulse) * D, l = n * I, C.x -= A * h, C.y -= A * l, b -= T * (t.rA.x * l - t.rA.y * h), w.x += B * h, w.y += B * l, x += P * (t.rB.x * l - t.rB.y * h), t.normalImpulse = r;
                else {
                    var G = g.points[0],
                        O = g.points[1],
                        R = G.normalImpulse,
                        k = O.normalImpulse,
                        F = (w.x - x * G.rB.y - C.x + b * G.rA.y) * D + (w.y + x * G.rB.x - C.y - b * G.rA.x) * I,
                        N = (w.x - x * O.rB.y - C.x + b * O.rA.y) * D + (w.y + x * O.rB.x - C.y - b * O.rA.x) * I,
                        V = F - G.velocityBias,
                        U = N - O.velocityBias;
                    V -= (e = g.K).col1.x * R + e.col2.x * k, U -= e.col1.y * R + e.col2.y * k;
                    for (;;) {
                        var W = -((e = g.normalMass).col1.x * V + e.col2.x * U),
                            j = -(e.col1.y * V + e.col2.y * U);
                        if (W >= 0 && j >= 0) {
                            u = (c = W - R) * D, d = c * I, m = (p = j - k) * D, y = p * I, C.x -= A * (u + m), C.y -= A * (d + y), b -= T * (G.rA.x * d - G.rA.y * u + O.rA.x * y - O.rA.y * m), w.x += B * (u + m), w.y += B * (d + y), x += P * (G.rB.x * d - G.rB.y * u + O.rB.x * y - O.rB.y * m), G.normalImpulse = W, O.normalImpulse = j;
                            break
                        }
                        if (W = -G.normalMass * V, j = 0, F = 0, N = g.K.col1.y * W + U, W >= 0 && N >= 0) {
                            u = (c = W - R) * D, d = c * I, m = (p = j - k) * D, y = p * I, C.x -= A * (u + m), C.y -= A * (d + y), b -= T * (G.rA.x * d - G.rA.y * u + O.rA.x * y - O.rA.y * m), w.x += B * (u + m), w.y += B * (d + y), x += P * (G.rB.x * d - G.rB.y * u + O.rB.x * y - O.rB.y * m), G.normalImpulse = W, O.normalImpulse = j;
                            break
                        }
                        if (W = 0, j = -O.normalMass * U, F = g.K.col2.x * j + V, N = 0, j >= 0 && F >= 0) {
                            u = (c = W - R) * D, d = c * I, m = (p = j - k) * D, y = p * I, C.x -= A * (u + m), C.y -= A * (d + y), b -= T * (G.rA.x * d - G.rA.y * u + O.rA.x * y - O.rA.y * m), w.x += B * (u + m), w.y += B * (d + y), x += P * (G.rB.x * d - G.rB.y * u + O.rB.x * y - O.rB.y * m), G.normalImpulse = W, O.normalImpulse = j;
                            break
                        }
                        if (W = 0, j = 0, F = V, N = U, F >= 0 && N >= 0) {
                            u = (c = W - R) * D, d = c * I, m = (p = j - k) * D, y = p * I, C.x -= A * (u + m), C.y -= A * (d + y), b -= T * (G.rA.x * d - G.rA.y * u + O.rA.x * y - O.rA.y * m), w.x += B * (u + m), w.y += B * (d + y), x += P * (G.rB.x * d - G.rB.y * u + O.rB.x * y - O.rB.y * m), G.normalImpulse = W, O.normalImpulse = j;
                            break
                        }
                        break
                    }
                }
                _.m_angularVelocity = b, v.m_angularVelocity = x
            }
        }, u.prototype.FinalizeVelocityConstraints = function() {
            for (var t = 0; t < this.m_constraintCount; ++t)
                for (var e = this.m_constraints[t], i = e.manifold, s = 0; s < e.pointCount; ++s) {
                    var o = i.m_points[s],
                        n = e.points[s];
                    o.m_normalImpulse = n.normalImpulse, o.m_tangentImpulse = n.tangentImpulse
                }
        }, u.prototype.SolvePositionConstraints = function(t) {
            void 0 === t && (t = 0);
            for (var e = 0, i = 0; i < this.m_constraintCount; i++) {
                var s = this.m_constraints[i],
                    o = s.bodyA,
                    n = s.bodyB,
                    a = o.m_mass * o.m_invMass,
                    r = o.m_mass * o.m_invI,
                    h = n.m_mass * n.m_invMass,
                    l = n.m_mass * n.m_invI;
                u.s_psm.Initialize(s);
                for (var c = u.s_psm.m_normal, p = 0; p < s.pointCount; p++) {
                    var d = s.points[p],
                        m = u.s_psm.m_points[p],
                        y = u.s_psm.m_separations[p],
                        f = m.x - o.m_sweep.c.x,
                        g = m.y - o.m_sweep.c.y,
                        _ = m.x - n.m_sweep.c.x,
                        v = m.y - n.m_sweep.c.y;
                    e = e < y ? e : y;
                    var b = S.Clamp(t * (y + x.b2_linearSlop), -x.b2_maxLinearCorrection, 0),
                        C = -d.equalizedMass * b,
                        w = C * c.x,
                        A = C * c.y;
                    o.m_sweep.c.x -= a * w, o.m_sweep.c.y -= a * A, o.m_sweep.a -= r * (f * A - g * w), o.SynchronizeTransform(), n.m_sweep.c.x += h * w, n.m_sweep.c.y += h * A, n.m_sweep.a += l * (_ * A - v * w), n.SynchronizeTransform()
                }
            }
            return e > -1.5 * x.b2_linearSlop
        }, Box2D.postDefs.push(function() {
            Box2D.Dynamics.Contacts.b2ContactSolver.s_worldManifold = new I, Box2D.Dynamics.Contacts.b2ContactSolver.s_psm = new _
        }), Box2D.inherit(d, Box2D.Dynamics.Contacts.b2Contact), d.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype, d.b2EdgeAndCircleContact = function() {
            Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments)
        }, d.Create = function(t) {
            return new d
        }, d.Destroy = function(t, e) {}, d.prototype.Reset = function(t, e) {
            this.__super.Reset.call(this, t, e)
        }, d.prototype.Evaluate = function() {
            var i = this.m_fixtureA.GetBody(),
                s = this.m_fixtureB.GetBody();
            this.b2CollideEdgeAndCircle(this.m_manifold, this.m_fixtureA.GetShape() instanceof e ? this.m_fixtureA.GetShape() : null, i.m_xf, this.m_fixtureB.GetShape() instanceof t ? this.m_fixtureB.GetShape() : null, s.m_xf)
        }, d.prototype.b2CollideEdgeAndCircle = function(t, e, i, s, o) {}, Box2D.inherit(m, Box2D.Dynamics.Contacts.b2Contact), m.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype, m.b2NullContact = function() {
            Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments)
        }, m.prototype.b2NullContact = function() {
            this.__super.b2Contact.call(this)
        }, m.prototype.Evaluate = function() {}, Box2D.inherit(y, Box2D.Dynamics.Contacts.b2Contact), y.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype, y.b2PolyAndCircleContact = function() {
            Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments)
        }, y.Create = function(t) {
            return new y
        }, y.Destroy = function(t, e) {}, y.prototype.Reset = function(t, e) {
            this.__super.Reset.call(this, t, e), x.b2Assert(t.GetType() == s.e_polygonShape), x.b2Assert(e.GetType() == s.e_circleShape)
        }, y.prototype.Evaluate = function() {
            var e = this.m_fixtureA.m_body,
                s = this.m_fixtureB.m_body;
            A.CollidePolygonAndCircle(this.m_manifold, this.m_fixtureA.GetShape() instanceof i ? this.m_fixtureA.GetShape() : null, e.m_xf, this.m_fixtureB.GetShape() instanceof t ? this.m_fixtureB.GetShape() : null, s.m_xf)
        }, Box2D.inherit(f, Box2D.Dynamics.Contacts.b2Contact), f.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype, f.b2PolyAndEdgeContact = function() {
            Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments)
        }, f.Create = function(t) {
            return new f
        }, f.Destroy = function(t, e) {}, f.prototype.Reset = function(t, e) {
            this.__super.Reset.call(this, t, e), x.b2Assert(t.GetType() == s.e_polygonShape), x.b2Assert(e.GetType() == s.e_edgeShape)
        }, f.prototype.Evaluate = function() {
            var t = this.m_fixtureA.GetBody(),
                s = this.m_fixtureB.GetBody();
            this.b2CollidePolyAndEdge(this.m_manifold, this.m_fixtureA.GetShape() instanceof i ? this.m_fixtureA.GetShape() : null, t.m_xf, this.m_fixtureB.GetShape() instanceof e ? this.m_fixtureB.GetShape() : null, s.m_xf)
        }, f.prototype.b2CollidePolyAndEdge = function(t, e, i, s, o) {}, Box2D.inherit(g, Box2D.Dynamics.Contacts.b2Contact), g.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype, g.b2PolygonContact = function() {
            Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments)
        }, g.Create = function(t) {
            return new g
        }, g.Destroy = function(t, e) {}, g.prototype.Reset = function(t, e) {
            this.__super.Reset.call(this, t, e)
        }, g.prototype.Evaluate = function() {
            var t = this.m_fixtureA.GetBody(),
                e = this.m_fixtureB.GetBody();
            A.CollidePolygons(this.m_manifold, this.m_fixtureA.GetShape() instanceof i ? this.m_fixtureA.GetShape() : null, t.m_xf, this.m_fixtureB.GetShape() instanceof i ? this.m_fixtureB.GetShape() : null, e.m_xf)
        }, _.b2PositionSolverManifold = function() {}, _.prototype.b2PositionSolverManifold = function() {
            this.m_normal = new w, this.m_separations = new Vector_a2j_Number(x.b2_maxManifoldPoints), this.m_points = new Vector(x.b2_maxManifoldPoints);
            for (var t = 0; t < x.b2_maxManifoldPoints; t++) this.m_points[t] = new w
        }, _.prototype.Initialize = function(t) {
            x.b2Assert(t.pointCount > 0);
            var e, i, s = 0,
                o = 0,
                n = 0,
                a = 0,
                r = 0;
            switch (t.type) {
                case B.e_circles:
                    e = t.bodyA.m_xf.R, i = t.localPoint;
                    var h = t.bodyA.m_xf.position.x + (e.col1.x * i.x + e.col2.x * i.y),
                        l = t.bodyA.m_xf.position.y + (e.col1.y * i.x + e.col2.y * i.y);
                    e = t.bodyB.m_xf.R, i = t.points[0].localPoint;
                    var c = t.bodyB.m_xf.position.x + (e.col1.x * i.x + e.col2.x * i.y),
                        p = t.bodyB.m_xf.position.y + (e.col1.y * i.x + e.col2.y * i.y),
                        u = c - h,
                        d = p - l,
                        m = u * u + d * d;
                    if (m > Number.MIN_VALUE * Number.MIN_VALUE) {
                        var y = Math.sqrt(m);
                        this.m_normal.x = u / y, this.m_normal.y = d / y
                    } else this.m_normal.x = 1, this.m_normal.y = 0;
                    this.m_points[0].x = .5 * (h + c), this.m_points[0].y = .5 * (l + p), this.m_separations[0] = u * this.m_normal.x + d * this.m_normal.y - t.radius;
                    break;
                case B.e_faceA:
                    for (e = t.bodyA.m_xf.R, i = t.localPlaneNormal, this.m_normal.x = e.col1.x * i.x + e.col2.x * i.y, this.m_normal.y = e.col1.y * i.x + e.col2.y * i.y, e = t.bodyA.m_xf.R, i = t.localPoint, a = t.bodyA.m_xf.position.x + (e.col1.x * i.x + e.col2.x * i.y), r = t.bodyA.m_xf.position.y + (e.col1.y * i.x + e.col2.y * i.y), e = t.bodyB.m_xf.R, s = 0; s < t.pointCount; ++s) i = t.points[s].localPoint, o = t.bodyB.m_xf.position.x + (e.col1.x * i.x + e.col2.x * i.y), n = t.bodyB.m_xf.position.y + (e.col1.y * i.x + e.col2.y * i.y), this.m_separations[s] = (o - a) * this.m_normal.x + (n - r) * this.m_normal.y - t.radius, this.m_points[s].x = o, this.m_points[s].y = n;
                    break;
                case B.e_faceB:
                    for (e = t.bodyB.m_xf.R, i = t.localPlaneNormal, this.m_normal.x = e.col1.x * i.x + e.col2.x * i.y, this.m_normal.y = e.col1.y * i.x + e.col2.y * i.y, e = t.bodyB.m_xf.R, i = t.localPoint, a = t.bodyB.m_xf.position.x + (e.col1.x * i.x + e.col2.x * i.y), r = t.bodyB.m_xf.position.y + (e.col1.y * i.x + e.col2.y * i.y), e = t.bodyA.m_xf.R, s = 0; s < t.pointCount; ++s) i = t.points[s].localPoint, o = t.bodyA.m_xf.position.x + (e.col1.x * i.x + e.col2.x * i.y), n = t.bodyA.m_xf.position.y + (e.col1.y * i.x + e.col2.y * i.y), this.m_separations[s] = (o - a) * this.m_normal.x + (n - r) * this.m_normal.y - t.radius, this.m_points[s].Set(o, n);
                    this.m_normal.x *= -1, this.m_normal.y *= -1
            }
        }, Box2D.postDefs.push(function() {
            Box2D.Dynamics.Contacts.b2PositionSolverManifold.circlePointA = new w, Box2D.Dynamics.Contacts.b2PositionSolverManifold.circlePointB = new w
        })
    }(),
    function() {
        Box2D.Dynamics.b2Body, Box2D.Dynamics.b2BodyDef, Box2D.Dynamics.b2ContactFilter, Box2D.Dynamics.b2ContactImpulse, Box2D.Dynamics.b2ContactListener, Box2D.Dynamics.b2ContactManager, Box2D.Dynamics.b2DebugDraw, Box2D.Dynamics.b2DestructionListener, Box2D.Dynamics.b2FilterData, Box2D.Dynamics.b2Fixture, Box2D.Dynamics.b2FixtureDef, Box2D.Dynamics.b2Island, Box2D.Dynamics.b2TimeStep, Box2D.Dynamics.b2World;
        var t = Box2D.Common.Math.b2Mat22,
            e = (Box2D.Common.Math.b2Mat33, Box2D.Common.Math.b2Math),
            i = (Box2D.Common.Math.b2Sweep, Box2D.Common.Math.b2Transform, Box2D.Common.Math.b2Vec2),
            s = (Box2D.Common.Math.b2Vec3, Box2D.Common.b2Color),
            o = (Box2D.Common.b2internal, Box2D.Common.b2Settings, Box2D.Collision.Shapes.b2CircleShape, Box2D.Collision.Shapes.b2EdgeChainDef, Box2D.Collision.Shapes.b2EdgeShape, Box2D.Collision.Shapes.b2MassData, Box2D.Collision.Shapes.b2PolygonShape, Box2D.Collision.Shapes.b2Shape, Box2D.Dynamics.Controllers.b2BuoyancyController),
            n = Box2D.Dynamics.Controllers.b2ConstantAccelController,
            a = Box2D.Dynamics.Controllers.b2ConstantForceController,
            r = Box2D.Dynamics.Controllers.b2Controller,
            h = Box2D.Dynamics.Controllers.b2ControllerEdge,
            l = Box2D.Dynamics.Controllers.b2GravityController,
            c = Box2D.Dynamics.Controllers.b2TensorDampingController;
        Box2D.inherit(o, Box2D.Dynamics.Controllers.b2Controller), o.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype, o.b2BuoyancyController = function() {
            Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments), this.normal = new i(0, -1), this.offset = 0, this.density = 0, this.velocity = new i(0, 0), this.linearDrag = 2, this.angularDrag = 1, this.useDensity = !1, this.useWorldGravity = !0, this.gravity = null
        }, o.prototype.Step = function(t) {
            if (this.m_bodyList) {
                this.useWorldGravity && (this.gravity = this.GetWorld().GetGravity().Copy());
                for (var e = this.m_bodyList; e; e = e.nextBody) {
                    var s = e.body;
                    if (0 != s.IsAwake()) {
                        for (var o = new i, n = new i, a = 0, r = 0, h = s.GetFixtureList(); h; h = h.GetNext()) {
                            var l = new i,
                                c = h.GetShape().ComputeSubmergedArea(this.normal, this.offset, s.GetTransform(), l);
                            a += c, o.x += c * l.x, o.y += c * l.y;
                            var p = 0;
                            r += c * (p = (this.useDensity, 1)), n.x += c * l.x * p, n.y += c * l.y * p
                        }
                        if (o.x /= a, o.y /= a, n.x /= r, n.y /= r, !(a < Number.MIN_VALUE)) {
                            var u = this.gravity.GetNegative();
                            u.Multiply(this.density * a), s.ApplyForce(u, n);
                            var d = s.GetLinearVelocityFromWorldPoint(o);
                            d.Subtract(this.velocity), d.Multiply(-this.linearDrag * a), s.ApplyForce(d, o), s.ApplyTorque(-s.GetInertia() / s.GetMass() * a * s.GetAngularVelocity() * this.angularDrag)
                        }
                    }
                }
            }
        }, o.prototype.Draw = function(t) {
            var e = 1e3,
                o = new i,
                n = new i;
            o.x = this.normal.x * this.offset + this.normal.y * e, o.y = this.normal.y * this.offset - this.normal.x * e, n.x = this.normal.x * this.offset - this.normal.y * e, n.y = this.normal.y * this.offset + this.normal.x * e;
            var a = new s(0, 0, 1);
            t.DrawSegment(o, n, a)
        }, Box2D.inherit(n, Box2D.Dynamics.Controllers.b2Controller), n.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype, n.b2ConstantAccelController = function() {
            Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments), this.A = new i(0, 0)
        }, n.prototype.Step = function(t) {
            for (var e = new i(this.A.x * t.dt, this.A.y * t.dt), s = this.m_bodyList; s; s = s.nextBody) {
                var o = s.body;
                o.IsAwake() && o.SetLinearVelocity(new i(o.GetLinearVelocity().x + e.x, o.GetLinearVelocity().y + e.y))
            }
        }, Box2D.inherit(a, Box2D.Dynamics.Controllers.b2Controller), a.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype, a.b2ConstantForceController = function() {
            Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments), this.F = new i(0, 0)
        }, a.prototype.Step = function(t) {
            for (var e = this.m_bodyList; e; e = e.nextBody) {
                var i = e.body;
                i.IsAwake() && i.ApplyForce(this.F, i.GetWorldCenter())
            }
        }, r.b2Controller = function() {}, r.prototype.Step = function(t) {}, r.prototype.Draw = function(t) {}, r.prototype.AddBody = function(t) {
            var e = new h;
            e.controller = this, e.body = t, e.nextBody = this.m_bodyList, e.prevBody = null, this.m_bodyList = e, e.nextBody && (e.nextBody.prevBody = e), this.m_bodyCount++, e.nextController = t.m_controllerList, e.prevController = null, t.m_controllerList = e, e.nextController && (e.nextController.prevController = e), t.m_controllerCount++
        }, r.prototype.RemoveBody = function(t) {
            for (var e = t.m_controllerList; e && e.controller != this;) e = e.nextController;
            e.prevBody && (e.prevBody.nextBody = e.nextBody), e.nextBody && (e.nextBody.prevBody = e.prevBody), e.nextController && (e.nextController.prevController = e.prevController), e.prevController && (e.prevController.nextController = e.nextController), this.m_bodyList == e && (this.m_bodyList = e.nextBody), t.m_controllerList == e && (t.m_controllerList = e.nextController), t.m_controllerCount--, this.m_bodyCount--
        }, r.prototype.Clear = function() {
            for (; this.m_bodyList;) this.RemoveBody(this.m_bodyList.body)
        }, r.prototype.GetNext = function() {
            return this.m_next
        }, r.prototype.GetWorld = function() {
            return this.m_world
        }, r.prototype.GetBodyList = function() {
            return this.m_bodyList
        }, h.b2ControllerEdge = function() {}, Box2D.inherit(l, Box2D.Dynamics.Controllers.b2Controller), l.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype, l.b2GravityController = function() {
            Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments), this.G = 1, this.invSqr = !0
        }, l.prototype.Step = function(t) {
            var e = null,
                s = null,
                o = null,
                n = 0,
                a = null,
                r = null,
                h = null,
                l = 0,
                c = 0,
                p = 0,
                u = null;
            if (this.invSqr)
                for (e = this.m_bodyList; e; e = e.nextBody)
                    for (o = (s = e.body).GetWorldCenter(), n = s.GetMass(), a = this.m_bodyList; a != e; a = a.nextBody)(p = (l = (h = (r = a.body).GetWorldCenter()).x - o.x) * l + (c = h.y - o.y) * c) < Number.MIN_VALUE || ((u = new i(l, c)).Multiply(this.G / p / Math.sqrt(p) * n * r.GetMass()), s.IsAwake() && s.ApplyForce(u, o), u.Multiply(-1), r.IsAwake() && r.ApplyForce(u, h));
            else
                for (e = this.m_bodyList; e; e = e.nextBody)
                    for (o = (s = e.body).GetWorldCenter(), n = s.GetMass(), a = this.m_bodyList; a != e; a = a.nextBody)(p = (l = (h = (r = a.body).GetWorldCenter()).x - o.x) * l + (c = h.y - o.y) * c) < Number.MIN_VALUE || ((u = new i(l, c)).Multiply(this.G / p * n * r.GetMass()), s.IsAwake() && s.ApplyForce(u, o), u.Multiply(-1), r.IsAwake() && r.ApplyForce(u, h))
        }, Box2D.inherit(c, Box2D.Dynamics.Controllers.b2Controller), c.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype, c.b2TensorDampingController = function() {
            Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments), this.T = new t, this.maxTimestep = 0
        }, c.prototype.SetAxisAligned = function(t, e) {
            void 0 === t && (t = 0), void 0 === e && (e = 0), this.T.col1.x = -t, this.T.col1.y = 0, this.T.col2.x = 0, this.T.col2.y = -e, this.maxTimestep = t > 0 || e > 0 ? 1 / Math.max(t, e) : 0
        }, c.prototype.Step = function(t) {
            var s = t.dt;
            if (!(s <= Number.MIN_VALUE)) {
                s > this.maxTimestep && this.maxTimestep > 0 && (s = this.maxTimestep);
                for (var o = this.m_bodyList; o; o = o.nextBody) {
                    var n = o.body;
                    if (n.IsAwake()) {
                        var a = n.GetWorldVector(e.MulMV(this.T, n.GetLocalVector(n.GetLinearVelocity())));
                        n.SetLinearVelocity(new i(n.GetLinearVelocity().x + a.x * s, n.GetLinearVelocity().y + a.y * s))
                    }
                }
            }
        }
    }(),
    function() {
        Box2D.Common.b2Color, Box2D.Common.b2internal;
        var t = Box2D.Common.b2Settings,
            e = Box2D.Common.Math.b2Mat22,
            i = Box2D.Common.Math.b2Mat33,
            s = Box2D.Common.Math.b2Math,
            o = (Box2D.Common.Math.b2Sweep, Box2D.Common.Math.b2Transform, Box2D.Common.Math.b2Vec2),
            n = Box2D.Common.Math.b2Vec3,
            a = Box2D.Dynamics.Joints.b2DistanceJoint,
            r = Box2D.Dynamics.Joints.b2DistanceJointDef,
            h = Box2D.Dynamics.Joints.b2FrictionJoint,
            l = Box2D.Dynamics.Joints.b2FrictionJointDef,
            c = Box2D.Dynamics.Joints.b2GearJoint,
            p = Box2D.Dynamics.Joints.b2GearJointDef,
            u = Box2D.Dynamics.Joints.b2Jacobian,
            d = Box2D.Dynamics.Joints.b2Joint,
            m = Box2D.Dynamics.Joints.b2JointDef,
            y = Box2D.Dynamics.Joints.b2JointEdge,
            f = Box2D.Dynamics.Joints.b2LineJoint,
            g = Box2D.Dynamics.Joints.b2LineJointDef,
            _ = Box2D.Dynamics.Joints.b2MouseJoint,
            v = Box2D.Dynamics.Joints.b2MouseJointDef,
            b = Box2D.Dynamics.Joints.b2PrismaticJoint,
            x = Box2D.Dynamics.Joints.b2PrismaticJointDef,
            C = Box2D.Dynamics.Joints.b2PulleyJoint,
            S = Box2D.Dynamics.Joints.b2PulleyJointDef,
            w = Box2D.Dynamics.Joints.b2RevoluteJoint,
            A = Box2D.Dynamics.Joints.b2RevoluteJointDef,
            T = Box2D.Dynamics.Joints.b2WeldJoint,
            B = Box2D.Dynamics.Joints.b2WeldJointDef;
        Box2D.Dynamics.b2Body, Box2D.Dynamics.b2BodyDef, Box2D.Dynamics.b2ContactFilter, Box2D.Dynamics.b2ContactImpulse, Box2D.Dynamics.b2ContactListener, Box2D.Dynamics.b2ContactManager, Box2D.Dynamics.b2DebugDraw, Box2D.Dynamics.b2DestructionListener, Box2D.Dynamics.b2FilterData, Box2D.Dynamics.b2Fixture, Box2D.Dynamics.b2FixtureDef, Box2D.Dynamics.b2Island, Box2D.Dynamics.b2TimeStep, Box2D.Dynamics.b2World;
        Box2D.inherit(a, Box2D.Dynamics.Joints.b2Joint), a.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype, a.b2DistanceJoint = function() {
            Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.m_localAnchor1 = new o, this.m_localAnchor2 = new o, this.m_u = new o
        }, a.prototype.GetAnchorA = function() {
            return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
        }, a.prototype.GetAnchorB = function() {
            return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
        }, a.prototype.GetReactionForce = function(t) {
            return void 0 === t && (t = 0), new o(t * this.m_impulse * this.m_u.x, t * this.m_impulse * this.m_u.y)
        }, a.prototype.GetReactionTorque = function(t) {
            return void 0 === t && (t = 0), 0
        }, a.prototype.GetLength = function() {
            return this.m_length
        }, a.prototype.SetLength = function(t) {
            void 0 === t && (t = 0), this.m_length = t
        }, a.prototype.GetFrequency = function() {
            return this.m_frequencyHz
        }, a.prototype.SetFrequency = function(t) {
            void 0 === t && (t = 0), this.m_frequencyHz = t
        }, a.prototype.GetDampingRatio = function() {
            return this.m_dampingRatio
        }, a.prototype.SetDampingRatio = function(t) {
            void 0 === t && (t = 0), this.m_dampingRatio = t
        }, a.prototype.b2DistanceJoint = function(t) {
            this.__super.b2Joint.call(this, t);
            this.m_localAnchor1.SetV(t.localAnchorA), this.m_localAnchor2.SetV(t.localAnchorB), this.m_length = t.length, this.m_frequencyHz = t.frequencyHz, this.m_dampingRatio = t.dampingRatio, this.m_impulse = 0, this.m_gamma = 0, this.m_bias = 0
        }, a.prototype.InitVelocityConstraints = function(e) {
            var i, s = 0,
                o = this.m_bodyA,
                n = this.m_bodyB;
            i = o.m_xf.R;
            var a = this.m_localAnchor1.x - o.m_sweep.localCenter.x,
                r = this.m_localAnchor1.y - o.m_sweep.localCenter.y;
            s = i.col1.x * a + i.col2.x * r, r = i.col1.y * a + i.col2.y * r, a = s, i = n.m_xf.R;
            var h = this.m_localAnchor2.x - n.m_sweep.localCenter.x,
                l = this.m_localAnchor2.y - n.m_sweep.localCenter.y;
            s = i.col1.x * h + i.col2.x * l, l = i.col1.y * h + i.col2.y * l, h = s, this.m_u.x = n.m_sweep.c.x + h - o.m_sweep.c.x - a, this.m_u.y = n.m_sweep.c.y + l - o.m_sweep.c.y - r;
            var c = Math.sqrt(this.m_u.x * this.m_u.x + this.m_u.y * this.m_u.y);
            c > t.b2_linearSlop ? this.m_u.Multiply(1 / c) : this.m_u.SetZero();
            var p = a * this.m_u.y - r * this.m_u.x,
                u = h * this.m_u.y - l * this.m_u.x,
                d = o.m_invMass + o.m_invI * p * p + n.m_invMass + n.m_invI * u * u;
            if (this.m_mass = 0 != d ? 1 / d : 0, this.m_frequencyHz > 0) {
                var m = c - this.m_length,
                    y = 2 * Math.PI * this.m_frequencyHz,
                    f = 2 * this.m_mass * this.m_dampingRatio * y,
                    g = this.m_mass * y * y;
                this.m_gamma = e.dt * (f + e.dt * g), this.m_gamma = 0 != this.m_gamma ? 1 / this.m_gamma : 0, this.m_bias = m * e.dt * g * this.m_gamma, this.m_mass = d + this.m_gamma, this.m_mass = 0 != this.m_mass ? 1 / this.m_mass : 0
            }
            if (e.warmStarting) {
                this.m_impulse *= e.dtRatio;
                var _ = this.m_impulse * this.m_u.x,
                    v = this.m_impulse * this.m_u.y;
                o.m_linearVelocity.x -= o.m_invMass * _, o.m_linearVelocity.y -= o.m_invMass * v, o.m_angularVelocity -= o.m_invI * (a * v - r * _), n.m_linearVelocity.x += n.m_invMass * _, n.m_linearVelocity.y += n.m_invMass * v, n.m_angularVelocity += n.m_invI * (h * v - l * _)
            } else this.m_impulse = 0
        }, a.prototype.SolveVelocityConstraints = function(t) {
            var e, i = this.m_bodyA,
                s = this.m_bodyB;
            e = i.m_xf.R;
            var o = this.m_localAnchor1.x - i.m_sweep.localCenter.x,
                n = this.m_localAnchor1.y - i.m_sweep.localCenter.y,
                a = e.col1.x * o + e.col2.x * n;
            n = e.col1.y * o + e.col2.y * n, o = a, e = s.m_xf.R;
            var r = this.m_localAnchor2.x - s.m_sweep.localCenter.x,
                h = this.m_localAnchor2.y - s.m_sweep.localCenter.y;
            a = e.col1.x * r + e.col2.x * h, h = e.col1.y * r + e.col2.y * h, r = a;
            var l = i.m_linearVelocity.x + -i.m_angularVelocity * n,
                c = i.m_linearVelocity.y + i.m_angularVelocity * o,
                p = s.m_linearVelocity.x + -s.m_angularVelocity * h,
                u = s.m_linearVelocity.y + s.m_angularVelocity * r,
                d = this.m_u.x * (p - l) + this.m_u.y * (u - c),
                m = -this.m_mass * (d + this.m_bias + this.m_gamma * this.m_impulse);
            this.m_impulse += m;
            var y = m * this.m_u.x,
                f = m * this.m_u.y;
            i.m_linearVelocity.x -= i.m_invMass * y, i.m_linearVelocity.y -= i.m_invMass * f, i.m_angularVelocity -= i.m_invI * (o * f - n * y), s.m_linearVelocity.x += s.m_invMass * y, s.m_linearVelocity.y += s.m_invMass * f, s.m_angularVelocity += s.m_invI * (r * f - h * y)
        }, a.prototype.SolvePositionConstraints = function(e) {
            void 0 === e && (e = 0);
            var i;
            if (this.m_frequencyHz > 0) return !0;
            var o = this.m_bodyA,
                n = this.m_bodyB;
            i = o.m_xf.R;
            var a = this.m_localAnchor1.x - o.m_sweep.localCenter.x,
                r = this.m_localAnchor1.y - o.m_sweep.localCenter.y,
                h = i.col1.x * a + i.col2.x * r;
            r = i.col1.y * a + i.col2.y * r, a = h, i = n.m_xf.R;
            var l = this.m_localAnchor2.x - n.m_sweep.localCenter.x,
                c = this.m_localAnchor2.y - n.m_sweep.localCenter.y;
            h = i.col1.x * l + i.col2.x * c, c = i.col1.y * l + i.col2.y * c, l = h;
            var p = n.m_sweep.c.x + l - o.m_sweep.c.x - a,
                u = n.m_sweep.c.y + c - o.m_sweep.c.y - r,
                d = Math.sqrt(p * p + u * u);
            p /= d, u /= d;
            var m = d - this.m_length;
            m = s.Clamp(m, -t.b2_maxLinearCorrection, t.b2_maxLinearCorrection);
            var y = -this.m_mass * m;
            this.m_u.Set(p, u);
            var f = y * this.m_u.x,
                g = y * this.m_u.y;
            return o.m_sweep.c.x -= o.m_invMass * f, o.m_sweep.c.y -= o.m_invMass * g, o.m_sweep.a -= o.m_invI * (a * g - r * f), n.m_sweep.c.x += n.m_invMass * f, n.m_sweep.c.y += n.m_invMass * g, n.m_sweep.a += n.m_invI * (l * g - c * f), o.SynchronizeTransform(), n.SynchronizeTransform(), s.Abs(m) < t.b2_linearSlop
        }, Box2D.inherit(r, Box2D.Dynamics.Joints.b2JointDef), r.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype, r.b2DistanceJointDef = function() {
            Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.localAnchorA = new o, this.localAnchorB = new o
        }, r.prototype.b2DistanceJointDef = function() {
            this.__super.b2JointDef.call(this), this.type = d.e_distanceJoint, this.length = 1, this.frequencyHz = 0, this.dampingRatio = 0
        }, r.prototype.Initialize = function(t, e, i, s) {
            this.bodyA = t, this.bodyB = e, this.localAnchorA.SetV(this.bodyA.GetLocalPoint(i)), this.localAnchorB.SetV(this.bodyB.GetLocalPoint(s));
            var o = s.x - i.x,
                n = s.y - i.y;
            this.length = Math.sqrt(o * o + n * n), this.frequencyHz = 0, this.dampingRatio = 0
        }, Box2D.inherit(h, Box2D.Dynamics.Joints.b2Joint), h.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype, h.b2FrictionJoint = function() {
            Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.m_localAnchorA = new o, this.m_localAnchorB = new o, this.m_linearMass = new e, this.m_linearImpulse = new o
        }, h.prototype.GetAnchorA = function() {
            return this.m_bodyA.GetWorldPoint(this.m_localAnchorA)
        }, h.prototype.GetAnchorB = function() {
            return this.m_bodyB.GetWorldPoint(this.m_localAnchorB)
        }, h.prototype.GetReactionForce = function(t) {
            return void 0 === t && (t = 0), new o(t * this.m_linearImpulse.x, t * this.m_linearImpulse.y)
        }, h.prototype.GetReactionTorque = function(t) {
            return void 0 === t && (t = 0), t * this.m_angularImpulse
        }, h.prototype.SetMaxForce = function(t) {
            void 0 === t && (t = 0), this.m_maxForce = t
        }, h.prototype.GetMaxForce = function() {
            return this.m_maxForce
        }, h.prototype.SetMaxTorque = function(t) {
            void 0 === t && (t = 0), this.m_maxTorque = t
        }, h.prototype.GetMaxTorque = function() {
            return this.m_maxTorque
        }, h.prototype.b2FrictionJoint = function(t) {
            this.__super.b2Joint.call(this, t), this.m_localAnchorA.SetV(t.localAnchorA), this.m_localAnchorB.SetV(t.localAnchorB), this.m_linearMass.SetZero(), this.m_angularMass = 0, this.m_linearImpulse.SetZero(), this.m_angularImpulse = 0, this.m_maxForce = t.maxForce, this.m_maxTorque = t.maxTorque
        }, h.prototype.InitVelocityConstraints = function(t) {
            var i, s = 0,
                o = this.m_bodyA,
                n = this.m_bodyB;
            i = o.m_xf.R;
            var a = this.m_localAnchorA.x - o.m_sweep.localCenter.x,
                r = this.m_localAnchorA.y - o.m_sweep.localCenter.y;
            s = i.col1.x * a + i.col2.x * r, r = i.col1.y * a + i.col2.y * r, a = s, i = n.m_xf.R;
            var h = this.m_localAnchorB.x - n.m_sweep.localCenter.x,
                l = this.m_localAnchorB.y - n.m_sweep.localCenter.y;
            s = i.col1.x * h + i.col2.x * l, l = i.col1.y * h + i.col2.y * l, h = s;
            var c = o.m_invMass,
                p = n.m_invMass,
                u = o.m_invI,
                d = n.m_invI,
                m = new e;
            if (m.col1.x = c + p, m.col2.x = 0, m.col1.y = 0, m.col2.y = c + p, m.col1.x += u * r * r, m.col2.x += -u * a * r, m.col1.y += -u * a * r, m.col2.y += u * a * a, m.col1.x += d * l * l, m.col2.x += -d * h * l, m.col1.y += -d * h * l, m.col2.y += d * h * h, m.GetInverse(this.m_linearMass), this.m_angularMass = u + d, this.m_angularMass > 0 && (this.m_angularMass = 1 / this.m_angularMass), t.warmStarting) {
                this.m_linearImpulse.x *= t.dtRatio, this.m_linearImpulse.y *= t.dtRatio, this.m_angularImpulse *= t.dtRatio;
                var y = this.m_linearImpulse;
                o.m_linearVelocity.x -= c * y.x, o.m_linearVelocity.y -= c * y.y, o.m_angularVelocity -= u * (a * y.y - r * y.x + this.m_angularImpulse), n.m_linearVelocity.x += p * y.x, n.m_linearVelocity.y += p * y.y, n.m_angularVelocity += d * (h * y.y - l * y.x + this.m_angularImpulse)
            } else this.m_linearImpulse.SetZero(), this.m_angularImpulse = 0
        }, h.prototype.SolveVelocityConstraints = function(t) {
            var e, i = 0,
                n = this.m_bodyA,
                a = this.m_bodyB,
                r = n.m_linearVelocity,
                h = n.m_angularVelocity,
                l = a.m_linearVelocity,
                c = a.m_angularVelocity,
                p = n.m_invMass,
                u = a.m_invMass,
                d = n.m_invI,
                m = a.m_invI;
            e = n.m_xf.R;
            var y = this.m_localAnchorA.x - n.m_sweep.localCenter.x,
                f = this.m_localAnchorA.y - n.m_sweep.localCenter.y;
            i = e.col1.x * y + e.col2.x * f, f = e.col1.y * y + e.col2.y * f, y = i, e = a.m_xf.R;
            var g = this.m_localAnchorB.x - a.m_sweep.localCenter.x,
                _ = this.m_localAnchorB.y - a.m_sweep.localCenter.y;
            i = e.col1.x * g + e.col2.x * _, _ = e.col1.y * g + e.col2.y * _, g = i;
            var v = 0,
                b = c - h,
                x = -this.m_angularMass * b,
                C = this.m_angularImpulse;
            v = t.dt * this.m_maxTorque, this.m_angularImpulse = s.Clamp(this.m_angularImpulse + x, -v, v), h -= d * (x = this.m_angularImpulse - C), c += m * x;
            var S = l.x - c * _ - r.x + h * f,
                w = l.y + c * g - r.y - h * y,
                A = s.MulMV(this.m_linearMass, new o(-S, -w)),
                T = this.m_linearImpulse.Copy();
            this.m_linearImpulse.Add(A), v = t.dt * this.m_maxForce, this.m_linearImpulse.LengthSquared() > v * v && (this.m_linearImpulse.Normalize(), this.m_linearImpulse.Multiply(v)), A = s.SubtractVV(this.m_linearImpulse, T), r.x -= p * A.x, r.y -= p * A.y, h -= d * (y * A.y - f * A.x), l.x += u * A.x, l.y += u * A.y, c += m * (g * A.y - _ * A.x), n.m_angularVelocity = h, a.m_angularVelocity = c
        }, h.prototype.SolvePositionConstraints = function(t) {
            return void 0 === t && (t = 0), !0
        }, Box2D.inherit(l, Box2D.Dynamics.Joints.b2JointDef), l.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype, l.b2FrictionJointDef = function() {
            Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.localAnchorA = new o, this.localAnchorB = new o
        }, l.prototype.b2FrictionJointDef = function() {
            this.__super.b2JointDef.call(this), this.type = d.e_frictionJoint, this.maxForce = 0, this.maxTorque = 0
        }, l.prototype.Initialize = function(t, e, i) {
            this.bodyA = t, this.bodyB = e, this.localAnchorA.SetV(this.bodyA.GetLocalPoint(i)), this.localAnchorB.SetV(this.bodyB.GetLocalPoint(i))
        }, Box2D.inherit(c, Box2D.Dynamics.Joints.b2Joint), c.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype, c.b2GearJoint = function() {
            Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.m_groundAnchor1 = new o, this.m_groundAnchor2 = new o, this.m_localAnchor1 = new o, this.m_localAnchor2 = new o, this.m_J = new u
        }, c.prototype.GetAnchorA = function() {
            return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
        }, c.prototype.GetAnchorB = function() {
            return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
        }, c.prototype.GetReactionForce = function(t) {
            return void 0 === t && (t = 0), new o(t * this.m_impulse * this.m_J.linearB.x, t * this.m_impulse * this.m_J.linearB.y)
        }, c.prototype.GetReactionTorque = function(t) {
            void 0 === t && (t = 0);
            var e = this.m_bodyB.m_xf.R,
                i = this.m_localAnchor1.x - this.m_bodyB.m_sweep.localCenter.x,
                s = this.m_localAnchor1.y - this.m_bodyB.m_sweep.localCenter.y,
                o = e.col1.x * i + e.col2.x * s;
            s = e.col1.y * i + e.col2.y * s, i = o;
            var n = this.m_impulse * this.m_J.linearB.x,
                a = this.m_impulse * this.m_J.linearB.y;
            return t * (this.m_impulse * this.m_J.angularB - i * a + s * n)
        }, c.prototype.GetRatio = function() {
            return this.m_ratio
        }, c.prototype.SetRatio = function(t) {
            void 0 === t && (t = 0), this.m_ratio = t
        }, c.prototype.b2GearJoint = function(t) {
            this.__super.b2Joint.call(this, t);
            var e = parseInt(t.joint1.m_type),
                i = parseInt(t.joint2.m_type);
            this.m_revolute1 = null, this.m_prismatic1 = null, this.m_revolute2 = null, this.m_prismatic2 = null;
            var s = 0,
                o = 0;
            this.m_ground1 = t.joint1.GetBodyA(), this.m_bodyA = t.joint1.GetBodyB(), e == d.e_revoluteJoint ? (this.m_revolute1 = t.joint1 instanceof w ? t.joint1 : null, this.m_groundAnchor1.SetV(this.m_revolute1.m_localAnchor1), this.m_localAnchor1.SetV(this.m_revolute1.m_localAnchor2), s = this.m_revolute1.GetJointAngle()) : (this.m_prismatic1 = t.joint1 instanceof b ? t.joint1 : null, this.m_groundAnchor1.SetV(this.m_prismatic1.m_localAnchor1), this.m_localAnchor1.SetV(this.m_prismatic1.m_localAnchor2), s = this.m_prismatic1.GetJointTranslation()), this.m_ground2 = t.joint2.GetBodyA(), this.m_bodyB = t.joint2.GetBodyB(), i == d.e_revoluteJoint ? (this.m_revolute2 = t.joint2 instanceof w ? t.joint2 : null, this.m_groundAnchor2.SetV(this.m_revolute2.m_localAnchor1), this.m_localAnchor2.SetV(this.m_revolute2.m_localAnchor2), o = this.m_revolute2.GetJointAngle()) : (this.m_prismatic2 = t.joint2 instanceof b ? t.joint2 : null, this.m_groundAnchor2.SetV(this.m_prismatic2.m_localAnchor1), this.m_localAnchor2.SetV(this.m_prismatic2.m_localAnchor2), o = this.m_prismatic2.GetJointTranslation()), this.m_ratio = t.ratio, this.m_constant = s + this.m_ratio * o, this.m_impulse = 0
        }, c.prototype.InitVelocityConstraints = function(t) {
            var e, i, s = this.m_ground1,
                o = this.m_ground2,
                n = this.m_bodyA,
                a = this.m_bodyB,
                r = 0,
                h = 0,
                l = 0,
                c = 0,
                p = 0,
                u = 0,
                d = 0;
            this.m_J.SetZero(), this.m_revolute1 ? (this.m_J.angularA = -1, d += n.m_invI) : (e = s.m_xf.R, i = this.m_prismatic1.m_localXAxis1, r = e.col1.x * i.x + e.col2.x * i.y, h = e.col1.y * i.x + e.col2.y * i.y, e = n.m_xf.R, l = this.m_localAnchor1.x - n.m_sweep.localCenter.x, c = this.m_localAnchor1.y - n.m_sweep.localCenter.y, u = e.col1.x * l + e.col2.x * c, c = e.col1.y * l + e.col2.y * c, p = (l = u) * h - c * r, this.m_J.linearA.Set(-r, -h), this.m_J.angularA = -p, d += n.m_invMass + n.m_invI * p * p), this.m_revolute2 ? (this.m_J.angularB = -this.m_ratio, d += this.m_ratio * this.m_ratio * a.m_invI) : (e = o.m_xf.R, i = this.m_prismatic2.m_localXAxis1, r = e.col1.x * i.x + e.col2.x * i.y, h = e.col1.y * i.x + e.col2.y * i.y, e = a.m_xf.R, l = this.m_localAnchor2.x - a.m_sweep.localCenter.x, c = this.m_localAnchor2.y - a.m_sweep.localCenter.y, u = e.col1.x * l + e.col2.x * c, c = e.col1.y * l + e.col2.y * c, p = (l = u) * h - c * r, this.m_J.linearB.Set(-this.m_ratio * r, -this.m_ratio * h), this.m_J.angularB = -this.m_ratio * p, d += this.m_ratio * this.m_ratio * (a.m_invMass + a.m_invI * p * p)), this.m_mass = d > 0 ? 1 / d : 0, t.warmStarting ? (n.m_linearVelocity.x += n.m_invMass * this.m_impulse * this.m_J.linearA.x, n.m_linearVelocity.y += n.m_invMass * this.m_impulse * this.m_J.linearA.y, n.m_angularVelocity += n.m_invI * this.m_impulse * this.m_J.angularA, a.m_linearVelocity.x += a.m_invMass * this.m_impulse * this.m_J.linearB.x, a.m_linearVelocity.y += a.m_invMass * this.m_impulse * this.m_J.linearB.y, a.m_angularVelocity += a.m_invI * this.m_impulse * this.m_J.angularB) : this.m_impulse = 0
        }, c.prototype.SolveVelocityConstraints = function(t) {
            var e = this.m_bodyA,
                i = this.m_bodyB,
                s = this.m_J.Compute(e.m_linearVelocity, e.m_angularVelocity, i.m_linearVelocity, i.m_angularVelocity),
                o = -this.m_mass * s;
            this.m_impulse += o, e.m_linearVelocity.x += e.m_invMass * o * this.m_J.linearA.x, e.m_linearVelocity.y += e.m_invMass * o * this.m_J.linearA.y, e.m_angularVelocity += e.m_invI * o * this.m_J.angularA, i.m_linearVelocity.x += i.m_invMass * o * this.m_J.linearB.x, i.m_linearVelocity.y += i.m_invMass * o * this.m_J.linearB.y, i.m_angularVelocity += i.m_invI * o * this.m_J.angularB
        }, c.prototype.SolvePositionConstraints = function(e) {
            void 0 === e && (e = 0);
            var i = this.m_bodyA,
                s = this.m_bodyB,
                o = 0,
                n = 0;
            o = this.m_revolute1 ? this.m_revolute1.GetJointAngle() : this.m_prismatic1.GetJointTranslation(), n = this.m_revolute2 ? this.m_revolute2.GetJointAngle() : this.m_prismatic2.GetJointTranslation();
            var a = this.m_constant - (o + this.m_ratio * n),
                r = -this.m_mass * a;
            return i.m_sweep.c.x += i.m_invMass * r * this.m_J.linearA.x, i.m_sweep.c.y += i.m_invMass * r * this.m_J.linearA.y, i.m_sweep.a += i.m_invI * r * this.m_J.angularA, s.m_sweep.c.x += s.m_invMass * r * this.m_J.linearB.x, s.m_sweep.c.y += s.m_invMass * r * this.m_J.linearB.y, s.m_sweep.a += s.m_invI * r * this.m_J.angularB, i.SynchronizeTransform(), s.SynchronizeTransform(), 0 < t.b2_linearSlop
        }, Box2D.inherit(p, Box2D.Dynamics.Joints.b2JointDef), p.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype, p.b2GearJointDef = function() {
            Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments)
        }, p.prototype.b2GearJointDef = function() {
            this.__super.b2JointDef.call(this), this.type = d.e_gearJoint, this.joint1 = null, this.joint2 = null, this.ratio = 1
        }, u.b2Jacobian = function() {
            this.linearA = new o, this.linearB = new o
        }, u.prototype.SetZero = function() {
            this.linearA.SetZero(), this.angularA = 0, this.linearB.SetZero(), this.angularB = 0
        }, u.prototype.Set = function(t, e, i, s) {
            void 0 === e && (e = 0), void 0 === s && (s = 0), this.linearA.SetV(t), this.angularA = e, this.linearB.SetV(i), this.angularB = s
        }, u.prototype.Compute = function(t, e, i, s) {
            return void 0 === e && (e = 0), void 0 === s && (s = 0), this.linearA.x * t.x + this.linearA.y * t.y + this.angularA * e + (this.linearB.x * i.x + this.linearB.y * i.y) + this.angularB * s
        }, d.b2Joint = function() {
            this.m_edgeA = new y, this.m_edgeB = new y, this.m_localCenterA = new o, this.m_localCenterB = new o
        }, d.prototype.GetType = function() {
            return this.m_type
        }, d.prototype.GetAnchorA = function() {
            return null
        }, d.prototype.GetAnchorB = function() {
            return null
        }, d.prototype.GetReactionForce = function(t) {
            return void 0 === t && (t = 0), null
        }, d.prototype.GetReactionTorque = function(t) {
            return void 0 === t && (t = 0), 0
        }, d.prototype.GetBodyA = function() {
            return this.m_bodyA
        }, d.prototype.GetBodyB = function() {
            return this.m_bodyB
        }, d.prototype.GetNext = function() {
            return this.m_next
        }, d.prototype.GetUserData = function() {
            return this.m_userData
        }, d.prototype.SetUserData = function(t) {
            this.m_userData = t
        }, d.prototype.IsActive = function() {
            return this.m_bodyA.IsActive() && this.m_bodyB.IsActive()
        }, d.Create = function(t, e) {
            var i = null;
            switch (t.type) {
                case d.e_distanceJoint:
                    i = new a(t instanceof r ? t : null);
                    break;
                case d.e_mouseJoint:
                    i = new _(t instanceof v ? t : null);
                    break;
                case d.e_prismaticJoint:
                    i = new b(t instanceof x ? t : null);
                    break;
                case d.e_revoluteJoint:
                    i = new w(t instanceof A ? t : null);
                    break;
                case d.e_pulleyJoint:
                    i = new C(t instanceof S ? t : null);
                    break;
                case d.e_gearJoint:
                    i = new c(t instanceof p ? t : null);
                    break;
                case d.e_lineJoint:
                    i = new f(t instanceof g ? t : null);
                    break;
                case d.e_weldJoint:
                    i = new T(t instanceof B ? t : null);
                    break;
                case d.e_frictionJoint:
                    i = new h(t instanceof l ? t : null)
            }
            return i
        }, d.Destroy = function(t, e) {}, d.prototype.b2Joint = function(e) {
            t.b2Assert(e.bodyA != e.bodyB), this.m_type = e.type, this.m_prev = null, this.m_next = null, this.m_bodyA = e.bodyA, this.m_bodyB = e.bodyB, this.m_collideConnected = e.collideConnected, this.m_islandFlag = !1, this.m_userData = e.userData
        }, d.prototype.InitVelocityConstraints = function(t) {}, d.prototype.SolveVelocityConstraints = function(t) {}, d.prototype.FinalizeVelocityConstraints = function() {}, d.prototype.SolvePositionConstraints = function(t) {
            return void 0 === t && (t = 0), !1
        }, Box2D.postDefs.push(function() {
            Box2D.Dynamics.Joints.b2Joint.e_unknownJoint = 0, Box2D.Dynamics.Joints.b2Joint.e_revoluteJoint = 1, Box2D.Dynamics.Joints.b2Joint.e_prismaticJoint = 2, Box2D.Dynamics.Joints.b2Joint.e_distanceJoint = 3, Box2D.Dynamics.Joints.b2Joint.e_pulleyJoint = 4, Box2D.Dynamics.Joints.b2Joint.e_mouseJoint = 5, Box2D.Dynamics.Joints.b2Joint.e_gearJoint = 6, Box2D.Dynamics.Joints.b2Joint.e_lineJoint = 7, Box2D.Dynamics.Joints.b2Joint.e_weldJoint = 8, Box2D.Dynamics.Joints.b2Joint.e_frictionJoint = 9, Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit = 0, Box2D.Dynamics.Joints.b2Joint.e_atLowerLimit = 1, Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit = 2, Box2D.Dynamics.Joints.b2Joint.e_equalLimits = 3
        }), m.b2JointDef = function() {}, m.prototype.b2JointDef = function() {
            this.type = d.e_unknownJoint, this.userData = null, this.bodyA = null, this.bodyB = null, this.collideConnected = !1
        }, y.b2JointEdge = function() {}, Box2D.inherit(f, Box2D.Dynamics.Joints.b2Joint), f.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype, f.b2LineJoint = function() {
            Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.m_localAnchor1 = new o, this.m_localAnchor2 = new o, this.m_localXAxis1 = new o, this.m_localYAxis1 = new o, this.m_axis = new o, this.m_perp = new o, this.m_K = new e, this.m_impulse = new o
        }, f.prototype.GetAnchorA = function() {
            return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
        }, f.prototype.GetAnchorB = function() {
            return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
        }, f.prototype.GetReactionForce = function(t) {
            return void 0 === t && (t = 0), new o(t * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x), t * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y))
        }, f.prototype.GetReactionTorque = function(t) {
            return void 0 === t && (t = 0), t * this.m_impulse.y
        }, f.prototype.GetJointTranslation = function() {
            var t = this.m_bodyA,
                e = this.m_bodyB,
                i = t.GetWorldPoint(this.m_localAnchor1),
                s = e.GetWorldPoint(this.m_localAnchor2),
                o = s.x - i.x,
                n = s.y - i.y,
                a = t.GetWorldVector(this.m_localXAxis1);
            return a.x * o + a.y * n
        }, f.prototype.GetJointSpeed = function() {
            var t, e = this.m_bodyA,
                i = this.m_bodyB;
            t = e.m_xf.R;
            var s = this.m_localAnchor1.x - e.m_sweep.localCenter.x,
                o = this.m_localAnchor1.y - e.m_sweep.localCenter.y,
                n = t.col1.x * s + t.col2.x * o;
            o = t.col1.y * s + t.col2.y * o, s = n, t = i.m_xf.R;
            var a = this.m_localAnchor2.x - i.m_sweep.localCenter.x,
                r = this.m_localAnchor2.y - i.m_sweep.localCenter.y;
            n = t.col1.x * a + t.col2.x * r, r = t.col1.y * a + t.col2.y * r, a = n;
            var h = e.m_sweep.c.x + s,
                l = e.m_sweep.c.y + o,
                c = i.m_sweep.c.x + a - h,
                p = i.m_sweep.c.y + r - l,
                u = e.GetWorldVector(this.m_localXAxis1),
                d = e.m_linearVelocity,
                m = i.m_linearVelocity,
                y = e.m_angularVelocity,
                f = i.m_angularVelocity;
            return c * (-y * u.y) + p * (y * u.x) + (u.x * (m.x + -f * r - d.x - -y * o) + u.y * (m.y + f * a - d.y - y * s))
        }, f.prototype.IsLimitEnabled = function() {
            return this.m_enableLimit
        }, f.prototype.EnableLimit = function(t) {
            this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableLimit = t
        }, f.prototype.GetLowerLimit = function() {
            return this.m_lowerTranslation
        }, f.prototype.GetUpperLimit = function() {
            return this.m_upperTranslation
        }, f.prototype.SetLimits = function(t, e) {
            void 0 === t && (t = 0), void 0 === e && (e = 0), this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_lowerTranslation = t, this.m_upperTranslation = e
        }, f.prototype.IsMotorEnabled = function() {
            return this.m_enableMotor
        }, f.prototype.EnableMotor = function(t) {
            this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableMotor = t
        }, f.prototype.SetMotorSpeed = function(t) {
            void 0 === t && (t = 0), this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_motorSpeed = t
        }, f.prototype.GetMotorSpeed = function() {
            return this.m_motorSpeed
        }, f.prototype.SetMaxMotorForce = function(t) {
            void 0 === t && (t = 0), this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_maxMotorForce = t
        }, f.prototype.GetMaxMotorForce = function() {
            return this.m_maxMotorForce
        }, f.prototype.GetMotorForce = function() {
            return this.m_motorImpulse
        }, f.prototype.b2LineJoint = function(t) {
            this.__super.b2Joint.call(this, t);
            this.m_localAnchor1.SetV(t.localAnchorA), this.m_localAnchor2.SetV(t.localAnchorB), this.m_localXAxis1.SetV(t.localAxisA), this.m_localYAxis1.x = -this.m_localXAxis1.y, this.m_localYAxis1.y = this.m_localXAxis1.x, this.m_impulse.SetZero(), this.m_motorMass = 0, this.m_motorImpulse = 0, this.m_lowerTranslation = t.lowerTranslation, this.m_upperTranslation = t.upperTranslation, this.m_maxMotorForce = t.maxMotorForce, this.m_motorSpeed = t.motorSpeed, this.m_enableLimit = t.enableLimit, this.m_enableMotor = t.enableMotor, this.m_limitState = d.e_inactiveLimit, this.m_axis.SetZero(), this.m_perp.SetZero()
        }, f.prototype.InitVelocityConstraints = function(e) {
            var i, o = this.m_bodyA,
                n = this.m_bodyB,
                a = 0;
            this.m_localCenterA.SetV(o.GetLocalCenter()), this.m_localCenterB.SetV(n.GetLocalCenter());
            var r = o.GetTransform();
            n.GetTransform();
            i = o.m_xf.R;
            var h = this.m_localAnchor1.x - this.m_localCenterA.x,
                l = this.m_localAnchor1.y - this.m_localCenterA.y;
            a = i.col1.x * h + i.col2.x * l, l = i.col1.y * h + i.col2.y * l, h = a, i = n.m_xf.R;
            var c = this.m_localAnchor2.x - this.m_localCenterB.x,
                p = this.m_localAnchor2.y - this.m_localCenterB.y;
            a = i.col1.x * c + i.col2.x * p, p = i.col1.y * c + i.col2.y * p, c = a;
            var u = n.m_sweep.c.x + c - o.m_sweep.c.x - h,
                m = n.m_sweep.c.y + p - o.m_sweep.c.y - l;
            this.m_invMassA = o.m_invMass, this.m_invMassB = n.m_invMass, this.m_invIA = o.m_invI, this.m_invIB = n.m_invI, this.m_axis.SetV(s.MulMV(r.R, this.m_localXAxis1)), this.m_a1 = (u + h) * this.m_axis.y - (m + l) * this.m_axis.x, this.m_a2 = c * this.m_axis.y - p * this.m_axis.x, this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2, this.m_motorMass = this.m_motorMass > Number.MIN_VALUE ? 1 / this.m_motorMass : 0, this.m_perp.SetV(s.MulMV(r.R, this.m_localYAxis1)), this.m_s1 = (u + h) * this.m_perp.y - (m + l) * this.m_perp.x, this.m_s2 = c * this.m_perp.y - p * this.m_perp.x;
            var y = this.m_invMassA,
                f = this.m_invMassB,
                g = this.m_invIA,
                _ = this.m_invIB;
            if (this.m_K.col1.x = y + f + g * this.m_s1 * this.m_s1 + _ * this.m_s2 * this.m_s2, this.m_K.col1.y = g * this.m_s1 * this.m_a1 + _ * this.m_s2 * this.m_a2, this.m_K.col2.x = this.m_K.col1.y, this.m_K.col2.y = y + f + g * this.m_a1 * this.m_a1 + _ * this.m_a2 * this.m_a2, this.m_enableLimit) {
                var v = this.m_axis.x * u + this.m_axis.y * m;
                s.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * t.b2_linearSlop ? this.m_limitState = d.e_equalLimits : v <= this.m_lowerTranslation ? this.m_limitState != d.e_atLowerLimit && (this.m_limitState = d.e_atLowerLimit, this.m_impulse.y = 0) : v >= this.m_upperTranslation ? this.m_limitState != d.e_atUpperLimit && (this.m_limitState = d.e_atUpperLimit, this.m_impulse.y = 0) : (this.m_limitState = d.e_inactiveLimit, this.m_impulse.y = 0)
            } else this.m_limitState = d.e_inactiveLimit;
            if (0 == this.m_enableMotor && (this.m_motorImpulse = 0), e.warmStarting) {
                this.m_impulse.x *= e.dtRatio, this.m_impulse.y *= e.dtRatio, this.m_motorImpulse *= e.dtRatio;
                var b = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x,
                    x = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y,
                    C = this.m_impulse.x * this.m_s1 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a1,
                    S = this.m_impulse.x * this.m_s2 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a2;
                o.m_linearVelocity.x -= this.m_invMassA * b, o.m_linearVelocity.y -= this.m_invMassA * x, o.m_angularVelocity -= this.m_invIA * C, n.m_linearVelocity.x += this.m_invMassB * b, n.m_linearVelocity.y += this.m_invMassB * x, n.m_angularVelocity += this.m_invIB * S
            } else this.m_impulse.SetZero(), this.m_motorImpulse = 0
        }, f.prototype.SolveVelocityConstraints = function(t) {
            var e = this.m_bodyA,
                i = this.m_bodyB,
                n = e.m_linearVelocity,
                a = e.m_angularVelocity,
                r = i.m_linearVelocity,
                h = i.m_angularVelocity,
                l = 0,
                c = 0,
                p = 0,
                u = 0;
            if (this.m_enableMotor && this.m_limitState != d.e_equalLimits) {
                var m = this.m_axis.x * (r.x - n.x) + this.m_axis.y * (r.y - n.y) + this.m_a2 * h - this.m_a1 * a,
                    y = this.m_motorMass * (this.m_motorSpeed - m),
                    f = this.m_motorImpulse,
                    g = t.dt * this.m_maxMotorForce;
                this.m_motorImpulse = s.Clamp(this.m_motorImpulse + y, -g, g), l = (y = this.m_motorImpulse - f) * this.m_axis.x, c = y * this.m_axis.y, p = y * this.m_a1, u = y * this.m_a2, n.x -= this.m_invMassA * l, n.y -= this.m_invMassA * c, a -= this.m_invIA * p, r.x += this.m_invMassB * l, r.y += this.m_invMassB * c, h += this.m_invIB * u
            }
            var _ = this.m_perp.x * (r.x - n.x) + this.m_perp.y * (r.y - n.y) + this.m_s2 * h - this.m_s1 * a;
            if (this.m_enableLimit && this.m_limitState != d.e_inactiveLimit) {
                var v = this.m_axis.x * (r.x - n.x) + this.m_axis.y * (r.y - n.y) + this.m_a2 * h - this.m_a1 * a,
                    b = this.m_impulse.Copy(),
                    x = this.m_K.Solve(new o, -_, -v);
                this.m_impulse.Add(x), this.m_limitState == d.e_atLowerLimit ? this.m_impulse.y = s.Max(this.m_impulse.y, 0) : this.m_limitState == d.e_atUpperLimit && (this.m_impulse.y = s.Min(this.m_impulse.y, 0));
                var C = -_ - (this.m_impulse.y - b.y) * this.m_K.col2.x,
                    S = 0;
                S = 0 != this.m_K.col1.x ? C / this.m_K.col1.x + b.x : b.x, this.m_impulse.x = S, x.x = this.m_impulse.x - b.x, x.y = this.m_impulse.y - b.y, l = x.x * this.m_perp.x + x.y * this.m_axis.x, c = x.x * this.m_perp.y + x.y * this.m_axis.y, p = x.x * this.m_s1 + x.y * this.m_a1, u = x.x * this.m_s2 + x.y * this.m_a2, n.x -= this.m_invMassA * l, n.y -= this.m_invMassA * c, a -= this.m_invIA * p, r.x += this.m_invMassB * l, r.y += this.m_invMassB * c, h += this.m_invIB * u
            } else {
                var w = 0;
                w = 0 != this.m_K.col1.x ? -_ / this.m_K.col1.x : 0, this.m_impulse.x += w, l = w * this.m_perp.x, c = w * this.m_perp.y, p = w * this.m_s1, u = w * this.m_s2, n.x -= this.m_invMassA * l, n.y -= this.m_invMassA * c, a -= this.m_invIA * p, r.x += this.m_invMassB * l, r.y += this.m_invMassB * c, h += this.m_invIB * u
            }
            e.m_linearVelocity.SetV(n), e.m_angularVelocity = a, i.m_linearVelocity.SetV(r), i.m_angularVelocity = h
        }, f.prototype.SolvePositionConstraints = function(i) {
            void 0 === i && (i = 0);
            var n, a = this.m_bodyA,
                r = this.m_bodyB,
                h = a.m_sweep.c,
                l = a.m_sweep.a,
                c = r.m_sweep.c,
                p = r.m_sweep.a,
                u = 0,
                d = 0,
                m = 0,
                y = 0,
                f = 0,
                g = 0,
                _ = !1,
                v = 0,
                b = e.FromAngle(l),
                x = e.FromAngle(p);
            n = b;
            var C = this.m_localAnchor1.x - this.m_localCenterA.x,
                S = this.m_localAnchor1.y - this.m_localCenterA.y;
            u = n.col1.x * C + n.col2.x * S, S = n.col1.y * C + n.col2.y * S, C = u, n = x;
            var w = this.m_localAnchor2.x - this.m_localCenterB.x,
                A = this.m_localAnchor2.y - this.m_localCenterB.y;
            u = n.col1.x * w + n.col2.x * A, A = n.col1.y * w + n.col2.y * A, w = u;
            var T = c.x + w - h.x - C,
                B = c.y + A - h.y - S;
            if (this.m_enableLimit) {
                this.m_axis = s.MulMV(b, this.m_localXAxis1), this.m_a1 = (T + C) * this.m_axis.y - (B + S) * this.m_axis.x, this.m_a2 = w * this.m_axis.y - A * this.m_axis.x;
                var P = this.m_axis.x * T + this.m_axis.y * B;
                s.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * t.b2_linearSlop ? (v = s.Clamp(P, -t.b2_maxLinearCorrection, t.b2_maxLinearCorrection), g = s.Abs(P), _ = !0) : P <= this.m_lowerTranslation ? (v = s.Clamp(P - this.m_lowerTranslation + t.b2_linearSlop, -t.b2_maxLinearCorrection, 0), g = this.m_lowerTranslation - P, _ = !0) : P >= this.m_upperTranslation && (v = s.Clamp(P - this.m_upperTranslation + t.b2_linearSlop, 0, t.b2_maxLinearCorrection), g = P - this.m_upperTranslation, _ = !0)
            }
            this.m_perp = s.MulMV(b, this.m_localYAxis1), this.m_s1 = (T + C) * this.m_perp.y - (B + S) * this.m_perp.x, this.m_s2 = w * this.m_perp.y - A * this.m_perp.x;
            var D = new o,
                I = this.m_perp.x * T + this.m_perp.y * B;
            if (g = s.Max(g, s.Abs(I)), 0, _) d = this.m_invMassA, m = this.m_invMassB, y = this.m_invIA, f = this.m_invIB, this.m_K.col1.x = d + m + y * this.m_s1 * this.m_s1 + f * this.m_s2 * this.m_s2, this.m_K.col1.y = y * this.m_s1 * this.m_a1 + f * this.m_s2 * this.m_a2, this.m_K.col2.x = this.m_K.col1.y, this.m_K.col2.y = d + m + y * this.m_a1 * this.m_a1 + f * this.m_a2 * this.m_a2, this.m_K.Solve(D, -I, -v);
            else {
                d = this.m_invMassA, m = this.m_invMassB, y = this.m_invIA, f = this.m_invIB;
                var E = d + m + y * this.m_s1 * this.m_s1 + f * this.m_s2 * this.m_s2,
                    L = 0;
                L = 0 != E ? -I / E : 0, D.x = L, D.y = 0
            }
            var M = D.x * this.m_perp.x + D.y * this.m_axis.x,
                G = D.x * this.m_perp.y + D.y * this.m_axis.y,
                O = D.x * this.m_s1 + D.y * this.m_a1,
                R = D.x * this.m_s2 + D.y * this.m_a2;
            return h.x -= this.m_invMassA * M, h.y -= this.m_invMassA * G, l -= this.m_invIA * O, c.x += this.m_invMassB * M, c.y += this.m_invMassB * G, p += this.m_invIB * R, a.m_sweep.a = l, r.m_sweep.a = p, a.SynchronizeTransform(), r.SynchronizeTransform(), g <= t.b2_linearSlop && 0 <= t.b2_angularSlop
        }, Box2D.inherit(g, Box2D.Dynamics.Joints.b2JointDef), g.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype, g.b2LineJointDef = function() {
            Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.localAnchorA = new o, this.localAnchorB = new o, this.localAxisA = new o
        }, g.prototype.b2LineJointDef = function() {
            this.__super.b2JointDef.call(this), this.type = d.e_lineJoint, this.localAxisA.Set(1, 0), this.enableLimit = !1, this.lowerTranslation = 0, this.upperTranslation = 0, this.enableMotor = !1, this.maxMotorForce = 0, this.motorSpeed = 0
        }, g.prototype.Initialize = function(t, e, i, s) {
            this.bodyA = t, this.bodyB = e, this.localAnchorA = this.bodyA.GetLocalPoint(i), this.localAnchorB = this.bodyB.GetLocalPoint(i), this.localAxisA = this.bodyA.GetLocalVector(s)
        }, Box2D.inherit(_, Box2D.Dynamics.Joints.b2Joint), _.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype, _.b2MouseJoint = function() {
            Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.K = new e, this.K1 = new e, this.K2 = new e, this.m_localAnchor = new o, this.m_target = new o, this.m_impulse = new o, this.m_mass = new e, this.m_C = new o
        }, _.prototype.GetAnchorA = function() {
            return this.m_target
        }, _.prototype.GetAnchorB = function() {
            return this.m_bodyB.GetWorldPoint(this.m_localAnchor)
        }, _.prototype.GetReactionForce = function(t) {
            return void 0 === t && (t = 0), new o(t * this.m_impulse.x, t * this.m_impulse.y)
        }, _.prototype.GetReactionTorque = function(t) {
            return void 0 === t && (t = 0), 0
        }, _.prototype.GetTarget = function() {
            return this.m_target
        }, _.prototype.SetTarget = function(t) {
            0 == this.m_bodyB.IsAwake() && this.m_bodyB.SetAwake(!0), this.m_target = t
        }, _.prototype.GetMaxForce = function() {
            return this.m_maxForce
        }, _.prototype.SetMaxForce = function(t) {
            void 0 === t && (t = 0), this.m_maxForce = t
        }, _.prototype.GetFrequency = function() {
            return this.m_frequencyHz
        }, _.prototype.SetFrequency = function(t) {
            void 0 === t && (t = 0), this.m_frequencyHz = t
        }, _.prototype.GetDampingRatio = function() {
            return this.m_dampingRatio
        }, _.prototype.SetDampingRatio = function(t) {
            void 0 === t && (t = 0), this.m_dampingRatio = t
        }, _.prototype.b2MouseJoint = function(t) {
            this.__super.b2Joint.call(this, t), this.m_target.SetV(t.target);
            var e = this.m_target.x - this.m_bodyB.m_xf.position.x,
                i = this.m_target.y - this.m_bodyB.m_xf.position.y,
                s = this.m_bodyB.m_xf.R;
            this.m_localAnchor.x = e * s.col1.x + i * s.col1.y, this.m_localAnchor.y = e * s.col2.x + i * s.col2.y, this.m_maxForce = t.maxForce, this.m_impulse.SetZero(), this.m_frequencyHz = t.frequencyHz, this.m_dampingRatio = t.dampingRatio, this.m_beta = 0, this.m_gamma = 0
        }, _.prototype.InitVelocityConstraints = function(t) {
            var e = this.m_bodyB,
                i = e.GetMass(),
                s = 2 * Math.PI * this.m_frequencyHz,
                o = 2 * i * this.m_dampingRatio * s,
                n = i * s * s;
            this.m_gamma = t.dt * (o + t.dt * n), this.m_gamma = 0 != this.m_gamma ? 1 / this.m_gamma : 0, this.m_beta = t.dt * n * this.m_gamma;
            var a;
            a = e.m_xf.R;
            var r = this.m_localAnchor.x - e.m_sweep.localCenter.x,
                h = this.m_localAnchor.y - e.m_sweep.localCenter.y,
                l = a.col1.x * r + a.col2.x * h;
            h = a.col1.y * r + a.col2.y * h, r = l;
            var c = e.m_invMass,
                p = e.m_invI;
            this.K1.col1.x = c, this.K1.col2.x = 0, this.K1.col1.y = 0, this.K1.col2.y = c, this.K2.col1.x = p * h * h, this.K2.col2.x = -p * r * h, this.K2.col1.y = -p * r * h, this.K2.col2.y = p * r * r, this.K.SetM(this.K1), this.K.AddM(this.K2), this.K.col1.x += this.m_gamma, this.K.col2.y += this.m_gamma, this.K.GetInverse(this.m_mass), this.m_C.x = e.m_sweep.c.x + r - this.m_target.x, this.m_C.y = e.m_sweep.c.y + h - this.m_target.y, e.m_angularVelocity *= .98, this.m_impulse.x *= t.dtRatio, this.m_impulse.y *= t.dtRatio, e.m_linearVelocity.x += c * this.m_impulse.x, e.m_linearVelocity.y += c * this.m_impulse.y, e.m_angularVelocity += p * (r * this.m_impulse.y - h * this.m_impulse.x)
        }, _.prototype.SolveVelocityConstraints = function(t) {
            var e, i = this.m_bodyB,
                s = 0,
                o = 0;
            e = i.m_xf.R;
            var n = this.m_localAnchor.x - i.m_sweep.localCenter.x,
                a = this.m_localAnchor.y - i.m_sweep.localCenter.y;
            s = e.col1.x * n + e.col2.x * a, a = e.col1.y * n + e.col2.y * a, n = s;
            var r = i.m_linearVelocity.x + -i.m_angularVelocity * a,
                h = i.m_linearVelocity.y + i.m_angularVelocity * n;
            e = this.m_mass, s = r + this.m_beta * this.m_C.x + this.m_gamma * this.m_impulse.x, o = h + this.m_beta * this.m_C.y + this.m_gamma * this.m_impulse.y;
            var l = -(e.col1.x * s + e.col2.x * o),
                c = -(e.col1.y * s + e.col2.y * o),
                p = this.m_impulse.x,
                u = this.m_impulse.y;
            this.m_impulse.x += l, this.m_impulse.y += c;
            var d = t.dt * this.m_maxForce;
            this.m_impulse.LengthSquared() > d * d && this.m_impulse.Multiply(d / this.m_impulse.Length()), l = this.m_impulse.x - p, c = this.m_impulse.y - u, i.m_linearVelocity.x += i.m_invMass * l, i.m_linearVelocity.y += i.m_invMass * c, i.m_angularVelocity += i.m_invI * (n * c - a * l)
        }, _.prototype.SolvePositionConstraints = function(t) {
            return void 0 === t && (t = 0), !0
        }, Box2D.inherit(v, Box2D.Dynamics.Joints.b2JointDef), v.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype, v.b2MouseJointDef = function() {
            Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.target = new o
        }, v.prototype.b2MouseJointDef = function() {
            this.__super.b2JointDef.call(this), this.type = d.e_mouseJoint, this.maxForce = 0, this.frequencyHz = 5, this.dampingRatio = .7
        }, Box2D.inherit(b, Box2D.Dynamics.Joints.b2Joint), b.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype, b.b2PrismaticJoint = function() {
            Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.m_localAnchor1 = new o, this.m_localAnchor2 = new o, this.m_localXAxis1 = new o, this.m_localYAxis1 = new o, this.m_axis = new o, this.m_perp = new o, this.m_K = new i, this.m_impulse = new n
        }, b.prototype.GetAnchorA = function() {
            return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
        }, b.prototype.GetAnchorB = function() {
            return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
        }, b.prototype.GetReactionForce = function(t) {
            return void 0 === t && (t = 0), new o(t * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x), t * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y))
        }, b.prototype.GetReactionTorque = function(t) {
            return void 0 === t && (t = 0), t * this.m_impulse.y
        }, b.prototype.GetJointTranslation = function() {
            var t = this.m_bodyA,
                e = this.m_bodyB,
                i = t.GetWorldPoint(this.m_localAnchor1),
                s = e.GetWorldPoint(this.m_localAnchor2),
                o = s.x - i.x,
                n = s.y - i.y,
                a = t.GetWorldVector(this.m_localXAxis1);
            return a.x * o + a.y * n
        }, b.prototype.GetJointSpeed = function() {
            var t, e = this.m_bodyA,
                i = this.m_bodyB;
            t = e.m_xf.R;
            var s = this.m_localAnchor1.x - e.m_sweep.localCenter.x,
                o = this.m_localAnchor1.y - e.m_sweep.localCenter.y,
                n = t.col1.x * s + t.col2.x * o;
            o = t.col1.y * s + t.col2.y * o, s = n, t = i.m_xf.R;
            var a = this.m_localAnchor2.x - i.m_sweep.localCenter.x,
                r = this.m_localAnchor2.y - i.m_sweep.localCenter.y;
            n = t.col1.x * a + t.col2.x * r, r = t.col1.y * a + t.col2.y * r, a = n;
            var h = e.m_sweep.c.x + s,
                l = e.m_sweep.c.y + o,
                c = i.m_sweep.c.x + a - h,
                p = i.m_sweep.c.y + r - l,
                u = e.GetWorldVector(this.m_localXAxis1),
                d = e.m_linearVelocity,
                m = i.m_linearVelocity,
                y = e.m_angularVelocity,
                f = i.m_angularVelocity;
            return c * (-y * u.y) + p * (y * u.x) + (u.x * (m.x + -f * r - d.x - -y * o) + u.y * (m.y + f * a - d.y - y * s))
        }, b.prototype.IsLimitEnabled = function() {
            return this.m_enableLimit
        }, b.prototype.EnableLimit = function(t) {
            this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableLimit = t
        }, b.prototype.GetLowerLimit = function() {
            return this.m_lowerTranslation
        }, b.prototype.GetUpperLimit = function() {
            return this.m_upperTranslation
        }, b.prototype.SetLimits = function(t, e) {
            void 0 === t && (t = 0), void 0 === e && (e = 0), this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_lowerTranslation = t, this.m_upperTranslation = e
        }, b.prototype.IsMotorEnabled = function() {
            return this.m_enableMotor
        }, b.prototype.EnableMotor = function(t) {
            this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableMotor = t
        }, b.prototype.SetMotorSpeed = function(t) {
            void 0 === t && (t = 0), this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_motorSpeed = t
        }, b.prototype.GetMotorSpeed = function() {
            return this.m_motorSpeed
        }, b.prototype.SetMaxMotorForce = function(t) {
            void 0 === t && (t = 0), this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_maxMotorForce = t
        }, b.prototype.GetMotorForce = function() {
            return this.m_motorImpulse
        }, b.prototype.b2PrismaticJoint = function(t) {
            this.__super.b2Joint.call(this, t);
            this.m_localAnchor1.SetV(t.localAnchorA), this.m_localAnchor2.SetV(t.localAnchorB), this.m_localXAxis1.SetV(t.localAxisA), this.m_localYAxis1.x = -this.m_localXAxis1.y, this.m_localYAxis1.y = this.m_localXAxis1.x, this.m_refAngle = t.referenceAngle, this.m_impulse.SetZero(), this.m_motorMass = 0, this.m_motorImpulse = 0, this.m_lowerTranslation = t.lowerTranslation, this.m_upperTranslation = t.upperTranslation, this.m_maxMotorForce = t.maxMotorForce, this.m_motorSpeed = t.motorSpeed, this.m_enableLimit = t.enableLimit, this.m_enableMotor = t.enableMotor, this.m_limitState = d.e_inactiveLimit, this.m_axis.SetZero(), this.m_perp.SetZero()
        }, b.prototype.InitVelocityConstraints = function(e) {
            var i, o = this.m_bodyA,
                n = this.m_bodyB,
                a = 0;
            this.m_localCenterA.SetV(o.GetLocalCenter()), this.m_localCenterB.SetV(n.GetLocalCenter());
            var r = o.GetTransform();
            n.GetTransform();
            i = o.m_xf.R;
            var h = this.m_localAnchor1.x - this.m_localCenterA.x,
                l = this.m_localAnchor1.y - this.m_localCenterA.y;
            a = i.col1.x * h + i.col2.x * l, l = i.col1.y * h + i.col2.y * l, h = a, i = n.m_xf.R;
            var c = this.m_localAnchor2.x - this.m_localCenterB.x,
                p = this.m_localAnchor2.y - this.m_localCenterB.y;
            a = i.col1.x * c + i.col2.x * p, p = i.col1.y * c + i.col2.y * p, c = a;
            var u = n.m_sweep.c.x + c - o.m_sweep.c.x - h,
                m = n.m_sweep.c.y + p - o.m_sweep.c.y - l;
            this.m_invMassA = o.m_invMass, this.m_invMassB = n.m_invMass, this.m_invIA = o.m_invI, this.m_invIB = n.m_invI, this.m_axis.SetV(s.MulMV(r.R, this.m_localXAxis1)), this.m_a1 = (u + h) * this.m_axis.y - (m + l) * this.m_axis.x, this.m_a2 = c * this.m_axis.y - p * this.m_axis.x, this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2, this.m_motorMass > Number.MIN_VALUE && (this.m_motorMass = 1 / this.m_motorMass), this.m_perp.SetV(s.MulMV(r.R, this.m_localYAxis1)), this.m_s1 = (u + h) * this.m_perp.y - (m + l) * this.m_perp.x, this.m_s2 = c * this.m_perp.y - p * this.m_perp.x;
            var y = this.m_invMassA,
                f = this.m_invMassB,
                g = this.m_invIA,
                _ = this.m_invIB;
            if (this.m_K.col1.x = y + f + g * this.m_s1 * this.m_s1 + _ * this.m_s2 * this.m_s2, this.m_K.col1.y = g * this.m_s1 + _ * this.m_s2, this.m_K.col1.z = g * this.m_s1 * this.m_a1 + _ * this.m_s2 * this.m_a2, this.m_K.col2.x = this.m_K.col1.y, this.m_K.col2.y = g + _, this.m_K.col2.z = g * this.m_a1 + _ * this.m_a2, this.m_K.col3.x = this.m_K.col1.z, this.m_K.col3.y = this.m_K.col2.z, this.m_K.col3.z = y + f + g * this.m_a1 * this.m_a1 + _ * this.m_a2 * this.m_a2, this.m_enableLimit) {
                var v = this.m_axis.x * u + this.m_axis.y * m;
                s.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * t.b2_linearSlop ? this.m_limitState = d.e_equalLimits : v <= this.m_lowerTranslation ? this.m_limitState != d.e_atLowerLimit && (this.m_limitState = d.e_atLowerLimit, this.m_impulse.z = 0) : v >= this.m_upperTranslation ? this.m_limitState != d.e_atUpperLimit && (this.m_limitState = d.e_atUpperLimit, this.m_impulse.z = 0) : (this.m_limitState = d.e_inactiveLimit, this.m_impulse.z = 0)
            } else this.m_limitState = d.e_inactiveLimit;
            if (0 == this.m_enableMotor && (this.m_motorImpulse = 0), e.warmStarting) {
                this.m_impulse.x *= e.dtRatio, this.m_impulse.y *= e.dtRatio, this.m_motorImpulse *= e.dtRatio;
                var b = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x,
                    x = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y,
                    C = this.m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1,
                    S = this.m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;
                o.m_linearVelocity.x -= this.m_invMassA * b, o.m_linearVelocity.y -= this.m_invMassA * x, o.m_angularVelocity -= this.m_invIA * C, n.m_linearVelocity.x += this.m_invMassB * b, n.m_linearVelocity.y += this.m_invMassB * x, n.m_angularVelocity += this.m_invIB * S
            } else this.m_impulse.SetZero(), this.m_motorImpulse = 0
        }, b.prototype.SolveVelocityConstraints = function(t) {
            var e = this.m_bodyA,
                i = this.m_bodyB,
                a = e.m_linearVelocity,
                r = e.m_angularVelocity,
                h = i.m_linearVelocity,
                l = i.m_angularVelocity,
                c = 0,
                p = 0,
                u = 0,
                m = 0;
            if (this.m_enableMotor && this.m_limitState != d.e_equalLimits) {
                var y = this.m_axis.x * (h.x - a.x) + this.m_axis.y * (h.y - a.y) + this.m_a2 * l - this.m_a1 * r,
                    f = this.m_motorMass * (this.m_motorSpeed - y),
                    g = this.m_motorImpulse,
                    _ = t.dt * this.m_maxMotorForce;
                this.m_motorImpulse = s.Clamp(this.m_motorImpulse + f, -_, _), c = (f = this.m_motorImpulse - g) * this.m_axis.x, p = f * this.m_axis.y, u = f * this.m_a1, m = f * this.m_a2, a.x -= this.m_invMassA * c, a.y -= this.m_invMassA * p, r -= this.m_invIA * u, h.x += this.m_invMassB * c, h.y += this.m_invMassB * p, l += this.m_invIB * m
            }
            var v = this.m_perp.x * (h.x - a.x) + this.m_perp.y * (h.y - a.y) + this.m_s2 * l - this.m_s1 * r,
                b = l - r;
            if (this.m_enableLimit && this.m_limitState != d.e_inactiveLimit) {
                var x = this.m_axis.x * (h.x - a.x) + this.m_axis.y * (h.y - a.y) + this.m_a2 * l - this.m_a1 * r,
                    C = this.m_impulse.Copy(),
                    S = this.m_K.Solve33(new n, -v, -b, -x);
                this.m_impulse.Add(S), this.m_limitState == d.e_atLowerLimit ? this.m_impulse.z = s.Max(this.m_impulse.z, 0) : this.m_limitState == d.e_atUpperLimit && (this.m_impulse.z = s.Min(this.m_impulse.z, 0));
                var w = -v - (this.m_impulse.z - C.z) * this.m_K.col3.x,
                    A = -b - (this.m_impulse.z - C.z) * this.m_K.col3.y,
                    T = this.m_K.Solve22(new o, w, A);
                T.x += C.x, T.y += C.y, this.m_impulse.x = T.x, this.m_impulse.y = T.y, S.x = this.m_impulse.x - C.x, S.y = this.m_impulse.y - C.y, S.z = this.m_impulse.z - C.z, c = S.x * this.m_perp.x + S.z * this.m_axis.x, p = S.x * this.m_perp.y + S.z * this.m_axis.y, u = S.x * this.m_s1 + S.y + S.z * this.m_a1, m = S.x * this.m_s2 + S.y + S.z * this.m_a2, a.x -= this.m_invMassA * c, a.y -= this.m_invMassA * p, r -= this.m_invIA * u, h.x += this.m_invMassB * c, h.y += this.m_invMassB * p, l += this.m_invIB * m
            } else {
                var B = this.m_K.Solve22(new o, -v, -b);
                this.m_impulse.x += B.x, this.m_impulse.y += B.y, c = B.x * this.m_perp.x, p = B.x * this.m_perp.y, u = B.x * this.m_s1 + B.y, m = B.x * this.m_s2 + B.y, a.x -= this.m_invMassA * c, a.y -= this.m_invMassA * p, r -= this.m_invIA * u, h.x += this.m_invMassB * c, h.y += this.m_invMassB * p, l += this.m_invIB * m
            }
            e.m_linearVelocity.SetV(a), e.m_angularVelocity = r, i.m_linearVelocity.SetV(h), i.m_angularVelocity = l
        }, b.prototype.SolvePositionConstraints = function(i) {
            void 0 === i && (i = 0);
            var a, r = this.m_bodyA,
                h = this.m_bodyB,
                l = r.m_sweep.c,
                c = r.m_sweep.a,
                p = h.m_sweep.c,
                u = h.m_sweep.a,
                d = 0,
                m = 0,
                y = 0,
                f = 0,
                g = 0,
                _ = 0,
                v = 0,
                b = !1,
                x = 0,
                C = e.FromAngle(c),
                S = e.FromAngle(u);
            a = C;
            var w = this.m_localAnchor1.x - this.m_localCenterA.x,
                A = this.m_localAnchor1.y - this.m_localCenterA.y;
            d = a.col1.x * w + a.col2.x * A, A = a.col1.y * w + a.col2.y * A, w = d, a = S;
            var T = this.m_localAnchor2.x - this.m_localCenterB.x,
                B = this.m_localAnchor2.y - this.m_localCenterB.y;
            d = a.col1.x * T + a.col2.x * B, B = a.col1.y * T + a.col2.y * B, T = d;
            var P = p.x + T - l.x - w,
                D = p.y + B - l.y - A;
            if (this.m_enableLimit) {
                this.m_axis = s.MulMV(C, this.m_localXAxis1), this.m_a1 = (P + w) * this.m_axis.y - (D + A) * this.m_axis.x, this.m_a2 = T * this.m_axis.y - B * this.m_axis.x;
                var I = this.m_axis.x * P + this.m_axis.y * D;
                s.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * t.b2_linearSlop ? (x = s.Clamp(I, -t.b2_maxLinearCorrection, t.b2_maxLinearCorrection), _ = s.Abs(I), b = !0) : I <= this.m_lowerTranslation ? (x = s.Clamp(I - this.m_lowerTranslation + t.b2_linearSlop, -t.b2_maxLinearCorrection, 0), _ = this.m_lowerTranslation - I, b = !0) : I >= this.m_upperTranslation && (x = s.Clamp(I - this.m_upperTranslation + t.b2_linearSlop, 0, t.b2_maxLinearCorrection), _ = I - this.m_upperTranslation, b = !0)
            }
            this.m_perp = s.MulMV(C, this.m_localYAxis1), this.m_s1 = (P + w) * this.m_perp.y - (D + A) * this.m_perp.x, this.m_s2 = T * this.m_perp.y - B * this.m_perp.x;
            var E = new n,
                L = this.m_perp.x * P + this.m_perp.y * D,
                M = u - c - this.m_refAngle;
            if (_ = s.Max(_, s.Abs(L)), v = s.Abs(M), b) m = this.m_invMassA, y = this.m_invMassB, f = this.m_invIA, g = this.m_invIB, this.m_K.col1.x = m + y + f * this.m_s1 * this.m_s1 + g * this.m_s2 * this.m_s2, this.m_K.col1.y = f * this.m_s1 + g * this.m_s2, this.m_K.col1.z = f * this.m_s1 * this.m_a1 + g * this.m_s2 * this.m_a2, this.m_K.col2.x = this.m_K.col1.y, this.m_K.col2.y = f + g, this.m_K.col2.z = f * this.m_a1 + g * this.m_a2, this.m_K.col3.x = this.m_K.col1.z, this.m_K.col3.y = this.m_K.col2.z, this.m_K.col3.z = m + y + f * this.m_a1 * this.m_a1 + g * this.m_a2 * this.m_a2, this.m_K.Solve33(E, -L, -M, -x);
            else {
                m = this.m_invMassA, y = this.m_invMassB, f = this.m_invIA, g = this.m_invIB;
                var G = m + y + f * this.m_s1 * this.m_s1 + g * this.m_s2 * this.m_s2,
                    O = f * this.m_s1 + g * this.m_s2,
                    R = f + g;
                this.m_K.col1.Set(G, O, 0), this.m_K.col2.Set(O, R, 0);
                var k = this.m_K.Solve22(new o, -L, -M);
                E.x = k.x, E.y = k.y, E.z = 0
            }
            var F = E.x * this.m_perp.x + E.z * this.m_axis.x,
                N = E.x * this.m_perp.y + E.z * this.m_axis.y,
                V = E.x * this.m_s1 + E.y + E.z * this.m_a1,
                U = E.x * this.m_s2 + E.y + E.z * this.m_a2;
            return l.x -= this.m_invMassA * F, l.y -= this.m_invMassA * N, c -= this.m_invIA * V, p.x += this.m_invMassB * F, p.y += this.m_invMassB * N, u += this.m_invIB * U, r.m_sweep.a = c, h.m_sweep.a = u, r.SynchronizeTransform(), h.SynchronizeTransform(), _ <= t.b2_linearSlop && v <= t.b2_angularSlop
        }, Box2D.inherit(x, Box2D.Dynamics.Joints.b2JointDef), x.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype, x.b2PrismaticJointDef = function() {
            Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.localAnchorA = new o, this.localAnchorB = new o, this.localAxisA = new o
        }, x.prototype.b2PrismaticJointDef = function() {
            this.__super.b2JointDef.call(this), this.type = d.e_prismaticJoint, this.localAxisA.Set(1, 0), this.referenceAngle = 0, this.enableLimit = !1, this.lowerTranslation = 0, this.upperTranslation = 0, this.enableMotor = !1, this.maxMotorForce = 0, this.motorSpeed = 0
        }, x.prototype.Initialize = function(t, e, i, s) {
            this.bodyA = t, this.bodyB = e, this.localAnchorA = this.bodyA.GetLocalPoint(i), this.localAnchorB = this.bodyB.GetLocalPoint(i), this.localAxisA = this.bodyA.GetLocalVector(s), this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle()
        }, Box2D.inherit(C, Box2D.Dynamics.Joints.b2Joint), C.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype, C.b2PulleyJoint = function() {
            Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.m_groundAnchor1 = new o, this.m_groundAnchor2 = new o, this.m_localAnchor1 = new o, this.m_localAnchor2 = new o, this.m_u1 = new o, this.m_u2 = new o
        }, C.prototype.GetAnchorA = function() {
            return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
        }, C.prototype.GetAnchorB = function() {
            return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
        }, C.prototype.GetReactionForce = function(t) {
            return void 0 === t && (t = 0), new o(t * this.m_impulse * this.m_u2.x, t * this.m_impulse * this.m_u2.y)
        }, C.prototype.GetReactionTorque = function(t) {
            return void 0 === t && (t = 0), 0
        }, C.prototype.GetGroundAnchorA = function() {
            var t = this.m_ground.m_xf.position.Copy();
            return t.Add(this.m_groundAnchor1), t
        }, C.prototype.GetGroundAnchorB = function() {
            var t = this.m_ground.m_xf.position.Copy();
            return t.Add(this.m_groundAnchor2), t
        }, C.prototype.GetLength1 = function() {
            var t = this.m_bodyA.GetWorldPoint(this.m_localAnchor1),
                e = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x,
                i = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y,
                s = t.x - e,
                o = t.y - i;
            return Math.sqrt(s * s + o * o)
        }, C.prototype.GetLength2 = function() {
            var t = this.m_bodyB.GetWorldPoint(this.m_localAnchor2),
                e = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x,
                i = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y,
                s = t.x - e,
                o = t.y - i;
            return Math.sqrt(s * s + o * o)
        }, C.prototype.GetRatio = function() {
            return this.m_ratio
        }, C.prototype.b2PulleyJoint = function(t) {
            this.__super.b2Joint.call(this, t);
            this.m_ground = this.m_bodyA.m_world.m_groundBody, this.m_groundAnchor1.x = t.groundAnchorA.x - this.m_ground.m_xf.position.x, this.m_groundAnchor1.y = t.groundAnchorA.y - this.m_ground.m_xf.position.y, this.m_groundAnchor2.x = t.groundAnchorB.x - this.m_ground.m_xf.position.x, this.m_groundAnchor2.y = t.groundAnchorB.y - this.m_ground.m_xf.position.y, this.m_localAnchor1.SetV(t.localAnchorA), this.m_localAnchor2.SetV(t.localAnchorB), this.m_ratio = t.ratio, this.m_constant = t.lengthA + this.m_ratio * t.lengthB, this.m_maxLength1 = s.Min(t.maxLengthA, this.m_constant - this.m_ratio * C.b2_minPulleyLength), this.m_maxLength2 = s.Min(t.maxLengthB, (this.m_constant - C.b2_minPulleyLength) / this.m_ratio), this.m_impulse = 0, this.m_limitImpulse1 = 0, this.m_limitImpulse2 = 0
        }, C.prototype.InitVelocityConstraints = function(e) {
            var i, s = this.m_bodyA,
                o = this.m_bodyB;
            i = s.m_xf.R;
            var n = this.m_localAnchor1.x - s.m_sweep.localCenter.x,
                a = this.m_localAnchor1.y - s.m_sweep.localCenter.y,
                r = i.col1.x * n + i.col2.x * a;
            a = i.col1.y * n + i.col2.y * a, n = r, i = o.m_xf.R;
            var h = this.m_localAnchor2.x - o.m_sweep.localCenter.x,
                l = this.m_localAnchor2.y - o.m_sweep.localCenter.y;
            r = i.col1.x * h + i.col2.x * l, l = i.col1.y * h + i.col2.y * l, h = r;
            var c = s.m_sweep.c.x + n,
                p = s.m_sweep.c.y + a,
                u = o.m_sweep.c.x + h,
                m = o.m_sweep.c.y + l,
                y = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x,
                f = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y,
                g = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x,
                _ = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
            this.m_u1.Set(c - y, p - f), this.m_u2.Set(u - g, m - _);
            var v = this.m_u1.Length(),
                b = this.m_u2.Length();
            v > t.b2_linearSlop ? this.m_u1.Multiply(1 / v) : this.m_u1.SetZero(), b > t.b2_linearSlop ? this.m_u2.Multiply(1 / b) : this.m_u2.SetZero(), this.m_constant - v - this.m_ratio * b > 0 ? (this.m_state = d.e_inactiveLimit, this.m_impulse = 0) : this.m_state = d.e_atUpperLimit, v < this.m_maxLength1 ? (this.m_limitState1 = d.e_inactiveLimit, this.m_limitImpulse1 = 0) : this.m_limitState1 = d.e_atUpperLimit, b < this.m_maxLength2 ? (this.m_limitState2 = d.e_inactiveLimit, this.m_limitImpulse2 = 0) : this.m_limitState2 = d.e_atUpperLimit;
            var x = n * this.m_u1.y - a * this.m_u1.x,
                C = h * this.m_u2.y - l * this.m_u2.x;
            if (this.m_limitMass1 = s.m_invMass + s.m_invI * x * x, this.m_limitMass2 = o.m_invMass + o.m_invI * C * C, this.m_pulleyMass = this.m_limitMass1 + this.m_ratio * this.m_ratio * this.m_limitMass2, this.m_limitMass1 = 1 / this.m_limitMass1, this.m_limitMass2 = 1 / this.m_limitMass2, this.m_pulleyMass = 1 / this.m_pulleyMass, e.warmStarting) {
                this.m_impulse *= e.dtRatio, this.m_limitImpulse1 *= e.dtRatio, this.m_limitImpulse2 *= e.dtRatio;
                var S = (-this.m_impulse - this.m_limitImpulse1) * this.m_u1.x,
                    w = (-this.m_impulse - this.m_limitImpulse1) * this.m_u1.y,
                    A = (-this.m_ratio * this.m_impulse - this.m_limitImpulse2) * this.m_u2.x,
                    T = (-this.m_ratio * this.m_impulse - this.m_limitImpulse2) * this.m_u2.y;
                s.m_linearVelocity.x += s.m_invMass * S, s.m_linearVelocity.y += s.m_invMass * w, s.m_angularVelocity += s.m_invI * (n * w - a * S), o.m_linearVelocity.x += o.m_invMass * A, o.m_linearVelocity.y += o.m_invMass * T, o.m_angularVelocity += o.m_invI * (h * T - l * A)
            } else this.m_impulse = 0, this.m_limitImpulse1 = 0, this.m_limitImpulse2 = 0
        }, C.prototype.SolveVelocityConstraints = function(t) {
            var e, i = this.m_bodyA,
                o = this.m_bodyB;
            e = i.m_xf.R;
            var n = this.m_localAnchor1.x - i.m_sweep.localCenter.x,
                a = this.m_localAnchor1.y - i.m_sweep.localCenter.y,
                r = e.col1.x * n + e.col2.x * a;
            a = e.col1.y * n + e.col2.y * a, n = r, e = o.m_xf.R;
            var h = this.m_localAnchor2.x - o.m_sweep.localCenter.x,
                l = this.m_localAnchor2.y - o.m_sweep.localCenter.y;
            r = e.col1.x * h + e.col2.x * l, l = e.col1.y * h + e.col2.y * l, h = r;
            var c = 0,
                p = 0,
                u = 0,
                m = 0,
                y = 0,
                f = 0,
                g = 0,
                _ = 0,
                v = 0,
                b = 0,
                x = 0;
            this.m_state == d.e_atUpperLimit && (c = i.m_linearVelocity.x + -i.m_angularVelocity * a, p = i.m_linearVelocity.y + i.m_angularVelocity * n, u = o.m_linearVelocity.x + -o.m_angularVelocity * l, m = o.m_linearVelocity.y + o.m_angularVelocity * h, v = -(this.m_u1.x * c + this.m_u1.y * p) - this.m_ratio * (this.m_u2.x * u + this.m_u2.y * m), b = this.m_pulleyMass * -v, x = this.m_impulse, this.m_impulse = s.Max(0, this.m_impulse + b), y = -(b = this.m_impulse - x) * this.m_u1.x, f = -b * this.m_u1.y, g = -this.m_ratio * b * this.m_u2.x, _ = -this.m_ratio * b * this.m_u2.y, i.m_linearVelocity.x += i.m_invMass * y, i.m_linearVelocity.y += i.m_invMass * f, i.m_angularVelocity += i.m_invI * (n * f - a * y), o.m_linearVelocity.x += o.m_invMass * g, o.m_linearVelocity.y += o.m_invMass * _, o.m_angularVelocity += o.m_invI * (h * _ - l * g)), this.m_limitState1 == d.e_atUpperLimit && (c = i.m_linearVelocity.x + -i.m_angularVelocity * a, p = i.m_linearVelocity.y + i.m_angularVelocity * n, v = -(this.m_u1.x * c + this.m_u1.y * p), b = -this.m_limitMass1 * v, x = this.m_limitImpulse1, this.m_limitImpulse1 = s.Max(0, this.m_limitImpulse1 + b), y = -(b = this.m_limitImpulse1 - x) * this.m_u1.x, f = -b * this.m_u1.y, i.m_linearVelocity.x += i.m_invMass * y, i.m_linearVelocity.y += i.m_invMass * f, i.m_angularVelocity += i.m_invI * (n * f - a * y)), this.m_limitState2 == d.e_atUpperLimit && (u = o.m_linearVelocity.x + -o.m_angularVelocity * l, m = o.m_linearVelocity.y + o.m_angularVelocity * h, v = -(this.m_u2.x * u + this.m_u2.y * m), b = -this.m_limitMass2 * v, x = this.m_limitImpulse2, this.m_limitImpulse2 = s.Max(0, this.m_limitImpulse2 + b), g = -(b = this.m_limitImpulse2 - x) * this.m_u2.x, _ = -b * this.m_u2.y, o.m_linearVelocity.x += o.m_invMass * g, o.m_linearVelocity.y += o.m_invMass * _, o.m_angularVelocity += o.m_invI * (h * _ - l * g))
        }, C.prototype.SolvePositionConstraints = function(e) {
            void 0 === e && (e = 0);
            var i, o = this.m_bodyA,
                n = this.m_bodyB,
                a = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x,
                r = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y,
                h = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x,
                l = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y,
                c = 0,
                p = 0,
                u = 0,
                m = 0,
                y = 0,
                f = 0,
                g = 0,
                _ = 0,
                v = 0,
                b = 0,
                x = 0,
                C = 0,
                S = 0,
                w = 0;
            return this.m_state == d.e_atUpperLimit && (i = o.m_xf.R, c = this.m_localAnchor1.x - o.m_sweep.localCenter.x, p = this.m_localAnchor1.y - o.m_sweep.localCenter.y, S = i.col1.x * c + i.col2.x * p, p = i.col1.y * c + i.col2.y * p, c = S, i = n.m_xf.R, u = this.m_localAnchor2.x - n.m_sweep.localCenter.x, m = this.m_localAnchor2.y - n.m_sweep.localCenter.y, S = i.col1.x * u + i.col2.x * m, m = i.col1.y * u + i.col2.y * m, u = S, y = o.m_sweep.c.x + c, f = o.m_sweep.c.y + p, g = n.m_sweep.c.x + u, _ = n.m_sweep.c.y + m, this.m_u1.Set(y - a, f - r), this.m_u2.Set(g - h, _ - l), v = this.m_u1.Length(), b = this.m_u2.Length(), v > t.b2_linearSlop ? this.m_u1.Multiply(1 / v) : this.m_u1.SetZero(), b > t.b2_linearSlop ? this.m_u2.Multiply(1 / b) : this.m_u2.SetZero(), x = this.m_constant - v - this.m_ratio * b, w = s.Max(w, -x), x = s.Clamp(x + t.b2_linearSlop, -t.b2_maxLinearCorrection, 0), y = -(C = -this.m_pulleyMass * x) * this.m_u1.x, f = -C * this.m_u1.y, g = -this.m_ratio * C * this.m_u2.x, _ = -this.m_ratio * C * this.m_u2.y, o.m_sweep.c.x += o.m_invMass * y, o.m_sweep.c.y += o.m_invMass * f, o.m_sweep.a += o.m_invI * (c * f - p * y), n.m_sweep.c.x += n.m_invMass * g, n.m_sweep.c.y += n.m_invMass * _, n.m_sweep.a += n.m_invI * (u * _ - m * g), o.SynchronizeTransform(), n.SynchronizeTransform()), this.m_limitState1 == d.e_atUpperLimit && (i = o.m_xf.R, c = this.m_localAnchor1.x - o.m_sweep.localCenter.x, p = this.m_localAnchor1.y - o.m_sweep.localCenter.y, S = i.col1.x * c + i.col2.x * p, p = i.col1.y * c + i.col2.y * p, c = S, y = o.m_sweep.c.x + c, f = o.m_sweep.c.y + p, this.m_u1.Set(y - a, f - r), (v = this.m_u1.Length()) > t.b2_linearSlop ? (this.m_u1.x *= 1 / v, this.m_u1.y *= 1 / v) : this.m_u1.SetZero(), x = this.m_maxLength1 - v, w = s.Max(w, -x), x = s.Clamp(x + t.b2_linearSlop, -t.b2_maxLinearCorrection, 0), y = -(C = -this.m_limitMass1 * x) * this.m_u1.x, f = -C * this.m_u1.y, o.m_sweep.c.x += o.m_invMass * y, o.m_sweep.c.y += o.m_invMass * f, o.m_sweep.a += o.m_invI * (c * f - p * y), o.SynchronizeTransform()), this.m_limitState2 == d.e_atUpperLimit && (i = n.m_xf.R, u = this.m_localAnchor2.x - n.m_sweep.localCenter.x, m = this.m_localAnchor2.y - n.m_sweep.localCenter.y, S = i.col1.x * u + i.col2.x * m, m = i.col1.y * u + i.col2.y * m, u = S, g = n.m_sweep.c.x + u, _ = n.m_sweep.c.y + m, this.m_u2.Set(g - h, _ - l), (b = this.m_u2.Length()) > t.b2_linearSlop ? (this.m_u2.x *= 1 / b, this.m_u2.y *= 1 / b) : this.m_u2.SetZero(), x = this.m_maxLength2 - b, w = s.Max(w, -x), x = s.Clamp(x + t.b2_linearSlop, -t.b2_maxLinearCorrection, 0), g = -(C = -this.m_limitMass2 * x) * this.m_u2.x, _ = -C * this.m_u2.y, n.m_sweep.c.x += n.m_invMass * g, n.m_sweep.c.y += n.m_invMass * _, n.m_sweep.a += n.m_invI * (u * _ - m * g), n.SynchronizeTransform()), w < t.b2_linearSlop
        }, Box2D.postDefs.push(function() {
            Box2D.Dynamics.Joints.b2PulleyJoint.b2_minPulleyLength = 2
        }), Box2D.inherit(S, Box2D.Dynamics.Joints.b2JointDef), S.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype, S.b2PulleyJointDef = function() {
            Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.groundAnchorA = new o, this.groundAnchorB = new o, this.localAnchorA = new o, this.localAnchorB = new o
        }, S.prototype.b2PulleyJointDef = function() {
            this.__super.b2JointDef.call(this), this.type = d.e_pulleyJoint, this.groundAnchorA.Set(-1, 1), this.groundAnchorB.Set(1, 1), this.localAnchorA.Set(-1, 0), this.localAnchorB.Set(1, 0), this.lengthA = 0, this.maxLengthA = 0, this.lengthB = 0, this.maxLengthB = 0, this.ratio = 1, this.collideConnected = !0
        }, S.prototype.Initialize = function(t, e, i, s, o, n, a) {
            void 0 === a && (a = 0), this.bodyA = t, this.bodyB = e, this.groundAnchorA.SetV(i), this.groundAnchorB.SetV(s), this.localAnchorA = this.bodyA.GetLocalPoint(o), this.localAnchorB = this.bodyB.GetLocalPoint(n);
            var r = o.x - i.x,
                h = o.y - i.y;
            this.lengthA = Math.sqrt(r * r + h * h);
            var l = n.x - s.x,
                c = n.y - s.y;
            this.lengthB = Math.sqrt(l * l + c * c), this.ratio = a;
            var p = this.lengthA + this.ratio * this.lengthB;
            this.maxLengthA = p - this.ratio * C.b2_minPulleyLength, this.maxLengthB = (p - C.b2_minPulleyLength) / this.ratio
        }, Box2D.inherit(w, Box2D.Dynamics.Joints.b2Joint), w.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype, w.b2RevoluteJoint = function() {
            Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.K = new e, this.K1 = new e, this.K2 = new e, this.K3 = new e, this.impulse3 = new n, this.impulse2 = new o, this.reduced = new o, this.m_localAnchor1 = new o, this.m_localAnchor2 = new o, this.m_impulse = new n, this.m_mass = new i
        }, w.prototype.GetAnchorA = function() {
            return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
        }, w.prototype.GetAnchorB = function() {
            return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
        }, w.prototype.GetReactionForce = function(t) {
            return void 0 === t && (t = 0), new o(t * this.m_impulse.x, t * this.m_impulse.y)
        }, w.prototype.GetReactionTorque = function(t) {
            return void 0 === t && (t = 0), t * this.m_impulse.z
        }, w.prototype.GetJointAngle = function() {
            return this.m_bodyB.m_sweep.a - this.m_bodyA.m_sweep.a - this.m_referenceAngle
        }, w.prototype.GetJointSpeed = function() {
            return this.m_bodyB.m_angularVelocity - this.m_bodyA.m_angularVelocity
        }, w.prototype.IsLimitEnabled = function() {
            return this.m_enableLimit
        }, w.prototype.EnableLimit = function(t) {
            this.m_enableLimit = t
        }, w.prototype.GetLowerLimit = function() {
            return this.m_lowerAngle
        }, w.prototype.GetUpperLimit = function() {
            return this.m_upperAngle
        }, w.prototype.SetLimits = function(t, e) {
            void 0 === t && (t = 0), void 0 === e && (e = 0), this.m_lowerAngle = t, this.m_upperAngle = e
        }, w.prototype.IsMotorEnabled = function() {
            return this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableMotor
        }, w.prototype.EnableMotor = function(t) {
            this.m_enableMotor = t
        }, w.prototype.SetMotorSpeed = function(t) {
            void 0 === t && (t = 0), this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_motorSpeed = t
        }, w.prototype.GetMotorSpeed = function() {
            return this.m_motorSpeed
        }, w.prototype.SetMaxMotorTorque = function(t) {
            void 0 === t && (t = 0), this.m_maxMotorTorque = t
        }, w.prototype.GetMotorTorque = function() {
            return this.m_maxMotorTorque
        }, w.prototype.b2RevoluteJoint = function(t) {
            this.__super.b2Joint.call(this, t), this.m_localAnchor1.SetV(t.localAnchorA), this.m_localAnchor2.SetV(t.localAnchorB), this.m_referenceAngle = t.referenceAngle, this.m_impulse.SetZero(), this.m_motorImpulse = 0, this.m_lowerAngle = t.lowerAngle, this.m_upperAngle = t.upperAngle, this.m_maxMotorTorque = t.maxMotorTorque, this.m_motorSpeed = t.motorSpeed, this.m_enableLimit = t.enableLimit, this.m_enableMotor = t.enableMotor, this.m_limitState = d.e_inactiveLimit
        }, w.prototype.InitVelocityConstraints = function(e) {
            var i, o = this.m_bodyA,
                n = this.m_bodyB,
                a = 0;
            this.m_enableMotor || this.m_enableLimit, i = o.m_xf.R;
            var r = this.m_localAnchor1.x - o.m_sweep.localCenter.x,
                h = this.m_localAnchor1.y - o.m_sweep.localCenter.y;
            a = i.col1.x * r + i.col2.x * h, h = i.col1.y * r + i.col2.y * h, r = a, i = n.m_xf.R;
            var l = this.m_localAnchor2.x - n.m_sweep.localCenter.x,
                c = this.m_localAnchor2.y - n.m_sweep.localCenter.y;
            a = i.col1.x * l + i.col2.x * c, c = i.col1.y * l + i.col2.y * c, l = a;
            var p = o.m_invMass,
                u = n.m_invMass,
                m = o.m_invI,
                y = n.m_invI;
            if (this.m_mass.col1.x = p + u + h * h * m + c * c * y, this.m_mass.col2.x = -h * r * m - c * l * y, this.m_mass.col3.x = -h * m - c * y, this.m_mass.col1.y = this.m_mass.col2.x, this.m_mass.col2.y = p + u + r * r * m + l * l * y, this.m_mass.col3.y = r * m + l * y, this.m_mass.col1.z = this.m_mass.col3.x, this.m_mass.col2.z = this.m_mass.col3.y, this.m_mass.col3.z = m + y, this.m_motorMass = 1 / (m + y), 0 == this.m_enableMotor && (this.m_motorImpulse = 0), this.m_enableLimit) {
                var f = n.m_sweep.a - o.m_sweep.a - this.m_referenceAngle;
                s.Abs(this.m_upperAngle - this.m_lowerAngle) < 2 * t.b2_angularSlop ? this.m_limitState = d.e_equalLimits : f <= this.m_lowerAngle ? (this.m_limitState != d.e_atLowerLimit && (this.m_impulse.z = 0), this.m_limitState = d.e_atLowerLimit) : f >= this.m_upperAngle ? (this.m_limitState != d.e_atUpperLimit && (this.m_impulse.z = 0), this.m_limitState = d.e_atUpperLimit) : (this.m_limitState = d.e_inactiveLimit, this.m_impulse.z = 0)
            } else this.m_limitState = d.e_inactiveLimit;
            if (e.warmStarting) {
                this.m_impulse.x *= e.dtRatio, this.m_impulse.y *= e.dtRatio, this.m_motorImpulse *= e.dtRatio;
                var g = this.m_impulse.x,
                    _ = this.m_impulse.y;
                o.m_linearVelocity.x -= p * g, o.m_linearVelocity.y -= p * _, o.m_angularVelocity -= m * (r * _ - h * g + this.m_motorImpulse + this.m_impulse.z), n.m_linearVelocity.x += u * g, n.m_linearVelocity.y += u * _, n.m_angularVelocity += y * (l * _ - c * g + this.m_motorImpulse + this.m_impulse.z)
            } else this.m_impulse.SetZero(), this.m_motorImpulse = 0
        }, w.prototype.SolveVelocityConstraints = function(t) {
            var e, i = this.m_bodyA,
                o = this.m_bodyB,
                n = 0,
                a = 0,
                r = 0,
                h = 0,
                l = 0,
                c = i.m_linearVelocity,
                p = i.m_angularVelocity,
                u = o.m_linearVelocity,
                m = o.m_angularVelocity,
                y = i.m_invMass,
                f = o.m_invMass,
                g = i.m_invI,
                _ = o.m_invI;
            if (this.m_enableMotor && this.m_limitState != d.e_equalLimits) {
                var v = m - p - this.m_motorSpeed,
                    b = this.m_motorMass * -v,
                    x = this.m_motorImpulse,
                    C = t.dt * this.m_maxMotorTorque;
                this.m_motorImpulse = s.Clamp(this.m_motorImpulse + b, -C, C), p -= g * (b = this.m_motorImpulse - x), m += _ * b
            }
            if (this.m_enableLimit && this.m_limitState != d.e_inactiveLimit) {
                e = i.m_xf.R, a = this.m_localAnchor1.x - i.m_sweep.localCenter.x, r = this.m_localAnchor1.y - i.m_sweep.localCenter.y, n = e.col1.x * a + e.col2.x * r, r = e.col1.y * a + e.col2.y * r, a = n, e = o.m_xf.R, h = this.m_localAnchor2.x - o.m_sweep.localCenter.x, l = this.m_localAnchor2.y - o.m_sweep.localCenter.y, n = e.col1.x * h + e.col2.x * l, l = e.col1.y * h + e.col2.y * l, h = n;
                var S = u.x + -m * l - c.x - -p * r,
                    w = u.y + m * h - c.y - p * a,
                    A = m - p;
                this.m_mass.Solve33(this.impulse3, -S, -w, -A), this.m_limitState == d.e_equalLimits ? this.m_impulse.Add(this.impulse3) : this.m_limitState == d.e_atLowerLimit ? this.m_impulse.z + this.impulse3.z < 0 && (this.m_mass.Solve22(this.reduced, -S, -w), this.impulse3.x = this.reduced.x, this.impulse3.y = this.reduced.y, this.impulse3.z = -this.m_impulse.z, this.m_impulse.x += this.reduced.x, this.m_impulse.y += this.reduced.y, this.m_impulse.z = 0) : this.m_limitState == d.e_atUpperLimit && this.m_impulse.z + this.impulse3.z > 0 && (this.m_mass.Solve22(this.reduced, -S, -w), this.impulse3.x = this.reduced.x, this.impulse3.y = this.reduced.y, this.impulse3.z = -this.m_impulse.z, this.m_impulse.x += this.reduced.x, this.m_impulse.y += this.reduced.y, this.m_impulse.z = 0), c.x -= y * this.impulse3.x, c.y -= y * this.impulse3.y, p -= g * (a * this.impulse3.y - r * this.impulse3.x + this.impulse3.z), u.x += f * this.impulse3.x, u.y += f * this.impulse3.y, m += _ * (h * this.impulse3.y - l * this.impulse3.x + this.impulse3.z)
            } else {
                e = i.m_xf.R, a = this.m_localAnchor1.x - i.m_sweep.localCenter.x, r = this.m_localAnchor1.y - i.m_sweep.localCenter.y, n = e.col1.x * a + e.col2.x * r, r = e.col1.y * a + e.col2.y * r, a = n, e = o.m_xf.R, h = this.m_localAnchor2.x - o.m_sweep.localCenter.x, l = this.m_localAnchor2.y - o.m_sweep.localCenter.y, n = e.col1.x * h + e.col2.x * l, l = e.col1.y * h + e.col2.y * l, h = n;
                var T = u.x + -m * l - c.x - -p * r,
                    B = u.y + m * h - c.y - p * a;
                this.m_mass.Solve22(this.impulse2, -T, -B), this.m_impulse.x += this.impulse2.x, this.m_impulse.y += this.impulse2.y, c.x -= y * this.impulse2.x, c.y -= y * this.impulse2.y, p -= g * (a * this.impulse2.y - r * this.impulse2.x), u.x += f * this.impulse2.x, u.y += f * this.impulse2.y, m += _ * (h * this.impulse2.y - l * this.impulse2.x)
            }
            i.m_linearVelocity.SetV(c), i.m_angularVelocity = p, o.m_linearVelocity.SetV(u), o.m_angularVelocity = m
        }, w.prototype.SolvePositionConstraints = function(e) {
            void 0 === e && (e = 0);
            var i, o = 0,
                n = this.m_bodyA,
                a = this.m_bodyB,
                r = 0,
                h = 0,
                l = 0,
                c = 0,
                p = 0;
            if (this.m_enableLimit && this.m_limitState != d.e_inactiveLimit) {
                var u = a.m_sweep.a - n.m_sweep.a - this.m_referenceAngle,
                    m = 0;
                this.m_limitState == d.e_equalLimits ? (o = s.Clamp(u - this.m_lowerAngle, -t.b2_maxAngularCorrection, t.b2_maxAngularCorrection), m = -this.m_motorMass * o, r = s.Abs(o)) : this.m_limitState == d.e_atLowerLimit ? (r = -(o = u - this.m_lowerAngle), o = s.Clamp(o + t.b2_angularSlop, -t.b2_maxAngularCorrection, 0), m = -this.m_motorMass * o) : this.m_limitState == d.e_atUpperLimit && (r = o = u - this.m_upperAngle, o = s.Clamp(o - t.b2_angularSlop, 0, t.b2_maxAngularCorrection), m = -this.m_motorMass * o), n.m_sweep.a -= n.m_invI * m, a.m_sweep.a += a.m_invI * m, n.SynchronizeTransform(), a.SynchronizeTransform()
            }
            i = n.m_xf.R;
            var y = this.m_localAnchor1.x - n.m_sweep.localCenter.x,
                f = this.m_localAnchor1.y - n.m_sweep.localCenter.y;
            l = i.col1.x * y + i.col2.x * f, f = i.col1.y * y + i.col2.y * f, y = l, i = a.m_xf.R;
            var g = this.m_localAnchor2.x - a.m_sweep.localCenter.x,
                _ = this.m_localAnchor2.y - a.m_sweep.localCenter.y;
            l = i.col1.x * g + i.col2.x * _, _ = i.col1.y * g + i.col2.y * _, g = l;
            var v = a.m_sweep.c.x + g - n.m_sweep.c.x - y,
                b = a.m_sweep.c.y + _ - n.m_sweep.c.y - f,
                x = v * v + b * b,
                C = Math.sqrt(x);
            h = C;
            var S = n.m_invMass,
                A = a.m_invMass,
                T = n.m_invI,
                B = a.m_invI,
                P = 10 * t.b2_linearSlop;
            if (x > P * P) {
                var D = 1 / (S + A);
                c = D * -v, p = D * -b;
                n.m_sweep.c.x -= .5 * S * c, n.m_sweep.c.y -= .5 * S * p, a.m_sweep.c.x += .5 * A * c, a.m_sweep.c.y += .5 * A * p, v = a.m_sweep.c.x + g - n.m_sweep.c.x - y, b = a.m_sweep.c.y + _ - n.m_sweep.c.y - f
            }
            return this.K1.col1.x = S + A, this.K1.col2.x = 0, this.K1.col1.y = 0, this.K1.col2.y = S + A, this.K2.col1.x = T * f * f, this.K2.col2.x = -T * y * f, this.K2.col1.y = -T * y * f, this.K2.col2.y = T * y * y, this.K3.col1.x = B * _ * _, this.K3.col2.x = -B * g * _, this.K3.col1.y = -B * g * _, this.K3.col2.y = B * g * g, this.K.SetM(this.K1), this.K.AddM(this.K2), this.K.AddM(this.K3), this.K.Solve(w.tImpulse, -v, -b), c = w.tImpulse.x, p = w.tImpulse.y, n.m_sweep.c.x -= n.m_invMass * c, n.m_sweep.c.y -= n.m_invMass * p, n.m_sweep.a -= n.m_invI * (y * p - f * c), a.m_sweep.c.x += a.m_invMass * c, a.m_sweep.c.y += a.m_invMass * p, a.m_sweep.a += a.m_invI * (g * p - _ * c), n.SynchronizeTransform(), a.SynchronizeTransform(), h <= t.b2_linearSlop && r <= t.b2_angularSlop
        }, Box2D.postDefs.push(function() {
            Box2D.Dynamics.Joints.b2RevoluteJoint.tImpulse = new o
        }), Box2D.inherit(A, Box2D.Dynamics.Joints.b2JointDef), A.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype, A.b2RevoluteJointDef = function() {
            Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.localAnchorA = new o, this.localAnchorB = new o
        }, A.prototype.b2RevoluteJointDef = function() {
            this.__super.b2JointDef.call(this), this.type = d.e_revoluteJoint, this.localAnchorA.Set(0, 0), this.localAnchorB.Set(0, 0), this.referenceAngle = 0, this.lowerAngle = 0, this.upperAngle = 0, this.maxMotorTorque = 0, this.motorSpeed = 0, this.enableLimit = !1, this.enableMotor = !1
        }, A.prototype.Initialize = function(t, e, i) {
            this.bodyA = t, this.bodyB = e, this.localAnchorA = this.bodyA.GetLocalPoint(i), this.localAnchorB = this.bodyB.GetLocalPoint(i), this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle()
        }, Box2D.inherit(T, Box2D.Dynamics.Joints.b2Joint), T.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype, T.b2WeldJoint = function() {
            Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.m_localAnchorA = new o, this.m_localAnchorB = new o, this.m_impulse = new n, this.m_mass = new i
        }, T.prototype.GetAnchorA = function() {
            return this.m_bodyA.GetWorldPoint(this.m_localAnchorA)
        }, T.prototype.GetAnchorB = function() {
            return this.m_bodyB.GetWorldPoint(this.m_localAnchorB)
        }, T.prototype.GetReactionForce = function(t) {
            return void 0 === t && (t = 0), new o(t * this.m_impulse.x, t * this.m_impulse.y)
        }, T.prototype.GetReactionTorque = function(t) {
            return void 0 === t && (t = 0), t * this.m_impulse.z
        }, T.prototype.b2WeldJoint = function(t) {
            this.__super.b2Joint.call(this, t), this.m_localAnchorA.SetV(t.localAnchorA), this.m_localAnchorB.SetV(t.localAnchorB), this.m_referenceAngle = t.referenceAngle, this.m_impulse.SetZero(), this.m_mass = new i
        }, T.prototype.InitVelocityConstraints = function(t) {
            var e, i = 0,
                s = this.m_bodyA,
                o = this.m_bodyB;
            e = s.m_xf.R;
            var n = this.m_localAnchorA.x - s.m_sweep.localCenter.x,
                a = this.m_localAnchorA.y - s.m_sweep.localCenter.y;
            i = e.col1.x * n + e.col2.x * a, a = e.col1.y * n + e.col2.y * a, n = i, e = o.m_xf.R;
            var r = this.m_localAnchorB.x - o.m_sweep.localCenter.x,
                h = this.m_localAnchorB.y - o.m_sweep.localCenter.y;
            i = e.col1.x * r + e.col2.x * h, h = e.col1.y * r + e.col2.y * h, r = i;
            var l = s.m_invMass,
                c = o.m_invMass,
                p = s.m_invI,
                u = o.m_invI;
            this.m_mass.col1.x = l + c + a * a * p + h * h * u, this.m_mass.col2.x = -a * n * p - h * r * u, this.m_mass.col3.x = -a * p - h * u, this.m_mass.col1.y = this.m_mass.col2.x, this.m_mass.col2.y = l + c + n * n * p + r * r * u, this.m_mass.col3.y = n * p + r * u, this.m_mass.col1.z = this.m_mass.col3.x, this.m_mass.col2.z = this.m_mass.col3.y, this.m_mass.col3.z = p + u, t.warmStarting ? (this.m_impulse.x *= t.dtRatio, this.m_impulse.y *= t.dtRatio, this.m_impulse.z *= t.dtRatio, s.m_linearVelocity.x -= l * this.m_impulse.x, s.m_linearVelocity.y -= l * this.m_impulse.y, s.m_angularVelocity -= p * (n * this.m_impulse.y - a * this.m_impulse.x + this.m_impulse.z), o.m_linearVelocity.x += c * this.m_impulse.x, o.m_linearVelocity.y += c * this.m_impulse.y, o.m_angularVelocity += u * (r * this.m_impulse.y - h * this.m_impulse.x + this.m_impulse.z)) : this.m_impulse.SetZero()
        }, T.prototype.SolveVelocityConstraints = function(t) {
            var e, i = 0,
                s = this.m_bodyA,
                o = this.m_bodyB,
                a = s.m_linearVelocity,
                r = s.m_angularVelocity,
                h = o.m_linearVelocity,
                l = o.m_angularVelocity,
                c = s.m_invMass,
                p = o.m_invMass,
                u = s.m_invI,
                d = o.m_invI;
            e = s.m_xf.R;
            var m = this.m_localAnchorA.x - s.m_sweep.localCenter.x,
                y = this.m_localAnchorA.y - s.m_sweep.localCenter.y;
            i = e.col1.x * m + e.col2.x * y, y = e.col1.y * m + e.col2.y * y, m = i, e = o.m_xf.R;
            var f = this.m_localAnchorB.x - o.m_sweep.localCenter.x,
                g = this.m_localAnchorB.y - o.m_sweep.localCenter.y;
            i = e.col1.x * f + e.col2.x * g, g = e.col1.y * f + e.col2.y * g, f = i;
            var _ = h.x - l * g - a.x + r * y,
                v = h.y + l * f - a.y - r * m,
                b = l - r,
                x = new n;
            this.m_mass.Solve33(x, -_, -v, -b), this.m_impulse.Add(x), a.x -= c * x.x, a.y -= c * x.y, r -= u * (m * x.y - y * x.x + x.z), h.x += p * x.x, h.y += p * x.y, l += d * (f * x.y - g * x.x + x.z), s.m_angularVelocity = r, o.m_angularVelocity = l
        }, T.prototype.SolvePositionConstraints = function(e) {
            void 0 === e && (e = 0);
            var i, o = 0,
                a = this.m_bodyA,
                r = this.m_bodyB;
            i = a.m_xf.R;
            var h = this.m_localAnchorA.x - a.m_sweep.localCenter.x,
                l = this.m_localAnchorA.y - a.m_sweep.localCenter.y;
            o = i.col1.x * h + i.col2.x * l, l = i.col1.y * h + i.col2.y * l, h = o, i = r.m_xf.R;
            var c = this.m_localAnchorB.x - r.m_sweep.localCenter.x,
                p = this.m_localAnchorB.y - r.m_sweep.localCenter.y;
            o = i.col1.x * c + i.col2.x * p, p = i.col1.y * c + i.col2.y * p, c = o;
            var u = a.m_invMass,
                d = r.m_invMass,
                m = a.m_invI,
                y = r.m_invI,
                f = r.m_sweep.c.x + c - a.m_sweep.c.x - h,
                g = r.m_sweep.c.y + p - a.m_sweep.c.y - l,
                _ = r.m_sweep.a - a.m_sweep.a - this.m_referenceAngle,
                v = 10 * t.b2_linearSlop,
                b = Math.sqrt(f * f + g * g),
                x = s.Abs(_);
            b > v && (m *= 1, y *= 1), this.m_mass.col1.x = u + d + l * l * m + p * p * y, this.m_mass.col2.x = -l * h * m - p * c * y, this.m_mass.col3.x = -l * m - p * y, this.m_mass.col1.y = this.m_mass.col2.x, this.m_mass.col2.y = u + d + h * h * m + c * c * y, this.m_mass.col3.y = h * m + c * y, this.m_mass.col1.z = this.m_mass.col3.x, this.m_mass.col2.z = this.m_mass.col3.y, this.m_mass.col3.z = m + y;
            var C = new n;
            return this.m_mass.Solve33(C, -f, -g, -_), a.m_sweep.c.x -= u * C.x, a.m_sweep.c.y -= u * C.y, a.m_sweep.a -= m * (h * C.y - l * C.x + C.z), r.m_sweep.c.x += d * C.x, r.m_sweep.c.y += d * C.y, r.m_sweep.a += y * (c * C.y - p * C.x + C.z), a.SynchronizeTransform(), r.SynchronizeTransform(), b <= t.b2_linearSlop && x <= t.b2_angularSlop
        }, Box2D.inherit(B, Box2D.Dynamics.Joints.b2JointDef), B.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype, B.b2WeldJointDef = function() {
            Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.localAnchorA = new o, this.localAnchorB = new o
        }, B.prototype.b2WeldJointDef = function() {
            this.__super.b2JointDef.call(this), this.type = d.e_weldJoint, this.referenceAngle = 0
        }, B.prototype.Initialize = function(t, e, i) {
            this.bodyA = t, this.bodyB = e, this.localAnchorA.SetV(this.bodyA.GetLocalPoint(i)), this.localAnchorB.SetV(this.bodyB.GetLocalPoint(i)), this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle()
        }
    }(),
    function() {
        var t = Box2D.Dynamics.b2DebugDraw;
        t.b2DebugDraw = function() {
            this.m_drawScale = 1, this.m_lineThickness = 1, this.m_alpha = 1, this.m_fillAlpha = 1, this.m_xformScale = 1;
            var t = this;
            this.m_sprite = {
                graphics: {
                    clear: function() {
                        t.m_ctx.clearRect(0, 0, t.m_ctx.canvas.width, t.m_ctx.canvas.height)
                    }
                }
            }
        }, t.prototype._color = function(t, e) {
            return "rgba(" + ((16711680 & t) >> 16) + "," + ((65280 & t) >> 8) + "," + (255 & t) + "," + e + ")"
        }, t.prototype.b2DebugDraw = function() {
            this.m_drawFlags = 0
        }, t.prototype.SetFlags = function(t) {
            void 0 === t && (t = 0), this.m_drawFlags = t
        }, t.prototype.GetFlags = function() {
            return this.m_drawFlags
        }, t.prototype.AppendFlags = function(t) {
            void 0 === t && (t = 0), this.m_drawFlags |= t
        }, t.prototype.ClearFlags = function(t) {
            void 0 === t && (t = 0), this.m_drawFlags &= ~t
        }, t.prototype.SetSprite = function(t) {
            this.m_ctx = t
        }, t.prototype.GetSprite = function() {
            return this.m_ctx
        }, t.prototype.SetDrawScale = function(t) {
            void 0 === t && (t = 0), this.m_drawScale = t
        }, t.prototype.GetDrawScale = function() {
            return this.m_drawScale
        }, t.prototype.SetLineThickness = function(t) {
            void 0 === t && (t = 0), this.m_lineThickness = t, this.m_ctx.strokeWidth = t
        }, t.prototype.GetLineThickness = function() {
            return this.m_lineThickness
        }, t.prototype.SetAlpha = function(t) {
            void 0 === t && (t = 0), this.m_alpha = t
        }, t.prototype.GetAlpha = function() {
            return this.m_alpha
        }, t.prototype.SetFillAlpha = function(t) {
            void 0 === t && (t = 0), this.m_fillAlpha = t
        }, t.prototype.GetFillAlpha = function() {
            return this.m_fillAlpha
        }, t.prototype.SetXFormScale = function(t) {
            void 0 === t && (t = 0), this.m_xformScale = t
        }, t.prototype.GetXFormScale = function() {
            return this.m_xformScale
        }, t.prototype.DrawPolygon = function(t, e, i) {
            if (e) {
                var s = this.m_ctx,
                    o = this.m_drawScale;
                s.beginPath(), s.strokeStyle = this._color(i.color, this.m_alpha), s.moveTo(t[0].x * o, t[0].y * o);
                for (var n = 1; n < e; n++) s.lineTo(t[n].x * o, t[n].y * o);
                s.lineTo(t[0].x * o, t[0].y * o), s.closePath(), s.stroke()
            }
        }, t.prototype.DrawSolidPolygon = function(t, e, i) {
            if (e) {
                var s = this.m_ctx,
                    o = this.m_drawScale;
                s.beginPath(), s.strokeStyle = this._color(i.color, this.m_alpha), s.fillStyle = this._color(i.color, this.m_fillAlpha), s.moveTo(t[0].x * o, t[0].y * o);
                for (var n = 1; n < e; n++) s.lineTo(t[n].x * o, t[n].y * o);
                s.lineTo(t[0].x * o, t[0].y * o), s.closePath(), s.fill(), s.stroke()
            }
        }, t.prototype.DrawCircle = function(t, e, i) {
            if (e) {
                var s = this.m_ctx,
                    o = this.m_drawScale;
                s.beginPath(), s.strokeStyle = this._color(i.color, this.m_alpha), s.arc(t.x * o, t.y * o, e * o, 0, 2 * Math.PI, !0), s.closePath(), s.stroke()
            }
        }, t.prototype.DrawSolidCircle = function(t, e, i, s) {
            if (e) {
                var o = this.m_ctx,
                    n = this.m_drawScale,
                    a = t.x * n,
                    r = t.y * n;
                o.moveTo(0, 0), o.beginPath(), o.strokeStyle = this._color(s.color, this.m_alpha), o.fillStyle = this._color(s.color, this.m_fillAlpha), o.arc(a, r, e * n, 0, 2 * Math.PI, !0), o.moveTo(a, r), o.lineTo((t.x + i.x * e) * n, (t.y + i.y * e) * n), o.closePath(), o.fill(), o.stroke()
            }
        }, t.prototype.DrawSegment = function(t, e, i) {
            var s = this.m_ctx,
                o = this.m_drawScale;
            s.strokeStyle = this._color(i.color, this.m_alpha), s.beginPath(), s.moveTo(t.x * o, t.y * o), s.lineTo(e.x * o, e.y * o), s.closePath(), s.stroke()
        }, t.prototype.DrawTransform = function(t) {
            var e = this.m_ctx,
                i = this.m_drawScale;
            e.beginPath(), e.strokeStyle = this._color(16711680, this.m_alpha), e.moveTo(t.position.x * i, t.position.y * i), e.lineTo((t.position.x + this.m_xformScale * t.R.col1.x) * i, (t.position.y + this.m_xformScale * t.R.col1.y) * i), e.strokeStyle = this._color(65280, this.m_alpha), e.moveTo(t.position.x * i, t.position.y * i), e.lineTo((t.position.x + this.m_xformScale * t.R.col2.x) * i, (t.position.y + this.m_xformScale * t.R.col2.y) * i), e.closePath(), e.stroke()
        }
    }();
var i;
for (i = 0; i < Box2D.postDefs.length; ++i) Box2D.postDefs[i]();
! function(t) {
    if ("object" == typeof exports && "undefined" != typeof module) module.exports = t();
    else if ("function" == typeof define && define.amd) define([], t);
    else {
        ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).poly2tri = t()
    }
}(function() {
    return function t(e, i, s) {
        function o(a, r) {
            if (!i[a]) {
                if (!e[a]) {
                    var h = "function" == typeof require && require;
                    if (!r && h) return h(a, !0);
                    if (n) return n(a, !0);
                    var l = new Error("Cannot find module '" + a + "'");
                    throw l.code = "MODULE_NOT_FOUND", l
                }
                var c = i[a] = {
                    exports: {}
                };
                e[a][0].call(c.exports, function(t) {
                    return o(e[a][1][t] || t)
                }, c, c.exports, t, e, i, s)
            }
            return i[a].exports
        }
        for (var n = "function" == typeof require && require, a = 0; a < s.length; a++) o(s[a]);
        return o
    }({
        1: [function(t, e, i) {
            e.exports = {
                version: "1.5.0"
            }
        }, {}],
        2: [function(t, e, i) {
            var s = function(t, e) {
                this.head_ = t, this.tail_ = e, this.search_node_ = t
            };
            s.prototype.head = function() {
                return this.head_
            }, s.prototype.setHead = function(t) {
                this.head_ = t
            }, s.prototype.tail = function() {
                return this.tail_
            }, s.prototype.setTail = function(t) {
                this.tail_ = t
            }, s.prototype.search = function() {
                return this.search_node_
            }, s.prototype.setSearch = function(t) {
                this.search_node_ = t
            }, s.prototype.findSearchNode = function() {
                return this.search_node_
            }, s.prototype.locateNode = function(t) {
                var e = this.search_node_;
                if (t < e.value) {
                    for (; e = e.prev;)
                        if (t >= e.value) return this.search_node_ = e, e
                } else
                    for (; e = e.next;)
                        if (t < e.value) return this.search_node_ = e.prev, e.prev;
                return null
            }, s.prototype.locatePoint = function(t) {
                var e = t.x,
                    i = this.findSearchNode(e),
                    s = i.point.x;
                if (e === s) {
                    if (t !== i.point)
                        if (t === i.prev.point) i = i.prev;
                        else {
                            if (t !== i.next.point) throw new Error("poly2tri Invalid AdvancingFront.locatePoint() call");
                            i = i.next
                        }
                } else if (e < s)
                    for (;
                        (i = i.prev) && t !== i.point;);
                else
                    for (;
                        (i = i.next) && t !== i.point;);
                return i && (this.search_node_ = i), i
            }, e.exports = s, e.exports.Node = function(t, e) {
                this.point = t, this.triangle = e || null, this.next = null, this.prev = null, this.value = t.x
            }
        }, {}],
        3: [function(t, e, i) {
            e.exports = function(t, e) {
                if (!t) throw new Error(e || "Assert Failed")
            }
        }, {}],
        4: [function(t, e, i) {
            var s = t("./xy"),
                o = function(t, e) {
                    this.x = +t || 0, this.y = +e || 0, this._p2t_edge_list = null
                };
            o.prototype.toString = function() {
                return s.toStringBase(this)
            }, o.prototype.toJSON = function() {
                return {
                    x: this.x,
                    y: this.y
                }
            }, o.prototype.clone = function() {
                return new o(this.x, this.y)
            }, o.prototype.set_zero = function() {
                return this.x = 0, this.y = 0, this
            }, o.prototype.set = function(t, e) {
                return this.x = +t || 0, this.y = +e || 0, this
            }, o.prototype.negate = function() {
                return this.x = -this.x, this.y = -this.y, this
            }, o.prototype.add = function(t) {
                return this.x += t.x, this.y += t.y, this
            }, o.prototype.sub = function(t) {
                return this.x -= t.x, this.y -= t.y, this
            }, o.prototype.mul = function(t) {
                return this.x *= t, this.y *= t, this
            }, o.prototype.length = function() {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            }, o.prototype.normalize = function() {
                var t = this.length();
                return this.x /= t, this.y /= t, t
            }, o.prototype.equals = function(t) {
                return this.x === t.x && this.y === t.y
            }, o.negate = function(t) {
                return new o(-t.x, -t.y)
            }, o.add = function(t, e) {
                return new o(t.x + e.x, t.y + e.y)
            }, o.sub = function(t, e) {
                return new o(t.x - e.x, t.y - e.y)
            }, o.mul = function(t, e) {
                return new o(t * e.x, t * e.y)
            }, o.cross = function(t, e) {
                return "number" == typeof t ? "number" == typeof e ? t * e : new o(-t * e.y, t * e.x) : "number" == typeof e ? new o(e * t.y, -e * t.x) : t.x * e.y - t.y * e.x
            }, o.toString = s.toString, o.compare = s.compare, o.cmp = s.compare, o.equals = s.equals, o.dot = function(t, e) {
                return t.x * e.x + t.y * e.y
            }, e.exports = o
        }, {
            "./xy": 11
        }],
        5: [function(t, e, i) {
            var s = t("./xy"),
                o = function(t, e) {
                    this.name = "PointError", this.points = e = e || [], this.message = t || "Invalid Points!";
                    for (var i = 0; i < e.length; i++) this.message += " " + s.toString(e[i])
                };
            (o.prototype = new Error).constructor = o, e.exports = o
        }, {
            "./xy": 11
        }],
        6: [function(t, e, i) {
            (function(e) {
                var s = e.poly2tri;
                i.noConflict = function() {
                    return e.poly2tri = s, i
                }, i.VERSION = t("../dist/version.json").version, i.PointError = t("./pointerror"), i.Point = t("./point"), i.Triangle = t("./triangle"), i.SweepContext = t("./sweepcontext");
                var o = t("./sweep");
                i.triangulate = o.triangulate, i.sweep = {
                    Triangulate: o.triangulate
                }
            }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
        }, {
            "../dist/version.json": 1,
            "./point": 4,
            "./pointerror": 5,
            "./sweep": 7,
            "./sweepcontext": 8,
            "./triangle": 9
        }],
        7: [function(t, e, i) {
            function s(t) {
                var e, i = t.pointCount();
                for (e = 1; e < i; ++e)
                    for (var s = t.getPoint(e), o = n(t, s), r = s._p2t_edge_list, h = 0; r && h < r.length; ++h) a(t, r[h], o)
            }

            function o(t) {
                for (var e = t.front().head().next.triangle, i = t.front().head().next.point; !e.getConstrainedEdgeCW(i);) e = e.neighborCCW(i);
                t.meshClean(e)
            }

            function n(t, e) {
                var i = t.locateNode(e),
                    s = l(t, e, i);
                return e.x <= i.point.x + k && c(t, i), p(t, s), s
            }

            function a(t, e, i) {
                t.edge_event.constrained_edge = e, t.edge_event.right = e.p.x > e.q.x, h(i.triangle, e.p, e.q) || (v(t, e, i), r(t, e.p, e.q, i.triangle, e.q))
            }

            function r(t, e, i, s, o) {
                if (!h(s, e, i)) {
                    var n = s.pointCCW(o),
                        a = N(i, n, e);
                    if (a === F.COLLINEAR) throw new M("poly2tri EdgeEvent: Collinear not supported!", [i, n, e]);
                    var l = s.pointCW(o),
                        c = N(i, l, e);
                    if (c === F.COLLINEAR) throw new M("poly2tri EdgeEvent: Collinear not supported!", [i, l, e]);
                    a === c ? (s = a === F.CW ? s.neighborCCW(o) : s.neighborCW(o), r(t, e, i, s, o)) : P(t, e, i, s, o)
                }
            }

            function h(t, e, i) {
                var s = t.edgeIndex(e, i);
                if (-1 !== s) {
                    t.markConstrainedEdgeByIndex(s);
                    var o = t.getNeighbor(s);
                    return o && o.markConstrainedEdgeByPoints(e, i), !0
                }
                return !1
            }

            function l(t, e, i) {
                var s = new G(e, i.point, i.next.point);
                s.markNeighbor(i.triangle), t.addToMap(s);
                var o = new O(e);
                return o.next = i.next, o.prev = i, i.next.prev = o, i.next = o, d(t, s) || t.mapTriangleToNodes(s), o
            }

            function c(t, e) {
                var i = new G(e.prev.point, e.point, e.next.point);
                i.markNeighbor(e.prev.triangle), i.markNeighbor(e.triangle), t.addToMap(i), e.prev.next = e.next, e.next.prev = e.prev, d(t, i) || t.mapTriangleToNodes(i)
            }

            function p(t, e) {
                for (var i = e.next; i.next && !U(i.point, i.next.point, i.prev.point);) c(t, i), i = i.next;
                for (i = e.prev; i.prev && !U(i.point, i.next.point, i.prev.point);) c(t, i), i = i.prev;
                e.next && e.next.next && u(e) && f(t, e)
            }

            function u(t) {
                var e = t.point.x - t.next.next.point.x,
                    i = t.point.y - t.next.next.point.y;
                return L(i >= 0, "unordered y"), e >= 0 || Math.abs(e) < i
            }

            function d(t, e) {
                for (var i = 0; i < 3; ++i)
                    if (!e.delaunay_edge[i]) {
                        var s = e.getNeighbor(i);
                        if (s) {
                            var o = e.getPoint(i),
                                n = s.oppositePoint(e, o),
                                a = s.index(n);
                            if (s.constrained_edge[a] || s.delaunay_edge[a]) {
                                e.constrained_edge[i] = s.constrained_edge[a];
                                continue
                            }
                            if (m(o, e.pointCCW(o), e.pointCW(o), n)) {
                                e.delaunay_edge[i] = !0, s.delaunay_edge[a] = !0, y(e, o, s, n);
                                var r = !d(t, e);
                                return r && t.mapTriangleToNodes(e), (r = !d(t, s)) && t.mapTriangleToNodes(s), e.delaunay_edge[i] = !1, s.delaunay_edge[a] = !1, !0
                            }
                        }
                    }
                return !1
            }

            function m(t, e, i, s) {
                var o = t.x - s.x,
                    n = t.y - s.y,
                    a = e.x - s.x,
                    r = e.y - s.y,
                    h = o * r - a * n;
                if (h <= 0) return !1;
                var l = i.x - s.x,
                    c = i.y - s.y,
                    p = l * n - o * c;
                return !(p <= 0) && (o * o + n * n) * (a * c - l * r) + (a * a + r * r) * p + (l * l + c * c) * h > 0
            }

            function y(t, e, i, s) {
                var o, n, a, r;
                o = t.neighborCCW(e), n = t.neighborCW(e), a = i.neighborCCW(s), r = i.neighborCW(s);
                var h, l, c, p;
                h = t.getConstrainedEdgeCCW(e), l = t.getConstrainedEdgeCW(e), c = i.getConstrainedEdgeCCW(s), p = i.getConstrainedEdgeCW(s);
                var u, d, m, y;
                u = t.getDelaunayEdgeCCW(e), d = t.getDelaunayEdgeCW(e), m = i.getDelaunayEdgeCCW(s), y = i.getDelaunayEdgeCW(s), t.legalize(e, s), i.legalize(s, e), i.setDelaunayEdgeCCW(e, u), t.setDelaunayEdgeCW(e, d), t.setDelaunayEdgeCCW(s, m), i.setDelaunayEdgeCW(s, y), i.setConstrainedEdgeCCW(e, h), t.setConstrainedEdgeCW(e, l), t.setConstrainedEdgeCCW(s, c), i.setConstrainedEdgeCW(s, p), t.clearNeighbors(), i.clearNeighbors(), o && i.markNeighbor(o), n && t.markNeighbor(n), a && t.markNeighbor(a), r && i.markNeighbor(r), t.markNeighbor(i)
            }

            function f(t, e) {
                for (N(e.point, e.next.point, e.next.next.point) === F.CCW ? t.basin.left_node = e.next.next : t.basin.left_node = e.next, t.basin.bottom_node = t.basin.left_node; t.basin.bottom_node.next && t.basin.bottom_node.point.y >= t.basin.bottom_node.next.point.y;) t.basin.bottom_node = t.basin.bottom_node.next;
                if (t.basin.bottom_node !== t.basin.left_node) {
                    for (t.basin.right_node = t.basin.bottom_node; t.basin.right_node.next && t.basin.right_node.point.y < t.basin.right_node.next.point.y;) t.basin.right_node = t.basin.right_node.next;
                    t.basin.right_node !== t.basin.bottom_node && (t.basin.width = t.basin.right_node.point.x - t.basin.left_node.point.x, t.basin.left_highest = t.basin.left_node.point.y > t.basin.right_node.point.y, g(t, t.basin.bottom_node))
                }
            }

            function g(t, e) {
                if (!_(t, e) && (c(t, e), e.prev !== t.basin.left_node || e.next !== t.basin.right_node)) {
                    if (e.prev === t.basin.left_node) {
                        if (N(e.point, e.next.point, e.next.next.point) === F.CW) return;
                        e = e.next
                    } else if (e.next === t.basin.right_node) {
                        if (N(e.point, e.prev.point, e.prev.prev.point) === F.CCW) return;
                        e = e.prev
                    } else e = e.prev.point.y < e.next.point.y ? e.prev : e.next;
                    g(t, e)
                }
            }

            function _(t, e) {
                var i;
                return i = t.basin.left_highest ? t.basin.left_node.point.y - e.point.y : t.basin.right_node.point.y - e.point.y, t.basin.width > i
            }

            function v(t, e, i) {
                t.edge_event.right ? b(t, e, i) : w(t, e, i)
            }

            function b(t, e, i) {
                for (; i.next.point.x < e.p.x;) N(e.q, i.next.point, e.p) === F.CCW ? x(t, e, i) : i = i.next
            }

            function x(t, e, i) {
                i.point.x < e.p.x && (N(i.point, i.next.point, i.next.next.point) === F.CCW ? C(t, e, i) : (S(t, e, i), x(t, e, i)))
            }

            function C(t, e, i) {
                c(t, i.next), i.next.point !== e.p && N(e.q, i.next.point, e.p) === F.CCW && N(i.point, i.next.point, i.next.next.point) === F.CCW && C(t, e, i)
            }

            function S(t, e, i) {
                N(i.next.point, i.next.next.point, i.next.next.next.point) === F.CCW ? C(t, e, i.next) : N(e.q, i.next.next.point, e.p) === F.CCW && S(t, e, i.next)
            }

            function w(t, e, i) {
                for (; i.prev.point.x > e.p.x;) N(e.q, i.prev.point, e.p) === F.CW ? A(t, e, i) : i = i.prev
            }

            function A(t, e, i) {
                i.point.x > e.p.x && (N(i.point, i.prev.point, i.prev.prev.point) === F.CW ? B(t, e, i) : (T(t, e, i), A(t, e, i)))
            }

            function T(t, e, i) {
                N(i.prev.point, i.prev.prev.point, i.prev.prev.prev.point) === F.CW ? B(t, e, i.prev) : N(e.q, i.prev.prev.point, e.p) === F.CW && T(t, e, i.prev)
            }

            function B(t, e, i) {
                c(t, i.prev), i.prev.point !== e.p && N(e.q, i.prev.point, e.p) === F.CW && N(i.point, i.prev.point, i.prev.prev.point) === F.CW && B(t, e, i)
            }

            function P(t, e, i, s, o) {
                var n = s.neighborAcross(o);
                L(n, "FLIP failed due to missing triangle!");
                var a = n.oppositePoint(s, o);
                if (s.getConstrainedEdgeAcross(o)) {
                    var h = s.index(o);
                    throw new M("poly2tri Intersecting Constraints", [o, a, s.getPoint((h + 1) % 3), s.getPoint((h + 2) % 3)])
                }
                V(o, s.pointCCW(o), s.pointCW(o), a) ? (y(s, o, n, a), t.mapTriangleToNodes(s), t.mapTriangleToNodes(n), o === i && a === e ? i === t.edge_event.constrained_edge.q && e === t.edge_event.constrained_edge.p && (s.markConstrainedEdgeByPoints(e, i), n.markConstrainedEdgeByPoints(e, i), d(t, s), d(t, n)) : P(t, e, i, s = D(t, N(i, a, e), s, n, o, a), o)) : (E(t, e, i, s, n, I(e, i, n, a)), r(t, e, i, s, o))
            }

            function D(t, e, i, s, o, n) {
                var a;
                return e === F.CCW ? (a = s.edgeIndex(o, n), s.delaunay_edge[a] = !0, d(t, s), s.clearDelaunayEdges(), i) : (a = i.edgeIndex(o, n), i.delaunay_edge[a] = !0, d(t, i), i.clearDelaunayEdges(), s)
            }

            function I(t, e, i, s) {
                var o = N(e, s, t);
                if (o === F.CW) return i.pointCCW(s);
                if (o === F.CCW) return i.pointCW(s);
                throw new M("poly2tri [Unsupported] nextFlipPoint: opposing point on constrained edge!", [e, s, t])
            }

            function E(t, e, i, s, o, n) {
                var a = o.neighborAcross(n);
                L(a, "FLIP failed due to missing triangle");
                var r = a.oppositePoint(o, n);
                V(i, s.pointCCW(i), s.pointCW(i), r) ? P(t, i, r, a, r) : E(t, e, i, s, a, I(e, i, a, r))
            }
            var L = t("./assert"),
                M = t("./pointerror"),
                G = t("./triangle"),
                O = t("./advancingfront").Node,
                R = t("./utils"),
                k = R.EPSILON,
                F = R.Orientation,
                N = R.orient2d,
                V = R.inScanArea,
                U = R.isAngleObtuse;
            i.triangulate = function(t) {
                t.initTriangulation(), t.createAdvancingFront(), s(t), o(t)
            }
        }, {
            "./advancingfront": 2,
            "./assert": 3,
            "./pointerror": 5,
            "./triangle": 9,
            "./utils": 10
        }],
        8: [function(t, e, i) {
            var s = t("./pointerror"),
                o = t("./point"),
                n = t("./triangle"),
                a = t("./sweep"),
                r = t("./advancingfront"),
                h = r.Node,
                l = function(t, e) {
                    if (this.p = t, this.q = e, t.y > e.y) this.q = t, this.p = e;
                    else if (t.y === e.y)
                        if (t.x > e.x) this.q = t, this.p = e;
                        else if (t.x === e.x) throw new s("poly2tri Invalid Edge constructor: repeated points!", [t]);
                    this.q._p2t_edge_list || (this.q._p2t_edge_list = []), this.q._p2t_edge_list.push(this)
                },
                c = function() {
                    this.left_node = null, this.bottom_node = null, this.right_node = null, this.width = 0, this.left_highest = !1
                };
            c.prototype.clear = function() {
                this.left_node = null, this.bottom_node = null, this.right_node = null, this.width = 0, this.left_highest = !1
            };
            var p = function() {
                    this.constrained_edge = null, this.right = !1
                },
                u = function(t, e) {
                    e = e || {}, this.triangles_ = [], this.map_ = [], this.points_ = e.cloneArrays ? t.slice(0) : t, this.edge_list = [], this.pmin_ = this.pmax_ = null, this.front_ = null, this.head_ = null, this.tail_ = null, this.af_head_ = null, this.af_middle_ = null, this.af_tail_ = null, this.basin = new c, this.edge_event = new p, this.initEdges(this.points_)
                };
            u.prototype.addHole = function(t) {
                this.initEdges(t);
                var e, i = t.length;
                for (e = 0; e < i; e++) this.points_.push(t[e]);
                return this
            }, u.prototype.AddHole = u.prototype.addHole, u.prototype.addHoles = function(t) {
                var e, i = t.length;
                for (e = 0; e < i; e++) this.initEdges(t[e]);
                return this.points_ = this.points_.concat.apply(this.points_, t), this
            }, u.prototype.addPoint = function(t) {
                return this.points_.push(t), this
            }, u.prototype.AddPoint = u.prototype.addPoint, u.prototype.addPoints = function(t) {
                return this.points_ = this.points_.concat(t), this
            }, u.prototype.triangulate = function() {
                return a.triangulate(this), this
            }, u.prototype.getBoundingBox = function() {
                return {
                    min: this.pmin_,
                    max: this.pmax_
                }
            }, u.prototype.getTriangles = function() {
                return this.triangles_
            }, u.prototype.GetTriangles = u.prototype.getTriangles, u.prototype.front = function() {
                return this.front_
            }, u.prototype.pointCount = function() {
                return this.points_.length
            }, u.prototype.head = function() {
                return this.head_
            }, u.prototype.setHead = function(t) {
                this.head_ = t
            }, u.prototype.tail = function() {
                return this.tail_
            }, u.prototype.setTail = function(t) {
                this.tail_ = t
            }, u.prototype.getMap = function() {
                return this.map_
            }, u.prototype.initTriangulation = function() {
                var t, e = this.points_[0].x,
                    i = this.points_[0].x,
                    s = this.points_[0].y,
                    n = this.points_[0].y,
                    a = this.points_.length;
                for (t = 1; t < a; t++) {
                    var r = this.points_[t];
                    r.x > e && (e = r.x), r.x < i && (i = r.x), r.y > s && (s = r.y), r.y < n && (n = r.y)
                }
                this.pmin_ = new o(i, n), this.pmax_ = new o(e, s);
                var h = .3 * (e - i),
                    l = .3 * (s - n);
                this.head_ = new o(e + h, n - l), this.tail_ = new o(i - h, n - l), this.points_.sort(o.compare)
            }, u.prototype.initEdges = function(t) {
                var e, i = t.length;
                for (e = 0; e < i; ++e) this.edge_list.push(new l(t[e], t[(e + 1) % i]))
            }, u.prototype.getPoint = function(t) {
                return this.points_[t]
            }, u.prototype.addToMap = function(t) {
                this.map_.push(t)
            }, u.prototype.locateNode = function(t) {
                return this.front_.locateNode(t.x)
            }, u.prototype.createAdvancingFront = function() {
                var t, e, i, s = new n(this.points_[0], this.tail_, this.head_);
                this.map_.push(s), t = new h(s.getPoint(1), s), e = new h(s.getPoint(0), s), i = new h(s.getPoint(2)), this.front_ = new r(t, i), t.next = e, e.next = i, e.prev = t, i.prev = e
            }, u.prototype.removeNode = function(t) {}, u.prototype.mapTriangleToNodes = function(t) {
                for (var e = 0; e < 3; ++e)
                    if (!t.getNeighbor(e)) {
                        var i = this.front_.locatePoint(t.pointCW(t.getPoint(e)));
                        i && (i.triangle = t)
                    }
            }, u.prototype.removeFromMap = function(t) {
                var e, i = this.map_,
                    s = i.length;
                for (e = 0; e < s; e++)
                    if (i[e] === t) {
                        i.splice(e, 1);
                        break
                    }
            }, u.prototype.meshClean = function(t) {
                for (var e, i, s = [t]; e = s.pop();)
                    if (!e.isInterior())
                        for (e.setInterior(!0), this.triangles_.push(e), i = 0; i < 3; i++) e.constrained_edge[i] || s.push(e.getNeighbor(i))
            }, e.exports = u
        }, {
            "./advancingfront": 2,
            "./point": 4,
            "./pointerror": 5,
            "./sweep": 7,
            "./triangle": 9
        }],
        9: [function(t, e, i) {
            var s = function(t, e, i) {
                    this.points_ = [t, e, i], this.neighbors_ = [null, null, null], this.interior_ = !1, this.constrained_edge = [!1, !1, !1], this.delaunay_edge = [!1, !1, !1]
                },
                o = t("./xy").toString;
            s.prototype.toString = function() {
                return "[" + o(this.points_[0]) + o(this.points_[1]) + o(this.points_[2]) + "]"
            }, s.prototype.getPoint = function(t) {
                return this.points_[t]
            }, s.prototype.GetPoint = s.prototype.getPoint, s.prototype.getPoints = function() {
                return this.points_
            }, s.prototype.getNeighbor = function(t) {
                return this.neighbors_[t]
            }, s.prototype.containsPoint = function(t) {
                var e = this.points_;
                return t === e[0] || t === e[1] || t === e[2]
            }, s.prototype.containsEdge = function(t) {
                return this.containsPoint(t.p) && this.containsPoint(t.q)
            }, s.prototype.containsPoints = function(t, e) {
                return this.containsPoint(t) && this.containsPoint(e)
            }, s.prototype.isInterior = function() {
                return this.interior_
            }, s.prototype.setInterior = function(t) {
                return this.interior_ = t, this
            }, s.prototype.markNeighborPointers = function(t, e, i) {
                var s = this.points_;
                if (t === s[2] && e === s[1] || t === s[1] && e === s[2]) this.neighbors_[0] = i;
                else if (t === s[0] && e === s[2] || t === s[2] && e === s[0]) this.neighbors_[1] = i;
                else {
                    if (!(t === s[0] && e === s[1] || t === s[1] && e === s[0])) throw new Error("poly2tri Invalid Triangle.markNeighborPointers() call");
                    this.neighbors_[2] = i
                }
            }, s.prototype.markNeighbor = function(t) {
                var e = this.points_;
                t.containsPoints(e[1], e[2]) ? (this.neighbors_[0] = t, t.markNeighborPointers(e[1], e[2], this)) : t.containsPoints(e[0], e[2]) ? (this.neighbors_[1] = t, t.markNeighborPointers(e[0], e[2], this)) : t.containsPoints(e[0], e[1]) && (this.neighbors_[2] = t, t.markNeighborPointers(e[0], e[1], this))
            }, s.prototype.clearNeighbors = function() {
                this.neighbors_[0] = null, this.neighbors_[1] = null, this.neighbors_[2] = null
            }, s.prototype.clearDelaunayEdges = function() {
                this.delaunay_edge[0] = !1, this.delaunay_edge[1] = !1, this.delaunay_edge[2] = !1
            }, s.prototype.pointCW = function(t) {
                var e = this.points_;
                return t === e[0] ? e[2] : t === e[1] ? e[0] : t === e[2] ? e[1] : null
            }, s.prototype.pointCCW = function(t) {
                var e = this.points_;
                return t === e[0] ? e[1] : t === e[1] ? e[2] : t === e[2] ? e[0] : null
            }, s.prototype.neighborCW = function(t) {
                return t === this.points_[0] ? this.neighbors_[1] : t === this.points_[1] ? this.neighbors_[2] : this.neighbors_[0]
            }, s.prototype.neighborCCW = function(t) {
                return t === this.points_[0] ? this.neighbors_[2] : t === this.points_[1] ? this.neighbors_[0] : this.neighbors_[1]
            }, s.prototype.getConstrainedEdgeCW = function(t) {
                return t === this.points_[0] ? this.constrained_edge[1] : t === this.points_[1] ? this.constrained_edge[2] : this.constrained_edge[0]
            }, s.prototype.getConstrainedEdgeCCW = function(t) {
                return t === this.points_[0] ? this.constrained_edge[2] : t === this.points_[1] ? this.constrained_edge[0] : this.constrained_edge[1]
            }, s.prototype.getConstrainedEdgeAcross = function(t) {
                return t === this.points_[0] ? this.constrained_edge[0] : t === this.points_[1] ? this.constrained_edge[1] : this.constrained_edge[2]
            }, s.prototype.setConstrainedEdgeCW = function(t, e) {
                t === this.points_[0] ? this.constrained_edge[1] = e : t === this.points_[1] ? this.constrained_edge[2] = e : this.constrained_edge[0] = e
            }, s.prototype.setConstrainedEdgeCCW = function(t, e) {
                t === this.points_[0] ? this.constrained_edge[2] = e : t === this.points_[1] ? this.constrained_edge[0] = e : this.constrained_edge[1] = e
            }, s.prototype.getDelaunayEdgeCW = function(t) {
                return t === this.points_[0] ? this.delaunay_edge[1] : t === this.points_[1] ? this.delaunay_edge[2] : this.delaunay_edge[0]
            }, s.prototype.getDelaunayEdgeCCW = function(t) {
                return t === this.points_[0] ? this.delaunay_edge[2] : t === this.points_[1] ? this.delaunay_edge[0] : this.delaunay_edge[1]
            }, s.prototype.setDelaunayEdgeCW = function(t, e) {
                t === this.points_[0] ? this.delaunay_edge[1] = e : t === this.points_[1] ? this.delaunay_edge[2] = e : this.delaunay_edge[0] = e
            }, s.prototype.setDelaunayEdgeCCW = function(t, e) {
                t === this.points_[0] ? this.delaunay_edge[2] = e : t === this.points_[1] ? this.delaunay_edge[0] = e : this.delaunay_edge[1] = e
            }, s.prototype.neighborAcross = function(t) {
                return t === this.points_[0] ? this.neighbors_[0] : t === this.points_[1] ? this.neighbors_[1] : this.neighbors_[2]
            }, s.prototype.oppositePoint = function(t, e) {
                var i = t.pointCW(e);
                return this.pointCW(i)
            }, s.prototype.legalize = function(t, e) {
                var i = this.points_;
                if (t === i[0]) i[1] = i[0], i[0] = i[2], i[2] = e;
                else if (t === i[1]) i[2] = i[1], i[1] = i[0], i[0] = e;
                else {
                    if (t !== i[2]) throw new Error("poly2tri Invalid Triangle.legalize() call");
                    i[0] = i[2], i[2] = i[1], i[1] = e
                }
            }, s.prototype.index = function(t) {
                var e = this.points_;
                if (t === e[0]) return 0;
                if (t === e[1]) return 1;
                if (t === e[2]) return 2;
                throw new Error("poly2tri Invalid Triangle.index() call")
            }, s.prototype.edgeIndex = function(t, e) {
                var i = this.points_;
                if (t === i[0]) {
                    if (e === i[1]) return 2;
                    if (e === i[2]) return 1
                } else if (t === i[1]) {
                    if (e === i[2]) return 0;
                    if (e === i[0]) return 2
                } else if (t === i[2]) {
                    if (e === i[0]) return 1;
                    if (e === i[1]) return 0
                }
                return -1
            }, s.prototype.markConstrainedEdgeByIndex = function(t) {
                this.constrained_edge[t] = !0
            }, s.prototype.markConstrainedEdgeByEdge = function(t) {
                this.markConstrainedEdgeByPoints(t.p, t.q)
            }, s.prototype.markConstrainedEdgeByPoints = function(t, e) {
                var i = this.points_;
                e === i[0] && t === i[1] || e === i[1] && t === i[0] ? this.constrained_edge[2] = !0 : e === i[0] && t === i[2] || e === i[2] && t === i[0] ? this.constrained_edge[1] = !0 : (e === i[1] && t === i[2] || e === i[2] && t === i[1]) && (this.constrained_edge[0] = !0)
            }, e.exports = s
        }, {
            "./xy": 11
        }],
        10: [function(t, e, i) {
            var s = 1e-12;
            i.EPSILON = s;
            var o = {
                CW: 1,
                CCW: -1,
                COLLINEAR: 0
            };
            i.Orientation = o, i.orient2d = function(t, e, i) {
                var n = (t.x - i.x) * (e.y - i.y) - (t.y - i.y) * (e.x - i.x);
                return n > -s && n < s ? o.COLLINEAR : n > 0 ? o.CCW : o.CW
            }, i.inScanArea = function(t, e, i, o) {
                return !((t.x - e.x) * (o.y - e.y) - (o.x - e.x) * (t.y - e.y) >= -s || (t.x - i.x) * (o.y - i.y) - (o.x - i.x) * (t.y - i.y) <= s)
            }, i.isAngleObtuse = function(t, e, i) {
                var s = e.x - t.x,
                    o = e.y - t.y;
                return s * (i.x - t.x) + o * (i.y - t.y) < 0
            }
        }, {}],
        11: [function(t, e, i) {
            function s(t) {
                return "(" + t.x + ";" + t.y + ")"
            }
            e.exports = {
                toString: function(t) {
                    var e = t.toString();
                    return "[object Object]" === e ? s(t) : e
                },
                toStringBase: s,
                compare: function(t, e) {
                    return t.y === e.y ? t.x - e.x : t.y - e.y
                },
                equals: function(t, e) {
                    return t.x === e.x && t.y === e.y
                }
            }
        }, {}]
    }, {}, [6])(6)
}),
function(t) {
    if ("object" == typeof exports) module.exports = t();
    else {
        var e;
        "undefined" != typeof window ? e = window : "undefined" != typeof global ? e = global : "undefined" != typeof self && (e = self), e.p2 = t()
    }
}(function() {
    return function t(e, i, s) {
        function o(a, r) {
            if (!i[a]) {
                if (!e[a]) {
                    var h = "function" == typeof require && require;
                    if (!r && h) return h(a, !0);
                    if (n) return n(a, !0);
                    throw new Error("Cannot find module '" + a + "'")
                }
                var l = i[a] = {
                    exports: {}
                };
                e[a][0].call(l.exports, function(t) {
                    var i = e[a][1][t];
                    return o(i || t)
                }, l, l.exports, t, e, i, s)
            }
            return i[a].exports
        }
        for (var n = "function" == typeof require && require, a = 0; a < s.length; a++) o(s[a]);
        return o
    }({
        1: [function(t, e, i) {
            function s() {}
            var o = t("./Scalar");
            e.exports = s, s.lineInt = function(t, e, i) {
                i = i || 0;
                var s, n, a, r, h, l, c, p = [0, 0];
                return s = t[1][1] - t[0][1], n = t[0][0] - t[1][0], a = s * t[0][0] + n * t[0][1], r = e[1][1] - e[0][1], h = e[0][0] - e[1][0], l = r * e[0][0] + h * e[0][1], c = s * h - r * n, o.eq(c, 0, i) || (p[0] = (h * a - n * l) / c, p[1] = (s * l - r * a) / c), p
            }, s.segmentsIntersect = function(t, e, i, s) {
                var o = e[0] - t[0],
                    n = e[1] - t[1],
                    a = s[0] - i[0],
                    r = s[1] - i[1];
                if (a * n - r * o == 0) return !1;
                var h = (o * (i[1] - t[1]) + n * (t[0] - i[0])) / (a * n - r * o),
                    l = (a * (t[1] - i[1]) + r * (i[0] - t[0])) / (r * o - a * n);
                return h >= 0 && h <= 1 && l >= 0 && l <= 1
            }
        }, {
            "./Scalar": 4
        }],
        2: [function(t, e, i) {
            function s() {}
            e.exports = s, s.area = function(t, e, i) {
                return (e[0] - t[0]) * (i[1] - t[1]) - (i[0] - t[0]) * (e[1] - t[1])
            }, s.left = function(t, e, i) {
                return s.area(t, e, i) > 0
            }, s.leftOn = function(t, e, i) {
                return s.area(t, e, i) >= 0
            }, s.right = function(t, e, i) {
                return s.area(t, e, i) < 0
            }, s.rightOn = function(t, e, i) {
                return s.area(t, e, i) <= 0
            };
            var o = [],
                n = [];
            s.collinear = function(t, e, i, a) {
                if (a) {
                    var r = o,
                        h = n;
                    r[0] = e[0] - t[0], r[1] = e[1] - t[1], h[0] = i[0] - e[0], h[1] = i[1] - e[1];
                    var l = r[0] * h[0] + r[1] * h[1],
                        c = Math.sqrt(r[0] * r[0] + r[1] * r[1]),
                        p = Math.sqrt(h[0] * h[0] + h[1] * h[1]);
                    return Math.acos(l / (c * p)) < a
                }
                return 0 == s.area(t, e, i)
            }, s.sqdist = function(t, e) {
                var i = e[0] - t[0],
                    s = e[1] - t[1];
                return i * i + s * s
            }
        }, {}],
        3: [function(t, e, i) {
            function s() {
                this.vertices = []
            }

            function o(t, e, i, s, o) {
                o = o || 0;
                var n = e[1] - t[1],
                    a = t[0] - e[0],
                    h = n * t[0] + a * t[1],
                    l = s[1] - i[1],
                    c = i[0] - s[0],
                    p = l * i[0] + c * i[1],
                    u = n * c - l * a;
                return r.eq(u, 0, o) ? [0, 0] : [(c * h - a * p) / u, (n * p - l * h) / u]
            }
            var n = t("./Line"),
                a = t("./Point"),
                r = t("./Scalar");
            e.exports = s, s.prototype.at = function(t) {
                var e = this.vertices,
                    i = e.length;
                return e[t < 0 ? t % i + i : t % i]
            }, s.prototype.first = function() {
                return this.vertices[0]
            }, s.prototype.last = function() {
                return this.vertices[this.vertices.length - 1]
            }, s.prototype.clear = function() {
                this.vertices.length = 0
            }, s.prototype.append = function(t, e, i) {
                if (void 0 === e) throw new Error("From is not given!");
                if (void 0 === i) throw new Error("To is not given!");
                if (i - 1 < e) throw new Error("lol1");
                if (i > t.vertices.length) throw new Error("lol2");
                if (e < 0) throw new Error("lol3");
                for (var s = e; s < i; s++) this.vertices.push(t.vertices[s])
            }, s.prototype.makeCCW = function() {
                for (var t = 0, e = this.vertices, i = 1; i < this.vertices.length; ++i)(e[i][1] < e[t][1] || e[i][1] == e[t][1] && e[i][0] > e[t][0]) && (t = i);
                a.left(this.at(t - 1), this.at(t), this.at(t + 1)) || this.reverse()
            }, s.prototype.reverse = function() {
                for (var t = [], e = 0, i = this.vertices.length; e !== i; e++) t.push(this.vertices.pop());
                this.vertices = t
            }, s.prototype.isReflex = function(t) {
                return a.right(this.at(t - 1), this.at(t), this.at(t + 1))
            };
            var h = [],
                l = [];
            s.prototype.canSee = function(t, e) {
                var i, s, o = h,
                    r = l;
                if (a.leftOn(this.at(t + 1), this.at(t), this.at(e)) && a.rightOn(this.at(t - 1), this.at(t), this.at(e))) return !1;
                s = a.sqdist(this.at(t), this.at(e));
                for (var c = 0; c !== this.vertices.length; ++c)
                    if ((c + 1) % this.vertices.length !== t && c !== t && a.leftOn(this.at(t), this.at(e), this.at(c + 1)) && a.rightOn(this.at(t), this.at(e), this.at(c)) && (o[0] = this.at(t), o[1] = this.at(e), r[0] = this.at(c), r[1] = this.at(c + 1), i = n.lineInt(o, r), a.sqdist(this.at(t), i) < s)) return !1;
                return !0
            }, s.prototype.copy = function(t, e, i) {
                var o = i || new s;
                if (o.clear(), t < e)
                    for (n = t; n <= e; n++) o.vertices.push(this.vertices[n]);
                else {
                    for (n = 0; n <= e; n++) o.vertices.push(this.vertices[n]);
                    for (var n = t; n < this.vertices.length; n++) o.vertices.push(this.vertices[n])
                }
                return o
            }, s.prototype.getCutEdges = function() {
                for (var t = [], e = [], i = [], o = new s, n = Number.MAX_VALUE, a = 0; a < this.vertices.length; ++a)
                    if (this.isReflex(a))
                        for (var r = 0; r < this.vertices.length; ++r)
                            if (this.canSee(a, r)) {
                                e = this.copy(a, r, o).getCutEdges(), i = this.copy(r, a, o).getCutEdges();
                                for (var h = 0; h < i.length; h++) e.push(i[h]);
                                e.length < n && (t = e, n = e.length, t.push([this.at(a), this.at(r)]))
                            }
                return t
            }, s.prototype.decomp = function() {
                var t = this.getCutEdges();
                return t.length > 0 ? this.slice(t) : [this]
            }, s.prototype.slice = function(t) {
                if (0 == t.length) return [this];
                if (t instanceof Array && t.length && t[0] instanceof Array && 2 == t[0].length && t[0][0] instanceof Array) {
                    for (var e = [this], i = 0; i < t.length; i++)
                        for (var s = t[i], o = 0; o < e.length; o++) {
                            var n = e[o].slice(s);
                            if (n) {
                                e.splice(o, 1), e.push(n[0], n[1]);
                                break
                            }
                        }
                    return e
                }
                var s = t,
                    i = this.vertices.indexOf(s[0]),
                    o = this.vertices.indexOf(s[1]);
                return -1 != i && -1 != o && [this.copy(i, o), this.copy(o, i)]
            }, s.prototype.isSimple = function() {
                for (var t = this.vertices, e = 0; e < t.length - 1; e++)
                    for (var i = 0; i < e - 1; i++)
                        if (n.segmentsIntersect(t[e], t[e + 1], t[i], t[i + 1])) return !1;
                for (e = 1; e < t.length - 2; e++)
                    if (n.segmentsIntersect(t[0], t[t.length - 1], t[e], t[e + 1])) return !1;
                return !0
            }, s.prototype.quickDecomp = function(t, e, i, n, r, h) {
                r = r || 100, h = h || 0, n = n || 25, t = void 0 !== t ? t : [], e = e || [], i = i || [];
                var l = [0, 0],
                    c = [0, 0],
                    p = [0, 0],
                    u = 0,
                    d = 0,
                    m = 0,
                    y = 0,
                    f = 0,
                    g = 0,
                    _ = 0,
                    v = new s,
                    b = new s,
                    x = this,
                    C = this.vertices;
                if (C.length < 3) return t;
                if (++h > r) return console.warn("quickDecomp: max level (" + r + ") reached."), t;
                for (var S = 0; S < this.vertices.length; ++S)
                    if (x.isReflex(S)) {
                        e.push(x.vertices[S]), u = d = Number.MAX_VALUE;
                        for (w = 0; w < this.vertices.length; ++w) a.left(x.at(S - 1), x.at(S), x.at(w)) && a.rightOn(x.at(S - 1), x.at(S), x.at(w - 1)) && (p = o(x.at(S - 1), x.at(S), x.at(w), x.at(w - 1)), a.right(x.at(S + 1), x.at(S), p) && (m = a.sqdist(x.vertices[S], p)) < d && (d = m, c = p, g = w)), a.left(x.at(S + 1), x.at(S), x.at(w + 1)) && a.rightOn(x.at(S + 1), x.at(S), x.at(w)) && (p = o(x.at(S + 1), x.at(S), x.at(w), x.at(w + 1)), a.left(x.at(S - 1), x.at(S), p) && (m = a.sqdist(x.vertices[S], p)) < u && (u = m, l = p, f = w));
                        if (g == (f + 1) % this.vertices.length) p[0] = (c[0] + l[0]) / 2, p[1] = (c[1] + l[1]) / 2, i.push(p), S < f ? (v.append(x, S, f + 1), v.vertices.push(p), b.vertices.push(p), 0 != g && b.append(x, g, x.vertices.length), b.append(x, 0, S + 1)) : (0 != S && v.append(x, S, x.vertices.length), v.append(x, 0, f + 1), v.vertices.push(p), b.vertices.push(p), b.append(x, g, S + 1));
                        else {
                            if (g > f && (f += this.vertices.length), y = Number.MAX_VALUE, f < g) return t;
                            for (var w = g; w <= f; ++w) a.leftOn(x.at(S - 1), x.at(S), x.at(w)) && a.rightOn(x.at(S + 1), x.at(S), x.at(w)) && (m = a.sqdist(x.at(S), x.at(w))) < y && (y = m, _ = w % this.vertices.length);
                            S < _ ? (v.append(x, S, _ + 1), 0 != _ && b.append(x, _, C.length), b.append(x, 0, S + 1)) : (0 != S && v.append(x, S, C.length), v.append(x, 0, _ + 1), b.append(x, _, S + 1))
                        }
                        return v.vertices.length < b.vertices.length ? (v.quickDecomp(t, e, i, n, r, h), b.quickDecomp(t, e, i, n, r, h)) : (b.quickDecomp(t, e, i, n, r, h), v.quickDecomp(t, e, i, n, r, h)), t
                    }
                return t.push(this), t
            }, s.prototype.removeCollinearPoints = function(t) {
                for (var e = 0, i = this.vertices.length - 1; this.vertices.length > 3 && i >= 0; --i) a.collinear(this.at(i - 1), this.at(i), this.at(i + 1), t) && (this.vertices.splice(i % this.vertices.length, 1), i--, e++);
                return e
            }
        }, {
            "./Line": 1,
            "./Point": 2,
            "./Scalar": 4
        }],
        4: [function(t, e, i) {
            function s() {}
            e.exports = s, s.eq = function(t, e, i) {
                return i = i || 0, Math.abs(t - e) < i
            }
        }, {}],
        5: [function(t, e, i) {
            e.exports = {
                Polygon: t("./Polygon"),
                Point: t("./Point")
            }
        }, {
            "./Point": 2,
            "./Polygon": 3
        }],
        6: [function(t, e, i) {
            e.exports = {
                name: "p2",
                version: "0.7.0",
                description: "A JavaScript 2D physics engine.",
                author: "Stefan Hedman <schteppe@gmail.com> (http://steffe.se)",
                keywords: ["p2.js", "p2", "physics", "engine", "2d"],
                main: "./src/p2.js",
                engines: {
                    node: "*"
                },
                repository: {
                    type: "git",
                    url: "https://github.com/schteppe/p2.js.git"
                },
                bugs: {
                    url: "https://github.com/schteppe/p2.js/issues"
                },
                licenses: [{
                    type: "MIT"
                }],
                devDependencies: {
                    grunt: "^0.4.5",
                    "grunt-contrib-jshint": "^0.11.2",
                    "grunt-contrib-nodeunit": "^0.4.1",
                    "grunt-contrib-uglify": "~0.4.0",
                    "grunt-contrib-watch": "~0.5.0",
                    "grunt-browserify": "~2.0.1",
                    "grunt-contrib-concat": "^0.4.0"
                },
                dependencies: {
                    "poly-decomp": "0.1.0"
                }
            }
        }, {}],
        7: [function(t, e, i) {
            function s(t) {
                this.lowerBound = o.create(), t && t.lowerBound && o.copy(this.lowerBound, t.lowerBound), this.upperBound = o.create(), t && t.upperBound && o.copy(this.upperBound, t.upperBound)
            }
            var o = t("../math/vec2");
            t("../utils/Utils"), e.exports = s;
            var n = o.create();
            s.prototype.setFromPoints = function(t, e, i, s) {
                var a = this.lowerBound,
                    r = this.upperBound;
                "number" != typeof i && (i = 0), 0 !== i ? o.rotate(a, t[0], i) : o.copy(a, t[0]), o.copy(r, a);
                for (var h = Math.cos(i), l = Math.sin(i), c = 1; c < t.length; c++) {
                    var p = t[c];
                    if (0 !== i) {
                        var u = p[0],
                            d = p[1];
                        n[0] = h * u - l * d, n[1] = l * u + h * d, p = n
                    }
                    for (var m = 0; m < 2; m++) p[m] > r[m] && (r[m] = p[m]), p[m] < a[m] && (a[m] = p[m])
                }
                e && (o.add(this.lowerBound, this.lowerBound, e), o.add(this.upperBound, this.upperBound, e)), s && (this.lowerBound[0] -= s, this.lowerBound[1] -= s, this.upperBound[0] += s, this.upperBound[1] += s)
            }, s.prototype.copy = function(t) {
                o.copy(this.lowerBound, t.lowerBound), o.copy(this.upperBound, t.upperBound)
            }, s.prototype.extend = function(t) {
                for (var e = 2; e--;) {
                    var i = t.lowerBound[e];
                    this.lowerBound[e] > i && (this.lowerBound[e] = i);
                    var s = t.upperBound[e];
                    this.upperBound[e] < s && (this.upperBound[e] = s)
                }
            }, s.prototype.overlaps = function(t) {
                var e = this.lowerBound,
                    i = this.upperBound,
                    s = t.lowerBound,
                    o = t.upperBound;
                return (s[0] <= i[0] && i[0] <= o[0] || e[0] <= o[0] && o[0] <= i[0]) && (s[1] <= i[1] && i[1] <= o[1] || e[1] <= o[1] && o[1] <= i[1])
            }, s.prototype.containsPoint = function(t) {
                var e = this.lowerBound,
                    i = this.upperBound;
                return e[0] <= t[0] && t[0] <= i[0] && e[1] <= t[1] && t[1] <= i[1]
            }, s.prototype.overlapsRay = function(t) {
                var e = 1 / t.direction[0],
                    i = 1 / t.direction[1],
                    s = (this.lowerBound[0] - t.from[0]) * e,
                    o = (this.upperBound[0] - t.from[0]) * e,
                    n = (this.lowerBound[1] - t.from[1]) * i,
                    a = (this.upperBound[1] - t.from[1]) * i,
                    r = Math.max(Math.max(Math.min(s, o), Math.min(n, a))),
                    h = Math.min(Math.min(Math.max(s, o), Math.max(n, a)));
                return h < 0 ? -1 : r > h ? -1 : r
            }
        }, {
            "../math/vec2": 30,
            "../utils/Utils": 57
        }],
        8: [function(t, e, i) {
            function s(t) {
                this.type = t, this.result = [], this.world = null, this.boundingVolumeType = s.AABB
            }
            var o = t("../math/vec2"),
                n = t("../objects/Body");
            e.exports = s, s.AABB = 1, s.BOUNDING_CIRCLE = 2, s.prototype.setWorld = function(t) {
                this.world = t
            }, s.prototype.getCollisionPairs = function(t) {};
            var a = o.create();
            s.boundingRadiusCheck = function(t, e) {
                o.sub(a, t.position, e.position);
                var i = o.squaredLength(a),
                    s = t.boundingRadius + e.boundingRadius;
                return i <= s * s
            }, s.aabbCheck = function(t, e) {
                return t.getAABB().overlaps(e.getAABB())
            }, s.prototype.boundingVolumeCheck = function(t, e) {
                var i;
                switch (this.boundingVolumeType) {
                    case s.BOUNDING_CIRCLE:
                        i = s.boundingRadiusCheck(t, e);
                        break;
                    case s.AABB:
                        i = s.aabbCheck(t, e);
                        break;
                    default:
                        throw new Error("Bounding volume type not recognized: " + this.boundingVolumeType)
                }
                return i
            }, s.canCollide = function(t, e) {
                var i = n.KINEMATIC,
                    s = n.STATIC;
                return !(t.type === s && e.type === s || t.type === i && e.type === s || t.type === s && e.type === i || t.type === i && e.type === i || t.sleepState === n.SLEEPING && e.sleepState === n.SLEEPING || t.sleepState === n.SLEEPING && e.type === s || e.sleepState === n.SLEEPING && t.type === s)
            }, s.NAIVE = 1, s.SAP = 2
        }, {
            "../math/vec2": 30,
            "../objects/Body": 31
        }],
        9: [function(t, e, i) {
            function s() {
                o.call(this, o.NAIVE)
            }
            var o = (t("../shapes/Circle"), t("../shapes/Plane"), t("../shapes/Shape"), t("../shapes/Particle"), t("../collision/Broadphase"));
            t("../math/vec2"), e.exports = s, (s.prototype = new o).constructor = s, s.prototype.getCollisionPairs = function(t) {
                var e = t.bodies,
                    i = this.result;
                i.length = 0;
                for (var s = 0, n = e.length; s !== n; s++)
                    for (var a = e[s], r = 0; r < s; r++) {
                        var h = e[r];
                        o.canCollide(a, h) && this.boundingVolumeCheck(a, h) && i.push(a, h)
                    }
                return i
            }, s.prototype.aabbQuery = function(t, e, i) {
                i = i || [];
                for (var s = t.bodies, o = 0; o < s.length; o++) {
                    var n = s[o];
                    n.aabbNeedsUpdate && n.updateAABB(), n.aabb.overlaps(e) && i.push(n)
                }
                return i
            }
        }, {
            "../collision/Broadphase": 8,
            "../math/vec2": 30,
            "../shapes/Circle": 39,
            "../shapes/Particle": 43,
            "../shapes/Plane": 44,
            "../shapes/Shape": 45
        }],
        10: [function(t, e, i) {
            function s() {
                this.contactEquations = [], this.frictionEquations = [], this.enableFriction = !0, this.enabledEquations = !0, this.slipForce = 10, this.frictionCoefficient = .3, this.surfaceVelocity = 0, this.contactEquationPool = new c({
                    size: 32
                }), this.frictionEquationPool = new p({
                    size: 64
                }), this.restitution = 0, this.stiffness = d.DEFAULT_STIFFNESS, this.relaxation = d.DEFAULT_RELAXATION, this.frictionStiffness = d.DEFAULT_STIFFNESS, this.frictionRelaxation = d.DEFAULT_RELAXATION, this.enableFrictionReduction = !0, this.collidingBodiesLastStep = new u, this.contactSkinSize = .01
            }

            function o(t, e) {
                a.set(t.vertices[0], .5 * -e.length, -e.radius), a.set(t.vertices[1], .5 * e.length, -e.radius), a.set(t.vertices[2], .5 * e.length, e.radius), a.set(t.vertices[3], .5 * -e.length, e.radius)
            }

            function n(t, e, i, s) {
                for (var o = K, n = H, l = q, c = J, p = t, u = e.vertices, d = null, m = 0; m !== u.length + 1; m++) {
                    var y = u[m % u.length],
                        f = u[(m + 1) % u.length];
                    a.rotate(o, y, s), a.rotate(n, f, s), h(o, o, i), h(n, n, i), r(l, o, p), r(c, n, p);
                    var g = a.crossLength(l, c);
                    if (null === d && (d = g), g * d <= 0) return !1;
                    d = g
                }
                return !0
            }
            var a = t("../math/vec2"),
                r = a.sub,
                h = a.add,
                l = a.dot,
                c = (t("../utils/Utils"), t("../utils/ContactEquationPool")),
                p = t("../utils/FrictionEquationPool"),
                u = t("../utils/TupleDictionary"),
                d = t("../equations/Equation"),
                m = (t("../equations/ContactEquation"), t("../equations/FrictionEquation"), t("../shapes/Circle")),
                y = t("../shapes/Convex"),
                f = t("../shapes/Shape"),
                g = (t("../objects/Body"), t("../shapes/Box"));
            e.exports = s;
            var _ = a.fromValues(0, 1),
                v = a.fromValues(0, 0),
                b = a.fromValues(0, 0),
                x = a.fromValues(0, 0),
                C = a.fromValues(0, 0),
                S = a.fromValues(0, 0),
                w = a.fromValues(0, 0),
                A = a.fromValues(0, 0),
                T = a.fromValues(0, 0),
                B = a.fromValues(0, 0),
                P = a.fromValues(0, 0),
                D = a.fromValues(0, 0),
                I = a.fromValues(0, 0),
                E = a.fromValues(0, 0),
                L = a.fromValues(0, 0),
                M = a.fromValues(0, 0),
                G = a.fromValues(0, 0),
                O = a.fromValues(0, 0),
                R = a.fromValues(0, 0),
                k = [],
                F = a.create(),
                N = a.create();
            s.prototype.bodiesOverlap = function(t, e) {
                for (var i = F, s = N, o = 0, n = t.shapes.length; o !== n; o++) {
                    var a = t.shapes[o];
                    t.toWorldFrame(i, a.position);
                    for (var r = 0, h = e.shapes.length; r !== h; r++) {
                        var l = e.shapes[r];
                        if (e.toWorldFrame(s, l.position), this[a.type | l.type](t, a, i, a.angle + t.angle, e, l, s, l.angle + e.angle, !0)) return !0
                    }
                }
                return !1
            }, s.prototype.collidedLastStep = function(t, e) {
                var i = 0 | t.id,
                    s = 0 | e.id;
                return !!this.collidingBodiesLastStep.get(i, s)
            }, s.prototype.reset = function() {
                this.collidingBodiesLastStep.reset();
                for (var t = this.contactEquations, e = t.length; e--;) {
                    var i = t[e],
                        s = i.bodyA.id,
                        o = i.bodyB.id;
                    this.collidingBodiesLastStep.set(s, o, !0)
                }
                for (var n = this.contactEquations, a = this.frictionEquations, r = 0; r < n.length; r++) this.contactEquationPool.release(n[r]);
                for (r = 0; r < a.length; r++) this.frictionEquationPool.release(a[r]);
                this.contactEquations.length = this.frictionEquations.length = 0
            }, s.prototype.createContactEquation = function(t, e, i, s) {
                var o = this.contactEquationPool.get();
                return o.bodyA = t, o.bodyB = e, o.shapeA = i, o.shapeB = s, o.restitution = this.restitution, o.firstImpact = !this.collidedLastStep(t, e), o.stiffness = this.stiffness, o.relaxation = this.relaxation, o.needsUpdate = !0, o.enabled = this.enabledEquations, o.offset = this.contactSkinSize, o
            }, s.prototype.createFrictionEquation = function(t, e, i, s) {
                var o = this.frictionEquationPool.get();
                return o.bodyA = t, o.bodyB = e, o.shapeA = i, o.shapeB = s, o.setSlipForce(this.slipForce), o.frictionCoefficient = this.frictionCoefficient, o.relativeVelocity = this.surfaceVelocity, o.enabled = this.enabledEquations, o.needsUpdate = !0, o.stiffness = this.frictionStiffness, o.relaxation = this.frictionRelaxation, o.contactEquations.length = 0, o
            }, s.prototype.createFrictionFromContact = function(t) {
                var e = this.createFrictionEquation(t.bodyA, t.bodyB, t.shapeA, t.shapeB);
                return a.copy(e.contactPointA, t.contactPointA), a.copy(e.contactPointB, t.contactPointB), a.rotate90cw(e.t, t.normalA), e.contactEquations.push(t), e
            }, s.prototype.createFrictionFromAverage = function(t) {
                var e = this.contactEquations[this.contactEquations.length - 1],
                    i = this.createFrictionEquation(e.bodyA, e.bodyB, e.shapeA, e.shapeB),
                    s = e.bodyA;
                e.bodyB, a.set(i.contactPointA, 0, 0), a.set(i.contactPointB, 0, 0), a.set(i.t, 0, 0);
                for (var o = 0; o !== t; o++)(e = this.contactEquations[this.contactEquations.length - 1 - o]).bodyA === s ? (a.add(i.t, i.t, e.normalA), a.add(i.contactPointA, i.contactPointA, e.contactPointA), a.add(i.contactPointB, i.contactPointB, e.contactPointB)) : (a.sub(i.t, i.t, e.normalA), a.add(i.contactPointA, i.contactPointA, e.contactPointB), a.add(i.contactPointB, i.contactPointB, e.contactPointA)), i.contactEquations.push(e);
                var n = 1 / t;
                return a.scale(i.contactPointA, i.contactPointA, n), a.scale(i.contactPointB, i.contactPointB, n), a.normalize(i.t, i.t), a.rotate90cw(i.t, i.t), i
            }, s.prototype[f.LINE | f.CONVEX] = s.prototype.convexLine = function(t, e, i, s, o, n, a, r, h) {
                return !h && 0
            }, s.prototype[f.LINE | f.BOX] = s.prototype.lineBox = function(t, e, i, s, o, n, a, r, h) {
                return !h && 0
            };
            var V = new g({
                    width: 1,
                    height: 1
                }),
                U = a.create();
            s.prototype[f.CAPSULE | f.CONVEX] = s.prototype[f.CAPSULE | f.BOX] = s.prototype.convexCapsule = function(t, e, i, s, n, r, h, l, c) {
                var p = U;
                a.set(p, r.length / 2, 0), a.rotate(p, p, l), a.add(p, p, h);
                var u = this.circleConvex(n, r, p, l, t, e, i, s, c, r.radius);
                a.set(p, -r.length / 2, 0), a.rotate(p, p, l), a.add(p, p, h);
                var d = this.circleConvex(n, r, p, l, t, e, i, s, c, r.radius);
                if (c && (u || d)) return !0;
                var m = V;
                return o(m, r), this.convexConvex(t, e, i, s, n, m, h, l, c) + u + d
            }, s.prototype[f.CAPSULE | f.LINE] = s.prototype.lineCapsule = function(t, e, i, s, o, n, a, r, h) {
                return !h && 0
            };
            var W = a.create(),
                j = a.create(),
                X = new g({
                    width: 1,
                    height: 1
                });
            s.prototype[f.CAPSULE | f.CAPSULE] = s.prototype.capsuleCapsule = function(t, e, i, s, n, r, h, l, c) {
                for (var p = W, u = j, d = 0, m = 0; m < 2; m++) {
                    a.set(p, (0 === m ? -1 : 1) * e.length / 2, 0), a.rotate(p, p, s), a.add(p, p, i);
                    for (var y = 0; y < 2; y++) {
                        a.set(u, (0 === y ? -1 : 1) * r.length / 2, 0), a.rotate(u, u, l), a.add(u, u, h), this.enableFrictionReduction && (v = this.enableFriction, this.enableFriction = !1);
                        var f = this.circleCircle(t, e, p, s, n, r, u, l, c, e.radius, r.radius);
                        if (this.enableFrictionReduction && (this.enableFriction = v), c && f) return !0;
                        d += f
                    }
                }
                this.enableFrictionReduction && (v = this.enableFriction, this.enableFriction = !1);
                var g = X;
                o(g, e);
                var _ = this.convexCapsule(t, g, i, s, n, r, h, l, c);
                if (this.enableFrictionReduction && (this.enableFriction = v), c && _) return !0;
                if (d += _, this.enableFrictionReduction) {
                    var v = this.enableFriction;
                    this.enableFriction = !1
                }
                o(g, r);
                var b = this.convexCapsule(n, g, h, l, t, e, i, s, c);
                return this.enableFrictionReduction && (this.enableFriction = v), !(!c || !b) || (d += b, this.enableFrictionReduction && d && this.enableFriction && this.frictionEquations.push(this.createFrictionFromAverage(d)), d)
            }, s.prototype[f.LINE | f.LINE] = s.prototype.lineLine = function(t, e, i, s, o, n, a, r, h) {
                return !h && 0
            }, s.prototype[f.PLANE | f.LINE] = s.prototype.planeLine = function(t, e, i, s, o, n, c, p, u) {
                var d = v,
                    m = b,
                    y = x,
                    f = C,
                    g = S,
                    P = w,
                    D = A,
                    I = T,
                    E = B,
                    L = k,
                    M = 0;
                a.set(d, -n.length / 2, 0), a.set(m, n.length / 2, 0), a.rotate(y, d, p), a.rotate(f, m, p), h(y, y, c), h(f, f, c), a.copy(d, y), a.copy(m, f), r(g, m, d), a.normalize(P, g), a.rotate90cw(E, P), a.rotate(I, _, s), L[0] = d, L[1] = m;
                for (var G = 0; G < L.length; G++) {
                    var O = L[G];
                    r(D, O, i);
                    var R = l(D, I);
                    if (R < 0) {
                        if (u) return !0;
                        var F = this.createContactEquation(t, o, e, n);
                        M++, a.copy(F.normalA, I), a.normalize(F.normalA, F.normalA), a.scale(D, I, R), r(F.contactPointA, O, D), r(F.contactPointA, F.contactPointA, t.position), r(F.contactPointB, O, c), h(F.contactPointB, F.contactPointB, c), r(F.contactPointB, F.contactPointB, o.position), this.contactEquations.push(F), this.enableFrictionReduction || this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(F))
                    }
                }
                return !u && (this.enableFrictionReduction || M && this.enableFriction && this.frictionEquations.push(this.createFrictionFromAverage(M)), M)
            }, s.prototype[f.PARTICLE | f.CAPSULE] = s.prototype.particleCapsule = function(t, e, i, s, o, n, a, r, h) {
                return this.circleLine(t, e, i, s, o, n, a, r, h, n.radius, 0)
            }, s.prototype[f.CIRCLE | f.LINE] = s.prototype.circleLine = function(t, e, i, s, o, n, c, p, u, d, m) {
                var d = d || 0,
                    m = void 0 !== m ? m : e.radius,
                    y = v,
                    f = b,
                    g = x,
                    _ = C,
                    M = S,
                    G = w,
                    O = A,
                    R = T,
                    F = B,
                    N = P,
                    V = D,
                    U = I,
                    W = E,
                    j = L,
                    X = k;
                a.set(R, -n.length / 2, 0), a.set(F, n.length / 2, 0), a.rotate(N, R, p), a.rotate(V, F, p), h(N, N, c), h(V, V, c), a.copy(R, N), a.copy(F, V), r(G, F, R), a.normalize(O, G), a.rotate90cw(M, O), r(U, i, R);
                var K = l(U, M);
                r(_, R, c), r(W, i, c);
                var H = m + d;
                if (Math.abs(K) < H) {
                    a.scale(y, M, K), r(g, i, y), a.scale(f, M, l(M, W)), a.normalize(f, f), a.scale(f, f, d), h(g, g, f);
                    var q = l(O, g),
                        J = l(O, R),
                        z = l(O, F);
                    if (q > J && q < z) {
                        if (u) return !0;
                        Q = this.createContactEquation(t, o, e, n);
                        return a.scale(Q.normalA, y, -1), a.normalize(Q.normalA, Q.normalA), a.scale(Q.contactPointA, Q.normalA, m), h(Q.contactPointA, Q.contactPointA, i), r(Q.contactPointA, Q.contactPointA, t.position), r(Q.contactPointB, g, c), h(Q.contactPointB, Q.contactPointB, c), r(Q.contactPointB, Q.contactPointB, o.position), this.contactEquations.push(Q), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(Q)), 1
                    }
                }
                X[0] = R, X[1] = F;
                for (var Y = 0; Y < X.length; Y++) {
                    var Z = X[Y];
                    if (r(U, Z, i), a.squaredLength(U) < Math.pow(H, 2)) {
                        if (u) return !0;
                        var Q = this.createContactEquation(t, o, e, n);
                        return a.copy(Q.normalA, U), a.normalize(Q.normalA, Q.normalA), a.scale(Q.contactPointA, Q.normalA, m), h(Q.contactPointA, Q.contactPointA, i), r(Q.contactPointA, Q.contactPointA, t.position), r(Q.contactPointB, Z, c), a.scale(j, Q.normalA, -d), h(Q.contactPointB, Q.contactPointB, j), h(Q.contactPointB, Q.contactPointB, c), r(Q.contactPointB, Q.contactPointB, o.position), this.contactEquations.push(Q), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(Q)), 1
                    }
                }
                return 0
            }, s.prototype[f.CIRCLE | f.CAPSULE] = s.prototype.circleCapsule = function(t, e, i, s, o, n, a, r, h) {
                return this.circleLine(t, e, i, s, o, n, a, r, h, n.radius)
            }, s.prototype[f.CIRCLE | f.CONVEX] = s.prototype[f.CIRCLE | f.BOX] = s.prototype.circleConvex = function(t, e, i, s, o, l, c, p, u, d) {
                for (var d = "number" == typeof d ? d : e.radius, m = v, y = b, f = x, g = C, _ = S, w = P, A = D, T = E, B = L, I = M, O = G, R = !1, k = Number.MAX_VALUE, F = l.vertices, N = 0; N !== F.length + 1; N++) {
                    var V = F[N % F.length],
                        U = F[(N + 1) % F.length];
                    if (a.rotate(m, V, p), a.rotate(y, U, p), h(m, m, c), h(y, y, c), r(f, y, m), a.normalize(g, f), a.rotate90cw(_, g), a.scale(B, _, -e.radius), h(B, B, i), n(B, l, c, p)) {
                        a.sub(I, m, B);
                        var W = Math.abs(a.dot(I, _));
                        W < k && (a.copy(O, B), k = W, a.scale(T, _, W), a.add(T, T, B), R = !0)
                    }
                }
                if (R) {
                    if (u) return !0;
                    X = this.createContactEquation(t, o, e, l);
                    return a.sub(X.normalA, O, i), a.normalize(X.normalA, X.normalA), a.scale(X.contactPointA, X.normalA, d), h(X.contactPointA, X.contactPointA, i), r(X.contactPointA, X.contactPointA, t.position), r(X.contactPointB, T, c), h(X.contactPointB, X.contactPointB, c), r(X.contactPointB, X.contactPointB, o.position), this.contactEquations.push(X), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(X)), 1
                }
                if (d > 0)
                    for (N = 0; N < F.length; N++) {
                        var j = F[N];
                        if (a.rotate(A, j, p), h(A, A, c), r(w, A, i), a.squaredLength(w) < Math.pow(d, 2)) {
                            if (u) return !0;
                            var X = this.createContactEquation(t, o, e, l);
                            return a.copy(X.normalA, w), a.normalize(X.normalA, X.normalA), a.scale(X.contactPointA, X.normalA, d), h(X.contactPointA, X.contactPointA, i), r(X.contactPointA, X.contactPointA, t.position), r(X.contactPointB, A, c), h(X.contactPointB, X.contactPointB, c), r(X.contactPointB, X.contactPointB, o.position), this.contactEquations.push(X), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(X)), 1
                        }
                    }
                return 0
            };
            var K = a.create(),
                H = a.create(),
                q = a.create(),
                J = a.create();
            s.prototype[f.PARTICLE | f.CONVEX] = s.prototype[f.PARTICLE | f.BOX] = s.prototype.particleConvex = function(t, e, i, s, o, c, p, u, d) {
                var m = v,
                    y = b,
                    f = x,
                    g = C,
                    _ = S,
                    T = w,
                    B = A,
                    D = P,
                    I = E,
                    L = O,
                    M = R,
                    G = Number.MAX_VALUE,
                    k = !1,
                    F = c.vertices;
                if (!n(i, c, p, u)) return 0;
                if (d) return !0;
                for (var N = 0; N !== F.length + 1; N++) {
                    var V = F[N % F.length],
                        U = F[(N + 1) % F.length];
                    a.rotate(m, V, u), a.rotate(y, U, u), h(m, m, p), h(y, y, p), r(f, y, m), a.normalize(g, f), a.rotate90cw(_, g), r(D, i, m), l(D, _), r(T, m, p), r(B, i, p), a.sub(L, m, i);
                    var W = Math.abs(a.dot(L, _));
                    W < G && (G = W, a.scale(I, _, W), a.add(I, I, i), a.copy(M, _), k = !0)
                }
                if (k) {
                    var j = this.createContactEquation(t, o, e, c);
                    return a.scale(j.normalA, M, -1), a.normalize(j.normalA, j.normalA), a.set(j.contactPointA, 0, 0), h(j.contactPointA, j.contactPointA, i), r(j.contactPointA, j.contactPointA, t.position), r(j.contactPointB, I, p), h(j.contactPointB, j.contactPointB, p), r(j.contactPointB, j.contactPointB, o.position), this.contactEquations.push(j), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(j)), 1
                }
                return 0
            }, s.prototype[f.CIRCLE] = s.prototype.circleCircle = function(t, e, i, s, o, n, l, c, p, u, d) {
                var m = v,
                    u = u || e.radius,
                    d = d || n.radius;
                r(m, i, l);
                var y = u + d;
                if (a.squaredLength(m) > Math.pow(y, 2)) return 0;
                if (p) return !0;
                var f = this.createContactEquation(t, o, e, n);
                return r(f.normalA, l, i), a.normalize(f.normalA, f.normalA), a.scale(f.contactPointA, f.normalA, u), a.scale(f.contactPointB, f.normalA, -d), h(f.contactPointA, f.contactPointA, i), r(f.contactPointA, f.contactPointA, t.position), h(f.contactPointB, f.contactPointB, l), r(f.contactPointB, f.contactPointB, o.position), this.contactEquations.push(f), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(f)), 1
            }, s.prototype[f.PLANE | f.CONVEX] = s.prototype[f.PLANE | f.BOX] = s.prototype.planeConvex = function(t, e, i, s, o, n, c, p, u) {
                var d = v,
                    m = b,
                    y = x,
                    f = 0;
                a.rotate(m, _, s);
                for (var g = 0; g !== n.vertices.length; g++) {
                    var C = n.vertices[g];
                    if (a.rotate(d, C, p), h(d, d, c), r(y, d, i), l(y, m) <= 0) {
                        if (u) return !0;
                        f++;
                        var S = this.createContactEquation(t, o, e, n);
                        r(y, d, i), a.copy(S.normalA, m);
                        var w = l(y, S.normalA);
                        a.scale(y, S.normalA, w), r(S.contactPointB, d, o.position), r(S.contactPointA, d, y), r(S.contactPointA, S.contactPointA, t.position), this.contactEquations.push(S), this.enableFrictionReduction || this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(S))
                    }
                }
                return this.enableFrictionReduction && this.enableFriction && f && this.frictionEquations.push(this.createFrictionFromAverage(f)), f
            }, s.prototype[f.PARTICLE | f.PLANE] = s.prototype.particlePlane = function(t, e, i, s, o, n, h, c, p) {
                var u = v,
                    d = b;
                c = c || 0, r(u, i, h), a.rotate(d, _, c);
                var m = l(u, d);
                if (m > 0) return 0;
                if (p) return !0;
                var y = this.createContactEquation(o, t, n, e);
                return a.copy(y.normalA, d), a.scale(u, y.normalA, m), r(y.contactPointA, i, u), r(y.contactPointA, y.contactPointA, o.position), r(y.contactPointB, i, t.position), this.contactEquations.push(y), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(y)), 1
            }, s.prototype[f.CIRCLE | f.PARTICLE] = s.prototype.circleParticle = function(t, e, i, s, o, n, l, c, p) {
                var u = v;
                if (r(u, l, i), a.squaredLength(u) > Math.pow(e.radius, 2)) return 0;
                if (p) return !0;
                var d = this.createContactEquation(t, o, e, n);
                return a.copy(d.normalA, u), a.normalize(d.normalA, d.normalA), a.scale(d.contactPointA, d.normalA, e.radius), h(d.contactPointA, d.contactPointA, i), r(d.contactPointA, d.contactPointA, t.position), r(d.contactPointB, l, o.position), this.contactEquations.push(d), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(d)), 1
            };
            var z = new m({
                    radius: 1
                }),
                Y = a.create(),
                Z = a.create();
            a.create(), s.prototype[f.PLANE | f.CAPSULE] = s.prototype.planeCapsule = function(t, e, i, s, o, n, r, l, c) {
                var p = Y,
                    u = Z,
                    d = z;
                a.set(p, -n.length / 2, 0), a.rotate(p, p, l), h(p, p, r), a.set(u, n.length / 2, 0), a.rotate(u, u, l), h(u, u, r), d.radius = n.radius;
                var m;
                this.enableFrictionReduction && (m = this.enableFriction, this.enableFriction = !1);
                var y = this.circlePlane(o, d, p, 0, t, e, i, s, c),
                    f = this.circlePlane(o, d, u, 0, t, e, i, s, c);
                if (this.enableFrictionReduction && (this.enableFriction = m), c) return y || f;
                var g = y + f;
                return this.enableFrictionReduction && g && this.frictionEquations.push(this.createFrictionFromAverage(g)), g
            }, s.prototype[f.CIRCLE | f.PLANE] = s.prototype.circlePlane = function(t, e, i, s, o, n, c, p, u) {
                var d = t,
                    m = e,
                    y = i,
                    f = o,
                    g = c,
                    C = p;
                C = C || 0;
                var S = v,
                    w = b,
                    A = x;
                r(S, y, g), a.rotate(w, _, C);
                var T = l(w, S);
                if (T > m.radius) return 0;
                if (u) return !0;
                var B = this.createContactEquation(f, d, n, e);
                return a.copy(B.normalA, w), a.scale(B.contactPointB, B.normalA, -m.radius), h(B.contactPointB, B.contactPointB, y), r(B.contactPointB, B.contactPointB, d.position), a.scale(A, B.normalA, T), r(B.contactPointA, S, A), h(B.contactPointA, B.contactPointA, g), r(B.contactPointA, B.contactPointA, f.position), this.contactEquations.push(B), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(B)), 1
            }, s.prototype[f.CONVEX] = s.prototype[f.CONVEX | f.BOX] = s.prototype[f.BOX] = s.prototype.convexConvex = function(t, e, i, o, n, c, p, u, d, m) {
                var y = v,
                    f = b,
                    g = x,
                    _ = C,
                    w = S,
                    P = A,
                    D = T,
                    I = B,
                    E = 0,
                    m = "number" == typeof m ? m : 0;
                if (!s.findSeparatingAxis(e, i, o, c, p, u, y)) return 0;
                r(D, p, i), l(y, D) > 0 && a.scale(y, y, -1);
                var L = s.getClosestEdge(e, o, y, !0),
                    M = s.getClosestEdge(c, u, y);
                if (-1 === L || -1 === M) return 0;
                for (var G = 0; G < 2; G++) {
                    var O = L,
                        R = M,
                        k = e,
                        F = c,
                        N = i,
                        V = p,
                        U = o,
                        W = u,
                        j = t,
                        X = n;
                    if (0 === G) {
                        var K;
                        K = O, O = R, R = K, K = k, k = F, F = K, K = N, N = V, V = K, K = U, U = W, W = K, K = j, j = X, X = K
                    }
                    for (var H = R; H < R + 2; H++) {
                        var q = F.vertices[(H + F.vertices.length) % F.vertices.length];
                        a.rotate(f, q, W), h(f, f, V);
                        for (var J = 0, z = O - 1; z < O + 2; z++) {
                            var Y = k.vertices[(z + k.vertices.length) % k.vertices.length],
                                Z = k.vertices[(z + 1 + k.vertices.length) % k.vertices.length];
                            a.rotate(g, Y, U), a.rotate(_, Z, U), h(g, g, N), h(_, _, N), r(w, _, g), a.rotate90cw(I, w), a.normalize(I, I), r(D, f, g);
                            $ = l(I, D);
                            (z === O && $ <= m || z !== O && $ <= 0) && J++
                        }
                        if (J >= 3) {
                            if (d) return !0;
                            var Q = this.createContactEquation(j, X, k, F);
                            E++;
                            var Y = k.vertices[O % k.vertices.length],
                                Z = k.vertices[(O + 1) % k.vertices.length];
                            a.rotate(g, Y, U), a.rotate(_, Z, U), h(g, g, N), h(_, _, N), r(w, _, g), a.rotate90cw(Q.normalA, w), a.normalize(Q.normalA, Q.normalA), r(D, f, g);
                            var $ = l(Q.normalA, D);
                            a.scale(P, Q.normalA, $), r(Q.contactPointA, f, N), r(Q.contactPointA, Q.contactPointA, P), h(Q.contactPointA, Q.contactPointA, N), r(Q.contactPointA, Q.contactPointA, j.position), r(Q.contactPointB, f, V), h(Q.contactPointB, Q.contactPointB, V), r(Q.contactPointB, Q.contactPointB, X.position), this.contactEquations.push(Q), this.enableFrictionReduction || this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(Q))
                        }
                    }
                }
                return this.enableFrictionReduction && this.enableFriction && E && this.frictionEquations.push(this.createFrictionFromAverage(E)), E
            };
            var Q = a.fromValues(0, 0);
            s.projectConvexOntoAxis = function(t, e, i, s, o) {
                var n, r, h = null,
                    c = null,
                    p = Q;
                a.rotate(p, s, -i);
                for (var u = 0; u < t.vertices.length; u++) n = t.vertices[u], r = l(n, p), (null === h || r > h) && (h = r), (null === c || r < c) && (c = r);
                if (c > h) {
                    var d = c;
                    c = h, h = d
                }
                var m = l(e, s);
                a.set(o, c + m, h + m)
            };
            var $ = a.fromValues(0, 0),
                tt = a.fromValues(0, 0),
                et = a.fromValues(0, 0),
                it = a.fromValues(0, 0),
                st = a.fromValues(0, 0),
                ot = a.fromValues(0, 0);
            s.findSeparatingAxis = function(t, e, i, o, n, h, l) {
                var c = null,
                    p = !1,
                    u = !1,
                    d = $,
                    m = tt,
                    y = et,
                    f = it,
                    _ = st,
                    v = ot;
                if (t instanceof g && o instanceof g)
                    for (w = 0; 2 !== w; w++) {
                        var b = t,
                            x = i;
                        1 === w && (b = o, x = h);
                        for (A = 0; 2 !== A; A++) {
                            0 === A ? a.set(f, 0, 1) : 1 === A && a.set(f, 1, 0), 0 !== x && a.rotate(f, f, x), s.projectConvexOntoAxis(t, e, i, f, _), s.projectConvexOntoAxis(o, n, h, f, v);
                            var C = _,
                                S = v;
                            _[0] > v[0] && (S = _, C = v, !0), p = (T = S[0] - C[1]) <= 0, (null === c || T > c) && (a.copy(l, f), c = T, u = p)
                        }
                    } else
                        for (var w = 0; 2 !== w; w++) {
                            var b = t,
                                x = i;
                            1 === w && (b = o, x = h);
                            for (var A = 0; A !== b.vertices.length; A++) {
                                a.rotate(m, b.vertices[A], x), a.rotate(y, b.vertices[(A + 1) % b.vertices.length], x), r(d, y, m), a.rotate90cw(f, d), a.normalize(f, f), s.projectConvexOntoAxis(t, e, i, f, _), s.projectConvexOntoAxis(o, n, h, f, v);
                                var C = _,
                                    S = v;
                                _[0] > v[0] && (S = _, C = v, !0);
                                var T = S[0] - C[1];
                                p = T <= 0, (null === c || T > c) && (a.copy(l, f), c = T, u = p)
                            }
                        }
                return u
            };
            var nt = a.fromValues(0, 0),
                at = a.fromValues(0, 0),
                rt = a.fromValues(0, 0);
            s.getClosestEdge = function(t, e, i, s) {
                var o = nt,
                    n = at,
                    h = rt;
                a.rotate(o, i, -e), s && a.scale(o, o, -1);
                for (var c = -1, p = t.vertices.length, u = -1, d = 0; d !== p; d++) {
                    r(n, t.vertices[(d + 1) % p], t.vertices[d % p]), a.rotate90cw(h, n), a.normalize(h, h);
                    var m = l(h, o);
                    (-1 === c || m > u) && (c = d % p, u = m)
                }
                return c
            };
            var ht = a.create(),
                lt = a.create(),
                ct = a.create(),
                pt = a.create(),
                ut = a.create(),
                dt = a.create(),
                mt = a.create();
            s.prototype[f.CIRCLE | f.HEIGHTFIELD] = s.prototype.circleHeightfield = function(t, e, i, s, o, n, l, c, p, u) {
                var d = n.heights,
                    u = u || e.radius,
                    m = n.elementWidth,
                    y = lt,
                    f = ht,
                    g = ut,
                    _ = mt,
                    v = dt,
                    b = ct,
                    x = pt,
                    C = Math.floor((i[0] - u - l[0]) / m),
                    S = Math.ceil((i[0] + u - l[0]) / m);
                C < 0 && (C = 0), S >= d.length && (S = d.length - 1);
                for (var w = d[C], A = d[S], T = C; T < S; T++) d[T] < A && (A = d[T]), d[T] > w && (w = d[T]);
                if (i[1] - u > w) return !p && 0;
                for (var B = !1, T = C; T < S; T++) {
                    a.set(b, T * m, d[T]), a.set(x, (T + 1) * m, d[T + 1]), a.add(b, b, l), a.add(x, x, l), a.sub(v, x, b), a.rotate(v, v, Math.PI / 2), a.normalize(v, v), a.scale(f, v, -u), a.add(f, f, i), a.sub(y, f, b);
                    var P = a.dot(y, v);
                    if (f[0] >= b[0] && f[0] < x[0] && P <= 0) {
                        if (p) return !0;
                        B = !0, a.scale(y, v, -P), a.add(g, f, y), a.copy(_, v);
                        D = this.createContactEquation(o, t, n, e);
                        a.copy(D.normalA, _), a.scale(D.contactPointB, D.normalA, -u), h(D.contactPointB, D.contactPointB, i), r(D.contactPointB, D.contactPointB, t.position), a.copy(D.contactPointA, g), a.sub(D.contactPointA, D.contactPointA, o.position), this.contactEquations.push(D), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(D))
                    }
                }
                if (B = !1, u > 0)
                    for (T = C; T <= S; T++)
                        if (a.set(b, T * m, d[T]), a.add(b, b, l), a.sub(y, i, b), a.squaredLength(y) < Math.pow(u, 2)) {
                            if (p) return !0;
                            B = !0;
                            var D = this.createContactEquation(o, t, n, e);
                            a.copy(D.normalA, y), a.normalize(D.normalA, D.normalA), a.scale(D.contactPointB, D.normalA, -u), h(D.contactPointB, D.contactPointB, i), r(D.contactPointB, D.contactPointB, t.position), r(D.contactPointA, b, l), h(D.contactPointA, D.contactPointA, l), r(D.contactPointA, D.contactPointA, o.position), this.contactEquations.push(D), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(D))
                        }
                return B ? 1 : 0
            };
            var yt = a.create(),
                ft = a.create(),
                gt = a.create(),
                _t = new y({
                    vertices: [a.create(), a.create(), a.create(), a.create()]
                });
            s.prototype[f.BOX | f.HEIGHTFIELD] = s.prototype[f.CONVEX | f.HEIGHTFIELD] = s.prototype.convexHeightfield = function(t, e, i, s, o, n, r, h, l) {
                var c = n.heights,
                    p = n.elementWidth,
                    u = yt,
                    d = ft,
                    m = gt,
                    y = _t,
                    f = Math.floor((t.aabb.lowerBound[0] - r[0]) / p),
                    g = Math.ceil((t.aabb.upperBound[0] - r[0]) / p);
                f < 0 && (f = 0), g >= c.length && (g = c.length - 1);
                for (var _ = c[f], v = c[g], b = f; b < g; b++) c[b] < v && (v = c[b]), c[b] > _ && (_ = c[b]);
                if (t.aabb.lowerBound[1] > _) return !l && 0;
                for (var x = 0, b = f; b < g; b++) {
                    a.set(u, b * p, c[b]), a.set(d, (b + 1) * p, c[b + 1]), a.add(u, u, r), a.add(d, d, r);
                    a.set(m, .5 * (d[0] + u[0]), .5 * (d[1] + u[1] - 100)), a.sub(y.vertices[0], d, m), a.sub(y.vertices[1], u, m), a.copy(y.vertices[2], y.vertices[1]), a.copy(y.vertices[3], y.vertices[0]), y.vertices[2][1] -= 100, y.vertices[3][1] -= 100, x += this.convexConvex(t, e, i, s, o, y, m, 0, l)
                }
                return x
            }
        }, {
            "../equations/ContactEquation": 21,
            "../equations/Equation": 22,
            "../equations/FrictionEquation": 23,
            "../math/vec2": 30,
            "../objects/Body": 31,
            "../shapes/Box": 37,
            "../shapes/Circle": 39,
            "../shapes/Convex": 40,
            "../shapes/Shape": 45,
            "../utils/ContactEquationPool": 48,
            "../utils/FrictionEquationPool": 49,
            "../utils/TupleDictionary": 56,
            "../utils/Utils": 57
        }],
        11: [function(t, e, i) {
            function s(t) {
                t = t || {}, this.from = t.from ? n.fromValues(t.from[0], t.from[1]) : n.create(), this.to = t.to ? n.fromValues(t.to[0], t.to[1]) : n.create(), this.checkCollisionResponse = void 0 === t.checkCollisionResponse || t.checkCollisionResponse, this.skipBackfaces = !!t.skipBackfaces, this.collisionMask = void 0 !== t.collisionMask ? t.collisionMask : -1, this.collisionGroup = void 0 !== t.collisionGroup ? t.collisionGroup : -1, this.mode = void 0 !== t.mode ? t.mode : s.ANY, this.callback = t.callback || function(t) {}, this.direction = n.create(), this.length = 1, this.update()
            }

            function o(t, e, i) {
                n.sub(r, i, t);
                var s = n.dot(r, e);
                return n.scale(h, e, s), n.add(h, h, t), n.squaredDistance(i, h)
            }
            e.exports = s;
            var n = t("../math/vec2");
            t("../collision/RaycastResult"), t("../shapes/Shape"), t("../collision/AABB"), s.prototype.constructor = s, s.CLOSEST = 1, s.ANY = 2, s.ALL = 4, s.prototype.update = function() {
                var t = this.direction;
                n.sub(t, this.to, this.from), this.length = n.length(t), n.normalize(t, t)
            }, s.prototype.intersectBodies = function(t, e) {
                for (var i = 0, s = e.length; !t.shouldStop(this) && i < s; i++) {
                    var o = e[i],
                        n = o.getAABB();
                    (n.overlapsRay(this) >= 0 || n.containsPoint(this.from)) && this.intersectBody(t, o)
                }
            };
            var a = n.create();
            s.prototype.intersectBody = function(t, e) {
                var i = this.checkCollisionResponse;
                if (!i || e.collisionResponse)
                    for (var s = a, o = 0, r = e.shapes.length; o < r; o++) {
                        var h = e.shapes[o];
                        if ((!i || h.collisionResponse) && 0 != (this.collisionGroup & h.collisionMask) && 0 != (h.collisionGroup & this.collisionMask)) {
                            n.rotate(s, h.position, e.angle), n.add(s, s, e.position);
                            var l = h.angle + e.angle;
                            if (this.intersectShape(t, h, l, s, e), t.shouldStop(this)) break
                        }
                    }
            }, s.prototype.intersectShape = function(t, e, i, s, n) {
                o(this.from, this.direction, s) > e.boundingRadius * e.boundingRadius || (this._currentBody = n, this._currentShape = e, e.raycast(t, this, s, i), this._currentBody = this._currentShape = null)
            }, s.prototype.getAABB = function(t) {
                var e = this.to,
                    i = this.from;
                n.set(t.lowerBound, Math.min(e[0], i[0]), Math.min(e[1], i[1])), n.set(t.upperBound, Math.max(e[0], i[0]), Math.max(e[1], i[1]))
            }, n.create(), s.prototype.reportIntersection = function(t, e, i, o) {
                var a = (this.from, this.to, this._currentShape),
                    r = this._currentBody;
                if (!(this.skipBackfaces && n.dot(i, this.direction) > 0)) switch (this.mode) {
                    case s.ALL:
                        t.set(i, a, r, e, o), this.callback(t);
                        break;
                    case s.CLOSEST:
                        (e < t.fraction || !t.hasHit()) && t.set(i, a, r, e, o);
                        break;
                    case s.ANY:
                        t.set(i, a, r, e, o)
                }
            };
            var r = n.create(),
                h = n.create()
        }, {
            "../collision/AABB": 7,
            "../collision/RaycastResult": 12,
            "../math/vec2": 30,
            "../shapes/Shape": 45
        }],
        12: [function(t, e, i) {
            function s() {
                this.normal = o.create(), this.shape = null, this.body = null, this.faceIndex = -1, this.fraction = -1, this.isStopped = !1
            }
            var o = t("../math/vec2"),
                n = t("../collision/Ray");
            e.exports = s, s.prototype.reset = function() {
                o.set(this.normal, 0, 0), this.shape = null, this.body = null, this.faceIndex = -1, this.fraction = -1, this.isStopped = !1
            }, s.prototype.getHitDistance = function(t) {
                return o.distance(t.from, t.to) * this.fraction
            }, s.prototype.hasHit = function() {
                return -1 !== this.fraction
            }, s.prototype.getHitPoint = function(t, e) {
                o.lerp(t, e.from, e.to, this.fraction)
            }, s.prototype.stop = function() {
                this.isStopped = !0
            }, s.prototype.shouldStop = function(t) {
                return this.isStopped || -1 !== this.fraction && t.mode === n.ANY
            }, s.prototype.set = function(t, e, i, s, n) {
                o.copy(this.normal, t), this.shape = e, this.body = i, this.fraction = s, this.faceIndex = n
            }
        }, {
            "../collision/Ray": 11,
            "../math/vec2": 30
        }],
        13: [function(t, e, i) {
            function s() {
                n.call(this, n.SAP), this.axisList = [], this.axisIndex = 0;
                var t = this;
                this._addBodyHandler = function(e) {
                    t.axisList.push(e.body)
                }, this._removeBodyHandler = function(e) {
                    var i = t.axisList.indexOf(e.body); - 1 !== i && t.axisList.splice(i, 1)
                }
            }
            var o = t("../utils/Utils"),
                n = t("../collision/Broadphase");
            e.exports = s, (s.prototype = new n).constructor = s, s.prototype.setWorld = function(t) {
                this.axisList.length = 0, o.appendArray(this.axisList, t.bodies), t.off("addBody", this._addBodyHandler).off("removeBody", this._removeBodyHandler), t.on("addBody", this._addBodyHandler).on("removeBody", this._removeBodyHandler), this.world = t
            }, s.sortAxisList = function(t, e) {
                e |= 0;
                for (var i = 1, s = t.length; i < s; i++) {
                    for (var o = t[i], n = i - 1; n >= 0 && !(t[n].aabb.lowerBound[e] <= o.aabb.lowerBound[e]); n--) t[n + 1] = t[n];
                    t[n + 1] = o
                }
                return t
            }, s.prototype.sortList = function() {
                var t = this.axisList,
                    e = this.axisIndex;
                s.sortAxisList(t, e)
            }, s.prototype.getCollisionPairs = function(t) {
                var e = this.axisList,
                    i = this.result,
                    s = this.axisIndex;
                i.length = 0;
                for (var o = e.length; o--;) {
                    var a = e[o];
                    a.aabbNeedsUpdate && a.updateAABB()
                }
                this.sortList();
                for (var r = 0, h = 0 | e.length; r !== h; r++)
                    for (var l = e[r], c = r + 1; c < h; c++) {
                        var p = e[c];
                        if (!(p.aabb.lowerBound[s] <= l.aabb.upperBound[s])) break;
                        n.canCollide(l, p) && this.boundingVolumeCheck(l, p) && i.push(l, p)
                    }
                return i
            }, s.prototype.aabbQuery = function(t, e, i) {
                i = i || [], this.sortList();
                var s = this.axisIndex,
                    o = "x";
                1 === s && (o = "y"), 2 === s && (o = "z");
                for (var n = this.axisList, a = (e.lowerBound[o], e.upperBound[o], 0); a < n.length; a++) {
                    var r = n[a];
                    r.aabbNeedsUpdate && r.updateAABB(), r.aabb.overlaps(e) && i.push(r)
                }
                return i
            }
        }, {
            "../collision/Broadphase": 8,
            "../utils/Utils": 57
        }],
        14: [function(t, e, i) {
            function s(t, e, i, s) {
                this.type = i, s = o.defaults(s, {
                    collideConnected: !0,
                    wakeUpBodies: !0
                }), this.equations = [], this.bodyA = t, this.bodyB = e, this.collideConnected = s.collideConnected, s.wakeUpBodies && (t && t.wakeUp(), e && e.wakeUp())
            }
            e.exports = s;
            var o = t("../utils/Utils");
            s.prototype.update = function() {
                throw new Error("method update() not implmemented in this Constraint subclass!")
            }, s.DISTANCE = 1, s.GEAR = 2, s.LOCK = 3, s.PRISMATIC = 4, s.REVOLUTE = 5, s.prototype.setStiffness = function(t) {
                for (var e = this.equations, i = 0; i !== e.length; i++) {
                    var s = e[i];
                    s.stiffness = t, s.needsUpdate = !0
                }
            }, s.prototype.setRelaxation = function(t) {
                for (var e = this.equations, i = 0; i !== e.length; i++) {
                    var s = e[i];
                    s.relaxation = t, s.needsUpdate = !0
                }
            }
        }, {
            "../utils/Utils": 57
        }],
        15: [function(t, e, i) {
            function s(t, e, i) {
                i = r.defaults(i, {
                    localAnchorA: [0, 0],
                    localAnchorB: [0, 0]
                }), o.call(this, t, e, o.DISTANCE, i), this.localAnchorA = a.fromValues(i.localAnchorA[0], i.localAnchorA[1]), this.localAnchorB = a.fromValues(i.localAnchorB[0], i.localAnchorB[1]);
                var s = this.localAnchorA,
                    h = this.localAnchorB;
                if (this.distance = 0, "number" == typeof i.distance) this.distance = i.distance;
                else {
                    var l = a.create(),
                        c = a.create(),
                        p = a.create();
                    a.rotate(l, s, t.angle), a.rotate(c, h, e.angle), a.add(p, e.position, c), a.sub(p, p, l), a.sub(p, p, t.position), this.distance = a.length(p)
                }
                var u;
                u = void 0 === i.maxForce ? Number.MAX_VALUE : i.maxForce;
                var d = new n(t, e, -u, u);
                this.equations = [d], this.maxForce = u;
                var p = a.create(),
                    m = a.create(),
                    y = a.create(),
                    f = this;
                d.computeGq = function() {
                    var t = this.bodyA,
                        e = this.bodyB,
                        i = t.position,
                        o = e.position;
                    return a.rotate(m, s, t.angle), a.rotate(y, h, e.angle), a.add(p, o, y), a.sub(p, p, m), a.sub(p, p, i), a.length(p) - f.distance
                }, this.setMaxForce(u), this.upperLimitEnabled = !1, this.upperLimit = 1, this.lowerLimitEnabled = !1, this.lowerLimit = 0, this.position = 0
            }
            var o = t("./Constraint"),
                n = t("../equations/Equation"),
                a = t("../math/vec2"),
                r = t("../utils/Utils");
            e.exports = s, (s.prototype = new o).constructor = s;
            var h = a.create(),
                l = a.create(),
                c = a.create();
            s.prototype.update = function() {
                var t = this.equations[0],
                    e = this.bodyA,
                    i = this.bodyB,
                    s = (this.distance, e.position),
                    o = i.position,
                    n = this.equations[0],
                    r = t.G;
                a.rotate(l, this.localAnchorA, e.angle), a.rotate(c, this.localAnchorB, i.angle), a.add(h, o, c), a.sub(h, h, l), a.sub(h, h, s), this.position = a.length(h);
                var p = !1;
                if (this.upperLimitEnabled && this.position > this.upperLimit && (n.maxForce = 0, n.minForce = -this.maxForce, this.distance = this.upperLimit, p = !0), this.lowerLimitEnabled && this.position < this.lowerLimit && (n.maxForce = this.maxForce, n.minForce = 0, this.distance = this.lowerLimit, p = !0), !this.lowerLimitEnabled && !this.upperLimitEnabled || p) {
                    n.enabled = !0, a.normalize(h, h);
                    var u = a.crossLength(l, h),
                        d = a.crossLength(c, h);
                    r[0] = -h[0], r[1] = -h[1], r[2] = -u, r[3] = h[0], r[4] = h[1], r[5] = d
                } else n.enabled = !1
            }, s.prototype.setMaxForce = function(t) {
                var e = this.equations[0];
                e.minForce = -t, e.maxForce = t
            }, s.prototype.getMaxForce = function() {
                return this.equations[0].maxForce
            }
        }, {
            "../equations/Equation": 22,
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Constraint": 14
        }],
        16: [function(t, e, i) {
            function s(t, e, i) {
                i = i || {}, o.call(this, t, e, o.GEAR, i), this.ratio = void 0 !== i.ratio ? i.ratio : 1, this.angle = void 0 !== i.angle ? i.angle : e.angle - this.ratio * t.angle, i.angle = this.angle, i.ratio = this.ratio, this.equations = [new n(t, e, i)], void 0 !== i.maxTorque && this.setMaxTorque(i.maxTorque)
            }
            var o = t("./Constraint"),
                n = (t("../equations/Equation"), t("../equations/AngleLockEquation"));
            t("../math/vec2"), e.exports = s, (s.prototype = new o).constructor = s, s.prototype.update = function() {
                var t = this.equations[0];
                t.ratio !== this.ratio && t.setRatio(this.ratio), t.angle = this.angle
            }, s.prototype.setMaxTorque = function(t) {
                this.equations[0].setMaxTorque(t)
            }, s.prototype.getMaxTorque = function(t) {
                return this.equations[0].maxForce
            }
        }, {
            "../equations/AngleLockEquation": 20,
            "../equations/Equation": 22,
            "../math/vec2": 30,
            "./Constraint": 14
        }],
        17: [function(t, e, i) {
            function s(t, e, i) {
                i = i || {}, o.call(this, t, e, o.LOCK, i);
                var s = void 0 === i.maxForce ? Number.MAX_VALUE : i.maxForce,
                    r = (i.localAngleB, new a(t, e, -s, s)),
                    h = new a(t, e, -s, s),
                    l = new a(t, e, -s, s),
                    c = n.create(),
                    p = n.create(),
                    u = this;
                r.computeGq = function() {
                    return n.rotate(c, u.localOffsetB, t.angle), n.sub(p, e.position, t.position), n.sub(p, p, c), p[0]
                }, h.computeGq = function() {
                    return n.rotate(c, u.localOffsetB, t.angle), n.sub(p, e.position, t.position), n.sub(p, p, c), p[1]
                };
                var d = n.create(),
                    m = n.create();
                l.computeGq = function() {
                    return n.rotate(d, u.localOffsetB, e.angle - u.localAngleB), n.scale(d, d, -1), n.sub(p, t.position, e.position), n.add(p, p, d), n.rotate(m, d, -Math.PI / 2), n.normalize(m, m), n.dot(p, m)
                }, this.localOffsetB = n.create(), i.localOffsetB ? n.copy(this.localOffsetB, i.localOffsetB) : (n.sub(this.localOffsetB, e.position, t.position), n.rotate(this.localOffsetB, this.localOffsetB, -t.angle)), this.localAngleB = 0, "number" == typeof i.localAngleB ? this.localAngleB = i.localAngleB : this.localAngleB = e.angle - t.angle, this.equations.push(r, h, l), this.setMaxForce(s)
            }
            var o = t("./Constraint"),
                n = t("../math/vec2"),
                a = t("../equations/Equation");
            e.exports = s, (s.prototype = new o).constructor = s, s.prototype.setMaxForce = function(t) {
                for (var e = this.equations, i = 0; i < this.equations.length; i++) e[i].maxForce = t, e[i].minForce = -t
            }, s.prototype.getMaxForce = function() {
                return this.equations[0].maxForce
            };
            var r = n.create(),
                h = n.create(),
                l = n.create(),
                c = n.fromValues(1, 0),
                p = n.fromValues(0, 1);
            s.prototype.update = function() {
                var t = this.equations[0],
                    e = this.equations[1],
                    i = this.equations[2],
                    s = this.bodyA,
                    o = this.bodyB;
                n.rotate(r, this.localOffsetB, s.angle), n.rotate(h, this.localOffsetB, o.angle - this.localAngleB), n.scale(h, h, -1), n.rotate(l, h, Math.PI / 2), n.normalize(l, l), t.G[0] = -1, t.G[1] = 0, t.G[2] = -n.crossLength(r, c), t.G[3] = 1, e.G[0] = 0, e.G[1] = -1, e.G[2] = -n.crossLength(r, p), e.G[4] = 1, i.G[0] = -l[0], i.G[1] = -l[1], i.G[3] = l[0], i.G[4] = l[1], i.G[5] = n.crossLength(h, l)
            }
        }, {
            "../equations/Equation": 22,
            "../math/vec2": 30,
            "./Constraint": 14
        }],
        18: [function(t, e, i) {
            function s(t, e, i) {
                i = i || {}, o.call(this, t, e, o.PRISMATIC, i);
                var s = r.fromValues(0, 0),
                    l = r.fromValues(1, 0),
                    c = r.fromValues(0, 0);
                i.localAnchorA && r.copy(s, i.localAnchorA), i.localAxisA && r.copy(l, i.localAxisA), i.localAnchorB && r.copy(c, i.localAnchorB), this.localAnchorA = s, this.localAnchorB = c, this.localAxisA = l;
                var p = this.maxForce = void 0 !== i.maxForce ? i.maxForce : Number.MAX_VALUE,
                    u = new a(t, e, -p, p),
                    d = new r.create,
                    m = new r.create,
                    y = new r.create,
                    f = new r.create;
                if (u.computeGq = function() {
                        return r.dot(y, f)
                    }, u.updateJacobian = function() {
                        var i = this.G,
                            o = t.position,
                            n = e.position;
                        r.rotate(d, s, t.angle), r.rotate(m, c, e.angle), r.add(y, n, m), r.sub(y, y, o), r.sub(y, y, d), r.rotate(f, l, t.angle + Math.PI / 2), i[0] = -f[0], i[1] = -f[1], i[2] = -r.crossLength(d, f) + r.crossLength(f, y), i[3] = f[0], i[4] = f[1], i[5] = r.crossLength(m, f)
                    }, this.equations.push(u), !i.disableRotationalLock) {
                    var g = new h(t, e, -p, p);
                    this.equations.push(g)
                }
                this.position = 0, this.velocity = 0, this.lowerLimitEnabled = void 0 !== i.lowerLimit, this.upperLimitEnabled = void 0 !== i.upperLimit, this.lowerLimit = void 0 !== i.lowerLimit ? i.lowerLimit : 0, this.upperLimit = void 0 !== i.upperLimit ? i.upperLimit : 1, this.upperLimitEquation = new n(t, e), this.lowerLimitEquation = new n(t, e), this.upperLimitEquation.minForce = this.lowerLimitEquation.minForce = 0, this.upperLimitEquation.maxForce = this.lowerLimitEquation.maxForce = p, this.motorEquation = new a(t, e), this.motorEnabled = !1, this.motorSpeed = 0;
                var _ = this,
                    v = this.motorEquation;
                v.computeGW, v.computeGq = function() {
                    return 0
                }, v.computeGW = function() {
                    var t = this.G,
                        e = this.bodyA,
                        i = this.bodyB,
                        s = e.velocity,
                        o = i.velocity,
                        n = e.angularVelocity,
                        a = i.angularVelocity;
                    return this.gmult(t, s, n, o, a) + _.motorSpeed
                }
            }
            var o = t("./Constraint"),
                n = t("../equations/ContactEquation"),
                a = t("../equations/Equation"),
                r = t("../math/vec2"),
                h = t("../equations/RotationalLockEquation");
            e.exports = s, (s.prototype = new o).constructor = s;
            var l = r.create(),
                c = r.create(),
                p = r.create(),
                u = r.create(),
                d = r.create(),
                m = r.create();
            s.prototype.update = function() {
                var t = this.equations,
                    e = t[0],
                    i = this.upperLimit,
                    s = this.lowerLimit,
                    o = this.upperLimitEquation,
                    n = this.lowerLimitEquation,
                    a = this.bodyA,
                    h = this.bodyB,
                    y = this.localAxisA,
                    f = this.localAnchorA,
                    g = this.localAnchorB;
                e.updateJacobian(), r.rotate(l, y, a.angle), r.rotate(u, f, a.angle), r.add(c, u, a.position), r.rotate(d, g, h.angle), r.add(p, d, h.position);
                var _ = this.position = r.dot(p, l) - r.dot(c, l);
                if (this.motorEnabled) {
                    var v = this.motorEquation.G;
                    v[0] = l[0], v[1] = l[1], v[2] = r.crossLength(l, d), v[3] = -l[0], v[4] = -l[1], v[5] = -r.crossLength(l, u)
                }
                if (this.upperLimitEnabled && _ > i ? (r.scale(o.normalA, l, -1), r.sub(o.contactPointA, c, a.position), r.sub(o.contactPointB, p, h.position), r.scale(m, l, i), r.add(o.contactPointA, o.contactPointA, m), -1 === t.indexOf(o) && t.push(o)) : -1 !== (b = t.indexOf(o)) && t.splice(b, 1), this.lowerLimitEnabled && _ < s) r.scale(n.normalA, l, 1), r.sub(n.contactPointA, c, a.position), r.sub(n.contactPointB, p, h.position), r.scale(m, l, s), r.sub(n.contactPointB, n.contactPointB, m), -1 === t.indexOf(n) && t.push(n);
                else {
                    var b = t.indexOf(n); - 1 !== b && t.splice(b, 1)
                }
            }, s.prototype.enableMotor = function() {
                this.motorEnabled || (this.equations.push(this.motorEquation), this.motorEnabled = !0)
            }, s.prototype.disableMotor = function() {
                if (this.motorEnabled) {
                    var t = this.equations.indexOf(this.motorEquation);
                    this.equations.splice(t, 1), this.motorEnabled = !1
                }
            }, s.prototype.setLimits = function(t, e) {
                "number" == typeof t ? (this.lowerLimit = t, this.lowerLimitEnabled = !0) : (this.lowerLimit = t, this.lowerLimitEnabled = !1), "number" == typeof e ? (this.upperLimit = e, this.upperLimitEnabled = !0) : (this.upperLimit = e, this.upperLimitEnabled = !1)
            }
        }, {
            "../equations/ContactEquation": 21,
            "../equations/Equation": 22,
            "../equations/RotationalLockEquation": 24,
            "../math/vec2": 30,
            "./Constraint": 14
        }],
        19: [function(t, e, i) {
            function s(t, e, i) {
                i = i || {}, o.call(this, t, e, o.REVOLUTE, i);
                var s = this.maxForce = void 0 !== i.maxForce ? i.maxForce : Number.MAX_VALUE;
                this.pivotA = h.create(), this.pivotB = h.create(), i.worldPivot ? (h.sub(this.pivotA, i.worldPivot, t.position), h.sub(this.pivotB, i.worldPivot, e.position), h.rotate(this.pivotA, this.pivotA, -t.angle), h.rotate(this.pivotB, this.pivotB, -e.angle)) : (h.copy(this.pivotA, i.localPivotA), h.copy(this.pivotB, i.localPivotB));
                var m = this.equations = [new n(t, e, -s, s), new n(t, e, -s, s)],
                    y = m[0],
                    f = m[1],
                    g = this;
                y.computeGq = function() {
                    return h.rotate(l, g.pivotA, t.angle), h.rotate(c, g.pivotB, e.angle), h.add(d, e.position, c), h.sub(d, d, t.position), h.sub(d, d, l), h.dot(d, p)
                }, f.computeGq = function() {
                    return h.rotate(l, g.pivotA, t.angle), h.rotate(c, g.pivotB, e.angle), h.add(d, e.position, c), h.sub(d, d, t.position), h.sub(d, d, l), h.dot(d, u)
                }, f.minForce = y.minForce = -s, f.maxForce = y.maxForce = s, this.motorEquation = new a(t, e), this.motorEnabled = !1, this.angle = 0, this.lowerLimitEnabled = !1, this.upperLimitEnabled = !1, this.lowerLimit = 0, this.upperLimit = 0, this.upperLimitEquation = new r(t, e), this.lowerLimitEquation = new r(t, e), this.upperLimitEquation.minForce = 0, this.lowerLimitEquation.maxForce = 0
            }
            var o = t("./Constraint"),
                n = t("../equations/Equation"),
                a = t("../equations/RotationalVelocityEquation"),
                r = t("../equations/RotationalLockEquation"),
                h = t("../math/vec2");
            e.exports = s;
            var l = h.create(),
                c = h.create(),
                p = h.fromValues(1, 0),
                u = h.fromValues(0, 1),
                d = h.create();
            (s.prototype = new o).constructor = s, s.prototype.setLimits = function(t, e) {
                "number" == typeof t ? (this.lowerLimit = t, this.lowerLimitEnabled = !0) : (this.lowerLimit = t, this.lowerLimitEnabled = !1), "number" == typeof e ? (this.upperLimit = e, this.upperLimitEnabled = !0) : (this.upperLimit = e, this.upperLimitEnabled = !1)
            }, s.prototype.update = function() {
                var t = this.bodyA,
                    e = this.bodyB,
                    i = this.pivotA,
                    s = this.pivotB,
                    o = this.equations,
                    n = (o[0], o[1], o[0]),
                    a = o[1],
                    r = this.upperLimit,
                    d = this.lowerLimit,
                    m = this.upperLimitEquation,
                    y = this.lowerLimitEquation,
                    f = this.angle = e.angle - t.angle;
                if (this.upperLimitEnabled && f > r ? (m.angle = r, -1 === o.indexOf(m) && o.push(m)) : -1 !== (g = o.indexOf(m)) && o.splice(g, 1), this.lowerLimitEnabled && f < d) y.angle = d, -1 === o.indexOf(y) && o.push(y);
                else {
                    var g = o.indexOf(y); - 1 !== g && o.splice(g, 1)
                }
                h.rotate(l, i, t.angle), h.rotate(c, s, e.angle), n.G[0] = -1, n.G[1] = 0, n.G[2] = -h.crossLength(l, p), n.G[3] = 1, n.G[4] = 0, n.G[5] = h.crossLength(c, p), a.G[0] = 0, a.G[1] = -1, a.G[2] = -h.crossLength(l, u), a.G[3] = 0, a.G[4] = 1, a.G[5] = h.crossLength(c, u)
            }, s.prototype.enableMotor = function() {
                this.motorEnabled || (this.equations.push(this.motorEquation), this.motorEnabled = !0)
            }, s.prototype.disableMotor = function() {
                if (this.motorEnabled) {
                    var t = this.equations.indexOf(this.motorEquation);
                    this.equations.splice(t, 1), this.motorEnabled = !1
                }
            }, s.prototype.motorIsEnabled = function() {
                return !!this.motorEnabled
            }, s.prototype.setMotorSpeed = function(t) {
                if (this.motorEnabled) {
                    var e = this.equations.indexOf(this.motorEquation);
                    this.equations[e].relativeVelocity = t
                }
            }, s.prototype.getMotorSpeed = function() {
                return !!this.motorEnabled && this.motorEquation.relativeVelocity
            }
        }, {
            "../equations/Equation": 22,
            "../equations/RotationalLockEquation": 24,
            "../equations/RotationalVelocityEquation": 25,
            "../math/vec2": 30,
            "./Constraint": 14
        }],
        20: [function(t, e, i) {
            function s(t, e, i) {
                i = i || {}, o.call(this, t, e, -Number.MAX_VALUE, Number.MAX_VALUE), this.angle = i.angle || 0, this.ratio = "number" == typeof i.ratio ? i.ratio : 1, this.setRatio(this.ratio)
            }
            var o = t("./Equation");
            t("../math/vec2"), e.exports = s, (s.prototype = new o).constructor = s, s.prototype.computeGq = function() {
                return this.ratio * this.bodyA.angle - this.bodyB.angle + this.angle
            }, s.prototype.setRatio = function(t) {
                var e = this.G;
                e[2] = t, e[5] = -1, this.ratio = t
            }, s.prototype.setMaxTorque = function(t) {
                this.maxForce = t, this.minForce = -t
            }
        }, {
            "../math/vec2": 30,
            "./Equation": 22
        }],
        21: [function(t, e, i) {
            function s(t, e) {
                o.call(this, t, e, 0, Number.MAX_VALUE), this.contactPointA = n.create(), this.penetrationVec = n.create(), this.contactPointB = n.create(), this.normalA = n.create(), this.restitution = 0, this.firstImpact = !1, this.shapeA = null, this.shapeB = null
            }
            var o = t("./Equation"),
                n = t("../math/vec2");
            e.exports = s, (s.prototype = new o).constructor = s, s.prototype.computeB = function(t, e, i) {
                var s = this.bodyA,
                    o = this.bodyB,
                    a = this.contactPointA,
                    r = this.contactPointB,
                    h = s.position,
                    l = o.position,
                    c = this.penetrationVec,
                    p = this.normalA,
                    u = this.G,
                    d = n.crossLength(a, p),
                    m = n.crossLength(r, p);
                u[0] = -p[0], u[1] = -p[1], u[2] = -d, u[3] = p[0], u[4] = p[1], u[5] = m, n.add(c, l, r), n.sub(c, c, h), n.sub(c, c, a);
                var y, f;
                return this.firstImpact && 0 !== this.restitution ? (f = 0, y = 1 / e * (1 + this.restitution) * this.computeGW()) : (f = n.dot(p, c) + this.offset, y = this.computeGW()), -f * t - y * e - i * this.computeGiMf()
            }
        }, {
            "../math/vec2": 30,
            "./Equation": 22
        }],
        22: [function(t, e, i) {
            function s(t, e, i, o) {
                this.minForce = void 0 === i ? -Number.MAX_VALUE : i, this.maxForce = void 0 === o ? Number.MAX_VALUE : o, this.bodyA = t, this.bodyB = e, this.stiffness = s.DEFAULT_STIFFNESS, this.relaxation = s.DEFAULT_RELAXATION, this.G = new n.ARRAY_TYPE(6);
                for (var a = 0; a < 6; a++) this.G[a] = 0;
                this.offset = 0, this.a = 0, this.b = 0, this.epsilon = 0, this.timeStep = 1 / 60, this.needsUpdate = !0, this.multiplier = 0, this.relativeVelocity = 0, this.enabled = !0
            }
            e.exports = s;
            var o = t("../math/vec2"),
                n = t("../utils/Utils");
            t("../objects/Body"), s.prototype.constructor = s, s.DEFAULT_STIFFNESS = 1e6, s.DEFAULT_RELAXATION = 4, s.prototype.update = function() {
                var t = this.stiffness,
                    e = this.relaxation,
                    i = this.timeStep;
                this.a = 4 / (i * (1 + 4 * e)), this.b = 4 * e / (1 + 4 * e), this.epsilon = 4 / (i * i * t * (1 + 4 * e)), this.needsUpdate = !1
            }, s.prototype.gmult = function(t, e, i, s, o) {
                return t[0] * e[0] + t[1] * e[1] + t[2] * i + t[3] * s[0] + t[4] * s[1] + t[5] * o
            }, s.prototype.computeB = function(t, e, i) {
                var s = this.computeGW();
                return -this.computeGq() * t - s * e - this.computeGiMf() * i
            };
            var a = o.create(),
                r = o.create();
            s.prototype.computeGq = function() {
                var t = this.G,
                    e = this.bodyA,
                    i = this.bodyB,
                    s = (e.position, i.position, e.angle),
                    o = i.angle;
                return this.gmult(t, a, s, r, o) + this.offset
            }, s.prototype.computeGW = function() {
                var t = this.G,
                    e = this.bodyA,
                    i = this.bodyB,
                    s = e.velocity,
                    o = i.velocity,
                    n = e.angularVelocity,
                    a = i.angularVelocity;
                return this.gmult(t, s, n, o, a) + this.relativeVelocity
            }, s.prototype.computeGWlambda = function() {
                var t = this.G,
                    e = this.bodyA,
                    i = this.bodyB,
                    s = e.vlambda,
                    o = i.vlambda,
                    n = e.wlambda,
                    a = i.wlambda;
                return this.gmult(t, s, n, o, a)
            };
            var h = o.create(),
                l = o.create();
            s.prototype.computeGiMf = function() {
                var t = this.bodyA,
                    e = this.bodyB,
                    i = t.force,
                    s = t.angularForce,
                    n = e.force,
                    a = e.angularForce,
                    r = t.invMassSolve,
                    c = e.invMassSolve,
                    p = t.invInertiaSolve,
                    u = e.invInertiaSolve,
                    d = this.G;
                return o.scale(h, i, r), o.multiply(h, t.massMultiplier, h), o.scale(l, n, c), o.multiply(l, e.massMultiplier, l), this.gmult(d, h, s * p, l, a * u)
            }, s.prototype.computeGiMGt = function() {
                var t = this.bodyA,
                    e = this.bodyB,
                    i = t.invMassSolve,
                    s = e.invMassSolve,
                    o = t.invInertiaSolve,
                    n = e.invInertiaSolve,
                    a = this.G;
                return a[0] * a[0] * i * t.massMultiplier[0] + a[1] * a[1] * i * t.massMultiplier[1] + a[2] * a[2] * o + a[3] * a[3] * s * e.massMultiplier[0] + a[4] * a[4] * s * e.massMultiplier[1] + a[5] * a[5] * n
            };
            var c = o.create(),
                p = o.create(),
                u = o.create();
            o.create(), o.create(), o.create(), s.prototype.addToWlambda = function(t) {
                var e = this.bodyA,
                    i = this.bodyB,
                    s = c,
                    n = p,
                    a = u,
                    r = e.invMassSolve,
                    h = i.invMassSolve,
                    l = e.invInertiaSolve,
                    d = i.invInertiaSolve,
                    m = this.G;
                n[0] = m[0], n[1] = m[1], a[0] = m[3], a[1] = m[4], o.scale(s, n, r * t), o.multiply(s, s, e.massMultiplier), o.add(e.vlambda, e.vlambda, s), e.wlambda += l * m[2] * t, o.scale(s, a, h * t), o.multiply(s, s, i.massMultiplier), o.add(i.vlambda, i.vlambda, s), i.wlambda += d * m[5] * t
            }, s.prototype.computeInvC = function(t) {
                return 1 / (this.computeGiMGt() + t)
            }
        }, {
            "../math/vec2": 30,
            "../objects/Body": 31,
            "../utils/Utils": 57
        }],
        23: [function(t, e, i) {
            function s(t, e, i) {
                n.call(this, t, e, -i, i), this.contactPointA = o.create(), this.contactPointB = o.create(), this.t = o.create(), this.contactEquations = [], this.shapeA = null, this.shapeB = null, this.frictionCoefficient = .3
            }
            var o = t("../math/vec2"),
                n = t("./Equation");
            t("../utils/Utils"), e.exports = s, (s.prototype = new n).constructor = s, s.prototype.setSlipForce = function(t) {
                this.maxForce = t, this.minForce = -t
            }, s.prototype.getSlipForce = function() {
                return this.maxForce
            }, s.prototype.computeB = function(t, e, i) {
                var s = (this.bodyA, this.bodyB, this.contactPointA),
                    n = this.contactPointB,
                    a = this.t,
                    r = this.G;
                return r[0] = -a[0], r[1] = -a[1], r[2] = -o.crossLength(s, a), r[3] = a[0], r[4] = a[1], r[5] = o.crossLength(n, a), -this.computeGW() * e - i * this.computeGiMf()
            }
        }, {
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Equation": 22
        }],
        24: [function(t, e, i) {
            function s(t, e, i) {
                i = i || {}, o.call(this, t, e, -Number.MAX_VALUE, Number.MAX_VALUE), this.angle = i.angle || 0;
                var s = this.G;
                s[2] = 1, s[5] = -1
            }
            var o = t("./Equation"),
                n = t("../math/vec2");
            e.exports = s, (s.prototype = new o).constructor = s;
            var a = n.create(),
                r = n.create(),
                h = n.fromValues(1, 0),
                l = n.fromValues(0, 1);
            s.prototype.computeGq = function() {
                return n.rotate(a, h, this.bodyA.angle + this.angle), n.rotate(r, l, this.bodyB.angle), n.dot(a, r)
            }
        }, {
            "../math/vec2": 30,
            "./Equation": 22
        }],
        25: [function(t, e, i) {
            function s(t, e) {
                o.call(this, t, e, -Number.MAX_VALUE, Number.MAX_VALUE), this.relativeVelocity = 1, this.ratio = 1
            }
            var o = t("./Equation");
            t("../math/vec2"), e.exports = s, (s.prototype = new o).constructor = s, s.prototype.computeB = function(t, e, i) {
                var s = this.G;
                s[2] = -1, s[5] = this.ratio;
                var o = this.computeGiMf();
                return -this.computeGW() * e - i * o
            }
        }, {
            "../math/vec2": 30,
            "./Equation": 22
        }],
        26: [function(t, e, i) {
            var s = function() {};
            e.exports = s, s.prototype = {
                constructor: s,
                on: function(t, e, i) {
                    e.context = i || this, void 0 === this._listeners && (this._listeners = {});
                    var s = this._listeners;
                    return void 0 === s[t] && (s[t] = []), -1 === s[t].indexOf(e) && s[t].push(e), this
                },
                has: function(t, e) {
                    if (void 0 === this._listeners) return !1;
                    var i = this._listeners;
                    if (e) {
                        if (void 0 !== i[t] && -1 !== i[t].indexOf(e)) return !0
                    } else if (void 0 !== i[t]) return !0;
                    return !1
                },
                off: function(t, e) {
                    if (void 0 === this._listeners) return this;
                    var i = this._listeners,
                        s = i[t].indexOf(e);
                    return -1 !== s && i[t].splice(s, 1), this
                },
                emit: function(t) {
                    if (void 0 === this._listeners) return this;
                    var e = this._listeners[t.type];
                    if (void 0 !== e) {
                        t.target = this;
                        for (var i = 0, s = e.length; i < s; i++) {
                            var o = e[i];
                            o.call(o.context, t)
                        }
                    }
                    return this
                }
            }
        }, {}],
        27: [function(t, e, i) {
            function s(t, e, i) {
                if (i = i || {}, !(t instanceof o && e instanceof o)) throw new Error("First two arguments must be Material instances.");
                this.id = s.idCounter++, this.materialA = t, this.materialB = e, this.friction = void 0 !== i.friction ? Number(i.friction) : .3, this.restitution = void 0 !== i.restitution ? Number(i.restitution) : 0, this.stiffness = void 0 !== i.stiffness ? Number(i.stiffness) : n.DEFAULT_STIFFNESS, this.relaxation = void 0 !== i.relaxation ? Number(i.relaxation) : n.DEFAULT_RELAXATION, this.frictionStiffness = void 0 !== i.frictionStiffness ? Number(i.frictionStiffness) : n.DEFAULT_STIFFNESS, this.frictionRelaxation = void 0 !== i.frictionRelaxation ? Number(i.frictionRelaxation) : n.DEFAULT_RELAXATION, this.surfaceVelocity = void 0 !== i.surfaceVelocity ? Number(i.surfaceVelocity) : 0, this.contactSkinSize = .005
            }
            var o = t("./Material"),
                n = t("../equations/Equation");
            e.exports = s, s.idCounter = 0
        }, {
            "../equations/Equation": 22,
            "./Material": 28
        }],
        28: [function(t, e, i) {
            function s(t) {
                this.id = t || s.idCounter++
            }
            e.exports = s, s.idCounter = 0
        }, {}],
        29: [function(t, e, i) {
            var s = {};
            s.GetArea = function(t) {
                if (t.length < 6) return 0;
                for (var e = t.length - 2, i = 0, s = 0; s < e; s += 2) i += (t[s + 2] - t[s]) * (t[s + 1] + t[s + 3]);
                return .5 * -(i += (t[0] - t[e]) * (t[e + 1] + t[1]))
            }, s.Triangulate = function(t) {
                var e = t.length >> 1;
                if (e < 3) return [];
                for (var i = [], o = [], n = 0; n < e; n++) o.push(n);
                for (var n = 0, a = e; a > 3;) {
                    var r = o[(n + 0) % a],
                        h = o[(n + 1) % a],
                        l = o[(n + 2) % a],
                        c = t[2 * r],
                        p = t[2 * r + 1],
                        u = t[2 * h],
                        d = t[2 * h + 1],
                        m = t[2 * l],
                        y = t[2 * l + 1],
                        f = !1;
                    if (s._convex(c, p, u, d, m, y)) {
                        f = !0;
                        for (var g = 0; g < a; g++) {
                            var _ = o[g];
                            if (_ != r && _ != h && _ != l && s._PointInTriangle(t[2 * _], t[2 * _ + 1], c, p, u, d, m, y)) {
                                f = !1;
                                break
                            }
                        }
                    }
                    if (f) i.push(r, h, l), o.splice((n + 1) % a, 1), a--, n = 0;
                    else if (n++ > 3 * a) break
                }
                return i.push(o[0], o[1], o[2]), i
            }, s._PointInTriangle = function(t, e, i, s, o, n, a, r) {
                var h = a - i,
                    l = r - s,
                    c = o - i,
                    p = n - s,
                    u = t - i,
                    d = e - s,
                    m = h * h + l * l,
                    y = h * c + l * p,
                    f = h * u + l * d,
                    g = c * c + p * p,
                    _ = c * u + p * d,
                    v = 1 / (m * g - y * y),
                    b = (g * f - y * _) * v,
                    x = (m * _ - y * f) * v;
                return b >= 0 && x >= 0 && b + x < 1
            }, s._convex = function(t, e, i, s, o, n) {
                return (e - s) * (o - i) + (i - t) * (n - s) >= 0
            }, e.exports = s
        }, {}],
        30: [function(t, e, i) {
            var s = e.exports = {},
                o = t("../utils/Utils");
            s.crossLength = function(t, e) {
                return t[0] * e[1] - t[1] * e[0]
            }, s.crossVZ = function(t, e, i) {
                return s.rotate(t, e, -Math.PI / 2), s.scale(t, t, i), t
            }, s.crossZV = function(t, e, i) {
                return s.rotate(t, i, Math.PI / 2), s.scale(t, t, e), t
            }, s.rotate = function(t, e, i) {
                if (0 !== i) {
                    var s = Math.cos(i),
                        o = Math.sin(i),
                        n = e[0],
                        a = e[1];
                    t[0] = s * n - o * a, t[1] = o * n + s * a
                } else t[0] = e[0], t[1] = e[1]
            }, s.rotate90cw = function(t, e) {
                var i = e[0],
                    s = e[1];
                t[0] = s, t[1] = -i
            }, s.toLocalFrame = function(t, e, i, o) {
                s.copy(t, e), s.sub(t, t, i), s.rotate(t, t, -o)
            }, s.toGlobalFrame = function(t, e, i, o) {
                s.copy(t, e), s.rotate(t, t, o), s.add(t, t, i)
            }, s.vectorToLocalFrame = function(t, e, i) {
                s.rotate(t, e, -i)
            }, s.vectorToGlobalFrame = function(t, e, i) {
                s.rotate(t, e, i)
            }, s.centroid = function(t, e, i, o) {
                return s.add(t, e, i), s.add(t, t, o), s.scale(t, t, 1 / 3), t
            }, s.create = function() {
                var t = new o.ARRAY_TYPE(2);
                return t[0] = 0, t[1] = 0, t
            }, s.clone = function(t) {
                var e = new o.ARRAY_TYPE(2);
                return e[0] = t[0], e[1] = t[1], e
            }, s.fromValues = function(t, e) {
                var i = new o.ARRAY_TYPE(2);
                return i[0] = t, i[1] = e, i
            }, s.copy = function(t, e) {
                return t[0] = e[0], t[1] = e[1], t
            }, s.set = function(t, e, i) {
                return t[0] = e, t[1] = i, t
            }, s.add = function(t, e, i) {
                return t[0] = e[0] + i[0], t[1] = e[1] + i[1], t
            }, s.subtract = function(t, e, i) {
                return t[0] = e[0] - i[0], t[1] = e[1] - i[1], t
            }, s.sub = s.subtract, s.multiply = function(t, e, i) {
                return t[0] = e[0] * i[0], t[1] = e[1] * i[1], t
            }, s.mul = s.multiply, s.divide = function(t, e, i) {
                return t[0] = e[0] / i[0], t[1] = e[1] / i[1], t
            }, s.div = s.divide, s.scale = function(t, e, i) {
                return t[0] = e[0] * i, t[1] = e[1] * i, t
            }, s.distance = function(t, e) {
                var i = e[0] - t[0],
                    s = e[1] - t[1];
                return Math.sqrt(i * i + s * s)
            }, s.dist = s.distance, s.squaredDistance = function(t, e) {
                var i = e[0] - t[0],
                    s = e[1] - t[1];
                return i * i + s * s
            }, s.sqrDist = s.squaredDistance, s.length = function(t) {
                var e = t[0],
                    i = t[1];
                return Math.sqrt(e * e + i * i)
            }, s.len = s.length, s.squaredLength = function(t) {
                var e = t[0],
                    i = t[1];
                return e * e + i * i
            }, s.sqrLen = s.squaredLength, s.negate = function(t, e) {
                return t[0] = -e[0], t[1] = -e[1], t
            }, s.normalize = function(t, e) {
                var i = e[0],
                    s = e[1],
                    o = i * i + s * s;
                return o > 0 && (o = 1 / Math.sqrt(o), t[0] = e[0] * o, t[1] = e[1] * o), t
            }, s.dot = function(t, e) {
                return t[0] * e[0] + t[1] * e[1]
            }, s.str = function(t) {
                return "vec2(" + t[0] + ", " + t[1] + ")"
            }, s.lerp = function(t, e, i, s) {
                var o = e[0],
                    n = e[1];
                return t[0] = o + s * (i[0] - o), t[1] = n + s * (i[1] - n), t
            }, s.reflect = function(t, e, i) {
                var s = e[0] * i[0] + e[1] * i[1];
                t[0] = e[0] - 2 * i[0] * s, t[1] = e[1] - 2 * i[1] * s
            }, s.getLineSegmentsIntersection = function(t, e, i, o, n) {
                var a = s.getLineSegmentsIntersectionFraction(e, i, o, n);
                return !(a < 0 || (t[0] = e[0] + a * (i[0] - e[0]), t[1] = e[1] + a * (i[1] - e[1]), 0))
            }, s.getLineSegmentsIntersectionFraction = function(t, e, i, s) {
                var o, n, a = e[0] - t[0],
                    r = e[1] - t[1],
                    h = s[0] - i[0],
                    l = s[1] - i[1];
                return o = (-r * (t[0] - i[0]) + a * (t[1] - i[1])) / (-h * r + a * l), n = (h * (t[1] - i[1]) - l * (t[0] - i[0])) / (-h * r + a * l), o >= 0 && o <= 1 && n >= 0 && n <= 1 ? n : -1
            }
        }, {
            "../utils/Utils": 57
        }],
        31: [function(t, e, i) {
            function s(t) {
                t = t || {}, c.call(this), this.id = t.id || ++s._idCounter, this.world = null, this.shapes = [], this.mass = t.mass || 0, this.invMass = 0, this.inertia = 0, this.invInertia = 0, this.invMassSolve = 0, this.invInertiaSolve = 0, this.fixedRotation = !!t.fixedRotation, this.fixedX = !!t.fixedX, this.fixedY = !!t.fixedY, this.massMultiplier = o.create(), this.position = o.fromValues(0, 0), t.position && o.copy(this.position, t.position), this.interpolatedPosition = o.fromValues(0, 0), this.interpolatedAngle = 0, this.previousPosition = o.fromValues(0, 0), this.previousAngle = 0, this.velocity = o.fromValues(0, 0), t.velocity && o.copy(this.velocity, t.velocity), this.vlambda = o.fromValues(0, 0), this.wlambda = 0, this.angle = t.angle || 0, this.angularVelocity = t.angularVelocity || 0, this.force = o.create(), t.force && o.copy(this.force, t.force), this.angularForce = t.angularForce || 0, this.damping = "number" == typeof t.damping ? t.damping : .1, this.angularDamping = "number" == typeof t.angularDamping ? t.angularDamping : .1, this.type = s.STATIC, void 0 !== t.type ? this.type = t.type : t.mass ? this.type = s.DYNAMIC : this.type = s.STATIC, this.boundingRadius = 0, this.aabb = new l, this.aabbNeedsUpdate = !0, this.allowSleep = void 0 === t.allowSleep || t.allowSleep, this.wantsToSleep = !1, this.sleepState = s.AWAKE, this.sleepSpeedLimit = void 0 !== t.sleepSpeedLimit ? t.sleepSpeedLimit : .2, this.sleepTimeLimit = void 0 !== t.sleepTimeLimit ? t.sleepTimeLimit : 1, this.gravityScale = void 0 !== t.gravityScale ? t.gravityScale : 1, this.collisionResponse = void 0 === t.collisionResponse || t.collisionResponse, this.idleTime = 0, this.timeLastSleepy = 0, this.ccdSpeedThreshold = void 0 !== t.ccdSpeedThreshold ? t.ccdSpeedThreshold : -1, this.ccdIterations = void 0 !== t.ccdIterations ? t.ccdIterations : 10, this.concavePath = null, this._wakeUpAfterNarrowphase = !1, this.updateMassProperties()
            }
            var o = t("../math/vec2"),
                n = t("poly-decomp"),
                a = t("../shapes/Convex"),
                r = t("../collision/RaycastResult"),
                h = t("../collision/Ray"),
                l = t("../collision/AABB"),
                c = t("../events/EventEmitter");
            e.exports = s, s.prototype = new c, s.prototype.constructor = s, s._idCounter = 0, s.prototype.updateSolveMassProperties = function() {
                this.sleepState === s.SLEEPING || this.type === s.KINEMATIC ? (this.invMassSolve = 0, this.invInertiaSolve = 0) : (this.invMassSolve = this.invMass, this.invInertiaSolve = this.invInertia)
            }, s.prototype.setDensity = function(t) {
                var e = this.getArea();
                this.mass = e * t, this.updateMassProperties()
            }, s.prototype.getArea = function() {
                for (var t = 0, e = 0; e < this.shapes.length; e++) t += this.shapes[e].area;
                return t
            }, s.prototype.getAABB = function() {
                return this.aabbNeedsUpdate && this.updateAABB(), this.aabb
            };
            var p = new l,
                u = o.create();
            s.prototype.updateAABB = function() {
                for (var t = this.shapes, e = t.length, i = u, s = this.angle, n = 0; n !== e; n++) {
                    var a = t[n],
                        r = a.angle + s;
                    o.rotate(i, a.position, s), o.add(i, i, this.position), a.computeAABB(p, i, r), 0 === n ? this.aabb.copy(p) : this.aabb.extend(p)
                }
                this.aabbNeedsUpdate = !1
            }, s.prototype.updateBoundingRadius = function() {
                for (var t = this.shapes, e = t.length, i = 0, s = 0; s !== e; s++) {
                    var n = t[s],
                        a = o.length(n.position),
                        r = n.boundingRadius;
                    a + r > i && (i = a + r)
                }
                this.boundingRadius = i
            }, s.prototype.addShape = function(t, e, i) {
                if (t.body) throw new Error("A shape can only be added to one body.");
                t.body = this, e ? o.copy(t.position, e) : o.set(t.position, 0, 0), t.angle = i || 0, this.shapes.push(t), this.updateMassProperties(), this.updateBoundingRadius(), this.aabbNeedsUpdate = !0
            }, s.prototype.removeShape = function(t) {
                var e = this.shapes.indexOf(t);
                return -1 !== e && (this.shapes.splice(e, 1), this.aabbNeedsUpdate = !0, t.body = null, !0)
            }, s.prototype.updateMassProperties = function() {
                if (this.type === s.STATIC || this.type === s.KINEMATIC) this.mass = Number.MAX_VALUE, this.invMass = 0, this.inertia = Number.MAX_VALUE, this.invInertia = 0;
                else {
                    var t = this.shapes,
                        e = t.length,
                        i = this.mass / e,
                        n = 0;
                    if (this.fixedRotation) this.inertia = Number.MAX_VALUE, this.invInertia = 0;
                    else {
                        for (var a = 0; a < e; a++) {
                            var r = t[a],
                                h = o.squaredLength(r.position);
                            n += r.computeMomentOfInertia(i) + i * h
                        }
                        this.inertia = n, this.invInertia = n > 0 ? 1 / n : 0
                    }
                    this.invMass = 1 / this.mass, o.set(this.massMultiplier, this.fixedX ? 0 : 1, this.fixedY ? 0 : 1)
                }
            }, o.create(), s.prototype.applyForce = function(t, e) {
                if (o.add(this.force, this.force, t), e) {
                    var i = o.crossLength(e, t);
                    this.angularForce += i
                }
            };
            var d = o.create(),
                m = o.create(),
                y = o.create();
            s.prototype.applyForceLocal = function(t, e) {
                e = e || y;
                var i = d,
                    s = m;
                this.vectorToWorldFrame(i, t), this.vectorToWorldFrame(s, e), this.applyForce(i, s)
            };
            var f = o.create();
            s.prototype.applyImpulse = function(t, e) {
                if (this.type === s.DYNAMIC) {
                    var i = f;
                    if (o.scale(i, t, this.invMass), o.multiply(i, this.massMultiplier, i), o.add(this.velocity, i, this.velocity), e) {
                        var n = o.crossLength(e, t);
                        n *= this.invInertia, this.angularVelocity += n
                    }
                }
            };
            var g = o.create(),
                _ = o.create(),
                v = o.create();
            s.prototype.applyImpulseLocal = function(t, e) {
                e = e || v;
                var i = g,
                    s = _;
                this.vectorToWorldFrame(i, t), this.vectorToWorldFrame(s, e), this.applyImpulse(i, s)
            }, s.prototype.toLocalFrame = function(t, e) {
                o.toLocalFrame(t, e, this.position, this.angle)
            }, s.prototype.toWorldFrame = function(t, e) {
                o.toGlobalFrame(t, e, this.position, this.angle)
            }, s.prototype.vectorToLocalFrame = function(t, e) {
                o.vectorToLocalFrame(t, e, this.angle)
            }, s.prototype.vectorToWorldFrame = function(t, e) {
                o.vectorToGlobalFrame(t, e, this.angle)
            }, s.prototype.fromPolygon = function(t, e) {
                e = e || {};
                for (h = this.shapes.length; h >= 0; --h) this.removeShape(this.shapes[h]);
                var i = new n.Polygon;
                if (i.vertices = t, i.makeCCW(), "number" == typeof e.removeCollinearPoints && i.removeCollinearPoints(e.removeCollinearPoints), void 0 === e.skipSimpleCheck && !i.isSimple()) return !1;
                this.concavePath = i.vertices.slice(0);
                for (h = 0; h < this.concavePath.length; h++) {
                    p = [0, 0];
                    o.copy(p, this.concavePath[h]), this.concavePath[h] = p
                }
                var s;
                s = e.optimalDecomp ? i.decomp() : i.quickDecomp();
                for (var r = o.create(), h = 0; h !== s.length; h++) {
                    for (var l = new a({
                            vertices: s[h].vertices
                        }), c = 0; c !== l.vertices.length; c++) {
                        var p = l.vertices[c];
                        o.sub(p, p, l.centerOfMass)
                    }
                    o.scale(r, l.centerOfMass, 1), l.updateTriangles(), l.updateCenterOfMass(), l.updateBoundingRadius(), this.addShape(l, r)
                }
                return this.adjustCenterOfMass(), this.aabbNeedsUpdate = !0, !0
            };
            var b = (o.fromValues(0, 0), o.fromValues(0, 0)),
                x = o.fromValues(0, 0),
                C = o.fromValues(0, 0);
            s.prototype.adjustCenterOfMass = function() {
                var t = b,
                    e = x,
                    i = C,
                    s = 0;
                o.set(e, 0, 0);
                for (a = 0; a !== this.shapes.length; a++) {
                    n = this.shapes[a];
                    o.scale(t, n.position, n.area), o.add(e, e, t), s += n.area
                }
                o.scale(i, e, 1 / s);
                for (a = 0; a !== this.shapes.length; a++) {
                    var n = this.shapes[a];
                    o.sub(n.position, n.position, i)
                }
                o.add(this.position, this.position, i);
                for (var a = 0; this.concavePath && a < this.concavePath.length; a++) o.sub(this.concavePath[a], this.concavePath[a], i);
                this.updateMassProperties(), this.updateBoundingRadius()
            }, s.prototype.setZeroForce = function() {
                o.set(this.force, 0, 0), this.angularForce = 0
            }, s.prototype.resetConstraintVelocity = function() {
                var t = this,
                    e = t.vlambda;
                o.set(e, 0, 0), t.wlambda = 0
            }, s.prototype.addConstraintVelocity = function() {
                var t = this,
                    e = t.velocity;
                o.add(e, e, t.vlambda), t.angularVelocity += t.wlambda
            }, s.prototype.applyDamping = function(t) {
                if (this.type === s.DYNAMIC) {
                    var e = this.velocity;
                    o.scale(e, e, Math.pow(1 - this.damping, t)), this.angularVelocity *= Math.pow(1 - this.angularDamping, t)
                }
            }, s.prototype.wakeUp = function() {
                var t = this.sleepState;
                this.sleepState = s.AWAKE, this.idleTime = 0, t !== s.AWAKE && this.emit(s.wakeUpEvent)
            }, s.prototype.sleep = function() {
                this.sleepState = s.SLEEPING, this.angularVelocity = 0, this.angularForce = 0, o.set(this.velocity, 0, 0), o.set(this.force, 0, 0), this.emit(s.sleepEvent)
            }, s.prototype.sleepTick = function(t, e, i) {
                this.allowSleep && this.type !== s.SLEEPING && (this.wantsToSleep = !1, (this.sleepState, o.squaredLength(this.velocity) + Math.pow(this.angularVelocity, 2)) >= Math.pow(this.sleepSpeedLimit, 2) ? (this.idleTime = 0, this.sleepState = s.AWAKE) : (this.idleTime += i, this.sleepState = s.SLEEPY), this.idleTime > this.sleepTimeLimit && (e ? this.wantsToSleep = !0 : this.sleep()))
            }, s.prototype.overlaps = function(t) {
                return this.world.overlapKeeper.bodiesAreOverlapping(this, t)
            };
            var S = o.create(),
                w = o.create();
            s.prototype.integrate = function(t) {
                var e = this.invMass,
                    i = this.force,
                    s = this.position,
                    n = this.velocity;
                o.copy(this.previousPosition, this.position), this.previousAngle = this.angle, this.fixedRotation || (this.angularVelocity += this.angularForce * this.invInertia * t), o.scale(S, i, t * e), o.multiply(S, this.massMultiplier, S), o.add(n, S, n), this.integrateToTimeOfImpact(t) || (o.scale(w, n, t), o.add(s, s, w), this.fixedRotation || (this.angle += this.angularVelocity * t)), this.aabbNeedsUpdate = !0
            };
            var A = new r,
                T = new h({
                    mode: h.ALL
                }),
                B = o.create(),
                P = o.create(),
                D = o.create(),
                I = o.create();
            s.prototype.integrateToTimeOfImpact = function(t) {
                if (this.ccdSpeedThreshold < 0 || o.squaredLength(this.velocity) < Math.pow(this.ccdSpeedThreshold, 2)) return !1;
                o.normalize(B, this.velocity), o.scale(P, this.velocity, t), o.add(P, P, this.position), o.sub(D, P, this.position);
                var e, i = this.angularVelocity * t,
                    s = o.length(D),
                    n = 1,
                    a = this;
                if (A.reset(), T.callback = function(t) {
                        t.body !== a && (e = t.body, t.getHitPoint(P, T), o.sub(D, P, a.position), n = o.length(D) / s, t.stop())
                    }, o.copy(T.from, this.position), o.copy(T.to, P), T.update(), this.world.raycast(A, T), !e) return !1;
                var r = this.angle;
                o.copy(I, this.position);
                for (var h = 0, l = 0, c = 0, p = n; p >= l && h < this.ccdIterations;) h++, c = (p - l) / 2, o.scale(w, D, n), o.add(this.position, I, w), this.angle = r + i * n, this.updateAABB(), this.aabb.overlaps(e.aabb) && this.world.narrowphase.bodiesOverlap(this, e) ? l = c : p = c;
                return n = c, o.copy(this.position, I), this.angle = r, o.scale(w, D, n), o.add(this.position, this.position, w), this.fixedRotation || (this.angle += i * n), !0
            }, s.prototype.getVelocityAtPoint = function(t, e) {
                return o.crossVZ(t, e, this.angularVelocity), o.subtract(t, this.velocity, t), t
            }, s.sleepyEvent = {
                type: "sleepy"
            }, s.sleepEvent = {
                type: "sleep"
            }, s.wakeUpEvent = {
                type: "wakeup"
            }, s.DYNAMIC = 1, s.STATIC = 2, s.KINEMATIC = 4, s.AWAKE = 0, s.SLEEPY = 1, s.SLEEPING = 2
        }, {
            "../collision/AABB": 7,
            "../collision/Ray": 11,
            "../collision/RaycastResult": 12,
            "../events/EventEmitter": 26,
            "../math/vec2": 30,
            "../shapes/Convex": 40,
            "poly-decomp": 5
        }],
        32: [function(t, e, i) {
            function s(t, e, i) {
                i = i || {}, n.call(this, t, e, i), this.localAnchorA = o.fromValues(0, 0), this.localAnchorB = o.fromValues(0, 0), i.localAnchorA && o.copy(this.localAnchorA, i.localAnchorA), i.localAnchorB && o.copy(this.localAnchorB, i.localAnchorB), i.worldAnchorA && this.setWorldAnchorA(i.worldAnchorA), i.worldAnchorB && this.setWorldAnchorB(i.worldAnchorB);
                var s = o.create(),
                    a = o.create();
                this.getWorldAnchorA(s), this.getWorldAnchorB(a);
                var r = o.distance(s, a);
                this.restLength = "number" == typeof i.restLength ? i.restLength : r
            }
            var o = t("../math/vec2"),
                n = t("./Spring");
            t("../utils/Utils"), e.exports = s, (s.prototype = new n).constructor = s, s.prototype.setWorldAnchorA = function(t) {
                this.bodyA.toLocalFrame(this.localAnchorA, t)
            }, s.prototype.setWorldAnchorB = function(t) {
                this.bodyB.toLocalFrame(this.localAnchorB, t)
            }, s.prototype.getWorldAnchorA = function(t) {
                this.bodyA.toWorldFrame(t, this.localAnchorA)
            }, s.prototype.getWorldAnchorB = function(t) {
                this.bodyB.toWorldFrame(t, this.localAnchorB)
            };
            var a = o.create(),
                r = o.create(),
                h = o.create(),
                l = o.create(),
                c = o.create(),
                p = o.create(),
                u = o.create(),
                d = o.create(),
                m = o.create();
            s.prototype.applyForce = function() {
                var t = this.stiffness,
                    e = this.damping,
                    i = this.restLength,
                    s = this.bodyA,
                    n = this.bodyB,
                    y = a,
                    f = r,
                    g = h,
                    _ = l,
                    v = m,
                    b = c,
                    x = p,
                    C = u,
                    S = d;
                this.getWorldAnchorA(b), this.getWorldAnchorB(x), o.sub(C, b, s.position), o.sub(S, x, n.position), o.sub(y, x, b);
                var w = o.len(y);
                o.normalize(f, y), o.sub(g, n.velocity, s.velocity), o.crossZV(v, n.angularVelocity, S), o.add(g, g, v), o.crossZV(v, s.angularVelocity, C), o.sub(g, g, v), o.scale(_, f, -t * (w - i) - e * o.dot(g, f)), o.sub(s.force, s.force, _), o.add(n.force, n.force, _);
                var A = o.crossLength(C, _),
                    T = o.crossLength(S, _);
                s.angularForce -= A, n.angularForce += T
            }
        }, {
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Spring": 34
        }],
        33: [function(t, e, i) {
            function s(t, e, i) {
                i = i || {}, o.call(this, t, e, i), this.restAngle = "number" == typeof i.restAngle ? i.restAngle : e.angle - t.angle
            }
            var o = (t("../math/vec2"), t("./Spring"));
            e.exports = s, (s.prototype = new o).constructor = s, s.prototype.applyForce = function() {
                var t = this.stiffness,
                    e = this.damping,
                    i = this.restAngle,
                    s = this.bodyA,
                    o = this.bodyB,
                    n = -t * (o.angle - s.angle - i) - e * (o.angularVelocity - s.angularVelocity) * 0;
                s.angularForce -= n, o.angularForce += n
            }
        }, {
            "../math/vec2": 30,
            "./Spring": 34
        }],
        34: [function(t, e, i) {
            function s(t, e, i) {
                i = o.defaults(i, {
                    stiffness: 100,
                    damping: 1
                }), this.stiffness = i.stiffness, this.damping = i.damping, this.bodyA = t, this.bodyB = e
            }
            var o = (t("../math/vec2"), t("../utils/Utils"));
            e.exports = s, s.prototype.applyForce = function() {}
        }, {
            "../math/vec2": 30,
            "../utils/Utils": 57
        }],
        35: [function(t, e, i) {
            function s(t, e) {
                e = e || {}, this.chassisBody = t, this.wheels = [], this.groundBody = new h({
                    mass: 0
                }), this.world = null;
                var i = this;
                this.preStepCallback = function() {
                    i.update()
                }
            }

            function o(t, e) {
                e = e || {}, this.vehicle = t, this.forwardEquation = new r(t.chassisBody, t.groundBody), this.sideEquation = new r(t.chassisBody, t.groundBody), this.steerValue = 0, this.engineForce = 0, this.setSideFriction(void 0 !== e.sideFriction ? e.sideFriction : 5), this.localForwardVector = n.fromValues(0, 1), e.localForwardVector && n.copy(this.localForwardVector, e.localForwardVector), this.localPosition = n.fromValues(0, 0), e.localPosition && n.copy(this.localPosition, e.localPosition), a.apply(this, t.chassisBody, t.groundBody), this.equations.push(this.forwardEquation, this.sideEquation), this.setBrakeForce(0)
            }
            var n = t("../math/vec2"),
                a = (t("../utils/Utils"), t("../constraints/Constraint")),
                r = t("../equations/FrictionEquation"),
                h = t("../objects/Body");
            e.exports = s, s.prototype.addToWorld = function(t) {
                this.world = t, t.addBody(this.groundBody), t.on("preStep", this.preStepCallback);
                for (var e = 0; e < this.wheels.length; e++) {
                    var i = this.wheels[e];
                    t.addConstraint(i)
                }
            }, s.prototype.removeFromWorld = function() {
                var t = this.world;
                t.removeBody(this.groundBody), t.off("preStep", this.preStepCallback);
                for (var e = 0; e < this.wheels.length; e++) {
                    var i = this.wheels[e];
                    t.removeConstraint(i)
                }
                this.world = null
            }, s.prototype.addWheel = function(t) {
                var e = new o(this, t);
                return this.wheels.push(e), e
            }, s.prototype.update = function() {
                for (var t = 0; t < this.wheels.length; t++) this.wheels[t].update()
            }, (o.prototype = new a).setBrakeForce = function(t) {
                this.forwardEquation.setSlipForce(t)
            }, o.prototype.setSideFriction = function(t) {
                this.sideEquation.setSlipForce(t)
            };
            var l = n.create(),
                c = n.create();
            o.prototype.getSpeed = function() {
                return this.vehicle.chassisBody.vectorToWorldFrame(c, this.localForwardVector), this.vehicle.chassisBody.getVelocityAtPoint(l, c), n.dot(l, c)
            };
            var p = n.create();
            o.prototype.update = function() {
                this.vehicle.chassisBody.vectorToWorldFrame(this.forwardEquation.t, this.localForwardVector), n.rotate(this.sideEquation.t, this.localForwardVector, Math.PI / 2), this.vehicle.chassisBody.vectorToWorldFrame(this.sideEquation.t, this.sideEquation.t), n.rotate(this.forwardEquation.t, this.forwardEquation.t, this.steerValue), n.rotate(this.sideEquation.t, this.sideEquation.t, this.steerValue), this.vehicle.chassisBody.toWorldFrame(this.forwardEquation.contactPointB, this.localPosition), n.copy(this.sideEquation.contactPointB, this.forwardEquation.contactPointB), this.vehicle.chassisBody.vectorToWorldFrame(this.forwardEquation.contactPointA, this.localPosition), n.copy(this.sideEquation.contactPointA, this.forwardEquation.contactPointA), n.normalize(p, this.forwardEquation.t), n.scale(p, p, this.engineForce), this.vehicle.chassisBody.applyForce(p, this.forwardEquation.contactPointA)
            }
        }, {
            "../constraints/Constraint": 14,
            "../equations/FrictionEquation": 23,
            "../math/vec2": 30,
            "../objects/Body": 31,
            "../utils/Utils": 57
        }],
        36: [function(t, e, i) {
            var s = e.exports = {
                AABB: t("./collision/AABB"),
                AngleLockEquation: t("./equations/AngleLockEquation"),
                Body: t("./objects/Body"),
                Broadphase: t("./collision/Broadphase"),
                Capsule: t("./shapes/Capsule"),
                Circle: t("./shapes/Circle"),
                Constraint: t("./constraints/Constraint"),
                ContactEquation: t("./equations/ContactEquation"),
                ContactEquationPool: t("./utils/ContactEquationPool"),
                ContactMaterial: t("./material/ContactMaterial"),
                Convex: t("./shapes/Convex"),
                DistanceConstraint: t("./constraints/DistanceConstraint"),
                Equation: t("./equations/Equation"),
                EventEmitter: t("./events/EventEmitter"),
                FrictionEquation: t("./equations/FrictionEquation"),
                FrictionEquationPool: t("./utils/FrictionEquationPool"),
                GearConstraint: t("./constraints/GearConstraint"),
                GSSolver: t("./solver/GSSolver"),
                Heightfield: t("./shapes/Heightfield"),
                Line: t("./shapes/Line"),
                LockConstraint: t("./constraints/LockConstraint"),
                Material: t("./material/Material"),
                Narrowphase: t("./collision/Narrowphase"),
                NaiveBroadphase: t("./collision/NaiveBroadphase"),
                Particle: t("./shapes/Particle"),
                Plane: t("./shapes/Plane"),
                Pool: t("./utils/Pool"),
                RevoluteConstraint: t("./constraints/RevoluteConstraint"),
                PrismaticConstraint: t("./constraints/PrismaticConstraint"),
                Ray: t("./collision/Ray"),
                RaycastResult: t("./collision/RaycastResult"),
                Box: t("./shapes/Box"),
                RotationalVelocityEquation: t("./equations/RotationalVelocityEquation"),
                SAPBroadphase: t("./collision/SAPBroadphase"),
                Shape: t("./shapes/Shape"),
                Solver: t("./solver/Solver"),
                Spring: t("./objects/Spring"),
                TopDownVehicle: t("./objects/TopDownVehicle"),
                LinearSpring: t("./objects/LinearSpring"),
                RotationalSpring: t("./objects/RotationalSpring"),
                Utils: t("./utils/Utils"),
                World: t("./world/World"),
                vec2: t("./math/vec2"),
                version: t("../package.json").version
            };
            Object.defineProperty(s, "Rectangle", {
                get: function() {
                    return console.warn("The Rectangle class has been renamed to Box."), this.Box
                }
            })
        }, {
            "../package.json": 6,
            "./collision/AABB": 7,
            "./collision/Broadphase": 8,
            "./collision/NaiveBroadphase": 9,
            "./collision/Narrowphase": 10,
            "./collision/Ray": 11,
            "./collision/RaycastResult": 12,
            "./collision/SAPBroadphase": 13,
            "./constraints/Constraint": 14,
            "./constraints/DistanceConstraint": 15,
            "./constraints/GearConstraint": 16,
            "./constraints/LockConstraint": 17,
            "./constraints/PrismaticConstraint": 18,
            "./constraints/RevoluteConstraint": 19,
            "./equations/AngleLockEquation": 20,
            "./equations/ContactEquation": 21,
            "./equations/Equation": 22,
            "./equations/FrictionEquation": 23,
            "./equations/RotationalVelocityEquation": 25,
            "./events/EventEmitter": 26,
            "./material/ContactMaterial": 27,
            "./material/Material": 28,
            "./math/vec2": 30,
            "./objects/Body": 31,
            "./objects/LinearSpring": 32,
            "./objects/RotationalSpring": 33,
            "./objects/Spring": 34,
            "./objects/TopDownVehicle": 35,
            "./shapes/Box": 37,
            "./shapes/Capsule": 38,
            "./shapes/Circle": 39,
            "./shapes/Convex": 40,
            "./shapes/Heightfield": 41,
            "./shapes/Line": 42,
            "./shapes/Particle": 43,
            "./shapes/Plane": 44,
            "./shapes/Shape": 45,
            "./solver/GSSolver": 46,
            "./solver/Solver": 47,
            "./utils/ContactEquationPool": 48,
            "./utils/FrictionEquationPool": 49,
            "./utils/Pool": 55,
            "./utils/Utils": 57,
            "./world/World": 61
        }],
        37: [function(t, e, i) {
            function s(t) {
                "number" == typeof arguments[0] && "number" == typeof arguments[1] && (t = {
                    width: arguments[0],
                    height: arguments[1]
                }, console.warn("The Rectangle has been renamed to Box and its constructor signature has changed. Please use the following format: new Box({ width: 1, height: 1, ... })")), t = t || {};
                var e = this.width = t.width || 1,
                    i = this.height = t.height || 1,
                    s = [o.fromValues(-e / 2, -i / 2), o.fromValues(e / 2, -i / 2), o.fromValues(e / 2, i / 2), o.fromValues(-e / 2, i / 2)],
                    r = [o.fromValues(1, 0), o.fromValues(0, 1)];
                t.vertices = s, t.axes = r, t.type = n.BOX, a.call(this, t)
            }
            var o = t("../math/vec2"),
                n = t("./Shape"),
                a = t("./Convex");
            e.exports = s, (s.prototype = new a).constructor = s, s.prototype.computeMomentOfInertia = function(t) {
                var e = this.width,
                    i = this.height;
                return t * (i * i + e * e) / 12
            }, s.prototype.updateBoundingRadius = function() {
                var t = this.width,
                    e = this.height;
                this.boundingRadius = Math.sqrt(t * t + e * e) / 2
            }, o.create(), o.create(), o.create(), o.create(), s.prototype.computeAABB = function(t, e, i) {
                t.setFromPoints(this.vertices, e, i, 0)
            }, s.prototype.updateArea = function() {
                this.area = this.width * this.height
            }
        }, {
            "../math/vec2": 30,
            "./Convex": 40,
            "./Shape": 45
        }],
        38: [function(t, e, i) {
            function s(t) {
                "number" == typeof arguments[0] && "number" == typeof arguments[1] && (t = {
                    length: arguments[0],
                    radius: arguments[1]
                }, console.warn("The Capsule constructor signature has changed. Please use the following format: new Capsule({ radius: 1, length: 1 })")), t = t || {}, this.length = t.length || 1, this.radius = t.radius || 1, t.type = o.CAPSULE, o.call(this, t)
            }
            var o = t("./Shape"),
                n = t("../math/vec2");
            e.exports = s, (s.prototype = new o).constructor = s, s.prototype.computeMomentOfInertia = function(t) {
                var e = this.radius,
                    i = this.length + e,
                    s = 2 * e;
                return t * (s * s + i * i) / 12
            }, s.prototype.updateBoundingRadius = function() {
                this.boundingRadius = this.radius + this.length / 2
            }, s.prototype.updateArea = function() {
                this.area = Math.PI * this.radius * this.radius + 2 * this.radius * this.length
            };
            var a = n.create();
            s.prototype.computeAABB = function(t, e, i) {
                var s = this.radius;
                n.set(a, this.length / 2, 0), 0 !== i && n.rotate(a, a, i), n.set(t.upperBound, Math.max(a[0] + s, -a[0] + s), Math.max(a[1] + s, -a[1] + s)), n.set(t.lowerBound, Math.min(a[0] - s, -a[0] - s), Math.min(a[1] - s, -a[1] - s)), n.add(t.lowerBound, t.lowerBound, e), n.add(t.upperBound, t.upperBound, e)
            };
            var r = n.create(),
                h = n.create(),
                l = n.create(),
                c = n.create(),
                p = n.fromValues(0, 1);
            s.prototype.raycast = function(t, e, i, s) {
                for (var o = e.from, a = e.to, u = (e.direction, r), d = h, m = l, y = c, f = this.length / 2, g = 0; g < 2; g++) {
                    var _ = this.radius * (2 * g - 1);
                    if (n.set(m, -f, _), n.set(y, f, _), n.toGlobalFrame(m, m, i, s), n.toGlobalFrame(y, y, i, s), (S = n.getLineSegmentsIntersectionFraction(o, a, m, y)) >= 0 && (n.rotate(d, p, s), n.scale(d, d, 2 * g - 1), e.reportIntersection(t, S, d, -1), t.shouldStop(e))) return
                }
                for (var v = Math.pow(this.radius, 2) + Math.pow(f, 2), g = 0; g < 2; g++) {
                    n.set(m, f * (2 * g - 1), 0), n.toGlobalFrame(m, m, i, s);
                    var b = Math.pow(a[0] - o[0], 2) + Math.pow(a[1] - o[1], 2),
                        x = 2 * ((a[0] - o[0]) * (o[0] - m[0]) + (a[1] - o[1]) * (o[1] - m[1])),
                        C = Math.pow(o[0] - m[0], 2) + Math.pow(o[1] - m[1], 2) - Math.pow(this.radius, 2),
                        S = Math.pow(x, 2) - 4 * b * C;
                    if (!(S < 0))
                        if (0 === S) {
                            if (n.lerp(u, o, a, S), n.squaredDistance(u, i) > v && (n.sub(d, u, m), n.normalize(d, d), e.reportIntersection(t, S, d, -1), t.shouldStop(e))) return
                        } else {
                            var w = Math.sqrt(S),
                                A = 1 / (2 * b),
                                T = (-x - w) * A,
                                B = (-x + w) * A;
                            if (T >= 0 && T <= 1 && (n.lerp(u, o, a, T), n.squaredDistance(u, i) > v && (n.sub(d, u, m), n.normalize(d, d), e.reportIntersection(t, T, d, -1), t.shouldStop(e)))) return;
                            if (B >= 0 && B <= 1 && (n.lerp(u, o, a, B), n.squaredDistance(u, i) > v && (n.sub(d, u, m), n.normalize(d, d), e.reportIntersection(t, B, d, -1), t.shouldStop(e)))) return
                        }
                }
            }
        }, {
            "../math/vec2": 30,
            "./Shape": 45
        }],
        39: [function(t, e, i) {
            function s(t) {
                "number" == typeof arguments[0] && (t = {
                    radius: arguments[0]
                }, console.warn("The Circle constructor signature has changed. Please use the following format: new Circle({ radius: 1 })")), t = t || {}, this.radius = t.radius || 1, t.type = o.CIRCLE, o.call(this, t)
            }
            var o = t("./Shape"),
                n = t("../math/vec2");
            e.exports = s, (s.prototype = new o).constructor = s, s.prototype.computeMomentOfInertia = function(t) {
                var e = this.radius;
                return t * e * e / 2
            }, s.prototype.updateBoundingRadius = function() {
                this.boundingRadius = this.radius
            }, s.prototype.updateArea = function() {
                this.area = Math.PI * this.radius * this.radius
            }, s.prototype.computeAABB = function(t, e, i) {
                var s = this.radius;
                n.set(t.upperBound, s, s), n.set(t.lowerBound, -s, -s), e && (n.add(t.lowerBound, t.lowerBound, e), n.add(t.upperBound, t.upperBound, e))
            };
            var a = n.create(),
                r = n.create();
            s.prototype.raycast = function(t, e, i, s) {
                var o = e.from,
                    h = e.to,
                    l = this.radius,
                    c = Math.pow(h[0] - o[0], 2) + Math.pow(h[1] - o[1], 2),
                    p = 2 * ((h[0] - o[0]) * (o[0] - i[0]) + (h[1] - o[1]) * (o[1] - i[1])),
                    u = Math.pow(o[0] - i[0], 2) + Math.pow(o[1] - i[1], 2) - Math.pow(l, 2),
                    d = Math.pow(p, 2) - 4 * c * u,
                    m = a,
                    y = r;
                if (!(d < 0))
                    if (0 === d) n.lerp(m, o, h, d), n.sub(y, m, i), n.normalize(y, y), e.reportIntersection(t, d, y, -1);
                    else {
                        var f = Math.sqrt(d),
                            g = 1 / (2 * c),
                            _ = (-p - f) * g,
                            v = (-p + f) * g;
                        if (_ >= 0 && _ <= 1 && (n.lerp(m, o, h, _), n.sub(y, m, i), n.normalize(y, y), e.reportIntersection(t, _, y, -1), t.shouldStop(e))) return;
                        v >= 0 && v <= 1 && (n.lerp(m, o, h, v), n.sub(y, m, i), n.normalize(y, y), e.reportIntersection(t, v, y, -1))
                    }
            }
        }, {
            "../math/vec2": 30,
            "./Shape": 45
        }],
        40: [function(t, e, i) {
            function s(t) {
                Array.isArray(arguments[0]) && (t = {
                    vertices: arguments[0],
                    axes: arguments[1]
                }, console.warn("The Convex constructor signature has changed. Please use the following format: new Convex({ vertices: [...], ... })")), t = t || {}, this.vertices = [];
                for (var e = void 0 !== t.vertices ? t.vertices : [], i = 0; i < e.length; i++) {
                    var s = n.create();
                    n.copy(s, e[i]), this.vertices.push(s)
                }
                if (this.axes = [], t.axes)
                    for (i = 0; i < t.axes.length; i++) {
                        var a = n.create();
                        n.copy(a, t.axes[i]), this.axes.push(a)
                    } else
                        for (i = 0; i < this.vertices.length; i++) {
                            var r = this.vertices[i],
                                h = this.vertices[(i + 1) % this.vertices.length],
                                l = n.create();
                            n.sub(l, h, r), n.rotate90cw(l, l), n.normalize(l, l), this.axes.push(l)
                        }
                if (this.centerOfMass = n.fromValues(0, 0), this.triangles = [], this.vertices.length && (this.updateTriangles(), this.updateCenterOfMass()), this.boundingRadius = 0, t.type = o.CONVEX, o.call(this, t), this.updateBoundingRadius(), this.updateArea(), this.area < 0) throw new Error("Convex vertices must be given in conter-clockwise winding.")
            }
            var o = t("./Shape"),
                n = t("../math/vec2"),
                a = t("../math/polyk");
            t("poly-decomp"), e.exports = s, (s.prototype = new o).constructor = s;
            var r = n.create(),
                h = n.create();
            s.prototype.projectOntoLocalAxis = function(t, e) {
                for (var i, s, o = null, a = null, t = r, h = 0; h < this.vertices.length; h++) i = this.vertices[h], s = n.dot(i, t), (null === o || s > o) && (o = s), (null === a || s < a) && (a = s);
                if (a > o) {
                    var l = a;
                    a = o, o = l
                }
                n.set(e, a, o)
            }, s.prototype.projectOntoWorldAxis = function(t, e, i, s) {
                var o = h;
                this.projectOntoLocalAxis(t, s), 0 !== i ? n.rotate(o, t, i) : o = t;
                var a = n.dot(e, o);
                n.set(s, s[0] + a, s[1] + a)
            }, s.prototype.updateTriangles = function() {
                this.triangles.length = 0;
                for (var t = [], e = 0; e < this.vertices.length; e++) {
                    var i = this.vertices[e];
                    t.push(i[0], i[1])
                }
                for (var s = a.Triangulate(t), e = 0; e < s.length; e += 3) {
                    var o = s[e],
                        n = s[e + 1],
                        r = s[e + 2];
                    this.triangles.push([o, n, r])
                }
            };
            var l = n.create(),
                c = n.create(),
                p = n.create(),
                u = n.create(),
                d = n.create();
            n.create(), n.create(), n.create(), n.create(), s.prototype.updateCenterOfMass = function() {
                var t = this.triangles,
                    e = this.vertices,
                    i = this.centerOfMass,
                    o = l,
                    a = p,
                    r = u,
                    h = d,
                    m = c;
                n.set(i, 0, 0);
                for (var y = 0, f = 0; f !== t.length; f++) {
                    var g = t[f],
                        a = e[g[0]],
                        r = e[g[1]],
                        h = e[g[2]];
                    n.centroid(o, a, r, h);
                    var _ = s.triangleArea(a, r, h);
                    y += _, n.scale(m, o, _), n.add(i, i, m)
                }
                n.scale(i, i, 1 / y)
            }, s.prototype.computeMomentOfInertia = function(t) {
                for (var e = 0, i = 0, s = this.vertices.length, o = s - 1, a = 0; a < s; o = a, a++) {
                    var r = this.vertices[o],
                        h = this.vertices[a],
                        l = Math.abs(n.crossLength(r, h));
                    e += l * (n.dot(h, h) + n.dot(h, r) + n.dot(r, r)), i += l
                }
                return t / 6 * (e / i)
            }, s.prototype.updateBoundingRadius = function() {
                for (var t = this.vertices, e = 0, i = 0; i !== t.length; i++) {
                    var s = n.squaredLength(t[i]);
                    s > e && (e = s)
                }
                this.boundingRadius = Math.sqrt(e)
            }, s.triangleArea = function(t, e, i) {
                return .5 * ((e[0] - t[0]) * (i[1] - t[1]) - (i[0] - t[0]) * (e[1] - t[1]))
            }, s.prototype.updateArea = function() {
                this.updateTriangles(), this.area = 0;
                for (var t = this.triangles, e = this.vertices, i = 0; i !== t.length; i++) {
                    var o = t[i],
                        n = e[o[0]],
                        a = e[o[1]],
                        r = e[o[2]],
                        h = s.triangleArea(n, a, r);
                    this.area += h
                }
            }, s.prototype.computeAABB = function(t, e, i) {
                t.setFromPoints(this.vertices, e, i, 0)
            };
            var m = n.create(),
                y = n.create(),
                f = n.create();
            s.prototype.raycast = function(t, e, i, s) {
                var o = m,
                    a = y,
                    r = f,
                    h = this.vertices;
                n.toLocalFrame(o, e.from, i, s), n.toLocalFrame(a, e.to, i, s);
                for (var l = h.length, c = 0; c < l && !t.shouldStop(e); c++) {
                    var p = h[c],
                        u = h[(c + 1) % l],
                        d = n.getLineSegmentsIntersectionFraction(o, a, p, u);
                    d >= 0 && (n.sub(r, u, p), n.rotate(r, r, -Math.PI / 2 + s), n.normalize(r, r), e.reportIntersection(t, d, r, c))
                }
            }
        }, {
            "../math/polyk": 29,
            "../math/vec2": 30,
            "./Shape": 45,
            "poly-decomp": 5
        }],
        41: [function(t, e, i) {
            function s(t) {
                if (Array.isArray(arguments[0])) {
                    if (t = {
                            heights: arguments[0]
                        }, "object" == typeof arguments[1])
                        for (var e in arguments[1]) t[e] = arguments[1][e];
                    console.warn("The Heightfield constructor signature has changed. Please use the following format: new Heightfield({ heights: [...], ... })")
                }
                t = t || {}, this.heights = t.heights ? t.heights.slice(0) : [], this.maxValue = t.maxValue || null, this.minValue = t.minValue || null, this.elementWidth = t.elementWidth || .1, void 0 !== t.maxValue && void 0 !== t.minValue || this.updateMaxMinValues(), t.type = o.HEIGHTFIELD, o.call(this, t)
            }
            var o = t("./Shape"),
                n = t("../math/vec2");
            t("../utils/Utils"), e.exports = s, (s.prototype = new o).constructor = s, s.prototype.updateMaxMinValues = function() {
                for (var t = this.heights, e = t[0], i = t[0], s = 0; s !== t.length; s++) {
                    var o = t[s];
                    o > e && (e = o), o < i && (i = o)
                }
                this.maxValue = e, this.minValue = i
            }, s.prototype.computeMomentOfInertia = function(t) {
                return Number.MAX_VALUE
            }, s.prototype.updateBoundingRadius = function() {
                this.boundingRadius = Number.MAX_VALUE
            }, s.prototype.updateArea = function() {
                for (var t = this.heights, e = 0, i = 0; i < t.length - 1; i++) e += (t[i] + t[i + 1]) / 2 * this.elementWidth;
                this.area = e
            };
            var a = [n.create(), n.create(), n.create(), n.create()];
            s.prototype.computeAABB = function(t, e, i) {
                n.set(a[0], 0, this.maxValue), n.set(a[1], this.elementWidth * this.heights.length, this.maxValue), n.set(a[2], this.elementWidth * this.heights.length, this.minValue), n.set(a[3], 0, this.minValue), t.setFromPoints(a, e, i)
            }, s.prototype.getLineSegment = function(t, e, i) {
                var s = this.heights,
                    o = this.elementWidth;
                n.set(t, i * o, s[i]), n.set(e, (i + 1) * o, s[i + 1])
            }, s.prototype.getSegmentIndex = function(t) {
                return Math.floor(t[0] / this.elementWidth)
            }, s.prototype.getClampedSegmentIndex = function(t) {
                var e = this.getSegmentIndex(t);
                return e = Math.min(this.heights.length, Math.max(e, 0))
            };
            var r = (n.create(), n.create()),
                h = n.create(),
                l = n.create(),
                c = n.create(),
                p = n.create();
            n.fromValues(0, 1), s.prototype.raycast = function(t, e, i, s) {
                var o = e.from,
                    a = e.to,
                    u = (e.direction, r),
                    d = h,
                    m = l,
                    y = c,
                    f = p;
                n.toLocalFrame(y, o, i, s), n.toLocalFrame(f, a, i, s);
                var g = this.getClampedSegmentIndex(y),
                    _ = this.getClampedSegmentIndex(f);
                if (g > _) {
                    var v = g;
                    g = _, _ = v
                }
                for (var b = 0; b < this.heights.length - 1; b++) {
                    this.getLineSegment(d, m, b);
                    var x = n.getLineSegmentsIntersectionFraction(y, f, d, m);
                    if (x >= 0 && (n.sub(u, m, d), n.rotate(u, u, s + Math.PI / 2), n.normalize(u, u), e.reportIntersection(t, x, u, -1), t.shouldStop(e))) return
                }
            }
        }, {
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Shape": 45
        }],
        42: [function(t, e, i) {
            function s(t) {
                "number" == typeof arguments[0] && (t = {
                    length: arguments[0]
                }, console.warn("The Line constructor signature has changed. Please use the following format: new Line({ length: 1, ... })")), t = t || {}, this.length = t.length || 1, t.type = o.LINE, o.call(this, t)
            }
            var o = t("./Shape"),
                n = t("../math/vec2");
            e.exports = s, (s.prototype = new o).constructor = s, s.prototype.computeMomentOfInertia = function(t) {
                return t * Math.pow(this.length, 2) / 12
            }, s.prototype.updateBoundingRadius = function() {
                this.boundingRadius = this.length / 2
            };
            var a = [n.create(), n.create()];
            s.prototype.computeAABB = function(t, e, i) {
                var s = this.length / 2;
                n.set(a[0], -s, 0), n.set(a[1], s, 0), t.setFromPoints(a, e, i, 0)
            };
            var r = (n.create(), n.create()),
                h = n.create(),
                l = n.create(),
                c = n.fromValues(0, 1);
            s.prototype.raycast = function(t, e, i, s) {
                var o = e.from,
                    a = e.to,
                    p = h,
                    u = l,
                    d = this.length / 2;
                n.set(p, -d, 0), n.set(u, d, 0), n.toGlobalFrame(p, p, i, s), n.toGlobalFrame(u, u, i, s);
                var m = n.getLineSegmentsIntersectionFraction(p, u, o, a);
                if (m >= 0) {
                    var y = r;
                    n.rotate(y, c, s), e.reportIntersection(t, m, y, -1)
                }
            }
        }, {
            "../math/vec2": 30,
            "./Shape": 45
        }],
        43: [function(t, e, i) {
            function s(t) {
                (t = t || {}).type = o.PARTICLE, o.call(this, t)
            }
            var o = t("./Shape"),
                n = t("../math/vec2");
            e.exports = s, (s.prototype = new o).constructor = s, s.prototype.computeMomentOfInertia = function(t) {
                return 0
            }, s.prototype.updateBoundingRadius = function() {
                this.boundingRadius = 0
            }, s.prototype.computeAABB = function(t, e, i) {
                n.copy(t.lowerBound, e), n.copy(t.upperBound, e)
            }
        }, {
            "../math/vec2": 30,
            "./Shape": 45
        }],
        44: [function(t, e, i) {
            function s(t) {
                (t = t || {}).type = o.PLANE, o.call(this, t)
            }
            var o = t("./Shape"),
                n = t("../math/vec2");
            t("../utils/Utils"), e.exports = s, (s.prototype = new o).constructor = s, s.prototype.computeMomentOfInertia = function(t) {
                return 0
            }, s.prototype.updateBoundingRadius = function() {
                this.boundingRadius = Number.MAX_VALUE
            }, s.prototype.computeAABB = function(t, e, i) {
                var s = i % (2 * Math.PI),
                    o = n.set,
                    a = Number.MAX_VALUE,
                    r = t.lowerBound,
                    h = t.upperBound;
                0 === s ? (o(r, -a, -a), o(h, a, 0)) : s === Math.PI / 2 ? (o(r, 0, -a), o(h, a, a)) : s === Math.PI ? (o(r, -a, 0), o(h, a, a)) : s === 3 * Math.PI / 2 ? (o(r, -a, -a), o(h, 0, a)) : (o(r, -a, -a), o(h, a, a)), n.add(r, r, e), n.add(h, h, e)
            }, s.prototype.updateArea = function() {
                this.area = Number.MAX_VALUE
            };
            var a = n.create(),
                r = (n.create(), n.create(), n.create()),
                h = n.create();
            s.prototype.raycast = function(t, e, i, s) {
                var o = e.from,
                    l = e.to,
                    c = e.direction,
                    p = a,
                    u = r,
                    d = h;
                n.set(u, 0, 1), n.rotate(u, u, s), n.sub(d, o, i);
                var m = n.dot(d, u);
                if (n.sub(d, l, i), !(m * n.dot(d, u) > 0 || n.squaredDistance(o, l) < m * m)) {
                    var y = n.dot(u, c);
                    n.sub(p, o, i);
                    var f = -n.dot(u, p) / y / e.length;
                    e.reportIntersection(t, f, u, -1)
                }
            }
        }, {
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Shape": 45
        }],
        45: [function(t, e, i) {
            function s(t) {
                t = t || {}, this.body = null, this.position = o.fromValues(0, 0), t.position && o.copy(this.position, t.position), this.angle = t.angle || 0, this.type = t.type || 0, this.id = s.idCounter++, this.boundingRadius = 0, this.collisionGroup = void 0 !== t.collisionGroup ? t.collisionGroup : 1, this.collisionResponse = void 0 === t.collisionResponse || t.collisionResponse, this.collisionMask = void 0 !== t.collisionMask ? t.collisionMask : 1, this.material = t.material || null, this.area = 0, this.sensor = void 0 !== t.sensor && t.sensor, this.type && this.updateBoundingRadius(), this.updateArea()
            }
            e.exports = s;
            var o = t("../math/vec2");
            s.idCounter = 0, s.CIRCLE = 1, s.PARTICLE = 2, s.PLANE = 4, s.CONVEX = 8, s.LINE = 16, s.BOX = 32, Object.defineProperty(s, "RECTANGLE", {
                get: function() {
                    return console.warn("Shape.RECTANGLE is deprecated, use Shape.BOX instead."), s.BOX
                }
            }), s.CAPSULE = 64, s.HEIGHTFIELD = 128, s.prototype.computeMomentOfInertia = function(t) {}, s.prototype.updateBoundingRadius = function() {}, s.prototype.updateArea = function() {}, s.prototype.computeAABB = function(t, e, i) {}, s.prototype.raycast = function(t, e, i, s) {}
        }, {
            "../math/vec2": 30
        }],
        46: [function(t, e, i) {
            function s(t) {
                a.call(this, t, a.GS), t = t || {}, this.iterations = t.iterations || 10, this.tolerance = t.tolerance || 1e-7, this.arrayStep = 30, this.lambda = new r.ARRAY_TYPE(this.arrayStep), this.Bs = new r.ARRAY_TYPE(this.arrayStep), this.invCs = new r.ARRAY_TYPE(this.arrayStep), this.useZeroRHS = !1, this.frictionIterations = 0, this.usedIterations = 0
            }

            function o(t) {
                for (var e = t.length; e--;) t[e] = 0
            }
            var n = t("../math/vec2"),
                a = t("./Solver"),
                r = t("../utils/Utils"),
                h = t("../equations/FrictionEquation");
            e.exports = s, (s.prototype = new a).constructor = s, s.prototype.solve = function(t, e) {
                this.sortEquations();
                var i = 0,
                    a = this.iterations,
                    l = this.frictionIterations,
                    c = this.equations,
                    p = c.length,
                    u = Math.pow(this.tolerance * p, 2),
                    d = e.bodies,
                    m = e.bodies.length,
                    y = (n.add, n.set, this.useZeroRHS),
                    f = this.lambda;
                if (this.usedIterations = 0, p)
                    for (v = 0; v !== m; v++)(S = d[v]).updateSolveMassProperties();
                f.length < p && (f = this.lambda = new r.ARRAY_TYPE(p + this.arrayStep), this.Bs = new r.ARRAY_TYPE(p + this.arrayStep), this.invCs = new r.ARRAY_TYPE(p + this.arrayStep)), o(f);
                for (var g = this.invCs, _ = this.Bs, f = this.lambda, v = 0; v !== c.length; v++)((b = c[v]).timeStep !== t || b.needsUpdate) && (b.timeStep = t, b.update()), _[v] = b.computeB(b.a, b.b, t), g[v] = b.computeInvC(b.epsilon);
                var b, x, C;
                if (0 !== p) {
                    for (v = 0; v !== m; v++) {
                        var S = d[v];
                        S.resetConstraintVelocity()
                    }
                    if (l) {
                        for (i = 0; i !== l; i++) {
                            for (x = 0, C = 0; C !== p; C++) {
                                b = c[C];
                                B = s.iterateEquation(C, b, b.epsilon, _, g, f, y, t, i);
                                x += Math.abs(B)
                            }
                            if (this.usedIterations++, x * x <= u) break
                        }
                        for (s.updateMultipliers(c, f, 1 / t), C = 0; C !== p; C++) {
                            var w = c[C];
                            if (w instanceof h) {
                                for (var A = 0, T = 0; T !== w.contactEquations.length; T++) A += w.contactEquations[T].multiplier;
                                A *= w.frictionCoefficient / w.contactEquations.length, w.maxForce = A, w.minForce = -A
                            }
                        }
                    }
                    for (i = 0; i !== a; i++) {
                        for (x = 0, C = 0; C !== p; C++) {
                            b = c[C];
                            var B = s.iterateEquation(C, b, b.epsilon, _, g, f, y, t, i);
                            x += Math.abs(B)
                        }
                        if (this.usedIterations++, x * x <= u) break
                    }
                    for (v = 0; v !== m; v++) d[v].addConstraintVelocity();
                    s.updateMultipliers(c, f, 1 / t)
                }
            }, s.updateMultipliers = function(t, e, i) {
                for (var s = t.length; s--;) t[s].multiplier = e[s] * i
            }, s.iterateEquation = function(t, e, i, s, o, n, a, r, h) {
                var l = s[t],
                    c = o[t],
                    p = n[t],
                    u = e.computeGWlambda(),
                    d = e.maxForce,
                    m = e.minForce;
                a && (l = 0);
                var y = c * (l - u - i * p),
                    f = p + y;
                return f < m * r ? y = m * r - p : f > d * r && (y = d * r - p), n[t] += y, e.addToWlambda(y), y
            }
        }, {
            "../equations/FrictionEquation": 23,
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Solver": 47
        }],
        47: [function(t, e, i) {
            function s(t, e) {
                t = t || {}, o.call(this), this.type = e, this.equations = [], this.equationSortFunction = t.equationSortFunction || !1
            }
            var o = (t("../utils/Utils"), t("../events/EventEmitter"));
            e.exports = s, (s.prototype = new o).constructor = s, s.prototype.solve = function(t, e) {
                throw new Error("Solver.solve should be implemented by subclasses!")
            };
            var n = {
                bodies: []
            };
            s.prototype.solveIsland = function(t, e) {
                this.removeAllEquations(), e.equations.length && (this.addEquations(e.equations), n.bodies.length = 0, e.getBodies(n.bodies), n.bodies.length && this.solve(t, n))
            }, s.prototype.sortEquations = function() {
                this.equationSortFunction && this.equations.sort(this.equationSortFunction)
            }, s.prototype.addEquation = function(t) {
                t.enabled && this.equations.push(t)
            }, s.prototype.addEquations = function(t) {
                for (var e = 0, i = t.length; e !== i; e++) {
                    var s = t[e];
                    s.enabled && this.equations.push(s)
                }
            }, s.prototype.removeEquation = function(t) {
                var e = this.equations.indexOf(t); - 1 !== e && this.equations.splice(e, 1)
            }, s.prototype.removeAllEquations = function() {
                this.equations.length = 0
            }, s.GS = 1, s.ISLAND = 2
        }, {
            "../events/EventEmitter": 26,
            "../utils/Utils": 57
        }],
        48: [function(t, e, i) {
            function s() {
                n.apply(this, arguments)
            }
            var o = t("../equations/ContactEquation"),
                n = t("./Pool");
            e.exports = s, (s.prototype = new n).constructor = s, s.prototype.create = function() {
                return new o
            }, s.prototype.destroy = function(t) {
                return t.bodyA = t.bodyB = null, this
            }
        }, {
            "../equations/ContactEquation": 21,
            "./Pool": 55
        }],
        49: [function(t, e, i) {
            function s() {
                n.apply(this, arguments)
            }
            var o = t("../equations/FrictionEquation"),
                n = t("./Pool");
            e.exports = s, (s.prototype = new n).constructor = s, s.prototype.create = function() {
                return new o
            }, s.prototype.destroy = function(t) {
                return t.bodyA = t.bodyB = null, this
            }
        }, {
            "../equations/FrictionEquation": 23,
            "./Pool": 55
        }],
        50: [function(t, e, i) {
            function s() {
                n.apply(this, arguments)
            }
            var o = t("../world/IslandNode"),
                n = t("./Pool");
            e.exports = s, (s.prototype = new n).constructor = s, s.prototype.create = function() {
                return new o
            }, s.prototype.destroy = function(t) {
                return t.reset(), this
            }
        }, {
            "../world/IslandNode": 60,
            "./Pool": 55
        }],
        51: [function(t, e, i) {
            function s() {
                n.apply(this, arguments)
            }
            var o = t("../world/Island"),
                n = t("./Pool");
            e.exports = s, (s.prototype = new n).constructor = s, s.prototype.create = function() {
                return new o
            }, s.prototype.destroy = function(t) {
                return t.reset(), this
            }
        }, {
            "../world/Island": 58,
            "./Pool": 55
        }],
        52: [function(t, e, i) {
            function s() {
                this.overlappingShapesLastState = new o, this.overlappingShapesCurrentState = new o, this.recordPool = new n({
                    size: 16
                }), this.tmpDict = new o, this.tmpArray1 = []
            }
            var o = t("./TupleDictionary"),
                n = (t("./OverlapKeeperRecord"), t("./OverlapKeeperRecordPool"));
            t("./Utils"), e.exports = s, s.prototype.tick = function() {
                for (var t = this.overlappingShapesLastState, e = this.overlappingShapesCurrentState, i = t.keys.length; i--;) {
                    var s = t.keys[i],
                        o = t.getByKey(s);
                    e.getByKey(s), o && this.recordPool.release(o)
                }
                t.reset(), t.copy(e), e.reset()
            }, s.prototype.setOverlapping = function(t, e, i, s) {
                var o = (this.overlappingShapesLastState, this.overlappingShapesCurrentState);
                if (!o.get(e.id, s.id)) {
                    var n = this.recordPool.get();
                    n.set(t, e, i, s), o.set(e.id, s.id, n)
                }
            }, s.prototype.getNewOverlaps = function(t) {
                return this.getDiff(this.overlappingShapesLastState, this.overlappingShapesCurrentState, t)
            }, s.prototype.getEndOverlaps = function(t) {
                return this.getDiff(this.overlappingShapesCurrentState, this.overlappingShapesLastState, t)
            }, s.prototype.bodiesAreOverlapping = function(t, e) {
                for (var i = this.overlappingShapesCurrentState, s = i.keys.length; s--;) {
                    var o = i.keys[s],
                        n = i.data[o];
                    if (n.bodyA === t && n.bodyB === e || n.bodyA === e && n.bodyB === t) return !0
                }
                return !1
            }, s.prototype.getDiff = function(t, e, i) {
                var s = t,
                    o = e;
                (i = i || []).length = 0;
                for (var n = o.keys.length; n--;) {
                    var a = o.keys[n],
                        r = o.data[a];
                    if (!r) throw new Error("Key " + a + " had no data!");
                    s.data[a] || i.push(r)
                }
                return i
            }, s.prototype.isNewOverlap = function(t, e) {
                var i = 0 | t.id,
                    s = 0 | e.id,
                    o = this.overlappingShapesLastState,
                    n = this.overlappingShapesCurrentState;
                return !o.get(i, s) && !!n.get(i, s)
            }, s.prototype.getNewBodyOverlaps = function(t) {
                this.tmpArray1.length = 0;
                var e = this.getNewOverlaps(this.tmpArray1);
                return this.getBodyDiff(e, t)
            }, s.prototype.getEndBodyOverlaps = function(t) {
                this.tmpArray1.length = 0;
                var e = this.getEndOverlaps(this.tmpArray1);
                return this.getBodyDiff(e, t)
            }, s.prototype.getBodyDiff = function(t, e) {
                e = e || [];
                for (var i = this.tmpDict, s = t.length; s--;) {
                    var o = t[s];
                    i.set(0 | o.bodyA.id, 0 | o.bodyB.id, o)
                }
                for (s = i.keys.length; s--;)(o = i.getByKey(i.keys[s])) && e.push(o.bodyA, o.bodyB);
                return i.reset(), e
            }
        }, {
            "./OverlapKeeperRecord": 53,
            "./OverlapKeeperRecordPool": 54,
            "./TupleDictionary": 56,
            "./Utils": 57
        }],
        53: [function(t, e, i) {
            function s(t, e, i, s) {
                this.shapeA = e, this.shapeB = s, this.bodyA = t, this.bodyB = i
            }
            e.exports = s, s.prototype.set = function(t, e, i, o) {
                s.call(this, t, e, i, o)
            }
        }, {}],
        54: [function(t, e, i) {
            function s() {
                n.apply(this, arguments)
            }
            var o = t("./OverlapKeeperRecord"),
                n = t("./Pool");
            e.exports = s, (s.prototype = new n).constructor = s, s.prototype.create = function() {
                return new o
            }, s.prototype.destroy = function(t) {
                return t.bodyA = t.bodyB = t.shapeA = t.shapeB = null, this
            }
        }, {
            "./OverlapKeeperRecord": 53,
            "./Pool": 55
        }],
        55: [function(t, e, i) {
            function s(t) {
                t = t || {}, this.objects = [], void 0 !== t.size && this.resize(t.size)
            }
            e.exports = s, s.prototype.resize = function(t) {
                for (var e = this.objects; e.length > t;) e.pop();
                for (; e.length < t;) e.push(this.create());
                return this
            }, s.prototype.get = function() {
                var t = this.objects;
                return t.length ? t.pop() : this.create()
            }, s.prototype.release = function(t) {
                return this.destroy(t), this.objects.push(t), this
            }
        }, {}],
        56: [function(t, e, i) {
            function s() {
                this.data = {}, this.keys = []
            }
            var o = t("./Utils");
            e.exports = s, s.prototype.getKey = function(t, e) {
                return t |= 0, e |= 0, (0 | t) == (0 | e) ? -1 : 0 | ((0 | t) > (0 | e) ? t << 16 | 65535 & e : e << 16 | 65535 & t)
            }, s.prototype.getByKey = function(t) {
                return t |= 0, this.data[t]
            }, s.prototype.get = function(t, e) {
                return this.data[this.getKey(t, e)]
            }, s.prototype.set = function(t, e, i) {
                if (!i) throw new Error("No data!");
                var s = this.getKey(t, e);
                return this.data[s] || this.keys.push(s), this.data[s] = i, s
            }, s.prototype.reset = function() {
                for (var t = this.data, e = this.keys, i = e.length; i--;) delete t[e[i]];
                e.length = 0
            }, s.prototype.copy = function(t) {
                this.reset(), o.appendArray(this.keys, t.keys);
                for (var e = t.keys.length; e--;) {
                    var i = t.keys[e];
                    this.data[i] = t.data[i]
                }
            }
        }, {
            "./Utils": 57
        }],
        57: [function(t, e, i) {
            function s() {}
            e.exports = s, s.appendArray = function(t, e) {
                if (e.length < 15e4) t.push.apply(t, e);
                else
                    for (var i = 0, s = e.length; i !== s; ++i) t.push(e[i])
            }, s.splice = function(t, e, i) {
                i = i || 1;
                for (var s = e, o = t.length - i; s < o; s++) t[s] = t[s + i];
                t.length = o
            }, s.ARRAY_TYPE = "undefined" != typeof P2_ARRAY_TYPE ? P2_ARRAY_TYPE : "undefined" != typeof Float32Array ? Float32Array : Array, s.extend = function(t, e) {
                for (var i in e) t[i] = e[i]
            }, s.defaults = function(t, e) {
                t = t || {};
                for (var i in e) i in t || (t[i] = e[i]);
                return t
            }
        }, {}],
        58: [function(t, e, i) {
            function s() {
                this.equations = [], this.bodies = []
            }
            var o = t("../objects/Body");
            e.exports = s, s.prototype.reset = function() {
                this.equations.length = this.bodies.length = 0
            };
            var n = [];
            s.prototype.getBodies = function(t) {
                var e = t || [],
                    i = this.equations;
                n.length = 0;
                for (var s = 0; s !== i.length; s++) {
                    var o = i[s]; - 1 === n.indexOf(o.bodyA.id) && (e.push(o.bodyA), n.push(o.bodyA.id)), -1 === n.indexOf(o.bodyB.id) && (e.push(o.bodyB), n.push(o.bodyB.id))
                }
                return e
            }, s.prototype.wantsToSleep = function() {
                for (var t = 0; t < this.bodies.length; t++) {
                    var e = this.bodies[t];
                    if (e.type === o.DYNAMIC && !e.wantsToSleep) return !1
                }
                return !0
            }, s.prototype.sleep = function() {
                for (var t = 0; t < this.bodies.length; t++) this.bodies[t].sleep();
                return !0
            }
        }, {
            "../objects/Body": 31
        }],
        59: [function(t, e, i) {
            function s(t) {
                this.nodePool = new o({
                    size: 16
                }), this.islandPool = new n({
                    size: 8
                }), this.equations = [], this.islands = [], this.nodes = [], this.queue = []
            }
            var o = (t("../math/vec2"), t("./Island"), t("./IslandNode"), t("./../utils/IslandNodePool")),
                n = t("./../utils/IslandPool"),
                a = t("../objects/Body");
            e.exports = s, s.getUnvisitedNode = function(t) {
                for (var e = t.length, i = 0; i !== e; i++) {
                    var s = t[i];
                    if (!s.visited && s.body.type === a.DYNAMIC) return s
                }
                return !1
            }, s.prototype.visit = function(t, e, i) {
                e.push(t.body);
                for (var s = t.equations.length, o = 0; o !== s; o++) {
                    var n = t.equations[o]; - 1 === i.indexOf(n) && i.push(n)
                }
            }, s.prototype.bfs = function(t, e, i) {
                var o = this.queue;
                for (o.length = 0, o.push(t), t.visited = !0, this.visit(t, e, i); o.length;)
                    for (var n, r = o.pop(); n = s.getUnvisitedNode(r.neighbors);) n.visited = !0, this.visit(n, e, i), n.body.type === a.DYNAMIC && o.push(n)
            }, s.prototype.split = function(t) {
                for (var e = t.bodies, i = this.nodes, o = this.equations; i.length;) this.nodePool.release(i.pop());
                for (h = 0; h !== e.length; h++) {
                    var n = this.nodePool.get();
                    n.body = e[h], i.push(n)
                }
                for (var a = 0; a !== o.length; a++) {
                    var r = o[a],
                        h = e.indexOf(r.bodyA),
                        l = e.indexOf(r.bodyB),
                        c = i[h],
                        p = i[l];
                    c.neighbors.push(p), p.neighbors.push(c), c.equations.push(r), p.equations.push(r)
                }
                for (var u = this.islands, h = 0; h < u.length; h++) this.islandPool.release(u[h]);
                u.length = 0;
                for (var d; d = s.getUnvisitedNode(i);) {
                    var m = this.islandPool.get();
                    this.bfs(d, m.bodies, m.equations), u.push(m)
                }
                return u
            }
        }, {
            "../math/vec2": 30,
            "../objects/Body": 31,
            "./../utils/IslandNodePool": 50,
            "./../utils/IslandPool": 51,
            "./Island": 58,
            "./IslandNode": 60
        }],
        60: [function(t, e, i) {
            function s(t) {
                this.body = t, this.neighbors = [], this.equations = [], this.visited = !1
            }
            e.exports = s, s.prototype.reset = function() {
                this.equations.length = 0, this.neighbors.length = 0, this.visited = !1, this.body = null
            }
        }, {}],
        61: [function(t, e, i) {
            function s(t) {
                p.apply(this), t = t || {}, this.springs = [], this.bodies = [], this.disabledBodyCollisionPairs = [], this.solver = t.solver || new o, this.narrowphase = new g(this), this.islandManager = new b, this.gravity = n.fromValues(0, -9.78), t.gravity && n.copy(this.gravity, t.gravity), this.frictionGravity = n.length(this.gravity) || 10, this.useWorldGravityAsFrictionGravity = !0, this.useFrictionGravityOnZeroGravity = !0, this.broadphase = t.broadphase || new f, this.broadphase.setWorld(this), this.constraints = [], this.defaultMaterial = new d, this.defaultContactMaterial = new m(this.defaultMaterial, this.defaultMaterial), this.lastTimeStep = 1 / 60, this.applySpringForces = !0, this.applyDamping = !0, this.applyGravity = !0, this.solveConstraints = !0, this.contactMaterials = [], this.time = 0, this.accumulator = 0, this.stepping = !1, this.bodiesToBeRemoved = [], this.islandSplit = void 0 === t.islandSplit || !!t.islandSplit, this.emitImpactEvent = !0, this._constraintIdCounter = 0, this._bodyIdCounter = 0, this.postStepEvent = {
                    type: "postStep"
                }, this.addBodyEvent = {
                    type: "addBody",
                    body: null
                }, this.removeBodyEvent = {
                    type: "removeBody",
                    body: null
                }, this.addSpringEvent = {
                    type: "addSpring",
                    spring: null
                }, this.impactEvent = {
                    type: "impact",
                    bodyA: null,
                    bodyB: null,
                    shapeA: null,
                    shapeB: null,
                    contactEquation: null
                }, this.postBroadphaseEvent = {
                    type: "postBroadphase",
                    pairs: null
                }, this.sleepMode = s.NO_SLEEPING, this.beginContactEvent = {
                    type: "beginContact",
                    shapeA: null,
                    shapeB: null,
                    bodyA: null,
                    bodyB: null,
                    contactEquations: []
                }, this.endContactEvent = {
                    type: "endContact",
                    shapeA: null,
                    shapeB: null,
                    bodyA: null,
                    bodyB: null
                }, this.preSolveEvent = {
                    type: "preSolve",
                    contactEquations: null,
                    frictionEquations: null
                }, this.overlappingShapesLastState = {
                    keys: []
                }, this.overlappingShapesCurrentState = {
                    keys: []
                }, this.overlapKeeper = new v
            }
            var o = t("../solver/GSSolver"),
                n = (t("../solver/Solver"), t("../collision/Ray"), t("../math/vec2")),
                a = t("../shapes/Circle"),
                r = t("../shapes/Convex"),
                h = (t("../shapes/Line"), t("../shapes/Plane")),
                l = t("../shapes/Capsule"),
                c = t("../shapes/Particle"),
                p = t("../events/EventEmitter"),
                u = t("../objects/Body"),
                d = (t("../shapes/Shape"), t("../objects/LinearSpring"), t("../material/Material")),
                m = t("../material/ContactMaterial"),
                y = (t("../constraints/DistanceConstraint"), t("../constraints/Constraint"), t("../constraints/LockConstraint"), t("../constraints/RevoluteConstraint"), t("../constraints/PrismaticConstraint"), t("../constraints/GearConstraint"), t("../../package.json"), t("../collision/Broadphase"), t("../collision/AABB")),
                f = t("../collision/SAPBroadphase"),
                g = t("../collision/Narrowphase"),
                _ = t("../utils/Utils"),
                v = t("../utils/OverlapKeeper"),
                b = t("./IslandManager");
            t("../objects/RotationalSpring"), e.exports = s, s.prototype = new Object(p.prototype), s.prototype.constructor = s, s.NO_SLEEPING = 1, s.BODY_SLEEPING = 2, s.ISLAND_SLEEPING = 4, s.prototype.addConstraint = function(t) {
                this.constraints.push(t)
            }, s.prototype.addContactMaterial = function(t) {
                this.contactMaterials.push(t)
            }, s.prototype.removeContactMaterial = function(t) {
                var e = this.contactMaterials.indexOf(t); - 1 !== e && _.splice(this.contactMaterials, e, 1)
            }, s.prototype.getContactMaterial = function(t, e) {
                for (var i = this.contactMaterials, s = 0, o = i.length; s !== o; s++) {
                    var n = i[s];
                    if (n.materialA.id === t.id && n.materialB.id === e.id || n.materialA.id === e.id && n.materialB.id === t.id) return n
                }
                return !1
            }, s.prototype.removeConstraint = function(t) {
                var e = this.constraints.indexOf(t); - 1 !== e && _.splice(this.constraints, e, 1)
            };
            var x = (n.create(), n.create(), n.create(), n.create(), n.create(), n.create(), n.create()),
                C = n.fromValues(0, 0),
                S = n.fromValues(0, 0);
            n.fromValues(0, 0), n.fromValues(0, 0), s.prototype.step = function(t, e, i) {
                if (i = i || 10, 0 === (e = e || 0)) this.internalStep(t), this.time += t;
                else {
                    this.accumulator += e;
                    for (var s = 0; this.accumulator >= t && s < i;) this.internalStep(t), this.time += t, this.accumulator -= t, s++;
                    for (var o = this.accumulator % t / t, a = 0; a !== this.bodies.length; a++) {
                        var r = this.bodies[a];
                        n.lerp(r.interpolatedPosition, r.previousPosition, r.position, o), r.interpolatedAngle = r.previousAngle + o * (r.angle - r.previousAngle)
                    }
                }
            };
            var w = [];
            s.prototype.internalStep = function(t) {
                this.stepping = !0;
                var e = this.springs.length,
                    i = this.springs,
                    o = this.bodies,
                    a = this.gravity,
                    r = this.solver,
                    h = this.bodies.length,
                    l = this.broadphase,
                    c = this.narrowphase,
                    p = this.constraints,
                    d = x,
                    m = (n.scale, n.add),
                    y = (n.rotate, this.islandManager);
                if (this.overlapKeeper.tick(), this.lastTimeStep = t, this.useWorldGravityAsFrictionGravity) {
                    var f = n.length(this.gravity);
                    0 === f && this.useFrictionGravityOnZeroGravity || (this.frictionGravity = f)
                }
                if (this.applyGravity)
                    for (S = 0; S !== h; S++) {
                        var g = (v = o[S]).force;
                        v.type === u.DYNAMIC && v.sleepState !== u.SLEEPING && (n.scale(d, a, v.mass * v.gravityScale), m(g, g, d))
                    }
                if (this.applySpringForces)
                    for (S = 0; S !== e; S++) i[S].applyForce();
                if (this.applyDamping)
                    for (S = 0; S !== h; S++) {
                        var v = o[S];
                        v.type === u.DYNAMIC && v.applyDamping(t)
                    }
                for (var b = l.getCollisionPairs(this), C = this.disabledBodyCollisionPairs, S = C.length - 2; S >= 0; S -= 2)
                    for (T = b.length - 2; T >= 0; T -= 2)(C[S] === b[T] && C[S + 1] === b[T + 1] || C[S + 1] === b[T] && C[S] === b[T + 1]) && b.splice(T, 2);
                K = p.length;
                for (S = 0; S !== K; S++) {
                    var A = p[S];
                    if (!A.collideConnected)
                        for (var T = b.length - 2; T >= 0; T -= 2)(A.bodyA === b[T] && A.bodyB === b[T + 1] || A.bodyB === b[T] && A.bodyA === b[T + 1]) && b.splice(T, 2)
                }
                this.postBroadphaseEvent.pairs = b, this.emit(this.postBroadphaseEvent), this.postBroadphaseEvent.pairs = null, c.reset(this);
                for (var S = 0, B = b.length; S !== B; S += 2)
                    for (var P = b[S], D = b[S + 1], I = 0, E = P.shapes.length; I !== E; I++)
                        for (var L = P.shapes[I], M = L.position, G = L.angle, O = 0, R = D.shapes.length; O !== R; O++) {
                            var k = D.shapes[O],
                                F = k.position,
                                N = k.angle,
                                V = this.defaultContactMaterial;
                            if (L.material && k.material) {
                                var U = this.getContactMaterial(L.material, k.material);
                                U && (V = U)
                            }
                            this.runNarrowphase(c, P, L, M, G, D, k, F, N, V, this.frictionGravity)
                        }
                for (S = 0; S !== h; S++)(H = o[S])._wakeUpAfterNarrowphase && (H.wakeUp(), H._wakeUpAfterNarrowphase = !1);
                if (this.has("endContact")) {
                    this.overlapKeeper.getEndOverlaps(w);
                    for (var W = this.endContactEvent, O = w.length; O--;) {
                        var j = w[O];
                        W.shapeA = j.shapeA, W.shapeB = j.shapeB, W.bodyA = j.bodyA, W.bodyB = j.bodyB, this.emit(W)
                    }
                    w.length = 0
                }
                var X = this.preSolveEvent;
                X.contactEquations = c.contactEquations, X.frictionEquations = c.frictionEquations, this.emit(X), X.contactEquations = X.frictionEquations = null;
                var K = p.length;
                for (S = 0; S !== K; S++) p[S].update();
                if (c.contactEquations.length || c.frictionEquations.length || K)
                    if (this.islandSplit) {
                        for (y.equations.length = 0, _.appendArray(y.equations, c.contactEquations), _.appendArray(y.equations, c.frictionEquations), S = 0; S !== K; S++) _.appendArray(y.equations, p[S].equations);
                        y.split(this);
                        for (S = 0; S !== y.islands.length; S++)(z = y.islands[S]).equations.length && r.solveIsland(t, z)
                    } else {
                        for (r.addEquations(c.contactEquations), r.addEquations(c.frictionEquations), S = 0; S !== K; S++) r.addEquations(p[S].equations);
                        this.solveConstraints && r.solve(t, this), r.removeAllEquations()
                    }
                for (S = 0; S !== h; S++) {
                    var H = o[S];
                    H.integrate(t)
                }
                for (S = 0; S !== h; S++) o[S].setZeroForce();
                if (this.emitImpactEvent && this.has("impact"))
                    for (var q = this.impactEvent, S = 0; S !== c.contactEquations.length; S++) {
                        var J = c.contactEquations[S];
                        J.firstImpact && (q.bodyA = J.bodyA, q.bodyB = J.bodyB, q.shapeA = J.shapeA, q.shapeB = J.shapeB, q.contactEquation = J, this.emit(q))
                    }
                if (this.sleepMode === s.BODY_SLEEPING)
                    for (S = 0; S !== h; S++) o[S].sleepTick(this.time, !1, t);
                else if (this.sleepMode === s.ISLAND_SLEEPING && this.islandSplit) {
                    for (S = 0; S !== h; S++) o[S].sleepTick(this.time, !0, t);
                    for (S = 0; S < this.islandManager.islands.length; S++) {
                        var z = this.islandManager.islands[S];
                        z.wantsToSleep() && z.sleep()
                    }
                }
                this.stepping = !1;
                for (var Y = this.bodiesToBeRemoved, S = 0; S !== Y.length; S++) this.removeBody(Y[S]);
                Y.length = 0, this.emit(this.postStepEvent)
            }, s.prototype.runNarrowphase = function(t, e, i, s, o, a, r, h, l, c, p) {
                if (0 != (i.collisionGroup & r.collisionMask) && 0 != (r.collisionGroup & i.collisionMask)) {
                    n.rotate(C, s, e.angle), n.rotate(S, h, a.angle), n.add(C, C, e.position), n.add(S, S, a.position);
                    var d = o + e.angle,
                        m = l + a.angle;
                    t.enableFriction = c.friction > 0, t.frictionCoefficient = c.friction;
                    var y;
                    y = e.type === u.STATIC || e.type === u.KINEMATIC ? a.mass : a.type === u.STATIC || a.type === u.KINEMATIC ? e.mass : e.mass * a.mass / (e.mass + a.mass), t.slipForce = c.friction * p * y, t.restitution = c.restitution, t.surfaceVelocity = c.surfaceVelocity, t.frictionStiffness = c.frictionStiffness, t.frictionRelaxation = c.frictionRelaxation, t.stiffness = c.stiffness, t.relaxation = c.relaxation, t.contactSkinSize = c.contactSkinSize, t.enabledEquations = e.collisionResponse && a.collisionResponse && i.collisionResponse && r.collisionResponse;
                    var f = t[i.type | r.type],
                        g = 0;
                    if (f) {
                        var _ = i.sensor || r.sensor,
                            v = t.frictionEquations.length;
                        g = i.type < r.type ? f.call(t, e, i, C, d, a, r, S, m, _) : f.call(t, a, r, S, m, e, i, C, d, _);
                        var b = t.frictionEquations.length - v;
                        if (g) {
                            if (e.allowSleep && e.type === u.DYNAMIC && e.sleepState === u.SLEEPING && a.sleepState === u.AWAKE && a.type !== u.STATIC && n.squaredLength(a.velocity) + Math.pow(a.angularVelocity, 2) >= 2 * Math.pow(a.sleepSpeedLimit, 2) && (e._wakeUpAfterNarrowphase = !0), a.allowSleep && a.type === u.DYNAMIC && a.sleepState === u.SLEEPING && e.sleepState === u.AWAKE && e.type !== u.STATIC && n.squaredLength(e.velocity) + Math.pow(e.angularVelocity, 2) >= 2 * Math.pow(e.sleepSpeedLimit, 2) && (a._wakeUpAfterNarrowphase = !0), this.overlapKeeper.setOverlapping(e, i, a, r), this.has("beginContact") && this.overlapKeeper.isNewOverlap(i, r)) {
                                var x = this.beginContactEvent;
                                if (x.shapeA = i, x.shapeB = r, x.bodyA = e, x.bodyB = a, x.contactEquations.length = 0, "number" == typeof g)
                                    for (w = t.contactEquations.length - g; w < t.contactEquations.length; w++) x.contactEquations.push(t.contactEquations[w]);
                                this.emit(x)
                            }
                            if ("number" == typeof g && b > 1)
                                for (var w = t.frictionEquations.length - b; w < t.frictionEquations.length; w++) {
                                    var A = t.frictionEquations[w];
                                    A.setSlipForce(A.getSlipForce() / b)
                                }
                        }
                    }
                }
            }, s.prototype.addSpring = function(t) {
                this.springs.push(t);
                var e = this.addSpringEvent;
                e.spring = t, this.emit(e), e.spring = null
            }, s.prototype.removeSpring = function(t) {
                var e = this.springs.indexOf(t); - 1 !== e && _.splice(this.springs, e, 1)
            }, s.prototype.addBody = function(t) {
                if (-1 === this.bodies.indexOf(t)) {
                    this.bodies.push(t), t.world = this;
                    var e = this.addBodyEvent;
                    e.body = t, this.emit(e), e.body = null
                }
            }, s.prototype.removeBody = function(t) {
                if (this.stepping) this.bodiesToBeRemoved.push(t);
                else {
                    t.world = null;
                    var e = this.bodies.indexOf(t); - 1 !== e && (_.splice(this.bodies, e, 1), this.removeBodyEvent.body = t, t.resetConstraintVelocity(), this.emit(this.removeBodyEvent), this.removeBodyEvent.body = null)
                }
            }, s.prototype.getBodyById = function(t) {
                for (var e = this.bodies, i = 0; i < e.length; i++) {
                    var s = e[i];
                    if (s.id === t) return s
                }
                return !1
            }, s.prototype.disableBodyCollision = function(t, e) {
                this.disabledBodyCollisionPairs.push(t, e)
            }, s.prototype.enableBodyCollision = function(t, e) {
                for (var i = this.disabledBodyCollisionPairs, s = 0; s < i.length; s += 2)
                    if (i[s] === t && i[s + 1] === e || i[s + 1] === t && i[s] === e) return void i.splice(s, 2)
            }, s.prototype.clear = function() {
                this.time = 0, this.solver && this.solver.equations.length && this.solver.removeAllEquations();
                for (var t = this.constraints, e = t.length - 1; e >= 0; e--) this.removeConstraint(t[e]);
                for (var i = this.bodies, e = i.length - 1; e >= 0; e--) this.removeBody(i[e]);
                for (var o = this.springs, e = o.length - 1; e >= 0; e--) this.removeSpring(o[e]);
                for (var n = this.contactMaterials, e = n.length - 1; e >= 0; e--) this.removeContactMaterial(n[e]);
                s.apply(this)
            };
            var A = n.create(),
                T = (n.fromValues(0, 0), n.fromValues(0, 0));
            s.prototype.hitTest = function(t, e, i) {
                i = i || 0;
                var s = new u({
                        position: t
                    }),
                    o = new c,
                    p = t,
                    d = A,
                    m = T;
                s.addShape(o);
                for (var y = this.narrowphase, f = [], g = 0, _ = e.length; g !== _; g++)
                    for (var v = e[g], b = 0, x = v.shapes.length; b !== x; b++) {
                        var C = v.shapes[b];
                        n.rotate(d, C.position, v.angle), n.add(d, d, v.position);
                        var S = C.angle + v.angle;
                        (C instanceof a && y.circleParticle(v, C, d, S, s, o, p, 0, !0) || C instanceof r && y.particleConvex(s, o, p, 0, v, C, d, S, !0) || C instanceof h && y.particlePlane(s, o, p, 0, v, C, d, S, !0) || C instanceof l && y.particleCapsule(s, o, p, 0, v, C, d, S, !0) || C instanceof c && n.squaredLength(n.sub(m, d, t)) < i * i) && f.push(v)
                    }
                return f
            }, s.prototype.setGlobalStiffness = function(t) {
                for (var e = this.constraints, i = 0; i !== e.length; i++)
                    for (var s = e[i], o = 0; o !== s.equations.length; o++) {
                        var n = s.equations[o];
                        n.stiffness = t, n.needsUpdate = !0
                    }
                for (var a = this.contactMaterials, i = 0; i !== a.length; i++)(s = a[i]).stiffness = s.frictionStiffness = t;
                (s = this.defaultContactMaterial).stiffness = s.frictionStiffness = t
            }, s.prototype.setGlobalRelaxation = function(t) {
                for (o = 0; o !== this.constraints.length; o++)
                    for (var e = this.constraints[o], i = 0; i !== e.equations.length; i++) {
                        var s = e.equations[i];
                        s.relaxation = t, s.needsUpdate = !0
                    }
                for (var o = 0; o !== this.contactMaterials.length; o++)(e = this.contactMaterials[o]).relaxation = e.frictionRelaxation = t;
                (e = this.defaultContactMaterial).relaxation = e.frictionRelaxation = t
            };
            var B = new y,
                P = [];
            s.prototype.raycast = function(t, e) {
                return e.getAABB(B), this.broadphase.aabbQuery(this, B, P), e.intersectBodies(t, P), P.length = 0, t.hasHit()
            }
        }, {
            "../../package.json": 6,
            "../collision/AABB": 7,
            "../collision/Broadphase": 8,
            "../collision/Narrowphase": 10,
            "../collision/Ray": 11,
            "../collision/SAPBroadphase": 13,
            "../constraints/Constraint": 14,
            "../constraints/DistanceConstraint": 15,
            "../constraints/GearConstraint": 16,
            "../constraints/LockConstraint": 17,
            "../constraints/PrismaticConstraint": 18,
            "../constraints/RevoluteConstraint": 19,
            "../events/EventEmitter": 26,
            "../material/ContactMaterial": 27,
            "../material/Material": 28,
            "../math/vec2": 30,
            "../objects/Body": 31,
            "../objects/LinearSpring": 32,
            "../objects/RotationalSpring": 33,
            "../shapes/Capsule": 38,
            "../shapes/Circle": 39,
            "../shapes/Convex": 40,
            "../shapes/Line": 42,
            "../shapes/Particle": 43,
            "../shapes/Plane": 44,
            "../shapes/Shape": 45,
            "../solver/GSSolver": 46,
            "../solver/Solver": 47,
            "../utils/OverlapKeeper": 52,
            "../utils/Utils": 57,
            "./IslandManager": 59
        }]
    }, {}, [36])(36)
}),
function() {
    var t = this,
        e = e || {};
    return e.game = null, e.WEBGL_RENDERER = 0, e.CANVAS_RENDERER = 1, e.VERSION = "v2.2.9", e._UID = 0, "undefined" != typeof Float32Array ? (e.Float32Array = Float32Array, e.Uint16Array = Uint16Array, e.Uint32Array = Uint32Array, e.ArrayBuffer = ArrayBuffer) : (e.Float32Array = Array, e.Uint16Array = Array), e.PI_2 = 2 * Math.PI, e.RAD_TO_DEG = 180 / Math.PI, e.DEG_TO_RAD = Math.PI / 180, e.RETINA_PREFIX = "@2x", e.DisplayObject = function() {
        this.position = new e.Point(0, 0), this.scale = new e.Point(1, 1), this.pivot = new e.Point(0, 0), this.rotation = 0, this.alpha = 1, this.visible = !0, this.hitArea = null, this.renderable = !1, this.parent = null, this.worldAlpha = 1, this.worldTransform = new e.Matrix, this.worldPosition = new e.Point(0, 0), this.worldScale = new e.Point(1, 1), this.worldRotation = 0, this.filterArea = null, this._sr = 0, this._cr = 1, this._bounds = new e.Rectangle(0, 0, 0, 0), this._currentBounds = null, this._mask = null, this._cacheAsBitmap = !1, this._cacheIsDirty = !1
    }, e.DisplayObject.prototype.constructor = e.DisplayObject, e.DisplayObject.prototype = {
        destroy: function() {
            if (this.children) {
                for (var t = this.children.length; t--;) this.children[t].destroy();
                this.children = []
            }
            this.hitArea = null, this.parent = null, this.worldTransform = null, this.filterArea = null, this.renderable = !1, this._bounds = null, this._currentBounds = null, this._mask = null, this._destroyCachedSprite()
        },
        updateTransform: function(t) {
            if (!t && !this.parent && !this.game) return this;
            var i = this.parent;
            t ? i = t : this.parent || (i = this.game.world);
            var s, o, n, a, r, h, l = i.worldTransform,
                c = this.worldTransform;
            return this.rotation % e.PI_2 ? (this.rotation !== this.rotationCache && (this.rotationCache = this.rotation, this._sr = Math.sin(this.rotation), this._cr = Math.cos(this.rotation)), s = this._cr * this.scale.x, o = this._sr * this.scale.x, n = -this._sr * this.scale.y, a = this._cr * this.scale.y, r = this.position.x, h = this.position.y, (this.pivot.x || this.pivot.y) && (r -= this.pivot.x * s + this.pivot.y * n, h -= this.pivot.x * o + this.pivot.y * a), c.a = s * l.a + o * l.c, c.b = s * l.b + o * l.d, c.c = n * l.a + a * l.c, c.d = n * l.b + a * l.d, c.tx = r * l.a + h * l.c + l.tx, c.ty = r * l.b + h * l.d + l.ty) : (s = this.scale.x, a = this.scale.y, r = this.position.x - this.pivot.x * s, h = this.position.y - this.pivot.y * a, c.a = s * l.a, c.b = s * l.b, c.c = a * l.c, c.d = a * l.d, c.tx = r * l.a + h * l.c + l.tx, c.ty = r * l.b + h * l.d + l.ty), this.worldAlpha = this.alpha * i.worldAlpha, this.worldPosition.set(c.tx, c.ty), this.worldScale.set(this.scale.x * Math.sqrt(c.a * c.a + c.c * c.c), this.scale.y * Math.sqrt(c.b * c.b + c.d * c.d)), this.worldRotation = Math.atan2(-c.c, c.d), this._currentBounds = null, this.transformCallback && this.transformCallback.call(this.transformCallbackContext, c, l), this
        },
        preUpdate: function() {},
        generateTexture: function(t, i, s) {
            var o = this.getLocalBounds(),
                n = new e.RenderTexture(0 | o.width, 0 | o.height, s, i, t);
            return e.DisplayObject._tempMatrix.tx = -o.x, e.DisplayObject._tempMatrix.ty = -o.y, n.render(this, e.DisplayObject._tempMatrix), n
        },
        updateCache: function() {
            return this._generateCachedSprite(), this
        },
        toGlobal: function(t) {
            return this.updateTransform(), this.worldTransform.apply(t)
        },
        toLocal: function(t, e) {
            return e && (t = e.toGlobal(t)), this.updateTransform(), this.worldTransform.applyInverse(t)
        },
        _renderCachedSprite: function(t) {
            this._cachedSprite.worldAlpha = this.worldAlpha, t.gl ? e.Sprite.prototype._renderWebGL.call(this._cachedSprite, t) : e.Sprite.prototype._renderCanvas.call(this._cachedSprite, t)
        },
        _generateCachedSprite: function() {
            this._cacheAsBitmap = !1;
            var t = this.getLocalBounds();
            if (t.width = Math.max(1, Math.ceil(t.width)), t.height = Math.max(1, Math.ceil(t.height)), this.updateTransform(), this._cachedSprite) this._cachedSprite.texture.resize(t.width, t.height);
            else {
                var i = new e.RenderTexture(t.width, t.height);
                this._cachedSprite = new e.Sprite(i), this._cachedSprite.worldTransform = this.worldTransform
            }
            var s = this._filters;
            this._filters = null, this._cachedSprite.filters = s, e.DisplayObject._tempMatrix.tx = -t.x, e.DisplayObject._tempMatrix.ty = -t.y, this._cachedSprite.texture.render(this, e.DisplayObject._tempMatrix, !0), this._cachedSprite.anchor.x = -t.x / t.width, this._cachedSprite.anchor.y = -t.y / t.height, this._filters = s, this._cacheAsBitmap = !0
        },
        _destroyCachedSprite: function() {
            this._cachedSprite && (this._cachedSprite.texture.destroy(!0), this._cachedSprite = null)
        }
    }, e.DisplayObject.prototype.displayObjectUpdateTransform = e.DisplayObject.prototype.updateTransform, Object.defineProperties(e.DisplayObject.prototype, {
        x: {
            get: function() {
                return this.position.x
            },
            set: function(t) {
                this.position.x = t
            }
        },
        y: {
            get: function() {
                return this.position.y
            },
            set: function(t) {
                this.position.y = t
            }
        },
        worldVisible: {
            get: function() {
                if (this.visible) {
                    var t = this.parent;
                    if (!t) return this.visible;
                    do {
                        if (!t.visible) return !1;
                        t = t.parent
                    } while (t);
                    return !0
                }
                return !1
            }
        },
        mask: {
            get: function() {
                return this._mask
            },
            set: function(t) {
                this._mask && (this._mask.isMask = !1), this._mask = t, t && (this._mask.isMask = !0)
            }
        },
        filters: {
            get: function() {
                return this._filters
            },
            set: function(t) {
                if (Array.isArray(t)) {
                    for (var i = [], s = 0; s < t.length; s++)
                        for (var o = t[s].passes, n = 0; n < o.length; n++) i.push(o[n]);
                    this._filterBlock = {
                        target: this,
                        filterPasses: i
                    }
                }
                this._filters = t, this.blendMode && this.blendMode === e.blendModes.MULTIPLY && (this.blendMode = e.blendModes.NORMAL)
            }
        },
        cacheAsBitmap: {
            get: function() {
                return this._cacheAsBitmap
            },
            set: function(t) {
                this._cacheAsBitmap !== t && (t ? this._generateCachedSprite() : this._destroyCachedSprite(), this._cacheAsBitmap = t)
            }
        }
    }), e.DisplayObjectContainer = function() {
        e.DisplayObject.call(this), this.children = [], this.ignoreChildInput = !1
    }, e.DisplayObjectContainer.prototype = Object.create(e.DisplayObject.prototype), e.DisplayObjectContainer.prototype.constructor = e.DisplayObjectContainer, e.DisplayObjectContainer.prototype.addChild = function(t) {
        return this.addChildAt(t, this.children.length)
    }, e.DisplayObjectContainer.prototype.addChildAt = function(t, e) {
        if (e >= 0 && e <= this.children.length) return t.parent && t.parent.removeChild(t), t.parent = this, this.children.splice(e, 0, t), t;
        throw new Error(t + "addChildAt: The index " + e + " supplied is out of bounds " + this.children.length)
    }, e.DisplayObjectContainer.prototype.swapChildren = function(t, e) {
        if (t !== e) {
            var i = this.getChildIndex(t),
                s = this.getChildIndex(e);
            if (i < 0 || s < 0) throw new Error("swapChildren: Both the supplied DisplayObjects must be a child of the caller.");
            this.children[i] = e, this.children[s] = t
        }
    }, e.DisplayObjectContainer.prototype.getChildIndex = function(t) {
        var e = this.children.indexOf(t);
        if (-1 === e) throw new Error("The supplied DisplayObject must be a child of the caller");
        return e
    }, e.DisplayObjectContainer.prototype.setChildIndex = function(t, e) {
        if (e < 0 || e >= this.children.length) throw new Error("The supplied index is out of bounds");
        var i = this.getChildIndex(t);
        this.children.splice(i, 1), this.children.splice(e, 0, t)
    }, e.DisplayObjectContainer.prototype.getChildAt = function(t) {
        if (t < 0 || t >= this.children.length) throw new Error("getChildAt: Supplied index " + t + " does not exist in the child list, or the supplied DisplayObject must be a child of the caller");
        return this.children[t]
    }, e.DisplayObjectContainer.prototype.removeChild = function(t) {
        var e = this.children.indexOf(t);
        if (-1 !== e) return this.removeChildAt(e)
    }, e.DisplayObjectContainer.prototype.removeChildAt = function(t) {
        var e = this.getChildAt(t);
        return e && (e.parent = void 0, this.children.splice(t, 1)), e
    }, e.DisplayObjectContainer.prototype.removeChildren = function(t, e) {
        void 0 === t && (t = 0), void 0 === e && (e = this.children.length);
        var i = e - t;
        if (i > 0 && i <= e) {
            for (var s = this.children.splice(begin, i), o = 0; o < s.length; o++) s[o].parent = void 0;
            return s
        }
        if (0 === i && 0 === this.children.length) return [];
        throw new Error("removeChildren: Range Error, numeric values are outside the acceptable range")
    }, e.DisplayObjectContainer.prototype.updateTransform = function() {
        if (this.visible && (this.displayObjectUpdateTransform(), !this._cacheAsBitmap))
            for (var t = 0; t < this.children.length; t++) this.children[t].updateTransform()
    }, e.DisplayObjectContainer.prototype.displayObjectContainerUpdateTransform = e.DisplayObjectContainer.prototype.updateTransform, e.DisplayObjectContainer.prototype.getBounds = function(t) {
        var i = t && t instanceof e.DisplayObject,
            s = !0;
        i ? s = t instanceof e.DisplayObjectContainer && t.contains(this) : t = this;
        var o;
        if (i) {
            var n = t.worldTransform;
            for (t.worldTransform = e.identityMatrix, o = 0; o < t.children.length; o++) t.children[o].updateTransform()
        }
        var a, r, h, l = 1 / 0,
            c = 1 / 0,
            p = -1 / 0,
            u = -1 / 0,
            d = !1;
        for (o = 0; o < this.children.length; o++) this.children[o].visible && (d = !0, a = this.children[o].getBounds(), l = l < a.x ? l : a.x, c = c < a.y ? c : a.y, r = a.width + a.x, h = a.height + a.y, p = p > r ? p : r, u = u > h ? u : h);
        var m = this._bounds;
        if (!d) {
            var y = (m = new e.Rectangle).x,
                f = m.width + m.x,
                g = m.y,
                _ = m.height + m.y,
                v = this.worldTransform,
                b = v.a,
                x = v.b,
                C = v.c,
                S = v.d,
                w = v.tx,
                A = v.ty,
                T = b * f + C * _ + w,
                B = S * _ + x * f + A,
                P = b * y + C * _ + w,
                D = S * _ + x * y + A,
                I = b * y + C * g + w,
                E = S * g + x * y + A,
                L = b * f + C * g + w,
                M = S * g + x * f + A;
            p = T, u = B, c = B, l = L < (l = I < (l = P < (l = T) ? P : l) ? I : l) ? L : l, c = M < (c = E < (c = D < c ? D : c) ? E : c) ? M : c, p = L > (p = I > (p = P > p ? P : p) ? I : p) ? L : p, u = M > (u = E > (u = D > u ? D : u) ? E : u) ? M : u
        }
        if (m.x = l, m.y = c, m.width = p - l, m.height = u - c, i)
            for (t.worldTransform = n, o = 0; o < t.children.length; o++) t.children[o].updateTransform();
        if (!s) {
            var G = t.getBounds();
            m.x -= G.x, m.y -= G.y
        }
        return m
    }, e.DisplayObjectContainer.prototype.getLocalBounds = function() {
        return this.getBounds(this)
    }, e.DisplayObjectContainer.prototype.contains = function(t) {
        return !!t && (t === this || this.contains(t.parent))
    }, e.DisplayObjectContainer.prototype._renderWebGL = function(t) {
        if (this.visible && !(this.alpha <= 0)) {
            if (this._cacheAsBitmap) return void this._renderCachedSprite(t);
            var e;
            if (this._mask || this._filters) {
                for (this._filters && (t.spriteBatch.flush(), t.filterManager.pushFilter(this._filterBlock)), this._mask && (t.spriteBatch.stop(), t.maskManager.pushMask(this.mask, t), t.spriteBatch.start()), e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(t);
                t.spriteBatch.stop(), this._mask && t.maskManager.popMask(this._mask, t), this._filters && t.filterManager.popFilter(), t.spriteBatch.start()
            } else
                for (e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(t)
        }
    }, e.DisplayObjectContainer.prototype._renderCanvas = function(t) {
        if (!1 !== this.visible && 0 !== this.alpha) {
            if (this._cacheAsBitmap) return void this._renderCachedSprite(t);
            this._mask && t.maskManager.pushMask(this._mask, t);
            for (var e = 0; e < this.children.length; e++) this.children[e]._renderCanvas(t);
            this._mask && t.maskManager.popMask(t)
        }
    }, Object.defineProperty(e.DisplayObjectContainer.prototype, "width", {
        get: function() {
            return this.getLocalBounds().width * this.scale.x
        },
        set: function(t) {
            var e = this.getLocalBounds().width;
            this.scale.x = 0 !== e ? t / e : 1, this._width = t
        }
    }), Object.defineProperty(e.DisplayObjectContainer.prototype, "height", {
        get: function() {
            return this.getLocalBounds().height * this.scale.y
        },
        set: function(t) {
            var e = this.getLocalBounds().height;
            this.scale.y = 0 !== e ? t / e : 1, this._height = t
        }
    }), e.Sprite = function(t) {
        e.DisplayObjectContainer.call(this), this.anchor = new e.Point, this.texture = t || e.Texture.emptyTexture, this._width = 0, this._height = 0, this.tint = 16777215, this.cachedTint = -1, this.tintedTexture = null, this.blendMode = e.blendModes.NORMAL, this.shader = null, this.exists = !0, this.texture.baseTexture.hasLoaded && this.onTextureUpdate(), this.renderable = !0
    }, e.Sprite.prototype = Object.create(e.DisplayObjectContainer.prototype), e.Sprite.prototype.constructor = e.Sprite, Object.defineProperty(e.Sprite.prototype, "width", {
        get: function() {
            return this.scale.x * this.texture.frame.width
        },
        set: function(t) {
            this.scale.x = t / this.texture.frame.width, this._width = t
        }
    }), Object.defineProperty(e.Sprite.prototype, "height", {
        get: function() {
            return this.scale.y * this.texture.frame.height
        },
        set: function(t) {
            this.scale.y = t / this.texture.frame.height, this._height = t
        }
    }), e.Sprite.prototype.setTexture = function(t, e) {
        void 0 !== e && this.texture.baseTexture.destroy(), this.texture.baseTexture.skipRender = !1, this.texture = t, this.texture.valid = !0, this.cachedTint = -1
    }, e.Sprite.prototype.onTextureUpdate = function() {
        this._width && (this.scale.x = this._width / this.texture.frame.width), this._height && (this.scale.y = this._height / this.texture.frame.height)
    }, e.Sprite.prototype.getBounds = function(t) {
        var e = this.texture.frame.width,
            i = this.texture.frame.height,
            s = e * (1 - this.anchor.x),
            o = e * -this.anchor.x,
            n = i * (1 - this.anchor.y),
            a = i * -this.anchor.y,
            r = t || this.worldTransform,
            h = r.a,
            l = r.b,
            c = r.c,
            p = r.d,
            u = r.tx,
            d = r.ty,
            m = -1 / 0,
            y = -1 / 0,
            f = 1 / 0,
            g = 1 / 0;
        if (0 === l && 0 === c) {
            if (h < 0) {
                h *= -1;
                _ = s;
                s = -o, o = -_
            }
            if (p < 0) {
                p *= -1;
                var _ = n;
                n = -a, a = -_
            }
            f = h * o + u, m = h * s + u, g = p * a + d, y = p * n + d
        } else {
            var v = h * o + c * a + u,
                b = p * a + l * o + d,
                x = h * s + c * a + u,
                C = p * a + l * s + d,
                S = h * s + c * n + u,
                w = p * n + l * s + d,
                A = h * o + c * n + u,
                T = p * n + l * o + d;
            f = A < (f = S < (f = x < (f = v < f ? v : f) ? x : f) ? S : f) ? A : f, g = T < (g = w < (g = C < (g = b < g ? b : g) ? C : g) ? w : g) ? T : g, m = A > (m = S > (m = x > (m = v > m ? v : m) ? x : m) ? S : m) ? A : m, y = T > (y = w > (y = C > (y = b > y ? b : y) ? C : y) ? w : y) ? T : y
        }
        var B = this._bounds;
        return B.x = f, B.width = m - f, B.y = g, B.height = y - g, this._currentBounds = B, B
    }, e.Sprite.prototype.getLocalBounds = function() {
        var t = this.worldTransform;
        this.worldTransform = e.identityMatrix;
        for (var i = 0; i < this.children.length; i++) this.children[i].updateTransform();
        var s = this.getBounds();
        for (this.worldTransform = t, i = 0; i < this.children.length; i++) this.children[i].updateTransform();
        return s
    }, e.Sprite.prototype._renderWebGL = function(t, e) {
        if (this.visible && !(this.alpha <= 0) && this.renderable) {
            var i = this.worldTransform;
            if (e && (i = e), this._mask || this._filters) {
                var s = t.spriteBatch;
                this._filters && (s.flush(), t.filterManager.pushFilter(this._filterBlock)), this._mask && (s.stop(), t.maskManager.pushMask(this.mask, t), s.start()), s.render(this);
                for (o = 0; o < this.children.length; o++) this.children[o]._renderWebGL(t);
                s.stop(), this._mask && t.maskManager.popMask(this._mask, t), this._filters && t.filterManager.popFilter(), s.start()
            } else {
                t.spriteBatch.render(this);
                for (var o = 0; o < this.children.length; o++) this.children[o]._renderWebGL(t, i)
            }
        }
    }, e.Sprite.prototype._renderCanvas = function(t, i) {
        if (!(!this.visible || 0 === this.alpha || !this.renderable || this.texture.crop.width <= 0 || this.texture.crop.height <= 0)) {
            var s = this.worldTransform;
            if (i && (s = i), this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode, t.context.globalCompositeOperation = e.blendModesCanvas[t.currentBlendMode]), this._mask && t.maskManager.pushMask(this._mask, t), this.texture.valid) {
                var o = this.texture.baseTexture.resolution / t.resolution;
                t.context.globalAlpha = this.worldAlpha, t.smoothProperty && t.scaleMode !== this.texture.baseTexture.scaleMode && (t.scaleMode = this.texture.baseTexture.scaleMode, t.context[t.smoothProperty] = t.scaleMode === e.scaleModes.LINEAR);
                var n = this.texture.trim ? this.texture.trim.x - this.anchor.x * this.texture.trim.width : this.anchor.x * -this.texture.frame.width,
                    a = this.texture.trim ? this.texture.trim.y - this.anchor.y * this.texture.trim.height : this.anchor.y * -this.texture.frame.height,
                    r = s.tx * t.resolution + t.shakeX,
                    h = s.ty * t.resolution + t.shakeY;
                t.roundPixels ? (t.context.setTransform(s.a, s.b, s.c, s.d, 0 | r, 0 | h), n |= 0, a |= 0) : t.context.setTransform(s.a, s.b, s.c, s.d, r, h);
                var l = this.texture.crop.width,
                    c = this.texture.crop.height;
                if (n /= o, a /= o, 16777215 !== this.tint)(this.texture.requiresReTint || this.cachedTint !== this.tint) && (this.tintedTexture = e.CanvasTinter.getTintedTexture(this, this.tint), this.cachedTint = this.tint, this.texture.requiresReTint = !1), t.context.drawImage(this.tintedTexture, 0, 0, l, c, n, a, l / o, c / o);
                else {
                    var p = this.texture.crop.x,
                        u = this.texture.crop.y;
                    t.context.drawImage(this.texture.baseTexture.source, p, u, l, c, n, a, l / o, c / o)
                }
            }
            for (var d = 0; d < this.children.length; d++) this.children[d]._renderCanvas(t);
            this._mask && t.maskManager.popMask(t)
        }
    }, e.SpriteBatch = function(t) {
        e.DisplayObjectContainer.call(this), this.textureThing = t, this.ready = !1
    }, e.SpriteBatch.prototype = Object.create(e.DisplayObjectContainer.prototype), e.SpriteBatch.prototype.constructor = e.SpriteBatch, e.SpriteBatch.prototype.initWebGL = function(t) {
        this.fastSpriteBatch = new e.WebGLFastSpriteBatch(t), this.ready = !0
    }, e.SpriteBatch.prototype.updateTransform = function() {
        this.displayObjectUpdateTransform()
    }, e.SpriteBatch.prototype._renderWebGL = function(t) {
        !this.visible || this.alpha <= 0 || !this.children.length || (this.ready || this.initWebGL(t.gl), this.fastSpriteBatch.gl !== t.gl && this.fastSpriteBatch.setContext(t.gl), t.spriteBatch.stop(), t.shaderManager.setShader(t.shaderManager.fastShader), this.fastSpriteBatch.begin(this, t), this.fastSpriteBatch.render(this), t.spriteBatch.start())
    }, e.SpriteBatch.prototype._renderCanvas = function(t) {
        if (this.visible && !(this.alpha <= 0) && this.children.length) {
            var e = t.context;
            e.globalAlpha = this.worldAlpha, this.displayObjectUpdateTransform();
            for (var i = this.worldTransform, s = !0, o = 0; o < this.children.length; o++) {
                var n = this.children[o];
                if (n.visible) {
                    var a = n.texture,
                        r = a.frame;
                    if (e.globalAlpha = this.worldAlpha * n.alpha, n.rotation % (2 * Math.PI) == 0) s && (e.setTransform(i.a, i.b, i.c, i.d, i.tx, i.ty), s = !1), e.drawImage(a.baseTexture.source, r.x, r.y, r.width, r.height, n.anchor.x * (-r.width * n.scale.x) + n.position.x + .5 + t.shakeX | 0, n.anchor.y * (-r.height * n.scale.y) + n.position.y + .5 + t.shakeY | 0, r.width * n.scale.x, r.height * n.scale.y);
                    else {
                        s || (s = !0), n.displayObjectUpdateTransform();
                        var h = n.worldTransform,
                            l = h.tx * t.resolution + t.shakeX,
                            c = h.ty * t.resolution + t.shakeY;
                        t.roundPixels ? e.setTransform(h.a, h.b, h.c, h.d, 0 | l, 0 | c) : e.setTransform(h.a, h.b, h.c, h.d, l, c), e.drawImage(a.baseTexture.source, r.x, r.y, r.width, r.height, n.anchor.x * -r.width + .5 | 0, n.anchor.y * -r.height + .5 | 0, r.width, r.height)
                    }
                }
            }
        }
    }, e.hex2rgb = function(t) {
        return [(t >> 16 & 255) / 255, (t >> 8 & 255) / 255, (255 & t) / 255]
    }, e.rgb2hex = function(t) {
        return (255 * t[0] << 16) + (255 * t[1] << 8) + 255 * t[2]
    }, e.canUseNewCanvasBlendModes = function() {
        if (void 0 === document) return !1;
        var t = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/",
            i = "AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==",
            s = new Image;
        s.src = t + "AP804Oa6" + i;
        var o = new Image;
        o.src = t + "/wCKxvRF" + i;
        var n = e.CanvasPool.create(this, 6, 1).getContext("2d");
        if (n.globalCompositeOperation = "multiply", n.drawImage(s, 0, 0), n.drawImage(o, 2, 0), !n.getImageData(2, 0, 1, 1)) return !1;
        var a = n.getImageData(2, 0, 1, 1).data;
        return e.CanvasPool.remove(this), 255 === a[0] && 0 === a[1] && 0 === a[2]
    }, e.getNextPowerOfTwo = function(t) {
        if (t > 0 && 0 == (t & t - 1)) return t;
        for (var e = 1; e < t;) e <<= 1;
        return e
    }, e.isPowerOfTwo = function(t, e) {
        return t > 0 && 0 == (t & t - 1) && e > 0 && 0 == (e & e - 1)
    }, e.CanvasPool = {
        create: function(t, i, s) {
            var o, n = e.CanvasPool.getFirst();
            if (-1 === n) {
                var a = {
                    parent: t,
                    canvas: document.createElement("canvas")
                };
                e.CanvasPool.pool.push(a), o = a.canvas
            } else e.CanvasPool.pool[n].parent = t, o = e.CanvasPool.pool[n].canvas;
            return void 0 !== i && (o.width = i, o.height = s), o
        },
        getFirst: function() {
            for (var t = e.CanvasPool.pool, i = 0; i < t.length; i++)
                if (!t[i].parent) return i;
            return -1
        },
        remove: function(t) {
            for (var i = e.CanvasPool.pool, s = 0; s < i.length; s++) i[s].parent === t && (i[s].parent = null, i[s].canvas.width = 1, i[s].canvas.height = 1)
        },
        removeByCanvas: function(t) {
            for (var i = e.CanvasPool.pool, s = 0; s < i.length; s++) i[s].canvas === t && (i[s].parent = null, i[s].canvas.width = 1, i[s].canvas.height = 1)
        },
        getTotal: function() {
            for (var t = e.CanvasPool.pool, i = 0, s = 0; s < t.length; s++) t[s].parent && i++;
            return i
        },
        getFree: function() {
            for (var t = e.CanvasPool.pool, i = 0, s = 0; s < t.length; s++) t[s].parent || i++;
            return i
        }
    }, e.CanvasPool.pool = [], e.initDefaultShaders = function() {}, e.CompileVertexShader = function(t, i) {
        return e._CompileShader(t, i, t.VERTEX_SHADER)
    }, e.CompileFragmentShader = function(t, i) {
        return e._CompileShader(t, i, t.FRAGMENT_SHADER)
    }, e._CompileShader = function(t, e, i) {
        var s = e;
        Array.isArray(e) && (s = e.join("\n"));
        var o = t.createShader(i);
        return t.shaderSource(o, s), t.compileShader(o), t.getShaderParameter(o, t.COMPILE_STATUS) ? o : (window.console.log(t.getShaderInfoLog(o)), null)
    }, e.compileProgram = function(t, i, s) {
        var o = e.CompileFragmentShader(t, s),
            n = e.CompileVertexShader(t, i),
            a = t.createProgram();
        return t.attachShader(a, n), t.attachShader(a, o), t.linkProgram(a), t.getProgramParameter(a, t.LINK_STATUS) || (window.console.log(t.getProgramInfoLog(a)), window.console.log("Could not initialise shaders")), a
    }, e.PixiShader = function(t) {
        this._UID = e._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"], this.textureCount = 0, this.firstRun = !0, this.dirty = !0, this.attributes = [], this.init()
    }, e.PixiShader.prototype.constructor = e.PixiShader, e.PixiShader.prototype.init = function() {
        var t = this.gl,
            i = e.compileProgram(t, this.vertexSrc || e.PixiShader.defaultVertexSrc, this.fragmentSrc);
        t.useProgram(i), this.uSampler = t.getUniformLocation(i, "uSampler"), this.projectionVector = t.getUniformLocation(i, "projectionVector"), this.offsetVector = t.getUniformLocation(i, "offsetVector"), this.dimensions = t.getUniformLocation(i, "dimensions"), this.aVertexPosition = t.getAttribLocation(i, "aVertexPosition"), this.aTextureCoord = t.getAttribLocation(i, "aTextureCoord"), this.colorAttribute = t.getAttribLocation(i, "aColor"), -1 === this.colorAttribute && (this.colorAttribute = 2), this.attributes = [this.aVertexPosition, this.aTextureCoord, this.colorAttribute];
        for (var s in this.uniforms) this.uniforms[s].uniformLocation = t.getUniformLocation(i, s);
        this.initUniforms(), this.program = i
    }, e.PixiShader.prototype.initUniforms = function() {
        this.textureCount = 1;
        var t, e = this.gl;
        for (var i in this.uniforms) {
            var s = (t = this.uniforms[i]).type;
            "sampler2D" === s ? (t._init = !1, null !== t.value && this.initSampler2D(t)) : "mat2" === s || "mat3" === s || "mat4" === s ? (t.glMatrix = !0, t.glValueLength = 1, "mat2" === s ? t.glFunc = e.uniformMatrix2fv : "mat3" === s ? t.glFunc = e.uniformMatrix3fv : "mat4" === s && (t.glFunc = e.uniformMatrix4fv)) : (t.glFunc = e["uniform" + s], t.glValueLength = "2f" === s || "2i" === s ? 2 : "3f" === s || "3i" === s ? 3 : "4f" === s || "4i" === s ? 4 : 1)
        }
    }, e.PixiShader.prototype.initSampler2D = function(t) {
        if (t.value && t.value.baseTexture && t.value.baseTexture.hasLoaded) {
            var e = this.gl;
            if (e.activeTexture(e["TEXTURE" + this.textureCount]), e.bindTexture(e.TEXTURE_2D, t.value.baseTexture._glTextures[e.id]), t.textureData) {
                var i = t.textureData,
                    s = i.magFilter ? i.magFilter : e.LINEAR,
                    o = i.minFilter ? i.minFilter : e.LINEAR,
                    n = i.wrapS ? i.wrapS : e.CLAMP_TO_EDGE,
                    a = i.wrapT ? i.wrapT : e.CLAMP_TO_EDGE,
                    r = i.luminance ? e.LUMINANCE : e.RGBA;
                if (i.repeat && (n = e.REPEAT, a = e.REPEAT), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, !!i.flipY), i.width) {
                    var h = i.width ? i.width : 512,
                        l = i.height ? i.height : 2,
                        c = i.border ? i.border : 0;
                    e.texImage2D(e.TEXTURE_2D, 0, r, h, l, c, r, e.UNSIGNED_BYTE, null)
                } else e.texImage2D(e.TEXTURE_2D, 0, r, e.RGBA, e.UNSIGNED_BYTE, t.value.baseTexture.source);
                e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, s), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, o), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, n), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, a)
            }
            e.uniform1i(t.uniformLocation, this.textureCount), t._init = !0, this.textureCount++
        }
    }, e.PixiShader.prototype.syncUniforms = function() {
        this.textureCount = 1;
        var t, i = this.gl;
        for (var s in this.uniforms) 1 === (t = this.uniforms[s]).glValueLength ? !0 === t.glMatrix ? t.glFunc.call(i, t.uniformLocation, t.transpose, t.value) : t.glFunc.call(i, t.uniformLocation, t.value) : 2 === t.glValueLength ? t.glFunc.call(i, t.uniformLocation, t.value.x, t.value.y) : 3 === t.glValueLength ? t.glFunc.call(i, t.uniformLocation, t.value.x, t.value.y, t.value.z) : 4 === t.glValueLength ? t.glFunc.call(i, t.uniformLocation, t.value.x, t.value.y, t.value.z, t.value.w) : "sampler2D" === t.type && (t._init ? (i.activeTexture(i["TEXTURE" + this.textureCount]), t.value.baseTexture._dirty[i.id] ? e.instances[i.id].updateTexture(t.value.baseTexture) : i.bindTexture(i.TEXTURE_2D, t.value.baseTexture._glTextures[i.id]), i.uniform1i(t.uniformLocation, this.textureCount), this.textureCount++) : this.initSampler2D(t))
    }, e.PixiShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null
    }, e.PixiShader.defaultVertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute vec4 aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   gl_Position = vec4( ((aVertexPosition + offsetVector) / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = vec4(aColor.rgb * aColor.a, aColor.a);", "}"], e.PixiFastShader = function(t) {
        this._UID = e._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision lowp float;", "varying vec2 vTextureCoord;", "varying float vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aPositionCoord;", "attribute vec2 aScale;", "attribute float aRotation;", "attribute vec2 aTextureCoord;", "attribute float aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform mat3 uMatrix;", "varying vec2 vTextureCoord;", "varying float vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   vec2 v;", "   vec2 sv = aVertexPosition * aScale;", "   v.x = (sv.x) * cos(aRotation) - (sv.y) * sin(aRotation);", "   v.y = (sv.x) * sin(aRotation) + (sv.y) * cos(aRotation);", "   v = ( uMatrix * vec3(v + aPositionCoord , 1.0) ).xy ;", "   gl_Position = vec4( ( v / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = aColor;", "}"], this.textureCount = 0, this.init()
    }, e.PixiFastShader.prototype.constructor = e.PixiFastShader, e.PixiFastShader.prototype.init = function() {
        var t = this.gl,
            i = e.compileProgram(t, this.vertexSrc, this.fragmentSrc);
        t.useProgram(i), this.uSampler = t.getUniformLocation(i, "uSampler"), this.projectionVector = t.getUniformLocation(i, "projectionVector"), this.offsetVector = t.getUniformLocation(i, "offsetVector"), this.dimensions = t.getUniformLocation(i, "dimensions"), this.uMatrix = t.getUniformLocation(i, "uMatrix"), this.aVertexPosition = t.getAttribLocation(i, "aVertexPosition"), this.aPositionCoord = t.getAttribLocation(i, "aPositionCoord"), this.aScale = t.getAttribLocation(i, "aScale"), this.aRotation = t.getAttribLocation(i, "aRotation"), this.aTextureCoord = t.getAttribLocation(i, "aTextureCoord"), this.colorAttribute = t.getAttribLocation(i, "aColor"), -1 === this.colorAttribute && (this.colorAttribute = 2), this.attributes = [this.aVertexPosition, this.aPositionCoord, this.aScale, this.aRotation, this.aTextureCoord, this.colorAttribute], this.program = i
    }, e.PixiFastShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null
    }, e.StripShader = function(t) {
        this._UID = e._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "uniform float alpha;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y)) * alpha;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "}"], this.init()
    }, e.StripShader.prototype.constructor = e.StripShader, e.StripShader.prototype.init = function() {
        var t = this.gl,
            i = e.compileProgram(t, this.vertexSrc, this.fragmentSrc);
        t.useProgram(i), this.uSampler = t.getUniformLocation(i, "uSampler"), this.projectionVector = t.getUniformLocation(i, "projectionVector"), this.offsetVector = t.getUniformLocation(i, "offsetVector"), this.colorAttribute = t.getAttribLocation(i, "aColor"), this.aVertexPosition = t.getAttribLocation(i, "aVertexPosition"), this.aTextureCoord = t.getAttribLocation(i, "aTextureCoord"), this.attributes = [this.aVertexPosition, this.aTextureCoord], this.translationMatrix = t.getUniformLocation(i, "translationMatrix"), this.alpha = t.getUniformLocation(i, "alpha"), this.program = i
    }, e.StripShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attribute = null
    }, e.PrimitiveShader = function(t) {
        this._UID = e._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec4 aColor;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform float alpha;", "uniform float flipY;", "uniform vec3 tint;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);", "   vColor = aColor * vec4(tint * alpha, alpha);", "}"], this.init()
    }, e.PrimitiveShader.prototype.constructor = e.PrimitiveShader, e.PrimitiveShader.prototype.init = function() {
        var t = this.gl,
            i = e.compileProgram(t, this.vertexSrc, this.fragmentSrc);
        t.useProgram(i), this.projectionVector = t.getUniformLocation(i, "projectionVector"), this.offsetVector = t.getUniformLocation(i, "offsetVector"), this.tintColor = t.getUniformLocation(i, "tint"), this.flipY = t.getUniformLocation(i, "flipY"), this.aVertexPosition = t.getAttribLocation(i, "aVertexPosition"), this.colorAttribute = t.getAttribLocation(i, "aColor"), this.attributes = [this.aVertexPosition, this.colorAttribute], this.translationMatrix = t.getUniformLocation(i, "translationMatrix"), this.alpha = t.getUniformLocation(i, "alpha"), this.program = i
    }, e.PrimitiveShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null
    }, e.ComplexPrimitiveShader = function(t) {
        this._UID = e._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform vec3 tint;", "uniform float alpha;", "uniform vec3 color;", "uniform float flipY;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);", "   vColor = vec4(color * alpha * tint, alpha);", "}"], this.init()
    }, e.ComplexPrimitiveShader.prototype.constructor = e.ComplexPrimitiveShader, e.ComplexPrimitiveShader.prototype.init = function() {
        var t = this.gl,
            i = e.compileProgram(t, this.vertexSrc, this.fragmentSrc);
        t.useProgram(i), this.projectionVector = t.getUniformLocation(i, "projectionVector"), this.offsetVector = t.getUniformLocation(i, "offsetVector"), this.tintColor = t.getUniformLocation(i, "tint"), this.color = t.getUniformLocation(i, "color"), this.flipY = t.getUniformLocation(i, "flipY"), this.aVertexPosition = t.getAttribLocation(i, "aVertexPosition"), this.attributes = [this.aVertexPosition, this.colorAttribute], this.translationMatrix = t.getUniformLocation(i, "translationMatrix"), this.alpha = t.getUniformLocation(i, "alpha"), this.program = i
    }, e.ComplexPrimitiveShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attribute = null
    }, e.glContexts = [], e.instances = [], e.WebGLRenderer = function(t) {
        this.game = t, e.defaultRenderer || (e.defaultRenderer = this), this.type = e.WEBGL_RENDERER, this.resolution = t.resolution, this.transparent = t.transparent, this.autoResize = !1, this.preserveDrawingBuffer = t.preserveDrawingBuffer, this.clearBeforeRender = t.clearBeforeRender, this.width = t.width, this.height = t.height, this.view = t.canvas, this._contextOptions = {
            alpha: this.transparent,
            antialias: t.antialias,
            premultipliedAlpha: this.transparent && "notMultiplied" !== this.transparent,
            stencil: !0,
            preserveDrawingBuffer: this.preserveDrawingBuffer
        }, this.projection = new e.Point, this.offset = new e.Point, this.shaderManager = new e.WebGLShaderManager, this.spriteBatch = new e.WebGLSpriteBatch, this.maskManager = new e.WebGLMaskManager, this.filterManager = new e.WebGLFilterManager, this.stencilManager = new e.WebGLStencilManager, this.blendModeManager = new e.WebGLBlendModeManager, this.renderSession = {}, this.renderSession.game = this.game, this.renderSession.gl = this.gl, this.renderSession.drawCount = 0, this.renderSession.shaderManager = this.shaderManager, this.renderSession.maskManager = this.maskManager, this.renderSession.filterManager = this.filterManager, this.renderSession.blendModeManager = this.blendModeManager, this.renderSession.spriteBatch = this.spriteBatch, this.renderSession.stencilManager = this.stencilManager, this.renderSession.renderer = this, this.renderSession.resolution = this.resolution, this.initContext(), this.mapBlendModes()
    }, e.WebGLRenderer.prototype.constructor = e.WebGLRenderer, e.WebGLRenderer.prototype.initContext = function() {
        var t = this.view.getContext("webgl", this._contextOptions) || this.view.getContext("experimental-webgl", this._contextOptions);
        if (this.gl = t, !t) throw new Error("This browser does not support webGL. Try using the canvas renderer");
        this.glContextId = t.id = e.WebGLRenderer.glContextId++, e.glContexts[this.glContextId] = t, e.instances[this.glContextId] = this, t.disable(t.DEPTH_TEST), t.disable(t.CULL_FACE), t.enable(t.BLEND), this.shaderManager.setContext(t), this.spriteBatch.setContext(t), this.maskManager.setContext(t), this.filterManager.setContext(t), this.blendModeManager.setContext(t), this.stencilManager.setContext(t), this.renderSession.gl = this.gl, this.resize(this.width, this.height)
    }, e.WebGLRenderer.prototype.render = function(t) {
        if (!this.contextLost) {
            var e = this.gl;
            e.viewport(0, 0, this.width, this.height), e.bindFramebuffer(e.FRAMEBUFFER, null), this.game.clearBeforeRender && (e.clearColor(t._bgColor.r, t._bgColor.g, t._bgColor.b, t._bgColor.a), e.clear(e.COLOR_BUFFER_BIT)), this.offset.x = this.game.camera._shake.x, this.offset.y = this.game.camera._shake.y, this.renderDisplayObject(t, this.projection)
        }
    }, e.WebGLRenderer.prototype.renderDisplayObject = function(t, i, s, o) {
        this.renderSession.blendModeManager.setBlendMode(e.blendModes.NORMAL), this.renderSession.drawCount = 0, this.renderSession.flipY = s ? -1 : 1, this.renderSession.projection = i, this.renderSession.offset = this.offset, this.spriteBatch.begin(this.renderSession), this.filterManager.begin(this.renderSession, s), t._renderWebGL(this.renderSession, o), this.spriteBatch.end()
    }, e.WebGLRenderer.prototype.resize = function(t, e) {
        this.width = t * this.resolution, this.height = e * this.resolution, this.view.width = this.width, this.view.height = this.height, this.autoResize && (this.view.style.width = this.width / this.resolution + "px", this.view.style.height = this.height / this.resolution + "px"), this.gl.viewport(0, 0, this.width, this.height), this.projection.x = this.width / 2 / this.resolution, this.projection.y = -this.height / 2 / this.resolution
    }, e.WebGLRenderer.prototype.updateTexture = function(t) {
        if (!t.hasLoaded) return !1;
        var i = this.gl;
        return t._glTextures[i.id] || (t._glTextures[i.id] = i.createTexture()), i.bindTexture(i.TEXTURE_2D, t._glTextures[i.id]), i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultipliedAlpha), i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, i.RGBA, i.UNSIGNED_BYTE, t.source), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, t.scaleMode === e.scaleModes.LINEAR ? i.LINEAR : i.NEAREST), t.mipmap && e.isPowerOfTwo(t.width, t.height) ? (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, t.scaleMode === e.scaleModes.LINEAR ? i.LINEAR_MIPMAP_LINEAR : i.NEAREST_MIPMAP_NEAREST), i.generateMipmap(i.TEXTURE_2D)) : i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, t.scaleMode === e.scaleModes.LINEAR ? i.LINEAR : i.NEAREST), t._powerOf2 ? (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.REPEAT), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.REPEAT)) : (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.CLAMP_TO_EDGE)), t._dirty[i.id] = !1, !0
    }, e.WebGLRenderer.prototype.destroy = function() {
        e.glContexts[this.glContextId] = null, this.projection = null, this.offset = null, this.shaderManager.destroy(), this.spriteBatch.destroy(), this.maskManager.destroy(), this.filterManager.destroy(), this.shaderManager = null, this.spriteBatch = null, this.maskManager = null, this.filterManager = null, this.gl = null, this.renderSession = null, e.CanvasPool.remove(this), e.instances[this.glContextId] = null, e.WebGLRenderer.glContextId--
    }, e.WebGLRenderer.prototype.mapBlendModes = function() {
        var t = this.gl;
        if (!e.blendModesWebGL) {
            var i = [],
                s = e.blendModes;
            i[s.NORMAL] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[s.ADD] = [t.SRC_ALPHA, t.DST_ALPHA], i[s.MULTIPLY] = [t.DST_COLOR, t.ONE_MINUS_SRC_ALPHA], i[s.SCREEN] = [t.SRC_ALPHA, t.ONE], i[s.OVERLAY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[s.DARKEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[s.LIGHTEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[s.COLOR_DODGE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[s.COLOR_BURN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[s.HARD_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[s.SOFT_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[s.DIFFERENCE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[s.EXCLUSION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[s.HUE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[s.SATURATION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[s.COLOR] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[s.LUMINOSITY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e.blendModesWebGL = i
        }
    }, e.WebGLRenderer.glContextId = 0, e.WebGLBlendModeManager = function() {
        this.currentBlendMode = 99999
    }, e.WebGLBlendModeManager.prototype.constructor = e.WebGLBlendModeManager, e.WebGLBlendModeManager.prototype.setContext = function(t) {
        this.gl = t
    }, e.WebGLBlendModeManager.prototype.setBlendMode = function(t) {
        if (this.currentBlendMode === t) return !1;
        this.currentBlendMode = t;
        var i = e.blendModesWebGL[this.currentBlendMode];
        return i && this.gl.blendFunc(i[0], i[1]), !0
    }, e.WebGLBlendModeManager.prototype.destroy = function() {
        this.gl = null
    }, e.WebGLMaskManager = function() {}, e.WebGLMaskManager.prototype.constructor = e.WebGLMaskManager, e.WebGLMaskManager.prototype.setContext = function(t) {
        this.gl = t
    }, e.WebGLMaskManager.prototype.pushMask = function(t, i) {
        var s = i.gl;
        t.dirty && e.WebGLGraphics.updateGraphics(t, s), void 0 !== t._webGL[s.id] && void 0 !== t._webGL[s.id].data && 0 !== t._webGL[s.id].data.length && i.stencilManager.pushStencil(t, t._webGL[s.id].data[0], i)
    }, e.WebGLMaskManager.prototype.popMask = function(t, e) {
        var i = this.gl;
        void 0 !== t._webGL[i.id] && void 0 !== t._webGL[i.id].data && 0 !== t._webGL[i.id].data.length && e.stencilManager.popStencil(t, t._webGL[i.id].data[0], e)
    }, e.WebGLMaskManager.prototype.destroy = function() {
        this.gl = null
    }, e.WebGLStencilManager = function() {
        this.stencilStack = [], this.reverse = !0, this.count = 0
    }, e.WebGLStencilManager.prototype.setContext = function(t) {
        this.gl = t
    }, e.WebGLStencilManager.prototype.pushStencil = function(t, e, i) {
        var s = this.gl;
        this.bindGraphics(t, e, i), 0 === this.stencilStack.length && (s.enable(s.STENCIL_TEST), s.clear(s.STENCIL_BUFFER_BIT), this.reverse = !0, this.count = 0), this.stencilStack.push(e);
        var o = this.count;
        s.colorMask(!1, !1, !1, !1), s.stencilFunc(s.ALWAYS, 0, 255), s.stencilOp(s.KEEP, s.KEEP, s.INVERT), 1 === e.mode ? (s.drawElements(s.TRIANGLE_FAN, e.indices.length - 4, s.UNSIGNED_SHORT, 0), this.reverse ? (s.stencilFunc(s.EQUAL, 255 - o, 255), s.stencilOp(s.KEEP, s.KEEP, s.DECR)) : (s.stencilFunc(s.EQUAL, o, 255), s.stencilOp(s.KEEP, s.KEEP, s.INCR)), s.drawElements(s.TRIANGLE_FAN, 4, s.UNSIGNED_SHORT, 2 * (e.indices.length - 4)), this.reverse ? s.stencilFunc(s.EQUAL, 255 - (o + 1), 255) : s.stencilFunc(s.EQUAL, o + 1, 255), this.reverse = !this.reverse) : (this.reverse ? (s.stencilFunc(s.EQUAL, o, 255), s.stencilOp(s.KEEP, s.KEEP, s.INCR)) : (s.stencilFunc(s.EQUAL, 255 - o, 255), s.stencilOp(s.KEEP, s.KEEP, s.DECR)), s.drawElements(s.TRIANGLE_STRIP, e.indices.length, s.UNSIGNED_SHORT, 0), this.reverse ? s.stencilFunc(s.EQUAL, o + 1, 255) : s.stencilFunc(s.EQUAL, 255 - (o + 1), 255)), s.colorMask(!0, !0, !0, !0), s.stencilOp(s.KEEP, s.KEEP, s.KEEP), this.count++
    }, e.WebGLStencilManager.prototype.bindGraphics = function(t, i, s) {
        this._currentGraphics = t;
        var o, n = this.gl,
            a = s.projection,
            r = s.offset;
        1 === i.mode ? (o = s.shaderManager.complexPrimitiveShader, s.shaderManager.setShader(o), n.uniform1f(o.flipY, s.flipY), n.uniformMatrix3fv(o.translationMatrix, !1, t.worldTransform.toArray(!0)), n.uniform2f(o.projectionVector, a.x, -a.y), n.uniform2f(o.offsetVector, -r.x, -r.y), n.uniform3fv(o.tintColor, e.hex2rgb(t.tint)), n.uniform3fv(o.color, i.color), n.uniform1f(o.alpha, t.worldAlpha * i.alpha), n.bindBuffer(n.ARRAY_BUFFER, i.buffer), n.vertexAttribPointer(o.aVertexPosition, 2, n.FLOAT, !1, 8, 0), n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, i.indexBuffer)) : (o = s.shaderManager.primitiveShader, s.shaderManager.setShader(o), n.uniformMatrix3fv(o.translationMatrix, !1, t.worldTransform.toArray(!0)), n.uniform1f(o.flipY, s.flipY), n.uniform2f(o.projectionVector, a.x, -a.y), n.uniform2f(o.offsetVector, -r.x, -r.y), n.uniform3fv(o.tintColor, e.hex2rgb(t.tint)), n.uniform1f(o.alpha, t.worldAlpha), n.bindBuffer(n.ARRAY_BUFFER, i.buffer), n.vertexAttribPointer(o.aVertexPosition, 2, n.FLOAT, !1, 24, 0), n.vertexAttribPointer(o.colorAttribute, 4, n.FLOAT, !1, 24, 8), n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, i.indexBuffer))
    }, e.WebGLStencilManager.prototype.popStencil = function(t, e, i) {
        var s = this.gl;
        if (this.stencilStack.pop(), this.count--, 0 === this.stencilStack.length) s.disable(s.STENCIL_TEST);
        else {
            var o = this.count;
            this.bindGraphics(t, e, i), s.colorMask(!1, !1, !1, !1), 1 === e.mode ? (this.reverse = !this.reverse, this.reverse ? (s.stencilFunc(s.EQUAL, 255 - (o + 1), 255), s.stencilOp(s.KEEP, s.KEEP, s.INCR)) : (s.stencilFunc(s.EQUAL, o + 1, 255), s.stencilOp(s.KEEP, s.KEEP, s.DECR)), s.drawElements(s.TRIANGLE_FAN, 4, s.UNSIGNED_SHORT, 2 * (e.indices.length - 4)), s.stencilFunc(s.ALWAYS, 0, 255), s.stencilOp(s.KEEP, s.KEEP, s.INVERT), s.drawElements(s.TRIANGLE_FAN, e.indices.length - 4, s.UNSIGNED_SHORT, 0), this.reverse ? s.stencilFunc(s.EQUAL, o, 255) : s.stencilFunc(s.EQUAL, 255 - o, 255)) : (this.reverse ? (s.stencilFunc(s.EQUAL, o + 1, 255), s.stencilOp(s.KEEP, s.KEEP, s.DECR)) : (s.stencilFunc(s.EQUAL, 255 - (o + 1), 255), s.stencilOp(s.KEEP, s.KEEP, s.INCR)), s.drawElements(s.TRIANGLE_STRIP, e.indices.length, s.UNSIGNED_SHORT, 0), this.reverse ? s.stencilFunc(s.EQUAL, o, 255) : s.stencilFunc(s.EQUAL, 255 - o, 255)), s.colorMask(!0, !0, !0, !0), s.stencilOp(s.KEEP, s.KEEP, s.KEEP)
        }
    }, e.WebGLStencilManager.prototype.destroy = function() {
        this.stencilStack = null, this.gl = null
    }, e.WebGLShaderManager = function() {
        this.maxAttibs = 10, this.attribState = [], this.tempAttribState = [];
        for (var t = 0; t < this.maxAttibs; t++) this.attribState[t] = !1;
        this.stack = []
    }, e.WebGLShaderManager.prototype.constructor = e.WebGLShaderManager, e.WebGLShaderManager.prototype.setContext = function(t) {
        this.gl = t, this.primitiveShader = new e.PrimitiveShader(t), this.complexPrimitiveShader = new e.ComplexPrimitiveShader(t), this.defaultShader = new e.PixiShader(t), this.fastShader = new e.PixiFastShader(t), this.stripShader = new e.StripShader(t), this.setShader(this.defaultShader)
    }, e.WebGLShaderManager.prototype.setAttribs = function(t) {
        var e;
        for (e = 0; e < this.tempAttribState.length; e++) this.tempAttribState[e] = !1;
        for (e = 0; e < t.length; e++) {
            var i = t[e];
            this.tempAttribState[i] = !0
        }
        var s = this.gl;
        for (e = 0; e < this.attribState.length; e++) this.attribState[e] !== this.tempAttribState[e] && (this.attribState[e] = this.tempAttribState[e], this.tempAttribState[e] ? s.enableVertexAttribArray(e) : s.disableVertexAttribArray(e))
    }, e.WebGLShaderManager.prototype.setShader = function(t) {
        return this._currentId !== t._UID && (this._currentId = t._UID, this.currentShader = t, this.gl.useProgram(t.program), this.setAttribs(t.attributes), !0)
    }, e.WebGLShaderManager.prototype.destroy = function() {
        this.attribState = null, this.tempAttribState = null, this.primitiveShader.destroy(), this.complexPrimitiveShader.destroy(), this.defaultShader.destroy(), this.fastShader.destroy(), this.stripShader.destroy(), this.gl = null
    }, e.WebGLSpriteBatch = function() {
        this.vertSize = 5, this.size = 2e3;
        var t = 4 * this.size * 4 * this.vertSize,
            i = 6 * this.size;
        this.vertices = new e.ArrayBuffer(t), this.positions = new e.Float32Array(this.vertices), this.colors = new e.Uint32Array(this.vertices), this.indices = new e.Uint16Array(i), this.lastIndexCount = 0;
        for (var s = 0, o = 0; s < i; s += 6, o += 4) this.indices[s + 0] = o + 0, this.indices[s + 1] = o + 1, this.indices[s + 2] = o + 2, this.indices[s + 3] = o + 0, this.indices[s + 4] = o + 2, this.indices[s + 5] = o + 3;
        this.drawing = !1, this.currentBatchSize = 0, this.currentBaseTexture = null, this.dirty = !0, this.textures = [], this.blendModes = [], this.shaders = [], this.sprites = [], this.defaultShader = new e.AbstractFilter(["precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"])
    }, e.WebGLSpriteBatch.prototype.setContext = function(t) {
        this.gl = t, this.vertexBuffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.indices, t.STATIC_DRAW), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this.vertices, t.DYNAMIC_DRAW), this.currentBlendMode = 99999;
        var i = new e.PixiShader(t);
        i.fragmentSrc = this.defaultShader.fragmentSrc, i.uniforms = {}, i.init(), this.defaultShader.shaders[t.id] = i
    }, e.WebGLSpriteBatch.prototype.begin = function(t) {
        this.renderSession = t, this.shader = this.renderSession.shaderManager.defaultShader, this.start()
    }, e.WebGLSpriteBatch.prototype.end = function() {
        this.flush()
    }, e.WebGLSpriteBatch.prototype.render = function(t, e) {
        var i = t.texture,
            s = t.worldTransform;
        e && (s = e), this.currentBatchSize >= this.size && (this.flush(), this.currentBaseTexture = i.baseTexture);
        var o = i._uvs;
        if (o) {
            var n, a, r, h, l = t.anchor.x,
                c = t.anchor.y;
            if (i.trim) {
                var p = i.trim;
                n = (a = p.x - l * p.width) + i.crop.width, r = (h = p.y - c * p.height) + i.crop.height
            } else n = i.frame.width * (1 - l), a = i.frame.width * -l, r = i.frame.height * (1 - c), h = i.frame.height * -c;
            var u = 4 * this.currentBatchSize * this.vertSize,
                d = i.baseTexture.resolution,
                m = s.a / d,
                y = s.b / d,
                f = s.c / d,
                g = s.d / d,
                _ = s.tx,
                v = s.ty,
                b = this.colors,
                x = this.positions;
            this.renderSession.roundPixels ? (x[u] = m * a + f * h + _ | 0, x[u + 1] = g * h + y * a + v | 0, x[u + 5] = m * n + f * h + _ | 0, x[u + 6] = g * h + y * n + v | 0, x[u + 10] = m * n + f * r + _ | 0, x[u + 11] = g * r + y * n + v | 0, x[u + 15] = m * a + f * r + _ | 0, x[u + 16] = g * r + y * a + v | 0) : (x[u] = m * a + f * h + _, x[u + 1] = g * h + y * a + v, x[u + 5] = m * n + f * h + _, x[u + 6] = g * h + y * n + v, x[u + 10] = m * n + f * r + _, x[u + 11] = g * r + y * n + v, x[u + 15] = m * a + f * r + _, x[u + 16] = g * r + y * a + v), x[u + 2] = o.x0, x[u + 3] = o.y0, x[u + 7] = o.x1, x[u + 8] = o.y1, x[u + 12] = o.x2, x[u + 13] = o.y2, x[u + 17] = o.x3, x[u + 18] = o.y3;
            var C = t.tint;
            b[u + 4] = b[u + 9] = b[u + 14] = b[u + 19] = (C >> 16) + (65280 & C) + ((255 & C) << 16) + (255 * t.worldAlpha << 24), this.sprites[this.currentBatchSize++] = t
        }
    }, e.WebGLSpriteBatch.prototype.renderTilingSprite = function(t) {
        var i = t.tilingTexture;
        this.currentBatchSize >= this.size && (this.flush(), this.currentBaseTexture = i.baseTexture), t._uvs || (t._uvs = new e.TextureUvs);
        var s = t._uvs,
            o = i.baseTexture.width,
            n = i.baseTexture.height;
        t.tilePosition.x %= o * t.tileScaleOffset.x, t.tilePosition.y %= n * t.tileScaleOffset.y;
        var a = t.tilePosition.x / (o * t.tileScaleOffset.x),
            r = t.tilePosition.y / (n * t.tileScaleOffset.y),
            h = t.width / o / (t.tileScale.x * t.tileScaleOffset.x),
            l = t.height / n / (t.tileScale.y * t.tileScaleOffset.y);
        s.x0 = 0 - a, s.y0 = 0 - r, s.x1 = 1 * h - a, s.y1 = 0 - r, s.x2 = 1 * h - a, s.y2 = 1 * l - r, s.x3 = 0 - a, s.y3 = 1 * l - r;
        var c = t.tint,
            p = (c >> 16) + (65280 & c) + ((255 & c) << 16) + (255 * t.worldAlpha << 24),
            u = this.positions,
            d = this.colors,
            m = t.width,
            y = t.height,
            f = t.anchor.x,
            g = t.anchor.y,
            _ = m * (1 - f),
            v = m * -f,
            b = y * (1 - g),
            x = y * -g,
            C = 4 * this.currentBatchSize * this.vertSize,
            S = i.baseTexture.resolution,
            w = t.worldTransform,
            A = w.a / S,
            T = w.b / S,
            B = w.c / S,
            P = w.d / S,
            D = w.tx,
            I = w.ty;
        u[C++] = A * v + B * x + D, u[C++] = P * x + T * v + I, u[C++] = s.x0, u[C++] = s.y0, d[C++] = p, u[C++] = A * _ + B * x + D, u[C++] = P * x + T * _ + I, u[C++] = s.x1, u[C++] = s.y1, d[C++] = p, u[C++] = A * _ + B * b + D, u[C++] = P * b + T * _ + I, u[C++] = s.x2, u[C++] = s.y2, d[C++] = p, u[C++] = A * v + B * b + D, u[C++] = P * b + T * v + I, u[C++] = s.x3, u[C++] = s.y3, d[C++] = p, this.sprites[this.currentBatchSize++] = t
    }, e.WebGLSpriteBatch.prototype.flush = function() {
        if (0 !== this.currentBatchSize) {
            var t, i = this.gl;
            if (this.dirty) {
                this.dirty = !1, i.activeTexture(i.TEXTURE0), i.bindBuffer(i.ARRAY_BUFFER, this.vertexBuffer), i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t = this.defaultShader.shaders[i.id];
                var s = 4 * this.vertSize;
                i.vertexAttribPointer(t.aVertexPosition, 2, i.FLOAT, !1, s, 0), i.vertexAttribPointer(t.aTextureCoord, 2, i.FLOAT, !1, s, 8), i.vertexAttribPointer(t.colorAttribute, 4, i.UNSIGNED_BYTE, !0, s, 16)
            }
            if (this.currentBatchSize > .5 * this.size) i.bufferSubData(i.ARRAY_BUFFER, 0, this.vertices);
            else {
                var o = this.positions.subarray(0, 4 * this.currentBatchSize * this.vertSize);
                i.bufferSubData(i.ARRAY_BUFFER, 0, o)
            }
            for (var n, a, r, h, l = 0, c = 0, p = null, u = this.renderSession.blendModeManager.currentBlendMode, d = null, m = !1, y = !1, f = 0, g = this.currentBatchSize; f < g; f++) {
                n = (h = this.sprites[f]).tilingTexture ? h.tilingTexture.baseTexture : h.texture.baseTexture, m = u !== (a = h.blendMode), y = d !== (r = h.shader || this.defaultShader);
                var _ = n.skipRender;
                if (_ && h.children.length > 0 && (_ = !1), (p !== n && !_ || m || y) && (this.renderBatch(p, l, c), c = f, l = 0, p = n, m && (u = a, this.renderSession.blendModeManager.setBlendMode(u)), y)) {
                    (t = (d = r).shaders[i.id]) || (t = new e.PixiShader(i), t.fragmentSrc = d.fragmentSrc, t.uniforms = d.uniforms, t.init(), d.shaders[i.id] = t), this.renderSession.shaderManager.setShader(t), t.dirty && t.syncUniforms();
                    var v = this.renderSession.projection;
                    i.uniform2f(t.projectionVector, v.x, v.y);
                    var b = this.renderSession.offset;
                    i.uniform2f(t.offsetVector, b.x, b.y)
                }
                l++
            }
            this.renderBatch(p, l, c), this.currentBatchSize = 0
        }
    }, e.WebGLSpriteBatch.prototype.renderBatch = function(t, e, i) {
        if (0 !== e) {
            var s = this.gl;
            if (t._dirty[s.id]) {
                if (!this.renderSession.renderer.updateTexture(t)) return
            } else s.bindTexture(s.TEXTURE_2D, t._glTextures[s.id]);
            s.drawElements(s.TRIANGLES, 6 * e, s.UNSIGNED_SHORT, 6 * i * 2), this.renderSession.drawCount++
        }
    }, e.WebGLSpriteBatch.prototype.stop = function() {
        this.flush(), this.dirty = !0
    }, e.WebGLSpriteBatch.prototype.start = function() {
        this.dirty = !0
    }, e.WebGLSpriteBatch.prototype.destroy = function() {
        this.vertices = null, this.indices = null, this.gl.deleteBuffer(this.vertexBuffer), this.gl.deleteBuffer(this.indexBuffer), this.currentBaseTexture = null, this.gl = null
    }, e.WebGLFastSpriteBatch = function(t) {
        this.vertSize = 10, this.maxSize = 6e3, this.size = this.maxSize;
        var i = 4 * this.size * this.vertSize,
            s = 6 * this.maxSize;
        this.vertices = new e.Float32Array(i), this.indices = new e.Uint16Array(s), this.vertexBuffer = null, this.indexBuffer = null, this.lastIndexCount = 0;
        for (var o = 0, n = 0; o < s; o += 6, n += 4) this.indices[o + 0] = n + 0, this.indices[o + 1] = n + 1, this.indices[o + 2] = n + 2, this.indices[o + 3] = n + 0, this.indices[o + 4] = n + 2, this.indices[o + 5] = n + 3;
        this.drawing = !1, this.currentBatchSize = 0, this.currentBaseTexture = null, this.currentBlendMode = 0, this.renderSession = null, this.shader = null, this.matrix = null, this.setContext(t)
    }, e.WebGLFastSpriteBatch.prototype.constructor = e.WebGLFastSpriteBatch, e.WebGLFastSpriteBatch.prototype.setContext = function(t) {
        this.gl = t, this.vertexBuffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.indices, t.STATIC_DRAW), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this.vertices, t.DYNAMIC_DRAW)
    }, e.WebGLFastSpriteBatch.prototype.begin = function(t, e) {
        this.renderSession = e, this.shader = this.renderSession.shaderManager.fastShader, this.matrix = t.worldTransform.toArray(!0), this.start()
    }, e.WebGLFastSpriteBatch.prototype.end = function() {
        this.flush()
    }, e.WebGLFastSpriteBatch.prototype.render = function(t) {
        var e = t.children,
            i = e[0];
        if (i.texture._uvs) {
            this.currentBaseTexture = i.texture.baseTexture, i.blendMode !== this.renderSession.blendModeManager.currentBlendMode && (this.flush(), this.renderSession.blendModeManager.setBlendMode(i.blendMode));
            for (var s = 0, o = e.length; s < o; s++) this.renderSprite(e[s]);
            this.flush()
        }
    }, e.WebGLFastSpriteBatch.prototype.renderSprite = function(t) {
        if (t.visible && (t.texture.baseTexture === this.currentBaseTexture || t.texture.baseTexture.skipRender || (this.flush(), this.currentBaseTexture = t.texture.baseTexture, t.texture._uvs))) {
            var e, i, s, o, n, a, r = this.vertices;
            if (e = t.texture._uvs, t.texture.frame.width, t.texture.frame.height, t.texture.trim) {
                var h = t.texture.trim;
                i = (s = h.x - t.anchor.x * h.width) + t.texture.crop.width, o = (n = h.y - t.anchor.y * h.height) + t.texture.crop.height
            } else i = t.texture.frame.width * (1 - t.anchor.x), s = t.texture.frame.width * -t.anchor.x, o = t.texture.frame.height * (1 - t.anchor.y), n = t.texture.frame.height * -t.anchor.y;
            a = 4 * this.currentBatchSize * this.vertSize, r[a++] = s, r[a++] = n, r[a++] = t.position.x, r[a++] = t.position.y, r[a++] = t.scale.x, r[a++] = t.scale.y, r[a++] = t.rotation, r[a++] = e.x0, r[a++] = e.y1, r[a++] = t.alpha, r[a++] = i, r[a++] = n, r[a++] = t.position.x, r[a++] = t.position.y, r[a++] = t.scale.x, r[a++] = t.scale.y, r[a++] = t.rotation, r[a++] = e.x1, r[a++] = e.y1, r[a++] = t.alpha, r[a++] = i, r[a++] = o, r[a++] = t.position.x, r[a++] = t.position.y, r[a++] = t.scale.x, r[a++] = t.scale.y, r[a++] = t.rotation, r[a++] = e.x2, r[a++] = e.y2, r[a++] = t.alpha, r[a++] = s, r[a++] = o, r[a++] = t.position.x, r[a++] = t.position.y, r[a++] = t.scale.x, r[a++] = t.scale.y, r[a++] = t.rotation, r[a++] = e.x3, r[a++] = e.y3, r[a++] = t.alpha, ++this.currentBatchSize >= this.size && this.flush()
        }
    }, e.WebGLFastSpriteBatch.prototype.flush = function() {
        if (0 !== this.currentBatchSize) {
            var t = this.gl;
            if (this.currentBaseTexture._glTextures[t.id] || this.renderSession.renderer.updateTexture(this.currentBaseTexture, t), t.bindTexture(t.TEXTURE_2D, this.currentBaseTexture._glTextures[t.id]), this.currentBatchSize > .5 * this.size) t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertices);
            else {
                var e = this.vertices.subarray(0, 4 * this.currentBatchSize * this.vertSize);
                t.bufferSubData(t.ARRAY_BUFFER, 0, e)
            }
            t.drawElements(t.TRIANGLES, 6 * this.currentBatchSize, t.UNSIGNED_SHORT, 0), this.currentBatchSize = 0, this.renderSession.drawCount++
        }
    }, e.WebGLFastSpriteBatch.prototype.stop = function() {
        this.flush()
    }, e.WebGLFastSpriteBatch.prototype.start = function() {
        var t = this.gl;
        t.activeTexture(t.TEXTURE0), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        var e = this.renderSession.projection;
        t.uniform2f(this.shader.projectionVector, e.x, e.y), t.uniformMatrix3fv(this.shader.uMatrix, !1, this.matrix);
        var i = 4 * this.vertSize;
        t.vertexAttribPointer(this.shader.aVertexPosition, 2, t.FLOAT, !1, i, 0), t.vertexAttribPointer(this.shader.aPositionCoord, 2, t.FLOAT, !1, i, 8), t.vertexAttribPointer(this.shader.aScale, 2, t.FLOAT, !1, i, 16), t.vertexAttribPointer(this.shader.aRotation, 1, t.FLOAT, !1, i, 24), t.vertexAttribPointer(this.shader.aTextureCoord, 2, t.FLOAT, !1, i, 28), t.vertexAttribPointer(this.shader.colorAttribute, 1, t.FLOAT, !1, i, 36)
    }, e.WebGLFilterManager = function() {
        this.filterStack = [], this.offsetX = 0, this.offsetY = 0
    }, e.WebGLFilterManager.prototype.constructor = e.WebGLFilterManager, e.WebGLFilterManager.prototype.setContext = function(t) {
        this.gl = t, this.texturePool = [], this.initShaderBuffers()
    }, e.WebGLFilterManager.prototype.begin = function(t, e) {
        this.renderSession = t, this.defaultShader = t.shaderManager.defaultShader;
        var i = this.renderSession.projection;
        this.width = 2 * i.x, this.height = 2 * -i.y, this.buffer = e
    }, e.WebGLFilterManager.prototype.pushFilter = function(t) {
        var i = this.gl,
            s = this.renderSession.projection,
            o = this.renderSession.offset;
        t._filterArea = t.target.filterArea || t.target.getBounds(), t._previous_stencil_mgr = this.renderSession.stencilManager, this.renderSession.stencilManager = new e.WebGLStencilManager, this.renderSession.stencilManager.setContext(i), i.disable(i.STENCIL_TEST), this.filterStack.push(t);
        var n = t.filterPasses[0];
        this.offsetX += t._filterArea.x, this.offsetY += t._filterArea.y;
        var a = this.texturePool.pop();
        a ? a.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution) : a = new e.FilterTexture(this.gl, this.width * this.renderSession.resolution, this.height * this.renderSession.resolution), i.bindTexture(i.TEXTURE_2D, a.texture);
        var r = t._filterArea,
            h = n.padding;
        r.x -= h, r.y -= h, r.width += 2 * h, r.height += 2 * h, r.x < 0 && (r.x = 0), r.width > this.width && (r.width = this.width), r.y < 0 && (r.y = 0), r.height > this.height && (r.height = this.height), i.bindFramebuffer(i.FRAMEBUFFER, a.frameBuffer), i.viewport(0, 0, r.width * this.renderSession.resolution, r.height * this.renderSession.resolution), s.x = r.width / 2, s.y = -r.height / 2, o.x = -r.x, o.y = -r.y, i.colorMask(!0, !0, !0, !0), i.clearColor(0, 0, 0, 0), i.clear(i.COLOR_BUFFER_BIT), t._glFilterTexture = a
    }, e.WebGLFilterManager.prototype.popFilter = function() {
        var t = this.gl,
            i = this.filterStack.pop(),
            s = i._filterArea,
            o = i._glFilterTexture,
            n = this.renderSession.projection,
            a = this.renderSession.offset;
        if (i.filterPasses.length > 1) {
            t.viewport(0, 0, s.width * this.renderSession.resolution, s.height * this.renderSession.resolution), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), this.vertexArray[0] = 0, this.vertexArray[1] = s.height, this.vertexArray[2] = s.width, this.vertexArray[3] = s.height, this.vertexArray[4] = 0, this.vertexArray[5] = 0, this.vertexArray[6] = s.width, this.vertexArray[7] = 0, t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertexArray), t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer), this.uvArray[2] = s.width / this.width, this.uvArray[5] = s.height / this.height, this.uvArray[6] = s.width / this.width, this.uvArray[7] = s.height / this.height, t.bufferSubData(t.ARRAY_BUFFER, 0, this.uvArray);
            var r = o,
                h = this.texturePool.pop();
            h || (h = new e.FilterTexture(this.gl, this.width * this.renderSession.resolution, this.height * this.renderSession.resolution)), h.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution), t.bindFramebuffer(t.FRAMEBUFFER, h.frameBuffer), t.clear(t.COLOR_BUFFER_BIT), t.disable(t.BLEND);
            for (var l = 0; l < i.filterPasses.length - 1; l++) {
                var c = i.filterPasses[l];
                t.bindFramebuffer(t.FRAMEBUFFER, h.frameBuffer), t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, r.texture), this.applyFilterPass(c, s, s.width, s.height);
                var p = r;
                r = h, h = p
            }
            t.enable(t.BLEND), o = r, this.texturePool.push(h)
        }
        var u = i.filterPasses[i.filterPasses.length - 1];
        this.offsetX -= s.x, this.offsetY -= s.y;
        var d = this.width,
            m = this.height,
            y = 0,
            f = 0,
            g = this.buffer;
        if (0 === this.filterStack.length) t.colorMask(!0, !0, !0, !0);
        else {
            var _ = this.filterStack[this.filterStack.length - 1];
            d = (s = _._filterArea).width, m = s.height, y = s.x, f = s.y, g = _._glFilterTexture.frameBuffer
        }
        n.x = d / 2, n.y = -m / 2, a.x = y, a.y = f;
        var v = (s = i._filterArea).x - y,
            b = s.y - f;
        t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), this.vertexArray[0] = v, this.vertexArray[1] = b + s.height, this.vertexArray[2] = v + s.width, this.vertexArray[3] = b + s.height, this.vertexArray[4] = v, this.vertexArray[5] = b, this.vertexArray[6] = v + s.width, this.vertexArray[7] = b, t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertexArray), t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer), this.uvArray[2] = s.width / this.width, this.uvArray[5] = s.height / this.height, this.uvArray[6] = s.width / this.width, this.uvArray[7] = s.height / this.height, t.bufferSubData(t.ARRAY_BUFFER, 0, this.uvArray), t.viewport(0, 0, d * this.renderSession.resolution, m * this.renderSession.resolution), t.bindFramebuffer(t.FRAMEBUFFER, g), t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, o.texture), this.renderSession.stencilManager && this.renderSession.stencilManager.destroy(), this.renderSession.stencilManager = i._previous_stencil_mgr, i._previous_stencil_mgr = null, this.renderSession.stencilManager.count > 0 ? t.enable(t.STENCIL_TEST) : t.disable(t.STENCIL_TEST), this.applyFilterPass(u, s, d, m), this.texturePool.push(o), i._glFilterTexture = null
    }, e.WebGLFilterManager.prototype.applyFilterPass = function(t, i, s, o) {
        var n = this.gl,
            a = t.shaders[n.id];
        a || (a = new e.PixiShader(n), a.fragmentSrc = t.fragmentSrc, a.uniforms = t.uniforms, a.init(), t.shaders[n.id] = a), this.renderSession.shaderManager.setShader(a), n.uniform2f(a.projectionVector, s / 2, -o / 2), n.uniform2f(a.offsetVector, 0, 0), t.uniforms.dimensions && (t.uniforms.dimensions.value[0] = this.width, t.uniforms.dimensions.value[1] = this.height, t.uniforms.dimensions.value[2] = this.vertexArray[0], t.uniforms.dimensions.value[3] = this.vertexArray[5]), a.syncUniforms(), n.bindBuffer(n.ARRAY_BUFFER, this.vertexBuffer), n.vertexAttribPointer(a.aVertexPosition, 2, n.FLOAT, !1, 0, 0), n.bindBuffer(n.ARRAY_BUFFER, this.uvBuffer), n.vertexAttribPointer(a.aTextureCoord, 2, n.FLOAT, !1, 0, 0), n.bindBuffer(n.ARRAY_BUFFER, this.colorBuffer), n.vertexAttribPointer(a.colorAttribute, 2, n.FLOAT, !1, 0, 0), n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, this.indexBuffer), n.drawElements(n.TRIANGLES, 6, n.UNSIGNED_SHORT, 0), this.renderSession.drawCount++
    }, e.WebGLFilterManager.prototype.initShaderBuffers = function() {
        var t = this.gl;
        this.vertexBuffer = t.createBuffer(), this.uvBuffer = t.createBuffer(), this.colorBuffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), this.vertexArray = new e.Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this.vertexArray, t.STATIC_DRAW), this.uvArray = new e.Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer), t.bufferData(t.ARRAY_BUFFER, this.uvArray, t.STATIC_DRAW), this.colorArray = new e.Float32Array([1, 16777215, 1, 16777215, 1, 16777215, 1, 16777215]), t.bindBuffer(t.ARRAY_BUFFER, this.colorBuffer), t.bufferData(t.ARRAY_BUFFER, this.colorArray, t.STATIC_DRAW), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 1, 3, 2]), t.STATIC_DRAW)
    }, e.WebGLFilterManager.prototype.destroy = function() {
        var t = this.gl;
        this.filterStack = null, this.offsetX = 0, this.offsetY = 0;
        for (var e = 0; e < this.texturePool.length; e++) this.texturePool[e].destroy();
        this.texturePool = null, t.deleteBuffer(this.vertexBuffer), t.deleteBuffer(this.uvBuffer), t.deleteBuffer(this.colorBuffer), t.deleteBuffer(this.indexBuffer)
    }, e.FilterTexture = function(t, i, s, o) {
        this.gl = t, this.frameBuffer = t.createFramebuffer(), this.texture = t.createTexture(), o = o || e.scaleModes.DEFAULT, t.bindTexture(t.TEXTURE_2D, this.texture), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, o === e.scaleModes.LINEAR ? t.LINEAR : t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, o === e.scaleModes.LINEAR ? t.LINEAR : t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.bindFramebuffer(t.FRAMEBUFFER, this.frameBuffer), t.bindFramebuffer(t.FRAMEBUFFER, this.frameBuffer), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, this.texture, 0), this.renderBuffer = t.createRenderbuffer(), t.bindRenderbuffer(t.RENDERBUFFER, this.renderBuffer), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, this.renderBuffer), this.resize(i, s)
    }, e.FilterTexture.prototype.constructor = e.FilterTexture, e.FilterTexture.prototype.clear = function() {
        var t = this.gl;
        t.clearColor(0, 0, 0, 0), t.clear(t.COLOR_BUFFER_BIT)
    }, e.FilterTexture.prototype.resize = function(t, e) {
        if (this.width !== t || this.height !== e) {
            this.width = t, this.height = e;
            var i = this.gl;
            i.bindTexture(i.TEXTURE_2D, this.texture), i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, t, e, 0, i.RGBA, i.UNSIGNED_BYTE, null), i.bindRenderbuffer(i.RENDERBUFFER, this.renderBuffer), i.renderbufferStorage(i.RENDERBUFFER, i.DEPTH_STENCIL, t, e)
        }
    }, e.FilterTexture.prototype.destroy = function() {
        var t = this.gl;
        t.deleteFramebuffer(this.frameBuffer), t.deleteTexture(this.texture), this.frameBuffer = null, this.texture = null
    }, e.CanvasBuffer = function(t, i) {
        this.width = t, this.height = i, this.canvas = e.CanvasPool.create(this, this.width, this.height), this.context = this.canvas.getContext("2d"), this.canvas.width = t, this.canvas.height = i
    }, e.CanvasBuffer.prototype.constructor = e.CanvasBuffer, e.CanvasBuffer.prototype.clear = function() {
        this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.width, this.height)
    }, e.CanvasBuffer.prototype.resize = function(t, e) {
        this.width = this.canvas.width = t, this.height = this.canvas.height = e
    }, e.CanvasBuffer.prototype.destroy = function() {
        e.CanvasPool.remove(this)
    }, e.CanvasMaskManager = function() {}, e.CanvasMaskManager.prototype.constructor = e.CanvasMaskManager, e.CanvasMaskManager.prototype.pushMask = function(t, i) {
        var s = i.context;
        s.save();
        var o = t.alpha,
            n = t.worldTransform,
            a = i.resolution;
        s.setTransform(n.a * a, n.b * a, n.c * a, n.d * a, n.tx * a, n.ty * a), e.CanvasGraphics.renderGraphicsMask(t, s), s.clip(), t.worldAlpha = o
    }, e.CanvasMaskManager.prototype.popMask = function(t) {
        t.context.restore()
    }, e.CanvasTinter = function() {}, e.CanvasTinter.getTintedTexture = function(t, i) {
        var s = t.tintedTexture || e.CanvasPool.create(this);
        return e.CanvasTinter.tintMethod(t.texture, i, s), s
    }, e.CanvasTinter.tintWithMultiply = function(t, e, i) {
        var s = i.getContext("2d"),
            o = t.crop;
        i.width === o.width && i.height === o.height || (i.width = o.width, i.height = o.height), s.clearRect(0, 0, o.width, o.height), s.fillStyle = "#" + ("00000" + (0 | e).toString(16)).substr(-6), s.fillRect(0, 0, o.width, o.height), s.globalCompositeOperation = "multiply", s.drawImage(t.baseTexture.source, o.x, o.y, o.width, o.height, 0, 0, o.width, o.height), s.globalCompositeOperation = "destination-atop", s.drawImage(t.baseTexture.source, o.x, o.y, o.width, o.height, 0, 0, o.width, o.height)
    }, e.CanvasTinter.tintWithPerPixel = function(t, i, s) {
        var o = s.getContext("2d"),
            n = t.crop;
        s.width = n.width, s.height = n.height, o.globalCompositeOperation = "copy", o.drawImage(t.baseTexture.source, n.x, n.y, n.width, n.height, 0, 0, n.width, n.height);
        for (var a = e.hex2rgb(i), r = a[0], h = a[1], l = a[2], c = o.getImageData(0, 0, n.width, n.height), p = c.data, u = 0; u < p.length; u += 4)
            if (p[u + 0] *= r, p[u + 1] *= h, p[u + 2] *= l, !e.CanvasTinter.canHandleAlpha) {
                var d = p[u + 3];
                p[u + 0] /= 255 / d, p[u + 1] /= 255 / d, p[u + 2] /= 255 / d
            }
        o.putImageData(c, 0, 0)
    }, e.CanvasTinter.checkInverseAlpha = function() {
        var t = new e.CanvasBuffer(2, 1);
        t.context.fillStyle = "rgba(10, 20, 30, 0.5)", t.context.fillRect(0, 0, 1, 1);
        var i = t.context.getImageData(0, 0, 1, 1);
        if (null === i) return !1;
        t.context.putImageData(i, 1, 0);
        var s = t.context.getImageData(1, 0, 1, 1);
        return s.data[0] === i.data[0] && s.data[1] === i.data[1] && s.data[2] === i.data[2] && s.data[3] === i.data[3]
    }, e.CanvasTinter.canHandleAlpha = e.CanvasTinter.checkInverseAlpha(), e.CanvasTinter.canUseMultiply = e.canUseNewCanvasBlendModes(), e.CanvasTinter.tintMethod = e.CanvasTinter.canUseMultiply ? e.CanvasTinter.tintWithMultiply : e.CanvasTinter.tintWithPerPixel, e.CanvasRenderer = function(t) {
        this.game = t, e.defaultRenderer || (e.defaultRenderer = this), this.type = e.CANVAS_RENDERER, this.resolution = t.resolution, this.clearBeforeRender = t.clearBeforeRender, this.transparent = t.transparent, this.autoResize = !1, this.width = t.width * this.resolution, this.height = t.height * this.resolution, this.view = t.canvas, this.context = this.view.getContext("2d", {
            alpha: this.transparent
        }), this.refresh = !0, this.count = 0, this.maskManager = new e.CanvasMaskManager, this.renderSession = {
            context: this.context,
            maskManager: this.maskManager,
            scaleMode: null,
            smoothProperty: Phaser.Canvas.getSmoothingPrefix(this.context),
            roundPixels: !1
        }, this.mapBlendModes(), this.resize(this.width, this.height)
    }, e.CanvasRenderer.prototype.constructor = e.CanvasRenderer, e.CanvasRenderer.prototype.render = function(t) {
        this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.globalAlpha = 1, this.renderSession.currentBlendMode = 0, this.renderSession.shakeX = this.game.camera._shake.x, this.renderSession.shakeY = this.game.camera._shake.y, this.context.globalCompositeOperation = "source-over", navigator.isCocoonJS && this.view.screencanvas && (this.context.fillStyle = "black", this.context.clear()), this.clearBeforeRender && (this.transparent ? this.context.clearRect(0, 0, this.width, this.height) : t._bgColor && (this.context.fillStyle = t._bgColor.rgba, this.context.fillRect(0, 0, this.width, this.height))), this.renderDisplayObject(t)
    }, e.CanvasRenderer.prototype.destroy = function(t) {
        void 0 === t && (t = !0), t && this.view.parent && this.view.parent.removeChild(this.view), this.view = null, this.context = null, this.maskManager = null, this.renderSession = null
    }, e.CanvasRenderer.prototype.resize = function(t, i) {
        this.width = t * this.resolution, this.height = i * this.resolution, this.view.width = this.width, this.view.height = this.height, this.autoResize && (this.view.style.width = this.width / this.resolution + "px", this.view.style.height = this.height / this.resolution + "px"), this.renderSession.smoothProperty && (this.context[this.renderSession.smoothProperty] = this.renderSession.scaleMode === e.scaleModes.LINEAR)
    }, e.CanvasRenderer.prototype.renderDisplayObject = function(t, e, i) {
        this.renderSession.context = e || this.context, this.renderSession.resolution = this.resolution, t._renderCanvas(this.renderSession, i)
    }, e.CanvasRenderer.prototype.mapBlendModes = function() {
        if (!e.blendModesCanvas) {
            var t = [],
                i = e.blendModes,
                s = e.canUseNewCanvasBlendModes();
            t[i.NORMAL] = "source-over", t[i.ADD] = "lighter", t[i.MULTIPLY] = s ? "multiply" : "source-over", t[i.SCREEN] = s ? "screen" : "source-over", t[i.OVERLAY] = s ? "overlay" : "source-over", t[i.DARKEN] = s ? "darken" : "source-over", t[i.LIGHTEN] = s ? "lighten" : "source-over", t[i.COLOR_DODGE] = s ? "color-dodge" : "source-over", t[i.COLOR_BURN] = s ? "color-burn" : "source-over", t[i.HARD_LIGHT] = s ? "hard-light" : "source-over", t[i.SOFT_LIGHT] = s ? "soft-light" : "source-over", t[i.DIFFERENCE] = s ? "difference" : "source-over", t[i.EXCLUSION] = s ? "exclusion" : "source-over", t[i.HUE] = s ? "hue" : "source-over", t[i.SATURATION] = s ? "saturation" : "source-over", t[i.COLOR] = s ? "color" : "source-over", t[i.LUMINOSITY] = s ? "luminosity" : "source-over", e.blendModesCanvas = t
        }
    }, e.BaseTexture = function(t, i) {
        this.resolution = 1, this.width = 100, this.height = 100, this.scaleMode = i || e.scaleModes.DEFAULT, this.hasLoaded = !1, this.source = t, this.premultipliedAlpha = !0, this._glTextures = [], this.mipmap = !1, this._dirty = [!0, !0, !0, !0], t && ((this.source.complete || this.source.getContext) && this.source.width && this.source.height && (this.hasLoaded = !0, this.width = this.source.naturalWidth || this.source.width, this.height = this.source.naturalHeight || this.source.height, this.dirty()), this.skipRender = !1, this._powerOf2 = !1)
    }, e.BaseTexture.prototype.constructor = e.BaseTexture, e.BaseTexture.prototype.forceLoaded = function(t, e) {
        this.hasLoaded = !0, this.width = t, this.height = e, this.dirty()
    }, e.BaseTexture.prototype.destroy = function() {
        this.source && e.CanvasPool.removeByCanvas(this.source), this.source = null, this.unloadFromGPU()
    }, e.BaseTexture.prototype.updateSourceImage = function(t) {
        console.warn("PIXI.BaseTexture.updateSourceImage is deprecated. Use Phaser.Sprite.loadTexture instead.")
    }, e.BaseTexture.prototype.dirty = function() {
        for (var t = 0; t < this._glTextures.length; t++) this._dirty[t] = !0
    }, e.BaseTexture.prototype.unloadFromGPU = function() {
        this.dirty();
        for (var t = this._glTextures.length - 1; t >= 0; t--) {
            var i = this._glTextures[t],
                s = e.glContexts[t];
            s && i && s.deleteTexture(i)
        }
        this._glTextures.length = 0, this.dirty()
    }, e.BaseTexture.fromCanvas = function(t, i) {
        return 0 === t.width && (t.width = 1), 0 === t.height && (t.height = 1), new e.BaseTexture(t, i)
    }, e.TextureSilentFail = !1, e.Texture = function(t, i, s, o) {
        this.noFrame = !1, i || (this.noFrame = !0, i = new e.Rectangle(0, 0, 1, 1)), t instanceof e.Texture && (t = t.baseTexture), this.baseTexture = t, this.frame = i, this.trim = o, this.valid = !1, this.isTiling = !1, this.requiresUpdate = !1, this.requiresReTint = !1, this._uvs = null, this.width = 0, this.height = 0, this.crop = s || new e.Rectangle(0, 0, 1, 1), t.hasLoaded && (this.noFrame && (i = new e.Rectangle(0, 0, t.width, t.height)), this.setFrame(i))
    }, e.Texture.prototype.constructor = e.Texture, e.Texture.prototype.onBaseTextureLoaded = function() {
        var t = this.baseTexture;
        this.noFrame && (this.frame = new e.Rectangle(0, 0, t.width, t.height)), this.setFrame(this.frame)
    }, e.Texture.prototype.destroy = function(t) {
        t && this.baseTexture.destroy(), this.valid = !1
    }, e.Texture.prototype.setFrame = function(t) {
        if (this.noFrame = !1, this.frame = t, this.width = t.width, this.height = t.height, this.crop.x = t.x, this.crop.y = t.y, this.crop.width = t.width, this.crop.height = t.height, this.trim || !(t.x + t.width > this.baseTexture.width || t.y + t.height > this.baseTexture.height)) this.valid = t && t.width && t.height && this.baseTexture.source && this.baseTexture.hasLoaded, this.trim && (this.width = this.trim.width, this.height = this.trim.height, this.frame.width = this.trim.width, this.frame.height = this.trim.height), this.valid && this._updateUvs();
        else {
            if (!e.TextureSilentFail) throw new Error("Texture Error: frame does not fit inside the base Texture dimensions " + this);
            this.valid = !1
        }
    }, e.Texture.prototype._updateUvs = function() {
        this._uvs || (this._uvs = new e.TextureUvs);
        var t = this.crop,
            i = this.baseTexture.width,
            s = this.baseTexture.height;
        this._uvs.x0 = t.x / i, this._uvs.y0 = t.y / s, this._uvs.x1 = (t.x + t.width) / i, this._uvs.y1 = t.y / s, this._uvs.x2 = (t.x + t.width) / i, this._uvs.y2 = (t.y + t.height) / s, this._uvs.x3 = t.x / i, this._uvs.y3 = (t.y + t.height) / s
    }, e.Texture.fromCanvas = function(t, i) {
        var s = e.BaseTexture.fromCanvas(t, i);
        return new e.Texture(s)
    }, e.TextureUvs = function() {
        this.x0 = 0, this.y0 = 0, this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.x3 = 0, this.y3 = 0
    }, e.RenderTexture = function(t, i, s, o, n) {
        if (this.width = t || 100, this.height = i || 100, this.resolution = n || 1, this.frame = new e.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution), this.crop = new e.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution), this.baseTexture = new e.BaseTexture, this.baseTexture.width = this.width * this.resolution, this.baseTexture.height = this.height * this.resolution, this.baseTexture._glTextures = [], this.baseTexture.resolution = this.resolution, this.baseTexture.scaleMode = o || e.scaleModes.DEFAULT, this.baseTexture.hasLoaded = !0, e.Texture.call(this, this.baseTexture, new e.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution)), this.renderer = s || e.defaultRenderer, this.renderer.type === e.WEBGL_RENDERER) {
            var a = this.renderer.gl;
            this.baseTexture._dirty[a.id] = !1, this.textureBuffer = new e.FilterTexture(a, this.width, this.height, this.baseTexture.scaleMode), this.baseTexture._glTextures[a.id] = this.textureBuffer.texture, this.render = this.renderWebGL, this.projection = new e.Point(.5 * this.width, .5 * -this.height)
        } else this.render = this.renderCanvas, this.textureBuffer = new e.CanvasBuffer(this.width * this.resolution, this.height * this.resolution), this.baseTexture.source = this.textureBuffer.canvas;
        this.valid = !0, this.tempMatrix = new Phaser.Matrix, this._updateUvs()
    }, e.RenderTexture.prototype = Object.create(e.Texture.prototype), e.RenderTexture.prototype.constructor = e.RenderTexture, e.RenderTexture.prototype.resize = function(t, i, s) {
        t === this.width && i === this.height || (this.valid = t > 0 && i > 0, this.width = t, this.height = i, this.frame.width = this.crop.width = t * this.resolution, this.frame.height = this.crop.height = i * this.resolution, s && (this.baseTexture.width = this.width * this.resolution, this.baseTexture.height = this.height * this.resolution), this.renderer.type === e.WEBGL_RENDERER && (this.projection.x = this.width / 2, this.projection.y = -this.height / 2), this.valid && this.textureBuffer.resize(this.width, this.height))
    }, e.RenderTexture.prototype.clear = function() {
        this.valid && (this.renderer.type === e.WEBGL_RENDERER && this.renderer.gl.bindFramebuffer(this.renderer.gl.FRAMEBUFFER, this.textureBuffer.frameBuffer), this.textureBuffer.clear())
    }, e.RenderTexture.prototype.renderWebGL = function(t, e, i) {
        if (this.valid && 0 !== t.alpha) {
            var s = t.worldTransform;
            s.identity(), s.translate(0, 2 * this.projection.y), e && s.append(e), s.scale(1, -1);
            for (var o = 0; o < t.children.length; o++) t.children[o].updateTransform();
            var n = this.renderer.gl;
            n.viewport(0, 0, this.width * this.resolution, this.height * this.resolution), n.bindFramebuffer(n.FRAMEBUFFER, this.textureBuffer.frameBuffer), i && this.textureBuffer.clear(), this.renderer.spriteBatch.dirty = !0, this.renderer.renderDisplayObject(t, this.projection, this.textureBuffer.frameBuffer, e), this.renderer.spriteBatch.dirty = !0
        }
    }, e.RenderTexture.prototype.renderCanvas = function(t, e, i) {
        if (this.valid && 0 !== t.alpha) {
            var s = t.worldTransform;
            s.identity(), e && s.append(e);
            for (var o = 0; o < t.children.length; o++) t.children[o].updateTransform();
            i && this.textureBuffer.clear();
            var n = this.renderer.resolution;
            this.renderer.resolution = this.resolution, this.renderer.renderDisplayObject(t, this.textureBuffer.context, e), this.renderer.resolution = n
        }
    }, e.RenderTexture.prototype.getImage = function() {
        var t = new Image;
        return t.src = this.getBase64(), t
    }, e.RenderTexture.prototype.getBase64 = function() {
        return this.getCanvas().toDataURL()
    }, e.RenderTexture.prototype.getCanvas = function() {
        if (this.renderer.type === e.WEBGL_RENDERER) {
            var t = this.renderer.gl,
                i = this.textureBuffer.width,
                s = this.textureBuffer.height,
                o = new Uint8Array(4 * i * s);
            t.bindFramebuffer(t.FRAMEBUFFER, this.textureBuffer.frameBuffer), t.readPixels(0, 0, i, s, t.RGBA, t.UNSIGNED_BYTE, o), t.bindFramebuffer(t.FRAMEBUFFER, null);
            var n = new e.CanvasBuffer(i, s),
                a = n.context.getImageData(0, 0, i, s);
            return a.data.set(o), n.context.putImageData(a, 0, 0), n.canvas
        }
        return this.textureBuffer.canvas
    }, e.AbstractFilter = function(t, e) {
        this.passes = [this], this.shaders = [], this.dirty = !0, this.padding = 0, this.uniforms = e || {}, this.fragmentSrc = t || []
    }, e.AbstractFilter.prototype.constructor = e.AbstractFilter, e.AbstractFilter.prototype.syncUniforms = function() {
        for (var t = 0, e = this.shaders.length; t < e; t++) this.shaders[t].dirty = !0
    }, e.Strip = function(t) {
        e.DisplayObjectContainer.call(this), this.texture = t, this.uvs = new e.Float32Array([0, 1, 1, 1, 1, 0, 0, 1]), this.vertices = new e.Float32Array([0, 0, 100, 0, 100, 100, 0, 100]), this.colors = new e.Float32Array([1, 1, 1, 1]), this.indices = new e.Uint16Array([0, 1, 2, 3]), this.dirty = !0, this.blendMode = e.blendModes.NORMAL, this.canvasPadding = 0, this.drawMode = e.Strip.DrawModes.TRIANGLE_STRIP
    }, e.Strip.prototype = Object.create(e.DisplayObjectContainer.prototype), e.Strip.prototype.constructor = e.Strip, e.Strip.prototype._renderWebGL = function(t) {
        !this.visible || this.alpha <= 0 || (t.spriteBatch.stop(), this._vertexBuffer || this._initWebGL(t), t.shaderManager.setShader(t.shaderManager.stripShader), this._renderStrip(t), t.spriteBatch.start())
    }, e.Strip.prototype._initWebGL = function(t) {
        var e = t.gl;
        this._vertexBuffer = e.createBuffer(), this._indexBuffer = e.createBuffer(), this._uvBuffer = e.createBuffer(), this._colorBuffer = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this._vertexBuffer), e.bufferData(e.ARRAY_BUFFER, this.vertices, e.DYNAMIC_DRAW), e.bindBuffer(e.ARRAY_BUFFER, this._uvBuffer), e.bufferData(e.ARRAY_BUFFER, this.uvs, e.STATIC_DRAW), e.bindBuffer(e.ARRAY_BUFFER, this._colorBuffer), e.bufferData(e.ARRAY_BUFFER, this.colors, e.STATIC_DRAW), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this._indexBuffer), e.bufferData(e.ELEMENT_ARRAY_BUFFER, this.indices, e.STATIC_DRAW)
    }, e.Strip.prototype._renderStrip = function(t) {
        var i = t.gl,
            s = t.projection,
            o = t.offset,
            n = t.shaderManager.stripShader,
            a = this.drawMode === e.Strip.DrawModes.TRIANGLE_STRIP ? i.TRIANGLE_STRIP : i.TRIANGLES;
        t.blendModeManager.setBlendMode(this.blendMode), i.uniformMatrix3fv(n.translationMatrix, !1, this.worldTransform.toArray(!0)), i.uniform2f(n.projectionVector, s.x, -s.y), i.uniform2f(n.offsetVector, -o.x, -o.y), i.uniform1f(n.alpha, this.worldAlpha), this.dirty ? (this.dirty = !1, i.bindBuffer(i.ARRAY_BUFFER, this._vertexBuffer), i.bufferData(i.ARRAY_BUFFER, this.vertices, i.STATIC_DRAW), i.vertexAttribPointer(n.aVertexPosition, 2, i.FLOAT, !1, 0, 0), i.bindBuffer(i.ARRAY_BUFFER, this._uvBuffer), i.bufferData(i.ARRAY_BUFFER, this.uvs, i.STATIC_DRAW), i.vertexAttribPointer(n.aTextureCoord, 2, i.FLOAT, !1, 0, 0), i.activeTexture(i.TEXTURE0), this.texture.baseTexture._dirty[i.id] ? t.renderer.updateTexture(this.texture.baseTexture) : i.bindTexture(i.TEXTURE_2D, this.texture.baseTexture._glTextures[i.id]), i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, this._indexBuffer), i.bufferData(i.ELEMENT_ARRAY_BUFFER, this.indices, i.STATIC_DRAW)) : (i.bindBuffer(i.ARRAY_BUFFER, this._vertexBuffer), i.bufferSubData(i.ARRAY_BUFFER, 0, this.vertices), i.vertexAttribPointer(n.aVertexPosition, 2, i.FLOAT, !1, 0, 0), i.bindBuffer(i.ARRAY_BUFFER, this._uvBuffer), i.vertexAttribPointer(n.aTextureCoord, 2, i.FLOAT, !1, 0, 0), i.activeTexture(i.TEXTURE0), this.texture.baseTexture._dirty[i.id] ? t.renderer.updateTexture(this.texture.baseTexture) : i.bindTexture(i.TEXTURE_2D, this.texture.baseTexture._glTextures[i.id]), i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, this._indexBuffer)), i.drawElements(a, this.indices.length, i.UNSIGNED_SHORT, 0)
    }, e.Strip.prototype._renderCanvas = function(t) {
        var i = t.context,
            s = this.worldTransform,
            o = s.tx * t.resolution + t.shakeX,
            n = s.ty * t.resolution + t.shakeY;
        t.roundPixels ? i.setTransform(s.a, s.b, s.c, s.d, 0 | o, 0 | n) : i.setTransform(s.a, s.b, s.c, s.d, o, n), this.drawMode === e.Strip.DrawModes.TRIANGLE_STRIP ? this._renderCanvasTriangleStrip(i) : this._renderCanvasTriangles(i)
    }, e.Strip.prototype._renderCanvasTriangleStrip = function(t) {
        var e = this.vertices,
            i = this.uvs,
            s = e.length / 2;
        this.count++;
        for (var o = 0; o < s - 2; o++) {
            var n = 2 * o;
            this._renderCanvasDrawTriangle(t, e, i, n, n + 2, n + 4)
        }
    }, e.Strip.prototype._renderCanvasTriangles = function(t) {
        var e = this.vertices,
            i = this.uvs,
            s = this.indices,
            o = s.length;
        this.count++;
        for (var n = 0; n < o; n += 3) {
            var a = 2 * s[n],
                r = 2 * s[n + 1],
                h = 2 * s[n + 2];
            this._renderCanvasDrawTriangle(t, e, i, a, r, h)
        }
    }, e.Strip.prototype._renderCanvasDrawTriangle = function(t, e, i, s, o, n) {
        var a = this.texture.baseTexture.source,
            r = this.texture.width,
            h = this.texture.height,
            l = e[s],
            c = e[o],
            p = e[n],
            u = e[s + 1],
            d = e[o + 1],
            m = e[n + 1],
            y = i[s] * r,
            f = i[o] * r,
            g = i[n] * r,
            _ = i[s + 1] * h,
            v = i[o + 1] * h,
            b = i[n + 1] * h;
        if (this.canvasPadding > 0) {
            var x = this.canvasPadding / this.worldTransform.a,
                C = this.canvasPadding / this.worldTransform.d,
                S = (l + c + p) / 3,
                w = (u + d + m) / 3,
                A = l - S,
                T = u - w,
                B = Math.sqrt(A * A + T * T);
            l = S + A / B * (B + x), u = w + T / B * (B + C), T = d - w, c = S + (A = c - S) / (B = Math.sqrt(A * A + T * T)) * (B + x), d = w + T / B * (B + C), T = m - w, p = S + (A = p - S) / (B = Math.sqrt(A * A + T * T)) * (B + x), m = w + T / B * (B + C)
        }
        t.save(), t.beginPath(), t.moveTo(l, u), t.lineTo(c, d), t.lineTo(p, m), t.closePath(), t.clip();
        var P = y * v + _ * g + f * b - v * g - _ * f - y * b,
            D = l * v + _ * p + c * b - v * p - _ * c - l * b,
            I = y * c + l * g + f * p - c * g - l * f - y * p,
            E = y * v * p + _ * c * g + l * f * b - l * v * g - _ * f * p - y * c * b,
            L = u * v + _ * m + d * b - v * m - _ * d - u * b,
            M = y * d + u * g + f * m - d * g - u * f - y * m,
            G = y * v * m + _ * d * g + u * f * b - u * v * g - _ * f * m - y * d * b;
        t.transform(D / P, L / P, I / P, M / P, E / P, G / P), t.drawImage(a, 0, 0), t.restore()
    }, e.Strip.prototype.renderStripFlat = function(t) {
        var e = this.context,
            i = t.vertices,
            s = i.length / 2;
        this.count++, e.beginPath();
        for (var o = 1; o < s - 2; o++) {
            var n = 2 * o,
                a = i[n],
                r = i[n + 2],
                h = i[n + 4],
                l = i[n + 1],
                c = i[n + 3],
                p = i[n + 5];
            e.moveTo(a, l), e.lineTo(r, c), e.lineTo(h, p)
        }
        e.fillStyle = "#FF0000", e.fill(), e.closePath()
    }, e.Strip.prototype.onTextureUpdate = function() {
        this.updateFrame = !0
    }, e.Strip.prototype.getBounds = function(t) {
        for (var i = t || this.worldTransform, s = i.a, o = i.b, n = i.c, a = i.d, r = i.tx, h = i.ty, l = -1 / 0, c = -1 / 0, p = 1 / 0, u = 1 / 0, d = this.vertices, m = 0, y = d.length; m < y; m += 2) {
            var f = d[m],
                g = d[m + 1],
                _ = s * f + n * g + r,
                v = a * g + o * f + h;
            p = _ < p ? _ : p, u = v < u ? v : u, l = _ > l ? _ : l, c = v > c ? v : c
        }
        if (p === -1 / 0 || c === 1 / 0) return e.EmptyRectangle;
        var b = this._bounds;
        return b.x = p, b.width = l - p, b.y = u, b.height = c - u, this._currentBounds = b, b
    }, e.Strip.DrawModes = {
        TRIANGLE_STRIP: 0,
        TRIANGLES: 1
    }, e.Rope = function(t, i) {
        e.Strip.call(this, t), this.points = i, this.vertices = new e.Float32Array(4 * i.length), this.uvs = new e.Float32Array(4 * i.length), this.colors = new e.Float32Array(2 * i.length), this.indices = new e.Uint16Array(2 * i.length), this.refresh()
    }, e.Rope.prototype = Object.create(e.Strip.prototype), e.Rope.prototype.constructor = e.Rope, e.Rope.prototype.refresh = function() {
        var t = this.points;
        if (!(t.length < 1)) {
            var e = this.uvs,
                i = (t[0], this.indices),
                s = this.colors;
            this.count -= .2, e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, s[0] = 1, s[1] = 1, i[0] = 0, i[1] = 1;
            for (var o, n, a, r = t.length, h = 1; h < r; h++) o = t[h], n = 4 * h, a = h / (r - 1), e[n] = a, e[n + 1] = 0, e[n + 2] = a, e[n + 3] = 1, n = 2 * h, s[n] = 1, s[n + 1] = 1, n = 2 * h, i[n] = n, i[n + 1] = n + 1, o
        }
    }, e.Rope.prototype.updateTransform = function() {
        var t = this.points;
        if (!(t.length < 1)) {
            var i, s = t[0],
                o = {
                    x: 0,
                    y: 0
                };
            this.count -= .2;
            for (var n, a, r, h, l = this.vertices, c = t.length, p = 0; p < c; p++) n = t[p], a = 4 * p, i = p < t.length - 1 ? t[p + 1] : n, o.y = -(i.x - s.x), o.x = i.y - s.y, 10 * (1 - p / (c - 1)) > 1 && 1, r = Math.sqrt(o.x * o.x + o.y * o.y), h = this.texture.height / 2, o.x /= r, o.y /= r, o.x *= h, o.y *= h, l[a] = n.x + o.x, l[a + 1] = n.y + o.y, l[a + 2] = n.x - o.x, l[a + 3] = n.y - o.y, s = n;
            e.DisplayObjectContainer.prototype.updateTransform.call(this)
        }
    }, e.Rope.prototype.setTexture = function(t) {
        this.texture = t
    }, e.TilingSprite = function(t, i, s) {
        e.Sprite.call(this, t), this._width = i || 128, this._height = s || 128, this.tileScale = new e.Point(1, 1), this.tileScaleOffset = new e.Point(1, 1), this.tilePosition = new e.Point, this.renderable = !0, this.tint = 16777215, this.textureDebug = !1, this.blendMode = e.blendModes.NORMAL, this.canvasBuffer = null, this.tilingTexture = null, this.tilePattern = null, this.refreshTexture = !0, this.frameWidth = 0, this.frameHeight = 0
    }, e.TilingSprite.prototype = Object.create(e.Sprite.prototype), e.TilingSprite.prototype.constructor = e.TilingSprite, e.TilingSprite.prototype.setTexture = function(t) {
        this.texture !== t && (this.texture = t, this.refreshTexture = !0, this.cachedTint = 16777215)
    }, e.TilingSprite.prototype._renderWebGL = function(t) {
        if (this.visible && this.renderable && 0 !== this.alpha) {
            if (this._mask && (t.spriteBatch.stop(), t.maskManager.pushMask(this.mask, t), t.spriteBatch.start()), this._filters && (t.spriteBatch.flush(), t.filterManager.pushFilter(this._filterBlock)), this.refreshTexture) {
                if (this.generateTilingTexture(!0, t), !this.tilingTexture) return;
                this.tilingTexture.needsUpdate && (t.renderer.updateTexture(this.tilingTexture.baseTexture), this.tilingTexture.needsUpdate = !1)
            }
            t.spriteBatch.renderTilingSprite(this);
            for (var e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(t);
            t.spriteBatch.stop(), this._filters && t.filterManager.popFilter(), this._mask && t.maskManager.popMask(this._mask, t), t.spriteBatch.start()
        }
    }, e.TilingSprite.prototype._renderCanvas = function(t) {
        if (this.visible && this.renderable && 0 !== this.alpha) {
            var i = t.context;
            this._mask && t.maskManager.pushMask(this._mask, t), i.globalAlpha = this.worldAlpha;
            var s = this.worldTransform,
                o = t.resolution,
                n = s.tx * o + t.shakeX,
                a = s.ty * o + t.shakeY;
            if (i.setTransform(s.a * o, s.b * o, s.c * o, s.d * o, n, a), this.refreshTexture) {
                if (this.generateTilingTexture(!1, t), !this.tilingTexture) return;
                this.tilePattern = i.createPattern(this.tilingTexture.baseTexture.source, "repeat")
            }
            var r = t.currentBlendMode;
            this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode, i.globalCompositeOperation = e.blendModesCanvas[t.currentBlendMode]);
            var h = this.tilePosition,
                l = this.tileScale;
            h.x %= this.tilingTexture.baseTexture.width, h.y %= this.tilingTexture.baseTexture.height, i.scale(l.x, l.y), i.translate(h.x + this.anchor.x * -this._width, h.y + this.anchor.y * -this._height), i.fillStyle = this.tilePattern;
            var n = -h.x,
                a = -h.y,
                c = this._width / l.x,
                p = this._height / l.y;
            t.roundPixels && (n |= 0, a |= 0, c |= 0, p |= 0), i.fillRect(n, a, c, p), i.scale(1 / l.x, 1 / l.y), i.translate(-h.x + this.anchor.x * this._width, -h.y + this.anchor.y * this._height), this._mask && t.maskManager.popMask(t);
            for (var u = 0; u < this.children.length; u++) this.children[u]._renderCanvas(t);
            r !== this.blendMode && (t.currentBlendMode = r, i.globalCompositeOperation = e.blendModesCanvas[r])
        }
    }, e.TilingSprite.prototype.onTextureUpdate = function() {}, e.TilingSprite.prototype.generateTilingTexture = function(t, i) {
        if (this.texture.baseTexture.hasLoaded) {
            var s = this.texture,
                o = s.frame,
                n = this._frame.sourceSizeW || this._frame.width,
                a = this._frame.sourceSizeH || this._frame.height,
                r = 0,
                h = 0;
            this._frame.trimmed && (r = this._frame.spriteSourceSizeX, h = this._frame.spriteSourceSizeY), t && (n = e.getNextPowerOfTwo(n), a = e.getNextPowerOfTwo(a)), this.canvasBuffer ? (this.canvasBuffer.resize(n, a), this.tilingTexture.baseTexture.width = n, this.tilingTexture.baseTexture.height = a, this.tilingTexture.needsUpdate = !0) : (this.canvasBuffer = new e.CanvasBuffer(n, a), this.tilingTexture = e.Texture.fromCanvas(this.canvasBuffer.canvas), this.tilingTexture.isTiling = !0, this.tilingTexture.needsUpdate = !0), this.textureDebug && (this.canvasBuffer.context.strokeStyle = "#00ff00", this.canvasBuffer.context.strokeRect(0, 0, n, a));
            var l = s.crop.width,
                c = s.crop.height;
            l === n && c === a || (l = n, c = a), this.canvasBuffer.context.drawImage(s.baseTexture.source, s.crop.x, s.crop.y, s.crop.width, s.crop.height, r, h, l, c), this.tileScaleOffset.x = o.width / n, this.tileScaleOffset.y = o.height / a, this.refreshTexture = !1, this.tilingTexture.baseTexture._powerOf2 = !0
        }
    }, e.TilingSprite.prototype.getBounds = function() {
        var t = this._width,
            e = this._height,
            i = t * (1 - this.anchor.x),
            s = t * -this.anchor.x,
            o = e * (1 - this.anchor.y),
            n = e * -this.anchor.y,
            a = this.worldTransform,
            r = a.a,
            h = a.b,
            l = a.c,
            c = a.d,
            p = a.tx,
            u = a.ty,
            d = r * s + l * n + p,
            m = c * n + h * s + u,
            y = r * i + l * n + p,
            f = c * n + h * i + u,
            g = r * i + l * o + p,
            _ = c * o + h * i + u,
            v = r * s + l * o + p,
            b = c * o + h * s + u,
            x = -1 / 0,
            C = -1 / 0,
            S = 1 / 0,
            w = 1 / 0;
        S = v < (S = g < (S = y < (S = d < S ? d : S) ? y : S) ? g : S) ? v : S, w = b < (w = _ < (w = f < (w = m < w ? m : w) ? f : w) ? _ : w) ? b : w, x = v > (x = g > (x = y > (x = d > x ? d : x) ? y : x) ? g : x) ? v : x, C = b > (C = _ > (C = f > (C = m > C ? m : C) ? f : C) ? _ : C) ? b : C;
        var A = this._bounds;
        return A.x = S, A.width = x - S, A.y = w, A.height = C - w, this._currentBounds = A, A
    }, e.TilingSprite.prototype.destroy = function() {
        e.Sprite.prototype.destroy.call(this), this.canvasBuffer && (this.canvasBuffer.destroy(), this.canvasBuffer = null), this.tileScale = null, this.tileScaleOffset = null, this.tilePosition = null, this.tilingTexture && (this.tilingTexture.destroy(!0), this.tilingTexture = null)
    }, Object.defineProperty(e.TilingSprite.prototype, "width", {
        get: function() {
            return this._width
        },
        set: function(t) {
            this._width = t
        }
    }), Object.defineProperty(e.TilingSprite.prototype, "height", {
        get: function() {
            return this._height
        },
        set: function(t) {
            this._height = t
        }
    }), "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = e), exports.PIXI = e) : "undefined" != typeof define && define.amd ? define("PIXI", t.PIXI = e) : t.PIXI = e, e
}.call(this),
    function() {
        function t(t, e) {
            this._scaleFactor = t, this._deltaMode = e, this.originalEvent = null
        }
        var e = this,
            i = i || {
                VERSION: "2.6.2",
                GAMES: [],
                AUTO: 0,
                CANVAS: 1,
                WEBGL: 2,
                HEADLESS: 3,
                NONE: 0,
                LEFT: 1,
                RIGHT: 2,
                UP: 3,
                DOWN: 4,
                SPRITE: 0,
                BUTTON: 1,
                IMAGE: 2,
                GRAPHICS: 3,
                TEXT: 4,
                TILESPRITE: 5,
                BITMAPTEXT: 6,
                GROUP: 7,
                RENDERTEXTURE: 8,
                TILEMAP: 9,
                TILEMAPLAYER: 10,
                EMITTER: 11,
                POLYGON: 12,
                BITMAPDATA: 13,
                CANVAS_FILTER: 14,
                WEBGL_FILTER: 15,
                ELLIPSE: 16,
                SPRITEBATCH: 17,
                RETROFONT: 18,
                POINTER: 19,
                ROPE: 20,
                CIRCLE: 21,
                RECTANGLE: 22,
                LINE: 23,
                MATRIX: 24,
                POINT: 25,
                ROUNDEDRECTANGLE: 26,
                CREATURE: 27,
                VIDEO: 28,
                PENDING_ATLAS: -1,
                HORIZONTAL: 0,
                VERTICAL: 1,
                LANDSCAPE: 0,
                PORTRAIT: 1,
                ANGLE_UP: 270,
                ANGLE_DOWN: 90,
                ANGLE_LEFT: 180,
                ANGLE_RIGHT: 0,
                ANGLE_NORTH_EAST: 315,
                ANGLE_NORTH_WEST: 225,
                ANGLE_SOUTH_EAST: 45,
                ANGLE_SOUTH_WEST: 135,
                TOP_LEFT: 0,
                TOP_CENTER: 1,
                TOP_RIGHT: 2,
                LEFT_TOP: 3,
                LEFT_CENTER: 4,
                LEFT_BOTTOM: 5,
                CENTER: 6,
                RIGHT_TOP: 7,
                RIGHT_CENTER: 8,
                RIGHT_BOTTOM: 9,
                BOTTOM_LEFT: 10,
                BOTTOM_CENTER: 11,
                BOTTOM_RIGHT: 12,
                blendModes: {
                    NORMAL: 0,
                    ADD: 1,
                    MULTIPLY: 2,
                    SCREEN: 3,
                    OVERLAY: 4,
                    DARKEN: 5,
                    LIGHTEN: 6,
                    COLOR_DODGE: 7,
                    COLOR_BURN: 8,
                    HARD_LIGHT: 9,
                    SOFT_LIGHT: 10,
                    DIFFERENCE: 11,
                    EXCLUSION: 12,
                    HUE: 13,
                    SATURATION: 14,
                    COLOR: 15,
                    LUMINOSITY: 16
                },
                scaleModes: {
                    DEFAULT: 0,
                    LINEAR: 0,
                    NEAREST: 1
                },
                PIXI: PIXI || {}
            };
        if (Math.trunc || (Math.trunc = function(t) {
                return t < 0 ? Math.ceil(t) : Math.floor(t)
            }), Function.prototype.bind || (Function.prototype.bind = function() {
                var t = Array.prototype.slice;
                return function(e) {
                    function i() {
                        var n = o.concat(t.call(arguments));
                        s.apply(this instanceof i ? this : e, n)
                    }
                    var s = this,
                        o = t.call(arguments, 1);
                    if ("function" != typeof s) throw new TypeError;
                    return i.prototype = function t(e) {
                        if (e && (t.prototype = e), !(this instanceof t)) return new t
                    }(s.prototype), i
                }
            }()), Array.isArray || (Array.isArray = function(t) {
                return "[object Array]" === Object.prototype.toString.call(t)
            }), Array.prototype.forEach || (Array.prototype.forEach = function(t) {
                if (void 0 === this || null === this) throw new TypeError;
                var e = Object(this),
                    i = e.length >>> 0;
                if ("function" != typeof t) throw new TypeError;
                for (var s = arguments.length >= 2 ? arguments[1] : void 0, o = 0; o < i; o++) o in e && t.call(s, e[o], o, e)
            }), "function" != typeof window.Uint32Array && "object" != typeof window.Uint32Array) {
            var s = function(t) {
                var e = new Array;
                window[t] = function(t) {
                    if ("number" == typeof t) {
                        Array.call(this, t), this.length = t;
                        for (e = 0; e < this.length; e++) this[e] = 0
                    } else {
                        Array.call(this, t.length), this.length = t.length;
                        for (var e = 0; e < this.length; e++) this[e] = t[e]
                    }
                }, window[t].prototype = e, window[t].constructor = window[t]
            };
            s("Uint32Array"), s("Int16Array")
        }
        window.console || (window.console = {}, window.console.log = window.console.assert = function() {}, window.console.warn = window.console.assert = function() {}), i.Utils = {
            reverseString: function(t) {
                return t.split("").reverse().join("")
            },
            getProperty: function(t, e) {
                for (var i = e.split("."), s = i.pop(), o = i.length, n = 1, a = i[0]; n < o && (t = t[a]);) a = i[n], n++;
                return t ? t[s] : null
            },
            setProperty: function(t, e, i) {
                for (var s = e.split("."), o = s.pop(), n = s.length, a = 1, r = s[0]; a < n && (t = t[r]);) r = s[a], a++;
                return t && (t[o] = i), t
            },
            chanceRoll: function(t) {
                return void 0 === t && (t = 50), t > 0 && 100 * Math.random() <= t
            },
            randomChoice: function(t, e) {
                return Math.random() < .5 ? t : e
            },
            parseDimension: function(t, e) {
                var i = 0,
                    s = 0;
                return "string" == typeof t ? "%" === t.substr(-1) ? (i = parseInt(t, 10) / 100, s = 0 === e ? window.innerWidth * i : window.innerHeight * i) : s = parseInt(t, 10) : s = t, s
            },
            pad: function(t, e, i, s) {
                if (void 0 === e) var e = 0;
                if (void 0 === i) var i = " ";
                if (void 0 === s) var s = 3;
                var o = 0;
                if (e + 1 >= (t = t.toString()).length) switch (s) {
                    case 1:
                        t = new Array(e + 1 - t.length).join(i) + t;
                        break;
                    case 3:
                        var n = Math.ceil((o = e - t.length) / 2),
                            a = o - n;
                        t = new Array(a + 1).join(i) + t + new Array(n + 1).join(i);
                        break;
                    default:
                        t += new Array(e + 1 - t.length).join(i)
                }
                return t
            },
            isPlainObject: function(t) {
                if ("object" != typeof t || t.nodeType || t === t.window) return !1;
                try {
                    if (t.constructor && !{}.hasOwnProperty.call(t.constructor.prototype, "isPrototypeOf")) return !1
                } catch (t) {
                    return !1
                }
                return !0
            },
            extend: function() {
                var t, e, s, o, n, a, r = arguments[0] || {},
                    h = 1,
                    l = arguments.length,
                    c = !1;
                for ("boolean" == typeof r && (c = r, r = arguments[1] || {}, h = 2), l === h && (r = this, --h); h < l; h++)
                    if (null != (t = arguments[h]))
                        for (e in t) s = r[e], o = t[e], r !== o && (c && o && (i.Utils.isPlainObject(o) || (n = Array.isArray(o))) ? (n ? (n = !1, a = s && Array.isArray(s) ? s : []) : a = s && i.Utils.isPlainObject(s) ? s : {}, r[e] = i.Utils.extend(c, a, o)) : void 0 !== o && (r[e] = o));
                return r
            },
            mixinPrototype: function(t, e, i) {
                void 0 === i && (i = !1);
                for (var s = Object.keys(e), o = 0; o < s.length; o++) {
                    var n = s[o],
                        a = e[n];
                    !i && n in t || (!a || "function" != typeof a.get && "function" != typeof a.set ? t[n] = a : "function" == typeof a.clone ? t[n] = a.clone() : Object.defineProperty(t, n, a))
                }
            },
            mixin: function(t, e) {
                if (!t || "object" != typeof t) return e;
                for (var s in t) {
                    var o = t[s];
                    if (!o.childNodes && !o.cloneNode) {
                        var n = typeof t[s];
                        t[s] && "object" === n ? typeof e[s] === n ? e[s] = i.Utils.mixin(t[s], e[s]) : e[s] = i.Utils.mixin(t[s], new o.constructor) : e[s] = t[s]
                    }
                }
                return e
            }
        }, i.Circle = function(t, e, s) {
            t = t || 0, e = e || 0, s = s || 0, this.x = t, this.y = e, this._diameter = s, this._radius = 0, s > 0 && (this._radius = .5 * s), this.type = i.CIRCLE
        }, i.Circle.prototype = {
            circumference: function() {
                return Math.PI * this._radius * 2
            },
            random: function(t) {
                void 0 === t && (t = new i.Point);
                var e = 2 * Math.PI * Math.random(),
                    s = Math.random() + Math.random(),
                    o = s > 1 ? 2 - s : s,
                    n = o * Math.cos(e),
                    a = o * Math.sin(e);
                return t.x = this.x + n * this.radius, t.y = this.y + a * this.radius, t
            },
            getBounds: function() {
                return new i.Rectangle(this.x - this.radius, this.y - this.radius, this.diameter, this.diameter)
            },
            setTo: function(t, e, i) {
                return this.x = t, this.y = e, this._diameter = i, this._radius = .5 * i, this
            },
            copyFrom: function(t) {
                return this.setTo(t.x, t.y, t.diameter)
            },
            copyTo: function(t) {
                return t.x = this.x, t.y = this.y, t.diameter = this._diameter, t
            },
            distance: function(t, e) {
                var s = i.Math.distance(this.x, this.y, t.x, t.y);
                return e ? Math.round(s) : s
            },
            clone: function(t) {
                return void 0 === t || null === t ? t = new i.Circle(this.x, this.y, this.diameter) : t.setTo(this.x, this.y, this.diameter), t
            },
            contains: function(t, e) {
                return i.Circle.contains(this, t, e)
            },
            circumferencePoint: function(t, e, s) {
                return i.Circle.circumferencePoint(this, t, e, s)
            },
            offset: function(t, e) {
                return this.x += t, this.y += e, this
            },
            offsetPoint: function(t) {
                return this.offset(t.x, t.y)
            },
            toString: function() {
                return "[{Phaser.Circle (x=" + this.x + " y=" + this.y + " diameter=" + this.diameter + " radius=" + this.radius + ")}]"
            }
        }, i.Circle.prototype.constructor = i.Circle, Object.defineProperty(i.Circle.prototype, "diameter", {
            get: function() {
                return this._diameter
            },
            set: function(t) {
                t > 0 && (this._diameter = t, this._radius = .5 * t)
            }
        }), Object.defineProperty(i.Circle.prototype, "radius", {
            get: function() {
                return this._radius
            },
            set: function(t) {
                t > 0 && (this._radius = t, this._diameter = 2 * t)
            }
        }), Object.defineProperty(i.Circle.prototype, "left", {
            get: function() {
                return this.x - this._radius
            },
            set: function(t) {
                t > this.x ? (this._radius = 0, this._diameter = 0) : this.radius = this.x - t
            }
        }), Object.defineProperty(i.Circle.prototype, "right", {
            get: function() {
                return this.x + this._radius
            },
            set: function(t) {
                t < this.x ? (this._radius = 0, this._diameter = 0) : this.radius = t - this.x
            }
        }), Object.defineProperty(i.Circle.prototype, "top", {
            get: function() {
                return this.y - this._radius
            },
            set: function(t) {
                t > this.y ? (this._radius = 0, this._diameter = 0) : this.radius = this.y - t
            }
        }), Object.defineProperty(i.Circle.prototype, "bottom", {
            get: function() {
                return this.y + this._radius
            },
            set: function(t) {
                t < this.y ? (this._radius = 0, this._diameter = 0) : this.radius = t - this.y
            }
        }), Object.defineProperty(i.Circle.prototype, "area", {
            get: function() {
                return this._radius > 0 ? Math.PI * this._radius * this._radius : 0
            }
        }), Object.defineProperty(i.Circle.prototype, "empty", {
            get: function() {
                return 0 === this._diameter
            },
            set: function(t) {
                !0 === t && this.setTo(0, 0, 0)
            }
        }), i.Circle.contains = function(t, e, i) {
            return t.radius > 0 && e >= t.left && e <= t.right && i >= t.top && i <= t.bottom && (t.x - e) * (t.x - e) + (t.y - i) * (t.y - i) <= t.radius * t.radius
        }, i.Circle.equals = function(t, e) {
            return t.x === e.x && t.y === e.y && t.diameter === e.diameter
        }, i.Circle.intersects = function(t, e) {
            return i.Math.distance(t.x, t.y, e.x, e.y) <= t.radius + e.radius
        }, i.Circle.circumferencePoint = function(t, e, s, o) {
            return void 0 === s && (s = !1), void 0 === o && (o = new i.Point), !0 === s && (e = i.Math.degToRad(e)), o.x = t.x + t.radius * Math.cos(e), o.y = t.y + t.radius * Math.sin(e), o
        }, i.Circle.intersectsRectangle = function(t, e) {
            var i = Math.abs(t.x - e.x - e.halfWidth);
            if (i > e.halfWidth + t.radius) return !1;
            var s = Math.abs(t.y - e.y - e.halfHeight);
            if (s > e.halfHeight + t.radius) return !1;
            if (i <= e.halfWidth || s <= e.halfHeight) return !0;
            var o = i - e.halfWidth,
                n = s - e.halfHeight;
            return o * o + n * n <= t.radius * t.radius
        }, PIXI.Circle = i.Circle, i.Ellipse = function(t, e, s, o) {
            t = t || 0, e = e || 0, s = s || 0, o = o || 0, this.x = t, this.y = e, this.width = s, this.height = o, this.type = i.ELLIPSE
        }, i.Ellipse.prototype = {
            setTo: function(t, e, i, s) {
                return this.x = t, this.y = e, this.width = i, this.height = s, this
            },
            getBounds: function() {
                return new i.Rectangle(this.x - this.width, this.y - this.height, this.width, this.height)
            },
            copyFrom: function(t) {
                return this.setTo(t.x, t.y, t.width, t.height)
            },
            copyTo: function(t) {
                return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t
            },
            clone: function(t) {
                return void 0 === t || null === t ? t = new i.Ellipse(this.x, this.y, this.width, this.height) : t.setTo(this.x, this.y, this.width, this.height), t
            },
            contains: function(t, e) {
                return i.Ellipse.contains(this, t, e)
            },
            random: function(t) {
                void 0 === t && (t = new i.Point);
                var e = Math.random() * Math.PI * 2,
                    s = Math.random();
                return t.x = Math.sqrt(s) * Math.cos(e), t.y = Math.sqrt(s) * Math.sin(e), t.x = this.x + t.x * this.width / 2, t.y = this.y + t.y * this.height / 2, t
            },
            toString: function() {
                return "[{Phaser.Ellipse (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + ")}]"
            }
        }, i.Ellipse.prototype.constructor = i.Ellipse, Object.defineProperty(i.Ellipse.prototype, "left", {
            get: function() {
                return this.x
            },
            set: function(t) {
                this.x = t
            }
        }), Object.defineProperty(i.Ellipse.prototype, "right", {
            get: function() {
                return this.x + this.width
            },
            set: function(t) {
                t < this.x ? this.width = 0 : this.width = t - this.x
            }
        }), Object.defineProperty(i.Ellipse.prototype, "top", {
            get: function() {
                return this.y
            },
            set: function(t) {
                this.y = t
            }
        }), Object.defineProperty(i.Ellipse.prototype, "bottom", {
            get: function() {
                return this.y + this.height
            },
            set: function(t) {
                t < this.y ? this.height = 0 : this.height = t - this.y
            }
        }), Object.defineProperty(i.Ellipse.prototype, "empty", {
            get: function() {
                return 0 === this.width || 0 === this.height
            },
            set: function(t) {
                !0 === t && this.setTo(0, 0, 0, 0)
            }
        }), i.Ellipse.contains = function(t, e, i) {
            if (t.width <= 0 || t.height <= 0) return !1;
            var s = (e - t.x) / t.width - .5,
                o = (i - t.y) / t.height - .5;
            return s *= s, o *= o, s + o < .25
        }, PIXI.Ellipse = i.Ellipse, i.Line = function(t, e, s, o) {
            t = t || 0, e = e || 0, s = s || 0, o = o || 0, this.start = new i.Point(t, e), this.end = new i.Point(s, o), this.type = i.LINE
        }, i.Line.prototype = {
            setTo: function(t, e, i, s) {
                return this.start.setTo(t, e), this.end.setTo(i, s), this
            },
            fromSprite: function(t, e, i) {
                return void 0 === i && (i = !1), i ? this.setTo(t.center.x, t.center.y, e.center.x, e.center.y) : this.setTo(t.x, t.y, e.x, e.y)
            },
            fromAngle: function(t, e, i, s) {
                return this.start.setTo(t, e), this.end.setTo(t + Math.cos(i) * s, e + Math.sin(i) * s), this
            },
            rotate: function(t, e) {
                var i = (this.start.x + this.end.x) / 2,
                    s = (this.start.y + this.end.y) / 2;
                return this.start.rotate(i, s, t, e), this.end.rotate(i, s, t, e), this
            },
            rotateAround: function(t, e, i, s) {
                return this.start.rotate(t, e, i, s), this.end.rotate(t, e, i, s), this
            },
            intersects: function(t, e, s) {
                return i.Line.intersectsPoints(this.start, this.end, t.start, t.end, e, s)
            },
            reflect: function(t) {
                return i.Line.reflect(this, t)
            },
            midPoint: function(t) {
                return void 0 === t && (t = new i.Point), t.x = (this.start.x + this.end.x) / 2, t.y = (this.start.y + this.end.y) / 2, t
            },
            centerOn: function(t, e) {
                var i = t - (this.start.x + this.end.x) / 2,
                    s = e - (this.start.y + this.end.y) / 2;
                this.start.add(i, s), this.end.add(i, s)
            },
            pointOnLine: function(t, e) {
                return (t - this.start.x) * (this.end.y - this.start.y) == (this.end.x - this.start.x) * (e - this.start.y)
            },
            pointOnSegment: function(t, e) {
                var i = Math.min(this.start.x, this.end.x),
                    s = Math.max(this.start.x, this.end.x),
                    o = Math.min(this.start.y, this.end.y),
                    n = Math.max(this.start.y, this.end.y);
                return this.pointOnLine(t, e) && t >= i && t <= s && e >= o && e <= n
            },
            random: function(t) {
                void 0 === t && (t = new i.Point);
                var e = Math.random();
                return t.x = this.start.x + e * (this.end.x - this.start.x), t.y = this.start.y + e * (this.end.y - this.start.y), t
            },
            coordinatesOnLine: function(t, e) {
                void 0 === t && (t = 1), void 0 === e && (e = []);
                var i = Math.round(this.start.x),
                    s = Math.round(this.start.y),
                    o = Math.round(this.end.x),
                    n = Math.round(this.end.y),
                    a = Math.abs(o - i),
                    r = Math.abs(n - s),
                    h = i < o ? 1 : -1,
                    l = s < n ? 1 : -1,
                    c = a - r;
                e.push([i, s]);
                for (var p = 1; i !== o || s !== n;) {
                    var u = c << 1;
                    u > -r && (c -= r, i += h), u < a && (c += a, s += l), p % t == 0 && e.push([i, s]), p++
                }
                return e
            },
            clone: function(t) {
                return void 0 === t || null === t ? t = new i.Line(this.start.x, this.start.y, this.end.x, this.end.y) : t.setTo(this.start.x, this.start.y, this.end.x, this.end.y), t
            }
        }, Object.defineProperty(i.Line.prototype, "length", {
            get: function() {
                return Math.sqrt((this.end.x - this.start.x) * (this.end.x - this.start.x) + (this.end.y - this.start.y) * (this.end.y - this.start.y))
            }
        }), Object.defineProperty(i.Line.prototype, "angle", {
            get: function() {
                return Math.atan2(this.end.y - this.start.y, this.end.x - this.start.x)
            }
        }), Object.defineProperty(i.Line.prototype, "slope", {
            get: function() {
                return (this.end.y - this.start.y) / (this.end.x - this.start.x)
            }
        }), Object.defineProperty(i.Line.prototype, "perpSlope", {
            get: function() {
                return -(this.end.x - this.start.x) / (this.end.y - this.start.y)
            }
        }), Object.defineProperty(i.Line.prototype, "x", {
            get: function() {
                return Math.min(this.start.x, this.end.x)
            }
        }), Object.defineProperty(i.Line.prototype, "y", {
            get: function() {
                return Math.min(this.start.y, this.end.y)
            }
        }), Object.defineProperty(i.Line.prototype, "left", {
            get: function() {
                return Math.min(this.start.x, this.end.x)
            }
        }), Object.defineProperty(i.Line.prototype, "right", {
            get: function() {
                return Math.max(this.start.x, this.end.x)
            }
        }), Object.defineProperty(i.Line.prototype, "top", {
            get: function() {
                return Math.min(this.start.y, this.end.y)
            }
        }), Object.defineProperty(i.Line.prototype, "bottom", {
            get: function() {
                return Math.max(this.start.y, this.end.y)
            }
        }), Object.defineProperty(i.Line.prototype, "width", {
            get: function() {
                return Math.abs(this.start.x - this.end.x)
            }
        }), Object.defineProperty(i.Line.prototype, "height", {
            get: function() {
                return Math.abs(this.start.y - this.end.y)
            }
        }), Object.defineProperty(i.Line.prototype, "normalX", {
            get: function() {
                return Math.cos(this.angle - 1.5707963267948966)
            }
        }), Object.defineProperty(i.Line.prototype, "normalY", {
            get: function() {
                return Math.sin(this.angle - 1.5707963267948966)
            }
        }), Object.defineProperty(i.Line.prototype, "normalAngle", {
            get: function() {
                return i.Math.wrap(this.angle - 1.5707963267948966, -Math.PI, Math.PI)
            }
        }), i.Line.intersectsPoints = function(t, e, s, o, n, a) {
            void 0 === n && (n = !0), void 0 === a && (a = new i.Point);
            var r = e.y - t.y,
                h = o.y - s.y,
                l = t.x - e.x,
                c = s.x - o.x,
                p = e.x * t.y - t.x * e.y,
                u = o.x * s.y - s.x * o.y,
                d = r * c - h * l;
            if (0 === d) return null;
            if (a.x = (l * u - c * p) / d, a.y = (h * p - r * u) / d, n) {
                var m = (o.y - s.y) * (e.x - t.x) - (o.x - s.x) * (e.y - t.y),
                    y = ((o.x - s.x) * (t.y - s.y) - (o.y - s.y) * (t.x - s.x)) / m,
                    f = ((e.x - t.x) * (t.y - s.y) - (e.y - t.y) * (t.x - s.x)) / m;
                return y >= 0 && y <= 1 && f >= 0 && f <= 1 ? a : null
            }
            return a
        }, i.Line.intersects = function(t, e, s, o) {
            return i.Line.intersectsPoints(t.start, t.end, e.start, e.end, s, o)
        }, i.Line.intersectsRectangle = function(t, e) {
            if (!i.Rectangle.intersects(t, e)) return !1;
            var s = t.start.x,
                o = t.start.y,
                n = t.end.x,
                a = t.end.y,
                r = e.x,
                h = e.y,
                l = e.right,
                c = e.bottom,
                p = 0;
            if (s >= r && s <= l && o >= h && o <= c || n >= r && n <= l && a >= h && a <= c) return !0;
            if (s < r && n >= r) {
                if ((p = o + (a - o) * (r - s) / (n - s)) > h && p <= c) return !0
            } else if (s > l && n <= l && (p = o + (a - o) * (l - s) / (n - s)) >= h && p <= c) return !0;
            if (o < h && a >= h) {
                if ((p = s + (n - s) * (h - o) / (a - o)) >= r && p <= l) return !0
            } else if (o > c && a <= c && (p = s + (n - s) * (c - o) / (a - o)) >= r && p <= l) return !0;
            return !1
        }, i.Line.reflect = function(t, e) {
            return 2 * e.normalAngle - 3.141592653589793 - t.angle
        }, i.Matrix = function(t, e, s, o, n, a) {
            void 0 !== t && null !== t || (t = 1), void 0 !== e && null !== e || (e = 0), void 0 !== s && null !== s || (s = 0), void 0 !== o && null !== o || (o = 1), void 0 !== n && null !== n || (n = 0), void 0 !== a && null !== a || (a = 0), this.a = t, this.b = e, this.c = s, this.d = o, this.tx = n, this.ty = a, this.type = i.MATRIX
        }, i.Matrix.prototype = {
            fromArray: function(t) {
                return this.setTo(t[0], t[1], t[3], t[4], t[2], t[5])
            },
            setTo: function(t, e, i, s, o, n) {
                return this.a = t, this.b = e, this.c = i, this.d = s, this.tx = o, this.ty = n, this
            },
            clone: function(t) {
                return void 0 === t || null === t ? t = new i.Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty) : (t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty), t
            },
            copyTo: function(t) {
                return t.copyFrom(this), t
            },
            copyFrom: function(t) {
                return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this
            },
            toArray: function(t, e) {
                return void 0 === e && (e = new PIXI.Float32Array(9)), t ? (e[0] = this.a, e[1] = this.b, e[2] = 0, e[3] = this.c, e[4] = this.d, e[5] = 0, e[6] = this.tx, e[7] = this.ty, e[8] = 1) : (e[0] = this.a, e[1] = this.c, e[2] = this.tx, e[3] = this.b, e[4] = this.d, e[5] = this.ty, e[6] = 0, e[7] = 0, e[8] = 1), e
            },
            apply: function(t, e) {
                return void 0 === e && (e = new i.Point), e.x = this.a * t.x + this.c * t.y + this.tx, e.y = this.b * t.x + this.d * t.y + this.ty, e
            },
            applyInverse: function(t, e) {
                void 0 === e && (e = new i.Point);
                var s = 1 / (this.a * this.d + this.c * -this.b),
                    o = t.x,
                    n = t.y;
                return e.x = this.d * s * o + -this.c * s * n + (this.ty * this.c - this.tx * this.d) * s, e.y = this.a * s * n + -this.b * s * o + (-this.ty * this.a + this.tx * this.b) * s, e
            },
            translate: function(t, e) {
                return this.tx += t, this.ty += e, this
            },
            scale: function(t, e) {
                return this.a *= t, this.d *= e, this.c *= t, this.b *= e, this.tx *= t, this.ty *= e, this
            },
            rotate: function(t) {
                var e = Math.cos(t),
                    i = Math.sin(t),
                    s = this.a,
                    o = this.c,
                    n = this.tx;
                return this.a = s * e - this.b * i, this.b = s * i + this.b * e, this.c = o * e - this.d * i, this.d = o * i + this.d * e, this.tx = n * e - this.ty * i, this.ty = n * i + this.ty * e, this
            },
            append: function(t) {
                var e = this.a,
                    i = this.b,
                    s = this.c,
                    o = this.d;
                return this.a = t.a * e + t.b * s, this.b = t.a * i + t.b * o, this.c = t.c * e + t.d * s, this.d = t.c * i + t.d * o, this.tx = t.tx * e + t.ty * s + this.tx, this.ty = t.tx * i + t.ty * o + this.ty, this
            },
            identity: function() {
                return this.setTo(1, 0, 0, 1, 0, 0)
            }
        }, i.identityMatrix = new i.Matrix, PIXI.Matrix = i.Matrix, PIXI.identityMatrix = i.identityMatrix, i.Point = function(t, e) {
            t = t || 0, e = e || 0, this.x = t, this.y = e, this.type = i.POINT
        }, i.Point.prototype = {
            copyFrom: function(t) {
                return this.setTo(t.x, t.y)
            },
            invert: function() {
                return this.setTo(this.y, this.x)
            },
            setTo: function(t, e) {
                return this.x = t || 0, this.y = e || (0 !== e ? this.x : 0), this
            },
            set: function(t, e) {
                return this.x = t || 0, this.y = e || (0 !== e ? this.x : 0), this
            },
            add: function(t, e) {
                return this.x += t, this.y += e, this
            },
            subtract: function(t, e) {
                return this.x -= t, this.y -= e, this
            },
            multiply: function(t, e) {
                return this.x *= t, this.y *= e, this
            },
            divide: function(t, e) {
                return this.x /= t, this.y /= e, this
            },
            clampX: function(t, e) {
                return this.x = i.Math.clamp(this.x, t, e), this
            },
            clampY: function(t, e) {
                return this.y = i.Math.clamp(this.y, t, e), this
            },
            clamp: function(t, e) {
                return this.x = i.Math.clamp(this.x, t, e), this.y = i.Math.clamp(this.y, t, e), this
            },
            clone: function(t) {
                return void 0 === t || null === t ? t = new i.Point(this.x, this.y) : t.setTo(this.x, this.y), t
            },
            copyTo: function(t) {
                return t.x = this.x, t.y = this.y, t
            },
            distance: function(t, e) {
                return i.Point.distance(this, t, e)
            },
            equals: function(t) {
                return t.x === this.x && t.y === this.y
            },
            angle: function(t, e) {
                return void 0 === e && (e = !1), e ? i.Math.radToDeg(Math.atan2(t.y - this.y, t.x - this.x)) : Math.atan2(t.y - this.y, t.x - this.x)
            },
            rotate: function(t, e, s, o, n) {
                return i.Point.rotate(this, t, e, s, o, n)
            },
            getMagnitude: function() {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            },
            getMagnitudeSq: function() {
                return this.x * this.x + this.y * this.y
            },
            setMagnitude: function(t) {
                return this.normalize().multiply(t, t)
            },
            normalize: function() {
                if (!this.isZero()) {
                    var t = this.getMagnitude();
                    this.x /= t, this.y /= t
                }
                return this
            },
            isZero: function() {
                return 0 === this.x && 0 === this.y
            },
            dot: function(t) {
                return this.x * t.x + this.y * t.y
            },
            cross: function(t) {
                return this.x * t.y - this.y * t.x
            },
            perp: function() {
                return this.setTo(-this.y, this.x)
            },
            rperp: function() {
                return this.setTo(this.y, -this.x)
            },
            normalRightHand: function() {
                return this.setTo(-1 * this.y, this.x)
            },
            floor: function() {
                return this.setTo(Math.floor(this.x), Math.floor(this.y))
            },
            ceil: function() {
                return this.setTo(Math.ceil(this.x), Math.ceil(this.y))
            },
            toString: function() {
                return "[{Point (x=" + this.x + " y=" + this.y + ")}]"
            }
        }, i.Point.prototype.constructor = i.Point, i.Point.add = function(t, e, s) {
            return void 0 === s && (s = new i.Point), s.x = t.x + e.x, s.y = t.y + e.y, s
        }, i.Point.subtract = function(t, e, s) {
            return void 0 === s && (s = new i.Point), s.x = t.x - e.x, s.y = t.y - e.y, s
        }, i.Point.multiply = function(t, e, s) {
            return void 0 === s && (s = new i.Point), s.x = t.x * e.x, s.y = t.y * e.y, s
        }, i.Point.divide = function(t, e, s) {
            return void 0 === s && (s = new i.Point), s.x = t.x / e.x, s.y = t.y / e.y, s
        }, i.Point.equals = function(t, e) {
            return t.x === e.x && t.y === e.y
        }, i.Point.angle = function(t, e) {
            return Math.atan2(t.y - e.y, t.x - e.x)
        }, i.Point.negative = function(t, e) {
            return void 0 === e && (e = new i.Point), e.setTo(-t.x, -t.y)
        }, i.Point.multiplyAdd = function(t, e, s, o) {
            return void 0 === o && (o = new i.Point), o.setTo(t.x + e.x * s, t.y + e.y * s)
        }, i.Point.interpolate = function(t, e, s, o) {
            return void 0 === o && (o = new i.Point), o.setTo(t.x + (e.x - t.x) * s, t.y + (e.y - t.y) * s)
        }, i.Point.perp = function(t, e) {
            return void 0 === e && (e = new i.Point), e.setTo(-t.y, t.x)
        }, i.Point.rperp = function(t, e) {
            return void 0 === e && (e = new i.Point), e.setTo(t.y, -t.x)
        }, i.Point.distance = function(t, e, s) {
            var o = i.Math.distance(t.x, t.y, e.x, e.y);
            return s ? Math.round(o) : o
        }, i.Point.project = function(t, e, s) {
            void 0 === s && (s = new i.Point);
            var o = t.dot(e) / e.getMagnitudeSq();
            return 0 !== o && s.setTo(o * e.x, o * e.y), s
        }, i.Point.projectUnit = function(t, e, s) {
            void 0 === s && (s = new i.Point);
            var o = t.dot(e);
            return 0 !== o && s.setTo(o * e.x, o * e.y), s
        }, i.Point.normalRightHand = function(t, e) {
            return void 0 === e && (e = new i.Point), e.setTo(-1 * t.y, t.x)
        }, i.Point.normalize = function(t, e) {
            void 0 === e && (e = new i.Point);
            var s = t.getMagnitude();
            return 0 !== s && e.setTo(t.x / s, t.y / s), e
        }, i.Point.rotate = function(t, e, s, o, n, a) {
            if (n && (o = i.Math.degToRad(o)), void 0 === a) {
                t.subtract(e, s);
                var r = Math.sin(o),
                    h = Math.cos(o),
                    l = h * t.x - r * t.y,
                    c = r * t.x + h * t.y;
                t.x = l + e, t.y = c + s
            } else {
                var p = o + Math.atan2(t.y - s, t.x - e);
                t.x = e + a * Math.cos(p), t.y = s + a * Math.sin(p)
            }
            return t
        }, i.Point.centroid = function(t, e) {
            if (void 0 === e && (e = new i.Point), "[object Array]" !== Object.prototype.toString.call(t)) throw new Error("Phaser.Point. Parameter 'points' must be an array");
            var s = t.length;
            if (s < 1) throw new Error("Phaser.Point. Parameter 'points' array must not be empty");
            if (1 === s) return e.copyFrom(t[0]), e;
            for (var o = 0; o < s; o++) i.Point.add(e, t[o], e);
            return e.divide(s, s), e
        }, i.Point.parse = function(t, e, s) {
            e = e || "x", s = s || "y";
            var o = new i.Point;
            return t[e] && (o.x = parseInt(t[e], 10)), t[s] && (o.y = parseInt(t[s], 10)), o
        }, PIXI.Point = i.Point, i.Polygon = function() {
            this.area = 0, this._points = [], arguments.length > 0 && this.setTo.apply(this, arguments), this.closed = !0, this.flattened = !1, this.type = i.POLYGON
        }, i.Polygon.prototype = {
            toNumberArray: function(t) {
                void 0 === t && (t = []);
                for (var e = 0; e < this._points.length; e++) "number" == typeof this._points[e] ? (t.push(this._points[e]), t.push(this._points[e + 1]), e++) : (t.push(this._points[e].x), t.push(this._points[e].y));
                return t
            },
            flatten: function() {
                return this._points = this.toNumberArray(), this.flattened = !0, this
            },
            clone: function(t) {
                var e = this._points.slice();
                return void 0 === t || null === t ? t = new i.Polygon(e) : t.setTo(e), t
            },
            contains: function(t, e) {
                var i = !1;
                if (this.flattened)
                    for (var s = -2, o = this._points.length - 2;
                        (s += 2) < this._points.length; o = s) {
                        var n = this._points[s],
                            a = this._points[s + 1],
                            r = this._points[o],
                            h = this._points[o + 1];
                        (a <= e && e < h || h <= e && e < a) && t < (r - n) * (e - a) / (h - a) + n && (i = !i)
                    } else
                        for (var s = -1, o = this._points.length - 1; ++s < this._points.length; o = s) {
                            var n = this._points[s].x,
                                a = this._points[s].y,
                                r = this._points[o].x,
                                h = this._points[o].y;
                            (a <= e && e < h || h <= e && e < a) && t < (r - n) * (e - a) / (h - a) + n && (i = !i)
                        }
                return i
            },
            setTo: function(t) {
                if (this.area = 0, this._points = [], arguments.length > 0) {
                    Array.isArray(t) || (t = Array.prototype.slice.call(arguments));
                    for (var e = Number.MAX_VALUE, i = 0, s = t.length; i < s; i++) {
                        if ("number" == typeof t[i]) {
                            o = new PIXI.Point(t[i], t[i + 1]);
                            i++
                        } else if (Array.isArray(t[i])) o = new PIXI.Point(t[i][0], t[i][1]);
                        else var o = new PIXI.Point(t[i].x, t[i].y);
                        this._points.push(o), o.y < e && (e = o.y)
                    }
                    this.calculateArea(e)
                }
                return this
            },
            calculateArea: function(t) {
                for (var e, i, s, o, n = 0, a = this._points.length; n < a; n++) e = this._points[n], i = n === a - 1 ? this._points[0] : this._points[n + 1], s = (e.y - t + (i.y - t)) / 2, o = e.x - i.x, this.area += s * o;
                return this.area
            }
        }, i.Polygon.prototype.constructor = i.Polygon, Object.defineProperty(i.Polygon.prototype, "points", {
            get: function() {
                return this._points
            },
            set: function(t) {
                null != t ? this.setTo(t) : this.setTo()
            }
        }), PIXI.Polygon = i.Polygon, i.Rectangle = function(t, e, s, o) {
            t = t || 0, e = e || 0, s = s || 0, o = o || 0, this.x = t, this.y = e, this.width = s, this.height = o, this.type = i.RECTANGLE
        }, i.Rectangle.prototype = {
            offset: function(t, e) {
                return this.x += t, this.y += e, this
            },
            offsetPoint: function(t) {
                return this.offset(t.x, t.y)
            },
            setTo: function(t, e, i, s) {
                return this.x = t, this.y = e, this.width = i, this.height = s, this
            },
            scale: function(t, e) {
                return void 0 === e && (e = t), this.width *= t, this.height *= e, this
            },
            centerOn: function(t, e) {
                return this.centerX = t, this.centerY = e, this
            },
            floor: function() {
                this.x = Math.floor(this.x), this.y = Math.floor(this.y)
            },
            floorAll: function() {
                this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.width = Math.floor(this.width), this.height = Math.floor(this.height)
            },
            ceil: function() {
                this.x = Math.ceil(this.x), this.y = Math.ceil(this.y)
            },
            ceilAll: function() {
                this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.width = Math.ceil(this.width), this.height = Math.ceil(this.height)
            },
            copyFrom: function(t) {
                return this.setTo(t.x, t.y, t.width, t.height)
            },
            copyTo: function(t) {
                return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t
            },
            inflate: function(t, e) {
                return i.Rectangle.inflate(this, t, e)
            },
            size: function(t) {
                return i.Rectangle.size(this, t)
            },
            resize: function(t, e) {
                return this.width = t, this.height = e, this
            },
            clone: function(t) {
                return i.Rectangle.clone(this, t)
            },
            contains: function(t, e) {
                return i.Rectangle.contains(this, t, e)
            },
            containsRect: function(t) {
                return i.Rectangle.containsRect(t, this)
            },
            equals: function(t) {
                return i.Rectangle.equals(this, t)
            },
            intersection: function(t, e) {
                return i.Rectangle.intersection(this, t, e)
            },
            intersects: function(t) {
                return i.Rectangle.intersects(this, t)
            },
            intersectsRaw: function(t, e, s, o, n) {
                return i.Rectangle.intersectsRaw(this, t, e, s, o, n)
            },
            union: function(t, e) {
                return i.Rectangle.union(this, t, e)
            },
            random: function(t) {
                return void 0 === t && (t = new i.Point), t.x = this.randomX, t.y = this.randomY, t
            },
            getPoint: function(t, e) {
                switch (void 0 === e && (e = new i.Point), t) {
                    default:
                        case i.TOP_LEFT:
                        return e.set(this.x, this.y);
                    case i.TOP_CENTER:
                            return e.set(this.centerX, this.y);
                    case i.TOP_RIGHT:
                            return e.set(this.right, this.y);
                    case i.LEFT_CENTER:
                            return e.set(this.x, this.centerY);
                    case i.CENTER:
                            return e.set(this.centerX, this.centerY);
                    case i.RIGHT_CENTER:
                            return e.set(this.right, this.centerY);
                    case i.BOTTOM_LEFT:
                            return e.set(this.x, this.bottom);
                    case i.BOTTOM_CENTER:
                            return e.set(this.centerX, this.bottom);
                    case i.BOTTOM_RIGHT:
                            return e.set(this.right, this.bottom)
                }
            },
            toString: function() {
                return "[{Rectangle (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + " empty=" + this.empty + ")}]"
            }
        }, Object.defineProperty(i.Rectangle.prototype, "halfWidth", {
            get: function() {
                return Math.round(this.width / 2)
            }
        }), Object.defineProperty(i.Rectangle.prototype, "halfHeight", {
            get: function() {
                return Math.round(this.height / 2)
            }
        }), Object.defineProperty(i.Rectangle.prototype, "bottom", {
            get: function() {
                return this.y + this.height
            },
            set: function(t) {
                t <= this.y ? this.height = 0 : this.height = t - this.y
            }
        }), Object.defineProperty(i.Rectangle.prototype, "bottomLeft", {
            get: function() {
                return new i.Point(this.x, this.bottom)
            },
            set: function(t) {
                this.x = t.x, this.bottom = t.y
            }
        }), Object.defineProperty(i.Rectangle.prototype, "bottomRight", {
            get: function() {
                return new i.Point(this.right, this.bottom)
            },
            set: function(t) {
                this.right = t.x, this.bottom = t.y
            }
        }), Object.defineProperty(i.Rectangle.prototype, "left", {
            get: function() {
                return this.x
            },
            set: function(t) {
                t >= this.right ? this.width = 0 : this.width = this.right - t, this.x = t
            }
        }), Object.defineProperty(i.Rectangle.prototype, "right", {
            get: function() {
                return this.x + this.width
            },
            set: function(t) {
                t <= this.x ? this.width = 0 : this.width = t - this.x
            }
        }), Object.defineProperty(i.Rectangle.prototype, "volume", {
            get: function() {
                return this.width * this.height
            }
        }), Object.defineProperty(i.Rectangle.prototype, "perimeter", {
            get: function() {
                return 2 * this.width + 2 * this.height
            }
        }), Object.defineProperty(i.Rectangle.prototype, "centerX", {
            get: function() {
                return this.x + this.halfWidth
            },
            set: function(t) {
                this.x = t - this.halfWidth
            }
        }), Object.defineProperty(i.Rectangle.prototype, "centerY", {
            get: function() {
                return this.y + this.halfHeight
            },
            set: function(t) {
                this.y = t - this.halfHeight
            }
        }), Object.defineProperty(i.Rectangle.prototype, "randomX", {
            get: function() {
                return this.x + Math.random() * this.width
            }
        }), Object.defineProperty(i.Rectangle.prototype, "randomY", {
            get: function() {
                return this.y + Math.random() * this.height
            }
        }), Object.defineProperty(i.Rectangle.prototype, "top", {
            get: function() {
                return this.y
            },
            set: function(t) {
                t >= this.bottom ? (this.height = 0, this.y = t) : this.height = this.bottom - t
            }
        }), Object.defineProperty(i.Rectangle.prototype, "topLeft", {
            get: function() {
                return new i.Point(this.x, this.y)
            },
            set: function(t) {
                this.x = t.x, this.y = t.y
            }
        }), Object.defineProperty(i.Rectangle.prototype, "topRight", {
            get: function() {
                return new i.Point(this.x + this.width, this.y)
            },
            set: function(t) {
                this.right = t.x, this.y = t.y
            }
        }), Object.defineProperty(i.Rectangle.prototype, "empty", {
            get: function() {
                return !this.width || !this.height
            },
            set: function(t) {
                !0 === t && this.setTo(0, 0, 0, 0)
            }
        }), i.Rectangle.prototype.constructor = i.Rectangle, i.Rectangle.inflate = function(t, e, i) {
            return t.x -= e, t.width += 2 * e, t.y -= i, t.height += 2 * i, t
        }, i.Rectangle.inflatePoint = function(t, e) {
            return i.Rectangle.inflate(t, e.x, e.y)
        }, i.Rectangle.size = function(t, e) {
            return void 0 === e || null === e ? e = new i.Point(t.width, t.height) : e.setTo(t.width, t.height), e
        }, i.Rectangle.clone = function(t, e) {
            return void 0 === e || null === e ? e = new i.Rectangle(t.x, t.y, t.width, t.height) : e.setTo(t.x, t.y, t.width, t.height), e
        }, i.Rectangle.contains = function(t, e, i) {
            return !(t.width <= 0 || t.height <= 0) && e >= t.x && e < t.right && i >= t.y && i < t.bottom
        }, i.Rectangle.containsRaw = function(t, e, i, s, o, n) {
            return o >= t && o < t + i && n >= e && n < e + s
        }, i.Rectangle.containsPoint = function(t, e) {
            return i.Rectangle.contains(t, e.x, e.y)
        }, i.Rectangle.containsRect = function(t, e) {
            return !(t.volume > e.volume) && t.x >= e.x && t.y >= e.y && t.right < e.right && t.bottom < e.bottom
        }, i.Rectangle.equals = function(t, e) {
            return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height
        }, i.Rectangle.sameDimensions = function(t, e) {
            return t.width === e.width && t.height === e.height
        }, i.Rectangle.intersection = function(t, e, s) {
            return void 0 === s && (s = new i.Rectangle), i.Rectangle.intersects(t, e) && (s.x = Math.max(t.x, e.x), s.y = Math.max(t.y, e.y), s.width = Math.min(t.right, e.right) - s.x, s.height = Math.min(t.bottom, e.bottom) - s.y), s
        }, i.Rectangle.intersects = function(t, e) {
            return !(t.width <= 0 || t.height <= 0 || e.width <= 0 || e.height <= 0 || t.right < e.x || t.bottom < e.y || t.x > e.right || t.y > e.bottom)
        }, i.Rectangle.intersectsRaw = function(t, e, i, s, o, n) {
            return void 0 === n && (n = 0), !(e > t.right + n || i < t.left - n || s > t.bottom + n || o < t.top - n)
        }, i.Rectangle.union = function(t, e, s) {
            return void 0 === s && (s = new i.Rectangle), s.setTo(Math.min(t.x, e.x), Math.min(t.y, e.y), Math.max(t.right, e.right) - Math.min(t.left, e.left), Math.max(t.bottom, e.bottom) - Math.min(t.top, e.top))
        }, i.Rectangle.aabb = function(t, e) {
            void 0 === e && (e = new i.Rectangle);
            var s = Number.NEGATIVE_INFINITY,
                o = Number.POSITIVE_INFINITY,
                n = Number.NEGATIVE_INFINITY,
                a = Number.POSITIVE_INFINITY;
            return t.forEach(function(t) {
                t.x > s && (s = t.x), t.x < o && (o = t.x), t.y > n && (n = t.y), t.y < a && (a = t.y)
            }), e.setTo(o, a, s - o, n - a), e
        }, PIXI.Rectangle = i.Rectangle, PIXI.EmptyRectangle = new i.Rectangle(0, 0, 0, 0), i.RoundedRectangle = function(t, e, s, o, n) {
            void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === s && (s = 0), void 0 === o && (o = 0), void 0 === n && (n = 20), this.x = t, this.y = e, this.width = s, this.height = o, this.radius = n || 20, this.type = i.ROUNDEDRECTANGLE
        }, i.RoundedRectangle.prototype = {
            clone: function() {
                return new i.RoundedRectangle(this.x, this.y, this.width, this.height, this.radius)
            },
            contains: function(t, e) {
                if (this.width <= 0 || this.height <= 0) return !1;
                var i = this.x;
                if (t >= i && t <= i + this.width) {
                    var s = this.y;
                    if (e >= s && e <= s + this.height) return !0
                }
                return !1
            }
        }, i.RoundedRectangle.prototype.constructor = i.RoundedRectangle, PIXI.RoundedRectangle = i.RoundedRectangle, i.Camera = function(t, e, s, o, n, a) {
            this.game = t, this.world = t.world, this.id = 0, this.view = new i.Rectangle(s, o, n, a), this.bounds = new i.Rectangle(s, o, n, a), this.deadzone = null, this.visible = !0, this.roundPx = !0, this.atLimit = {
                x: !1,
                y: !1
            }, this.target = null, this.displayObject = null, this.scale = null, this.totalInView = 0, this.lerp = new i.Point(1, 1), this.onShakeComplete = new i.Signal, this.onFlashComplete = new i.Signal, this.onFadeComplete = new i.Signal, this.fx = null, this._targetPosition = new i.Point, this._edge = 0, this._position = new i.Point, this._shake = {
                intensity: 0,
                duration: 0,
                horizontal: !1,
                vertical: !1,
                shakeBounds: !0,
                x: 0,
                y: 0
            }, this._fxDuration = 0, this._fxType = 0
        }, i.Camera.FOLLOW_LOCKON = 0, i.Camera.FOLLOW_PLATFORMER = 1, i.Camera.FOLLOW_TOPDOWN = 2, i.Camera.FOLLOW_TOPDOWN_TIGHT = 3, i.Camera.SHAKE_BOTH = 4, i.Camera.SHAKE_HORIZONTAL = 5, i.Camera.SHAKE_VERTICAL = 6, i.Camera.ENABLE_FX = !0, i.Camera.prototype = {
            boot: function() {
                this.displayObject = this.game.world, this.scale = this.game.world.scale, this.game.camera = this, i.Graphics && i.Camera.ENABLE_FX && (this.fx = new i.Graphics(this.game), this.game.stage.addChild(this.fx))
            },
            preUpdate: function() {
                this.totalInView = 0
            },
            follow: function(t, e, s, o) {
                void 0 === e && (e = i.Camera.FOLLOW_LOCKON), void 0 === s && (s = 1), void 0 === o && (o = 1), this.target = t, this.lerp.set(s, o);
                var n;
                switch (e) {
                    case i.Camera.FOLLOW_PLATFORMER:
                        var a = this.width / 8,
                            r = this.height / 3;
                        this.deadzone = new i.Rectangle((this.width - a) / 2, (this.height - r) / 2 - .25 * r, a, r);
                        break;
                    case i.Camera.FOLLOW_TOPDOWN:
                        n = Math.max(this.width, this.height) / 4, this.deadzone = new i.Rectangle((this.width - n) / 2, (this.height - n) / 2, n, n);
                        break;
                    case i.Camera.FOLLOW_TOPDOWN_TIGHT:
                        n = Math.max(this.width, this.height) / 8, this.deadzone = new i.Rectangle((this.width - n) / 2, (this.height - n) / 2, n, n);
                        break;
                    case i.Camera.FOLLOW_LOCKON:
                        this.deadzone = null;
                        break;
                    default:
                        this.deadzone = null
                }
            },
            unfollow: function() {
                this.target = null
            },
            focusOn: function(t) {
                this.setPosition(Math.round(t.x - this.view.halfWidth), Math.round(t.y - this.view.halfHeight))
            },
            focusOnXY: function(t, e) {
                this.setPosition(Math.round(t - this.view.halfWidth), Math.round(e - this.view.halfHeight))
            },
            shake: function(t, e, s, o, n) {
                return void 0 === t && (t = .05), void 0 === e && (e = 500), void 0 === s && (s = !0), void 0 === o && (o = i.Camera.SHAKE_BOTH), void 0 === n && (n = !0), !(!s && this._shake.duration > 0 || (this._shake.intensity = t, this._shake.duration = e, this._shake.shakeBounds = n, this._shake.x = 0, this._shake.y = 0, this._shake.horizontal = o === i.Camera.SHAKE_BOTH || o === i.Camera.SHAKE_HORIZONTAL, this._shake.vertical = o === i.Camera.SHAKE_BOTH || o === i.Camera.SHAKE_VERTICAL, 0))
            },
            flash: function(t, e, i) {
                return void 0 === t && (t = 16777215), void 0 === e && (e = 500), void 0 === i && (i = !1), !(!this.fx || !i && this._fxDuration > 0 || (this.fx.clear(), this.fx.beginFill(t), this.fx.drawRect(0, 0, this.width, this.height), this.fx.endFill(), this.fx.alpha = 1, this._fxDuration = e, this._fxType = 0, 0))
            },
            fade: function(t, e, i) {
                return void 0 === t && (t = 0), void 0 === e && (e = 500), void 0 === i && (i = !1), !(!this.fx || !i && this._fxDuration > 0 || (this.fx.clear(), this.fx.beginFill(t), this.fx.drawRect(0, 0, this.width, this.height), this.fx.endFill(), this.fx.alpha = 0, this._fxDuration = e, this._fxType = 1, 0))
            },
            update: function() {
                this._fxDuration > 0 && this.updateFX(), this._shake.duration > 0 && this.updateShake(), this.bounds && this.checkBounds(), this.roundPx && (this.view.floor(), this._shake.x = Math.floor(this._shake.x), this._shake.y = Math.floor(this._shake.y)), this.displayObject.position.x = -this.view.x, this.displayObject.position.y = -this.view.y
            },
            updateFX: function() {
                0 === this._fxType ? (this.fx.alpha -= this.game.time.elapsedMS / this._fxDuration, this.fx.alpha <= 0 && (this._fxDuration = 0, this.fx.alpha = 0, this.onFlashComplete.dispatch())) : (this.fx.alpha += this.game.time.elapsedMS / this._fxDuration, this.fx.alpha >= 1 && (this._fxDuration = 0, this.fx.alpha = 1, this.onFadeComplete.dispatch()))
            },
            updateShake: function() {
                this._shake.duration -= this.game.time.elapsedMS, this._shake.duration <= 0 ? (this.onShakeComplete.dispatch(), this._shake.x = 0, this._shake.y = 0) : (this._shake.horizontal && (this._shake.x = this.game.rnd.frac() * this._shake.intensity * this.view.width * 2 - this._shake.intensity * this.view.width), this._shake.vertical && (this._shake.y = this.game.rnd.frac() * this._shake.intensity * this.view.height * 2 - this._shake.intensity * this.view.height))
            },
            updateTarget: function() {
                this._targetPosition.x = this.view.x + this.target.worldPosition.x, this._targetPosition.y = this.view.y + this.target.worldPosition.y, this.deadzone ? (this._edge = this._targetPosition.x - this.view.x, this._edge < this.deadzone.left ? this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.left, this.lerp.x) : this._edge > this.deadzone.right && (this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.right, this.lerp.x)), this._edge = this._targetPosition.y - this.view.y, this._edge < this.deadzone.top ? this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.top, this.lerp.y) : this._edge > this.deadzone.bottom && (this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.bottom, this.lerp.y))) : (this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.view.halfWidth, this.lerp.x), this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.view.halfHeight, this.lerp.y)), this.bounds && this.checkBounds(), this.roundPx && this.view.floor(), this.displayObject.position.x = -this.view.x, this.displayObject.position.y = -this.view.y
            },
            setBoundsToWorld: function() {
                this.bounds && this.bounds.copyFrom(this.game.world.bounds)
            },
            checkBounds: function() {
                this.atLimit.x = !1, this.atLimit.y = !1;
                var t = this.view.x + this._shake.x,
                    e = this.view.right + this._shake.x,
                    i = this.view.y + this._shake.y,
                    s = this.view.bottom + this._shake.y;
                t <= this.bounds.x * this.scale.x && (this.atLimit.x = !0, this.view.x = this.bounds.x * this.scale.x, this._shake.shakeBounds || (this._shake.x = 0)), e >= this.bounds.right * this.scale.x && (this.atLimit.x = !0, this.view.x = this.bounds.right * this.scale.x - this.width, this._shake.shakeBounds || (this._shake.x = 0)), i <= this.bounds.top * this.scale.y && (this.atLimit.y = !0, this.view.y = this.bounds.top * this.scale.y, this._shake.shakeBounds || (this._shake.y = 0)), s >= this.bounds.bottom * this.scale.y && (this.atLimit.y = !0, this.view.y = this.bounds.bottom * this.scale.y - this.height, this._shake.shakeBounds || (this._shake.y = 0))
            },
            setPosition: function(t, e) {
                this.view.x = t, this.view.y = e, this.bounds && this.checkBounds()
            },
            setSize: function(t, e) {
                this.view.width = t, this.view.height = e
            },
            reset: function() {
                this.target = null, this.view.x = 0, this.view.y = 0, this._shake.duration = 0, this.resetFX()
            },
            resetFX: function() {
                this.fx.clear(), this.fx.alpha = 0, this._fxDuration = 0
            }
        }, i.Camera.prototype.constructor = i.Camera, Object.defineProperty(i.Camera.prototype, "x", {
            get: function() {
                return this.view.x
            },
            set: function(t) {
                this.view.x = t, this.bounds && this.checkBounds()
            }
        }), Object.defineProperty(i.Camera.prototype, "y", {
            get: function() {
                return this.view.y
            },
            set: function(t) {
                this.view.y = t, this.bounds && this.checkBounds()
            }
        }), Object.defineProperty(i.Camera.prototype, "position", {
            get: function() {
                return this._position.set(this.view.x, this.view.y), this._position
            },
            set: function(t) {
                void 0 !== t.x && (this.view.x = t.x), void 0 !== t.y && (this.view.y = t.y), this.bounds && this.checkBounds()
            }
        }), Object.defineProperty(i.Camera.prototype, "width", {
            get: function() {
                return this.view.width
            },
            set: function(t) {
                this.view.width = t
            }
        }), Object.defineProperty(i.Camera.prototype, "height", {
            get: function() {
                return this.view.height
            },
            set: function(t) {
                this.view.height = t
            }
        }), Object.defineProperty(i.Camera.prototype, "shakeIntensity", {
            get: function() {
                return this._shake.intensity
            },
            set: function(t) {
                this._shake.intensity = t
            }
        }), i.State = function() {
            this.game = null, this.key = "", this.add = null, this.make = null, this.camera = null, this.cache = null, this.input = null, this.load = null, this.math = null, this.sound = null, this.scale = null, this.stage = null, this.state = null, this.time = null, this.tweens = null, this.world = null, this.particles = null, this.physics = null, this.rnd = null
        }, i.State.prototype = {
            init: function() {},
            preload: function() {},
            loadUpdate: function() {},
            loadRender: function() {},
            create: function() {},
            update: function() {},
            preRender: function() {},
            render: function() {},
            resize: function() {},
            paused: function() {},
            resumed: function() {},
            pauseUpdate: function() {},
            shutdown: function() {}
        }, i.State.prototype.constructor = i.State, i.StateManager = function(t, e) {
            this.game = t, this.states = {}, this._pendingState = null, void 0 !== e && null !== e && (this._pendingState = e), this._clearWorld = !1, this._clearCache = !1, this._created = !1, this._args = [], this.current = "", this.onStateChange = new i.Signal, this.onInitCallback = null, this.onPreloadCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onRenderCallback = null, this.onResizeCallback = null, this.onPreRenderCallback = null, this.onLoadUpdateCallback = null, this.onLoadRenderCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null, this.onShutDownCallback = null
        }, i.StateManager.prototype = {
            boot: function() {
                this.game.onPause.add(this.pause, this), this.game.onResume.add(this.resume, this), null !== this._pendingState && "string" != typeof this._pendingState && this.add("default", this._pendingState, !0)
            },
            add: function(t, e, s) {
                void 0 === s && (s = !1);
                var o;
                return e instanceof i.State ? o = e : "object" == typeof e ? (o = e, o.game = this.game) : "function" == typeof e && (o = new e(this.game)), this.states[t] = o, s && (this.game.isBooted ? this.start(t) : this._pendingState = t), o
            },
            remove: function(t) {
                this.current === t && (this.callbackContext = null, this.onInitCallback = null, this.onShutDownCallback = null, this.onPreloadCallback = null, this.onLoadRenderCallback = null, this.onLoadUpdateCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onPreRenderCallback = null, this.onRenderCallback = null, this.onResizeCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null), delete this.states[t]
            },
            start: function(t, e, i) {
                void 0 === e && (e = !0), void 0 === i && (i = !1), this.checkState(t) && (this._pendingState = t, this._clearWorld = e, this._clearCache = i, arguments.length > 3 && (this._args = Array.prototype.splice.call(arguments, 3)))
            },
            restart: function(t, e) {
                void 0 === t && (t = !0), void 0 === e && (e = !1), this._pendingState = this.current, this._clearWorld = t, this._clearCache = e, arguments.length > 2 && (this._args = Array.prototype.slice.call(arguments, 2))
            },
            dummy: function() {},
            preUpdate: function() {
                if (this._pendingState && this.game.isBooted) {
                    var t = this.current;
                    if (this.clearCurrentState(), this.setCurrentState(this._pendingState), this.onStateChange.dispatch(this.current, t), this.current !== this._pendingState) return;
                    this._pendingState = null, this.onPreloadCallback ? (this.game.load.reset(!0), this.onPreloadCallback.call(this.callbackContext, this.game), 0 === this.game.load.totalQueuedFiles() && 0 === this.game.load.totalQueuedPacks() ? this.loadComplete() : this.game.load.start()) : this.loadComplete()
                }
            },
            clearCurrentState: function() {
                this.current && (this.onShutDownCallback && this.onShutDownCallback.call(this.callbackContext, this.game), this.game.tweens.removeAll(), this.game.camera.reset(), this.game.input.reset(!0), this.game.physics.clear(), this.game.time.removeAll(), this.game.scale.reset(this._clearWorld), this.game.debug && this.game.debug.reset(), this._clearWorld && (this.game.world.shutdown(), this._clearCache && this.game.cache.destroy()))
            },
            checkState: function(t) {
                return this.states[t] ? !!(this.states[t].preload || this.states[t].create || this.states[t].update || this.states[t].render) || (console.warn("Invalid Phaser State object given. Must contain at least a one of the required functions: preload, create, update or render"), !1) : (console.warn("Phaser.StateManager - No state found with the key: " + t), !1)
            },
            link: function(t) {
                this.states[t].game = this.game, this.states[t].add = this.game.add, this.states[t].make = this.game.make, this.states[t].camera = this.game.camera, this.states[t].cache = this.game.cache, this.states[t].input = this.game.input, this.states[t].load = this.game.load, this.states[t].math = this.game.math, this.states[t].sound = this.game.sound, this.states[t].scale = this.game.scale, this.states[t].state = this, this.states[t].stage = this.game.stage, this.states[t].time = this.game.time, this.states[t].tweens = this.game.tweens, this.states[t].world = this.game.world, this.states[t].particles = this.game.particles, this.states[t].rnd = this.game.rnd, this.states[t].physics = this.game.physics, this.states[t].key = t
            },
            unlink: function(t) {
                this.states[t] && (this.states[t].game = null, this.states[t].add = null, this.states[t].make = null, this.states[t].camera = null, this.states[t].cache = null, this.states[t].input = null, this.states[t].load = null, this.states[t].math = null, this.states[t].sound = null, this.states[t].scale = null, this.states[t].state = null, this.states[t].stage = null, this.states[t].time = null, this.states[t].tweens = null, this.states[t].world = null, this.states[t].particles = null, this.states[t].rnd = null, this.states[t].physics = null)
            },
            setCurrentState: function(t) {
                this.callbackContext = this.states[t], this.link(t), this.onInitCallback = this.states[t].init || this.dummy, this.onPreloadCallback = this.states[t].preload || null, this.onLoadRenderCallback = this.states[t].loadRender || null, this.onLoadUpdateCallback = this.states[t].loadUpdate || null, this.onCreateCallback = this.states[t].create || null, this.onUpdateCallback = this.states[t].update || null, this.onPreRenderCallback = this.states[t].preRender || null, this.onRenderCallback = this.states[t].render || null, this.onResizeCallback = this.states[t].resize || null, this.onPausedCallback = this.states[t].paused || null, this.onResumedCallback = this.states[t].resumed || null, this.onPauseUpdateCallback = this.states[t].pauseUpdate || null, this.onShutDownCallback = this.states[t].shutdown || this.dummy, "" !== this.current && this.game.physics.reset(), this.current = t, this._created = !1, this.onInitCallback.apply(this.callbackContext, this._args), t === this._pendingState && (this._args = []), this.game._kickstart = !0
            },
            getCurrentState: function() {
                return this.states[this.current]
            },
            loadComplete: function() {
                !1 === this._created && this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game), !1 === this._created && this.onCreateCallback ? (this._created = !0, this.onCreateCallback.call(this.callbackContext, this.game)) : this._created = !0
            },
            pause: function() {
                this._created && this.onPausedCallback && this.onPausedCallback.call(this.callbackContext, this.game)
            },
            resume: function() {
                this._created && this.onResumedCallback && this.onResumedCallback.call(this.callbackContext, this.game)
            },
            update: function() {
                this._created ? this.onUpdateCallback && this.onUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game)
            },
            pauseUpdate: function() {
                this._created ? this.onPauseUpdateCallback && this.onPauseUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game)
            },
            preRender: function(t) {
                this._created && this.onPreRenderCallback && this.onPreRenderCallback.call(this.callbackContext, this.game, t)
            },
            resize: function(t, e) {
                this.onResizeCallback && this.onResizeCallback.call(this.callbackContext, t, e)
            },
            render: function() {
                this._created ? this.onRenderCallback && (this.game.renderType === i.CANVAS ? (this.game.context.save(), this.game.context.setTransform(1, 0, 0, 1, 0, 0), this.onRenderCallback.call(this.callbackContext, this.game), this.game.context.restore()) : this.onRenderCallback.call(this.callbackContext, this.game)) : this.onLoadRenderCallback && this.onLoadRenderCallback.call(this.callbackContext, this.game)
            },
            destroy: function() {
                this._clearWorld = !0, this._clearCache = !0, this.clearCurrentState(), this.callbackContext = null, this.onInitCallback = null, this.onShutDownCallback = null, this.onPreloadCallback = null, this.onLoadRenderCallback = null, this.onLoadUpdateCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onRenderCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null, this.game = null, this.states = {}, this._pendingState = null, this.current = ""
            }
        }, i.StateManager.prototype.constructor = i.StateManager, Object.defineProperty(i.StateManager.prototype, "created", {
            get: function() {
                return this._created
            }
        }), i.Signal = function() {}, i.Signal.prototype = {
            _bindings: null,
            _prevParams: null,
            memorize: !1,
            _shouldPropagate: !0,
            active: !0,
            _boundDispatch: !1,
            validateListener: function(t, e) {
                if ("function" != typeof t) throw new Error("Phaser.Signal: listener is a required param of {fn}() and should be a Function.".replace("{fn}", e))
            },
            _registerListener: function(t, e, s, o, n) {
                var a, r = this._indexOfListener(t, s);
                if (-1 !== r) {
                    if ((a = this._bindings[r]).isOnce() !== e) throw new Error("You cannot add" + (e ? "" : "Once") + "() then add" + (e ? "Once" : "") + "() the same listener without removing the relationship first.")
                } else a = new i.SignalBinding(this, t, e, s, o, n), this._addBinding(a);
                return this.memorize && this._prevParams && a.execute(this._prevParams), a
            },
            _addBinding: function(t) {
                this._bindings || (this._bindings = []);
                var e = this._bindings.length;
                do {
                    e--
                } while (this._bindings[e] && t._priority <= this._bindings[e]._priority);
                this._bindings.splice(e + 1, 0, t)
            },
            _indexOfListener: function(t, e) {
                if (!this._bindings) return -1;
                void 0 === e && (e = null);
                for (var i, s = this._bindings.length; s--;)
                    if ((i = this._bindings[s])._listener === t && i.context === e) return s;
                return -1
            },
            has: function(t, e) {
                return -1 !== this._indexOfListener(t, e)
            },
            add: function(t, e, i) {
                this.validateListener(t, "add");
                var s = [];
                if (arguments.length > 3)
                    for (var o = 3; o < arguments.length; o++) s.push(arguments[o]);
                return this._registerListener(t, !1, e, i, s)
            },
            addOnce: function(t, e, i) {
                this.validateListener(t, "addOnce");
                var s = [];
                if (arguments.length > 3)
                    for (var o = 3; o < arguments.length; o++) s.push(arguments[o]);
                return this._registerListener(t, !0, e, i, s)
            },
            remove: function(t, e) {
                this.validateListener(t, "remove");
                var i = this._indexOfListener(t, e);
                return -1 !== i && (this._bindings[i]._destroy(), this._bindings.splice(i, 1)), t
            },
            removeAll: function(t) {
                if (void 0 === t && (t = null), this._bindings) {
                    for (var e = this._bindings.length; e--;) t ? this._bindings[e].context === t && (this._bindings[e]._destroy(), this._bindings.splice(e, 1)) : this._bindings[e]._destroy();
                    t || (this._bindings.length = 0)
                }
            },
            getNumListeners: function() {
                return this._bindings ? this._bindings.length : 0
            },
            halt: function() {
                this._shouldPropagate = !1
            },
            dispatch: function() {
                if (this.active && this._bindings) {
                    var t, e = Array.prototype.slice.call(arguments),
                        i = this._bindings.length;
                    if (this.memorize && (this._prevParams = e), i) {
                        t = this._bindings.slice(), this._shouldPropagate = !0;
                        do {
                            i--
                        } while (t[i] && this._shouldPropagate && !1 !== t[i].execute(e))
                    }
                }
            },
            forget: function() {
                this._prevParams && (this._prevParams = null)
            },
            dispose: function() {
                this.removeAll(), this._bindings = null, this._prevParams && (this._prevParams = null)
            },
            toString: function() {
                return "[Phaser.Signal active:" + this.active + " numListeners:" + this.getNumListeners() + "]"
            }
        }, Object.defineProperty(i.Signal.prototype, "boundDispatch", {
            get: function() {
                var t = this;
                return this._boundDispatch || (this._boundDispatch = function() {
                    return t.dispatch.apply(t, arguments)
                })
            }
        }), i.Signal.prototype.constructor = i.Signal, i.SignalBinding = function(t, e, i, s, o, n) {
            this._listener = e, i && (this._isOnce = !0), null != s && (this.context = s), this._signal = t, o && (this._priority = o), n && n.length && (this._args = n)
        }, i.SignalBinding.prototype = {
            context: null,
            _isOnce: !1,
            _priority: 0,
            _args: null,
            callCount: 0,
            active: !0,
            params: null,
            execute: function(t) {
                var e, i;
                return this.active && this._listener && (i = this.params ? this.params.concat(t) : t, this._args && (i = i.concat(this._args)), e = this._listener.apply(this.context, i), this.callCount++, this._isOnce && this.detach()), e
            },
            detach: function() {
                return this.isBound() ? this._signal.remove(this._listener, this.context) : null
            },
            isBound: function() {
                return !!this._signal && !!this._listener
            },
            isOnce: function() {
                return this._isOnce
            },
            getListener: function() {
                return this._listener
            },
            getSignal: function() {
                return this._signal
            },
            _destroy: function() {
                delete this._signal, delete this._listener, delete this.context
            },
            toString: function() {
                return "[Phaser.SignalBinding isOnce:" + this._isOnce + ", isBound:" + this.isBound() + ", active:" + this.active + "]"
            }
        }, i.SignalBinding.prototype.constructor = i.SignalBinding, i.Filter = function(t, e, s) {
            this.game = t, this.type = i.WEBGL_FILTER, this.passes = [this], this.shaders = [], this.dirty = !0, this.padding = 0, this.prevPoint = new i.Point;
            var o = new Date;
            if (this.uniforms = {
                    resolution: {
                        type: "2f",
                        value: {
                            x: 256,
                            y: 256
                        }
                    },
                    time: {
                        type: "1f",
                        value: 0
                    },
                    mouse: {
                        type: "2f",
                        value: {
                            x: 0,
                            y: 0
                        }
                    },
                    date: {
                        type: "4fv",
                        value: [o.getFullYear(), o.getMonth(), o.getDate(), 60 * o.getHours() * 60 + 60 * o.getMinutes() + o.getSeconds()]
                    },
                    sampleRate: {
                        type: "1f",
                        value: 44100
                    },
                    iChannel0: {
                        type: "sampler2D",
                        value: null,
                        textureData: {
                            repeat: !0
                        }
                    },
                    iChannel1: {
                        type: "sampler2D",
                        value: null,
                        textureData: {
                            repeat: !0
                        }
                    },
                    iChannel2: {
                        type: "sampler2D",
                        value: null,
                        textureData: {
                            repeat: !0
                        }
                    },
                    iChannel3: {
                        type: "sampler2D",
                        value: null,
                        textureData: {
                            repeat: !0
                        }
                    }
                }, e)
                for (var n in e) this.uniforms[n] = e[n];
            this.fragmentSrc = s || ""
        }, i.Filter.prototype = {
            init: function() {},
            setResolution: function(t, e) {
                this.uniforms.resolution.value.x = t, this.uniforms.resolution.value.y = e
            },
            update: function(t) {
                if (void 0 !== t) {
                    var e = t.x / this.game.width,
                        i = 1 - t.y / this.game.height;
                    e === this.prevPoint.x && i === this.prevPoint.y || (this.uniforms.mouse.value.x = e.toFixed(2), this.uniforms.mouse.value.y = i.toFixed(2), this.prevPoint.set(e, i))
                }
                this.uniforms.time.value = this.game.time.totalElapsedSeconds()
            },
            addToWorld: function(t, e, i, s, o, n) {
                void 0 === o && (o = 0), void 0 === n && (n = 0), void 0 !== i && null !== i ? this.width = i : i = this.width, void 0 !== s && null !== s ? this.height = s : s = this.height;
                var a = this.game.add.image(t, e, "__default");
                return a.width = i, a.height = s, a.anchor.set(o, n), a.filters = [this], a
            },
            destroy: function() {
                this.game = null
            }
        }, i.Filter.prototype.constructor = i.Filter, Object.defineProperty(i.Filter.prototype, "width", {
            get: function() {
                return this.uniforms.resolution.value.x
            },
            set: function(t) {
                this.uniforms.resolution.value.x = t
            }
        }), Object.defineProperty(i.Filter.prototype, "height", {
            get: function() {
                return this.uniforms.resolution.value.y
            },
            set: function(t) {
                this.uniforms.resolution.value.y = t
            }
        }), i.Plugin = function(t, e) {
            void 0 === e && (e = null), this.game = t, this.parent = e, this.active = !1, this.visible = !1, this.hasPreUpdate = !1, this.hasUpdate = !1, this.hasPostUpdate = !1, this.hasRender = !1, this.hasPostRender = !1
        }, i.Plugin.prototype = {
            preUpdate: function() {},
            update: function() {},
            render: function() {},
            postRender: function() {},
            destroy: function() {
                this.game = null, this.parent = null, this.active = !1, this.visible = !1
            }
        }, i.Plugin.prototype.constructor = i.Plugin, i.PluginManager = function(t) {
            this.game = t, this.plugins = [], this._len = 0, this._i = 0
        }, i.PluginManager.prototype = {
            add: function(t) {
                var e = Array.prototype.slice.call(arguments, 1),
                    i = !1;
                return "function" == typeof t ? t = new t(this.game, this) : (t.game = this.game, t.parent = this), "function" == typeof t.preUpdate && (t.hasPreUpdate = !0, i = !0), "function" == typeof t.update && (t.hasUpdate = !0, i = !0), "function" == typeof t.postUpdate && (t.hasPostUpdate = !0, i = !0), "function" == typeof t.render && (t.hasRender = !0, i = !0), "function" == typeof t.postRender && (t.hasPostRender = !0, i = !0), i ? ((t.hasPreUpdate || t.hasUpdate || t.hasPostUpdate) && (t.active = !0), (t.hasRender || t.hasPostRender) && (t.visible = !0), this._len = this.plugins.push(t), "function" == typeof t.init && t.init.apply(t, e), t) : null
            },
            remove: function(t, e) {
                for (void 0 === e && (e = !0), this._i = this._len; this._i--;)
                    if (this.plugins[this._i] === t) return e && t.destroy(), this.plugins.splice(this._i, 1), void this._len--
            },
            removeAll: function() {
                for (this._i = this._len; this._i--;) this.plugins[this._i].destroy();
                this.plugins.length = 0, this._len = 0
            },
            preUpdate: function() {
                for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasPreUpdate && this.plugins[this._i].preUpdate()
            },
            update: function() {
                for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasUpdate && this.plugins[this._i].update()
            },
            postUpdate: function() {
                for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasPostUpdate && this.plugins[this._i].postUpdate()
            },
            render: function() {
                for (this._i = this._len; this._i--;) this.plugins[this._i].visible && this.plugins[this._i].hasRender && this.plugins[this._i].render()
            },
            postRender: function() {
                for (this._i = this._len; this._i--;) this.plugins[this._i].visible && this.plugins[this._i].hasPostRender && this.plugins[this._i].postRender()
            },
            destroy: function() {
                this.removeAll(), this.game = null
            }
        }, i.PluginManager.prototype.constructor = i.PluginManager, i.Stage = function(t) {
            this.game = t, PIXI.DisplayObjectContainer.call(this), this.name = "_stage_root", this.disableVisibilityChange = !1, this.exists = !0, this.worldTransform = new PIXI.Matrix, this.stage = this, this.currentRenderOrderID = 0, this._hiddenVar = "hidden", this._onChange = null, this._bgColor = {
                r: 0,
                g: 0,
                b: 0,
                a: 0,
                color: 0,
                rgba: "#000000"
            }, this.game.transparent || (this._bgColor.a = 1), t.config && this.parseConfig(t.config)
        }, i.Stage.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), i.Stage.prototype.constructor = i.Stage, i.Stage.prototype.parseConfig = function(t) {
            t.disableVisibilityChange && (this.disableVisibilityChange = t.disableVisibilityChange), t.backgroundColor && this.setBackgroundColor(t.backgroundColor)
        }, i.Stage.prototype.boot = function() {
            i.DOM.getOffset(this.game.canvas, this.offset), i.Canvas.setUserSelect(this.game.canvas, "none"), i.Canvas.setTouchAction(this.game.canvas, "none"), this.checkVisibility()
        }, i.Stage.prototype.preUpdate = function() {
            this.currentRenderOrderID = 0;
            for (var t = 0; t < this.children.length; t++) this.children[t].preUpdate()
        }, i.Stage.prototype.update = function() {
            for (var t = this.children.length; t--;) this.children[t].update()
        }, i.Stage.prototype.postUpdate = function() {
            this.game.camera.update(), this.game.camera.target && (this.game.camera.target.postUpdate(), this.updateTransform(), this.game.camera.updateTarget());
            for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate();
            this.updateTransform()
        }, i.Stage.prototype.updateTransform = function() {
            this.worldAlpha = 1;
            for (var t = 0; t < this.children.length; t++) this.children[t].updateTransform()
        }, i.Stage.prototype.checkVisibility = function() {
            void 0 !== document.hidden ? this._hiddenVar = "visibilitychange" : void 0 !== document.webkitHidden ? this._hiddenVar = "webkitvisibilitychange" : void 0 !== document.mozHidden ? this._hiddenVar = "mozvisibilitychange" : void 0 !== document.msHidden ? this._hiddenVar = "msvisibilitychange" : this._hiddenVar = null;
            var t = this;
            this._onChange = function(e) {
                return t.visibilityChange(e)
            }, this._hiddenVar && document.addEventListener(this._hiddenVar, this._onChange, !1), window.onblur = this._onChange, window.onfocus = this._onChange, window.onpagehide = this._onChange, window.onpageshow = this._onChange, this.game.device.cocoonJSApp && (CocoonJS.App.onSuspended.addEventListener(function() {
                i.Stage.prototype.visibilityChange.call(t, {
                    type: "pause"
                })
            }), CocoonJS.App.onActivated.addEventListener(function() {
                i.Stage.prototype.visibilityChange.call(t, {
                    type: "resume"
                })
            }))
        }, i.Stage.prototype.visibilityChange = function(t) {
            return "pagehide" === t.type || "blur" === t.type || "pageshow" === t.type || "focus" === t.type ? void("pagehide" === t.type || "blur" === t.type ? this.game.focusLoss(t) : "pageshow" !== t.type && "focus" !== t.type || this.game.focusGain(t)) : void(this.disableVisibilityChange || (document.hidden || document.mozHidden || document.msHidden || document.webkitHidden || "pause" === t.type ? this.game.gamePaused(t) : this.game.gameResumed(t)))
        }, i.Stage.prototype.setBackgroundColor = function(t) {
            this.game.transparent || (i.Color.valueToColor(t, this._bgColor), i.Color.updateColor(this._bgColor), this._bgColor.r /= 255, this._bgColor.g /= 255, this._bgColor.b /= 255, this._bgColor.a = 1)
        }, i.Stage.prototype.destroy = function() {
            this._hiddenVar && document.removeEventListener(this._hiddenVar, this._onChange, !1), window.onpagehide = null, window.onpageshow = null, window.onblur = null, window.onfocus = null
        }, Object.defineProperty(i.Stage.prototype, "backgroundColor", {
            get: function() {
                return this._bgColor.color
            },
            set: function(t) {
                this.setBackgroundColor(t)
            }
        }), Object.defineProperty(i.Stage.prototype, "smoothed", {
            get: function() {
                return PIXI.scaleModes.DEFAULT === PIXI.scaleModes.LINEAR
            },
            set: function(t) {
                PIXI.scaleModes.DEFAULT = t ? PIXI.scaleModes.LINEAR : PIXI.scaleModes.NEAREST
            }
        }), i.Group = function(t, e, s, o, n, a) {
            void 0 === o && (o = !1), void 0 === n && (n = !1), void 0 === a && (a = i.Physics.ARCADE), this.game = t, void 0 === e && (e = t.world), this.name = s || "group", this.z = 0, PIXI.DisplayObjectContainer.call(this), o ? (this.game.stage.addChild(this), this.z = this.game.stage.children.length) : e && (e.addChild(this), this.z = e.children.length), this.type = i.GROUP, this.physicsType = i.GROUP, this.alive = !0, this.exists = !0, this.ignoreDestroy = !1, this.pendingDestroy = !1, this.classType = i.Sprite, this.cursor = null, this.inputEnableChildren = !1, this.onChildInputDown = new i.Signal, this.onChildInputUp = new i.Signal, this.onChildInputOver = new i.Signal, this.onChildInputOut = new i.Signal, this.enableBody = n, this.enableBodyDebug = !1, this.physicsBodyType = a, this.physicsSortDirection = null, this.onDestroy = new i.Signal, this.cursorIndex = 0, this.fixedToCamera = !1, this.cameraOffset = new i.Point, this.hash = [], this._sortProperty = "z"
        }, i.Group.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), i.Group.prototype.constructor = i.Group, i.Group.RETURN_NONE = 0, i.Group.RETURN_TOTAL = 1, i.Group.RETURN_CHILD = 2, i.Group.RETURN_ALL = 3, i.Group.SORT_ASCENDING = -1, i.Group.SORT_DESCENDING = 1, i.Group.prototype.add = function(t, e, i) {
            return void 0 === e && (e = !1), t.parent === this ? t : (t.body && t.parent && t.parent.hash && t.parent.removeFromHash(t), void 0 === i ? (t.z = this.children.length, this.addChild(t)) : (this.addChildAt(t, i), this.updateZ()), this.enableBody && t.hasOwnProperty("body") && null === t.body ? this.game.physics.enable(t, this.physicsBodyType) : t.body && this.addToHash(t), !this.inputEnableChildren || t.input && !t.inputEnabled || (t.inputEnabled = !0), !e && t.events && t.events.onAddedToGroup$dispatch(t, this), null === this.cursor && (this.cursor = t), t)
        }, i.Group.prototype.addAt = function(t, e, i) {
            this.add(t, i, e)
        }, i.Group.prototype.addToHash = function(t) {
            return t.parent === this && -1 === this.hash.indexOf(t) && (this.hash.push(t), !0)
        }, i.Group.prototype.removeFromHash = function(t) {
            if (t) {
                var e = this.hash.indexOf(t);
                if (-1 !== e) return this.hash.splice(e, 1), !0
            }
            return !1
        }, i.Group.prototype.addMultiple = function(t, e) {
            if (t instanceof i.Group) t.moveAll(this, e);
            else if (Array.isArray(t))
                for (var s = 0; s < t.length; s++) this.add(t[s], e);
            return t
        }, i.Group.prototype.getAt = function(t) {
            return t < 0 || t >= this.children.length ? -1 : this.getChildAt(t)
        }, i.Group.prototype.create = function(t, e, i, s, o, n) {
            void 0 === o && (o = !0);
            var a = new this.classType(this.game, t, e, i, s);
            return a.exists = o, a.visible = o, a.alive = o, this.add(a, !1, n)
        }, i.Group.prototype.createMultiple = function(t, e, i, s) {
            void 0 === i && (i = 0), void 0 === s && (s = !1), Array.isArray(e) || (e = [e]), Array.isArray(i) || (i = [i]);
            var o = this,
                n = [];
            return e.forEach(function(e) {
                i.forEach(function(i) {
                    for (var a = 0; a < t; a++) n.push(o.create(0, 0, e, i, s))
                })
            }), n
        }, i.Group.prototype.updateZ = function() {
            for (var t = this.children.length; t--;) this.children[t].z = t
        }, i.Group.prototype.align = function(t, e, s, o, n, a) {
            if (void 0 === n && (n = i.TOP_LEFT), void 0 === a && (a = 0), 0 === this.children.length || a > this.children.length || -1 === t && -1 === e) return !1;
            for (var r = new i.Rectangle(0, 0, s, o), h = t * s, l = e * o, c = a; c < this.children.length; c++) {
                var p = this.children[c];
                if (p.alignIn)
                    if (p.alignIn(r, n), -1 === t) r.y += o, r.y === l && (r.x += s, r.y = 0);
                    else if (-1 === e) r.x += s, r.x === h && (r.x = 0, r.y += o);
                else if (r.x += s, r.x === h && (r.x = 0, r.y += o, r.y === l)) return !0
            }
            return !0
        }, i.Group.prototype.resetCursor = function(t) {
            if (void 0 === t && (t = 0), t > this.children.length - 1 && (t = 0), this.cursor) return this.cursorIndex = t, this.cursor = this.children[this.cursorIndex], this.cursor
        }, i.Group.prototype.next = function() {
            if (this.cursor) return this.cursorIndex >= this.children.length - 1 ? this.cursorIndex = 0 : this.cursorIndex++, this.cursor = this.children[this.cursorIndex], this.cursor
        }, i.Group.prototype.previous = function() {
            if (this.cursor) return 0 === this.cursorIndex ? this.cursorIndex = this.children.length - 1 : this.cursorIndex--, this.cursor = this.children[this.cursorIndex], this.cursor
        }, i.Group.prototype.swap = function(t, e) {
            this.swapChildren(t, e), this.updateZ()
        }, i.Group.prototype.bringToTop = function(t) {
            return t.parent === this && this.getIndex(t) < this.children.length && (this.remove(t, !1, !0), this.add(t, !0)), t
        }, i.Group.prototype.sendToBack = function(t) {
            return t.parent === this && this.getIndex(t) > 0 && (this.remove(t, !1, !0), this.addAt(t, 0, !0)), t
        }, i.Group.prototype.moveUp = function(t) {
            if (t.parent === this && this.getIndex(t) < this.children.length - 1) {
                var e = this.getIndex(t),
                    i = this.getAt(e + 1);
                i && this.swap(t, i)
            }
            return t
        }, i.Group.prototype.moveDown = function(t) {
            if (t.parent === this && this.getIndex(t) > 0) {
                var e = this.getIndex(t),
                    i = this.getAt(e - 1);
                i && this.swap(t, i)
            }
            return t
        }, i.Group.prototype.xy = function(t, e, i) {
            return t < 0 || t > this.children.length ? -1 : (this.getChildAt(t).x = e, void(this.getChildAt(t).y = i))
        }, i.Group.prototype.reverse = function() {
            this.children.reverse(), this.updateZ()
        }, i.Group.prototype.getIndex = function(t) {
            return this.children.indexOf(t)
        }, i.Group.prototype.getByName = function(t) {
            for (var e = 0; e < this.children.length; e++)
                if (this.children[e].name === t) return this.children[e];
            return null
        }, i.Group.prototype.replace = function(t, e) {
            var s = this.getIndex(t);
            if (-1 !== s) return e.parent && (e.parent instanceof i.Group ? e.parent.remove(e) : e.parent.removeChild(e)), this.remove(t), this.addAt(e, s), t
        }, i.Group.prototype.hasProperty = function(t, e) {
            var i = e.length;
            return 1 === i && e[0] in t || 2 === i && e[0] in t && e[1] in t[e[0]] || 3 === i && e[0] in t && e[1] in t[e[0]] && e[2] in t[e[0]][e[1]] || 4 === i && e[0] in t && e[1] in t[e[0]] && e[2] in t[e[0]][e[1]] && e[3] in t[e[0]][e[1]][e[2]]
        }, i.Group.prototype.setProperty = function(t, e, i, s, o) {
            if (void 0 === o && (o = !1), s = s || 0, !this.hasProperty(t, e) && (!o || s > 0)) return !1;
            var n = e.length;
            return 1 === n ? 0 === s ? t[e[0]] = i : 1 === s ? t[e[0]] += i : 2 === s ? t[e[0]] -= i : 3 === s ? t[e[0]] *= i : 4 === s && (t[e[0]] /= i) : 2 === n ? 0 === s ? t[e[0]][e[1]] = i : 1 === s ? t[e[0]][e[1]] += i : 2 === s ? t[e[0]][e[1]] -= i : 3 === s ? t[e[0]][e[1]] *= i : 4 === s && (t[e[0]][e[1]] /= i) : 3 === n ? 0 === s ? t[e[0]][e[1]][e[2]] = i : 1 === s ? t[e[0]][e[1]][e[2]] += i : 2 === s ? t[e[0]][e[1]][e[2]] -= i : 3 === s ? t[e[0]][e[1]][e[2]] *= i : 4 === s && (t[e[0]][e[1]][e[2]] /= i) : 4 === n && (0 === s ? t[e[0]][e[1]][e[2]][e[3]] = i : 1 === s ? t[e[0]][e[1]][e[2]][e[3]] += i : 2 === s ? t[e[0]][e[1]][e[2]][e[3]] -= i : 3 === s ? t[e[0]][e[1]][e[2]][e[3]] *= i : 4 === s && (t[e[0]][e[1]][e[2]][e[3]] /= i)), !0
        }, i.Group.prototype.checkProperty = function(t, e, s, o) {
            return void 0 === o && (o = !1), !(!i.Utils.getProperty(t, e) && o) && i.Utils.getProperty(t, e) === s
        }, i.Group.prototype.set = function(t, e, i, s, o, n, a) {
            if (void 0 === a && (a = !1), e = e.split("."), void 0 === s && (s = !1), void 0 === o && (o = !1), (!1 === s || s && t.alive) && (!1 === o || o && t.visible)) return this.setProperty(t, e, i, n, a)
        }, i.Group.prototype.setAll = function(t, e, i, s, o, n) {
            void 0 === i && (i = !1), void 0 === s && (s = !1), void 0 === n && (n = !1), t = t.split("."), o = o || 0;
            for (var a = 0; a < this.children.length; a++)(!i || i && this.children[a].alive) && (!s || s && this.children[a].visible) && this.setProperty(this.children[a], t, e, o, n)
        }, i.Group.prototype.setAllChildren = function(t, e, s, o, n, a) {
            void 0 === s && (s = !1), void 0 === o && (o = !1), void 0 === a && (a = !1), n = n || 0;
            for (var r = 0; r < this.children.length; r++)(!s || s && this.children[r].alive) && (!o || o && this.children[r].visible) && (this.children[r] instanceof i.Group ? this.children[r].setAllChildren(t, e, s, o, n, a) : this.setProperty(this.children[r], t.split("."), e, n, a))
        }, i.Group.prototype.checkAll = function(t, e, i, s, o) {
            void 0 === i && (i = !1), void 0 === s && (s = !1), void 0 === o && (o = !1);
            for (var n = 0; n < this.children.length; n++)
                if ((!i || i && this.children[n].alive) && (!s || s && this.children[n].visible) && !this.checkProperty(this.children[n], t, e, o)) return !1;
            return !0
        }, i.Group.prototype.addAll = function(t, e, i, s) {
            this.setAll(t, e, i, s, 1)
        }, i.Group.prototype.subAll = function(t, e, i, s) {
            this.setAll(t, e, i, s, 2)
        }, i.Group.prototype.multiplyAll = function(t, e, i, s) {
            this.setAll(t, e, i, s, 3)
        }, i.Group.prototype.divideAll = function(t, e, i, s) {
            this.setAll(t, e, i, s, 4)
        }, i.Group.prototype.callAllExists = function(t, e) {
            var i;
            if (arguments.length > 2) {
                i = [];
                for (s = 2; s < arguments.length; s++) i.push(arguments[s])
            }
            for (var s = 0; s < this.children.length; s++) this.children[s].exists === e && this.children[s][t] && this.children[s][t].apply(this.children[s], i)
        }, i.Group.prototype.callbackFromArray = function(t, e, i) {
            if (1 === i) {
                if (t[e[0]]) return t[e[0]]
            } else if (2 === i) {
                if (t[e[0]][e[1]]) return t[e[0]][e[1]]
            } else if (3 === i) {
                if (t[e[0]][e[1]][e[2]]) return t[e[0]][e[1]][e[2]]
            } else if (4 === i) {
                if (t[e[0]][e[1]][e[2]][e[3]]) return t[e[0]][e[1]][e[2]][e[3]]
            } else if (t[e]) return t[e];
            return !1
        }, i.Group.prototype.callAll = function(t, e) {
            if (void 0 !== t) {
                var i = (t = t.split(".")).length;
                if (void 0 === e || null === e || "" === e) e = null;
                else if ("string" == typeof e) var s = (e = e.split(".")).length;
                var o;
                if (arguments.length > 2) {
                    o = [];
                    for (r = 2; r < arguments.length; r++) o.push(arguments[r])
                }
                for (var n = null, a = null, r = 0; r < this.children.length; r++) n = this.callbackFromArray(this.children[r], t, i), e && n ? (a = this.callbackFromArray(this.children[r], e, s), n && n.apply(a, o)) : n && n.apply(this.children[r], o)
            }
        }, i.Group.prototype.preUpdate = function() {
            if (this.pendingDestroy) return this.destroy(), !1;
            if (!this.exists || !this.parent.exists) return this.renderOrderID = -1, !1;
            for (var t = 0; t < this.children.length; t++) this.children[t].preUpdate();
            return !0
        }, i.Group.prototype.update = function() {
            for (var t = this.children.length; t--;) this.children[t].update()
        }, i.Group.prototype.postUpdate = function() {
            this.fixedToCamera && (this.x = this.game.camera.view.x + this.cameraOffset.x, this.y = this.game.camera.view.y + this.cameraOffset.y);
            for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate()
        }, i.Group.prototype.filter = function(t, e) {
            for (var s = -1, o = this.children.length, n = []; ++s < o;) {
                var a = this.children[s];
                (!e || e && a.exists) && t(a, s, this.children) && n.push(a)
            }
            return new i.ArraySet(n)
        }, i.Group.prototype.forEach = function(t, e, i) {
            if (void 0 === i && (i = !1), arguments.length <= 3)
                for (o = 0; o < this.children.length; o++)(!i || i && this.children[o].exists) && t.call(e, this.children[o]);
            else {
                for (var s = [null], o = 3; o < arguments.length; o++) s.push(arguments[o]);
                for (o = 0; o < this.children.length; o++)(!i || i && this.children[o].exists) && (s[0] = this.children[o], t.apply(e, s))
            }
        }, i.Group.prototype.forEachExists = function(t, e) {
            var s;
            if (arguments.length > 2) {
                s = [null];
                for (var o = 2; o < arguments.length; o++) s.push(arguments[o])
            }
            this.iterate("exists", !0, i.Group.RETURN_TOTAL, t, e, s)
        }, i.Group.prototype.forEachAlive = function(t, e) {
            var s;
            if (arguments.length > 2) {
                s = [null];
                for (var o = 2; o < arguments.length; o++) s.push(arguments[o])
            }
            this.iterate("alive", !0, i.Group.RETURN_TOTAL, t, e, s)
        }, i.Group.prototype.forEachDead = function(t, e) {
            var s;
            if (arguments.length > 2) {
                s = [null];
                for (var o = 2; o < arguments.length; o++) s.push(arguments[o])
            }
            this.iterate("alive", !1, i.Group.RETURN_TOTAL, t, e, s)
        }, i.Group.prototype.sort = function(t, e) {
            this.children.length < 2 || (void 0 === t && (t = "z"), void 0 === e && (e = i.Group.SORT_ASCENDING), this._sortProperty = t, e === i.Group.SORT_ASCENDING ? this.children.sort(this.ascendingSortHandler.bind(this)) : this.children.sort(this.descendingSortHandler.bind(this)), this.updateZ())
        }, i.Group.prototype.customSort = function(t, e) {
            this.children.length < 2 || (this.children.sort(t.bind(e)), this.updateZ())
        }, i.Group.prototype.ascendingSortHandler = function(t, e) {
            return t[this._sortProperty] < e[this._sortProperty] ? -1 : t[this._sortProperty] > e[this._sortProperty] ? 1 : t.z < e.z ? -1 : 1
        }, i.Group.prototype.descendingSortHandler = function(t, e) {
            return t[this._sortProperty] < e[this._sortProperty] ? 1 : t[this._sortProperty] > e[this._sortProperty] ? -1 : 0
        }, i.Group.prototype.iterate = function(t, e, s, o, n, a) {
            if (0 === this.children.length) {
                if (s === i.Group.RETURN_TOTAL) return 0;
                if (s === i.Group.RETURN_ALL) return []
            }
            var r = 0;
            if (s === i.Group.RETURN_ALL) var h = [];
            for (var l = 0; l < this.children.length; l++)
                if (this.children[l][t] === e) {
                    if (r++, o && (a ? (a[0] = this.children[l], o.apply(n, a)) : o.call(n, this.children[l])), s === i.Group.RETURN_CHILD) return this.children[l];
                    s === i.Group.RETURN_ALL && h.push(this.children[l])
                }
            return s === i.Group.RETURN_TOTAL ? r : s === i.Group.RETURN_ALL ? h : null
        }, i.Group.prototype.getFirstExists = function(t, e, s, o, n, a) {
            void 0 === e && (e = !1), "boolean" != typeof t && (t = !0);
            var r = this.iterate("exists", t, i.Group.RETURN_CHILD);
            return null === r && e ? this.create(s, o, n, a) : this.resetChild(r, s, o, n, a)
        }, i.Group.prototype.getFirstAlive = function(t, e, s, o, n) {
            void 0 === t && (t = !1);
            var a = this.iterate("alive", !0, i.Group.RETURN_CHILD);
            return null === a && t ? this.create(e, s, o, n) : this.resetChild(a, e, s, o, n)
        }, i.Group.prototype.getFirstDead = function(t, e, s, o, n) {
            void 0 === t && (t = !1);
            var a = this.iterate("alive", !1, i.Group.RETURN_CHILD);
            return null === a && t ? this.create(e, s, o, n) : this.resetChild(a, e, s, o, n)
        }, i.Group.prototype.resetChild = function(t, e, i, s, o) {
            return null === t ? null : (void 0 === e && (e = null), void 0 === i && (i = null), null !== e && null !== i && t.reset(e, i), void 0 !== s && t.loadTexture(s, o), t)
        }, i.Group.prototype.getTop = function() {
            if (this.children.length > 0) return this.children[this.children.length - 1]
        }, i.Group.prototype.getBottom = function() {
            if (this.children.length > 0) return this.children[0]
        }, i.Group.prototype.getClosestTo = function(t, e, s) {
            for (var o = Number.MAX_VALUE, n = 0, a = null, r = 0; r < this.children.length; r++) {
                var h = this.children[r];
                h.exists && (n = Math.abs(i.Point.distance(t, h))) < o && (!e || e.call(s, h, n)) && (o = n, a = h)
            }
            return a
        }, i.Group.prototype.getFurthestFrom = function(t, e, s) {
            for (var o = 0, n = 0, a = null, r = 0; r < this.children.length; r++) {
                var h = this.children[r];
                h.exists && (n = Math.abs(i.Point.distance(t, h))) > o && (!e || e.call(s, h, n)) && (o = n, a = h)
            }
            return a
        }, i.Group.prototype.countLiving = function() {
            return this.iterate("alive", !0, i.Group.RETURN_TOTAL)
        }, i.Group.prototype.countDead = function() {
            return this.iterate("alive", !1, i.Group.RETURN_TOTAL)
        }, i.Group.prototype.getRandom = function(t, e) {
            return void 0 === t && (t = 0), void 0 === e && (e = this.children.length), 0 === e ? null : i.ArrayUtils.getRandomItem(this.children, t, e)
        }, i.Group.prototype.getRandomExists = function(t, e) {
            var i = this.getAll("exists", !0, t, e);
            return this.game.rnd.pick(i)
        }, i.Group.prototype.getAll = function(t, e, i, s) {
            void 0 === i && (i = 0), void 0 === s && (s = this.children.length);
            for (var o = [], n = i; n < s; n++) {
                var a = this.children[n];
                t && a[t] === e && o.push(a)
            }
            return o
        }, i.Group.prototype.remove = function(t, e, i) {
            if (void 0 === e && (e = !1), void 0 === i && (i = !1), 0 === this.children.length || -1 === this.children.indexOf(t)) return !1;
            i || !t.events || t.destroyPhase || t.events.onRemovedFromGroup$dispatch(t, this);
            var s = this.removeChild(t);
            return this.removeFromHash(t), this.updateZ(), this.cursor === t && this.next(), e && s && s.destroy(!0), !0
        }, i.Group.prototype.moveAll = function(t, e) {
            if (void 0 === e && (e = !1), this.children.length > 0 && t instanceof i.Group) {
                do {
                    t.add(this.children[0], e)
                } while (this.children.length > 0);
                this.hash = [], this.cursor = null
            }
            return t
        }, i.Group.prototype.removeAll = function(t, e, i) {
            if (void 0 === t && (t = !1), void 0 === e && (e = !1), void 0 === i && (i = !1), 0 !== this.children.length) {
                do {
                    !e && this.children[0].events && this.children[0].events.onRemovedFromGroup$dispatch(this.children[0], this);
                    var s = this.removeChild(this.children[0]);
                    this.removeFromHash(s), t && s && s.destroy(!0, i)
                } while (this.children.length > 0);
                this.hash = [], this.cursor = null
            }
        }, i.Group.prototype.removeBetween = function(t, e, i, s) {
            if (void 0 === e && (e = this.children.length - 1), void 0 === i && (i = !1), void 0 === s && (s = !1), 0 !== this.children.length) {
                if (t > e || t < 0 || e > this.children.length) return !1;
                for (var o = e; o >= t;) {
                    !s && this.children[o].events && this.children[o].events.onRemovedFromGroup$dispatch(this.children[o], this);
                    var n = this.removeChild(this.children[o]);
                    this.removeFromHash(n), i && n && n.destroy(!0), this.cursor === this.children[o] && (this.cursor = null), o--
                }
                this.updateZ()
            }
        }, i.Group.prototype.destroy = function(t, e) {
            null === this.game || this.ignoreDestroy || (void 0 === t && (t = !0), void 0 === e && (e = !1), this.onDestroy.dispatch(this, t, e), this.removeAll(t), this.cursor = null, this.filters = null, this.pendingDestroy = !1, e || (this.parent && this.parent.removeChild(this), this.game = null, this.exists = !1))
        }, Object.defineProperty(i.Group.prototype, "total", {
            get: function() {
                return this.iterate("exists", !0, i.Group.RETURN_TOTAL)
            }
        }), Object.defineProperty(i.Group.prototype, "length", {
            get: function() {
                return this.children.length
            }
        }), Object.defineProperty(i.Group.prototype, "angle", {
            get: function() {
                return i.Math.radToDeg(this.rotation)
            },
            set: function(t) {
                this.rotation = i.Math.degToRad(t)
            }
        }), Object.defineProperty(i.Group.prototype, "centerX", {
            get: function() {
                return this.getBounds(this.parent).centerX
            },
            set: function(t) {
                var e = this.getBounds(this.parent),
                    i = this.x - e.x;
                this.x = t + i - e.halfWidth
            }
        }), Object.defineProperty(i.Group.prototype, "centerY", {
            get: function() {
                return this.getBounds(this.parent).centerY
            },
            set: function(t) {
                var e = this.getBounds(this.parent),
                    i = this.y - e.y;
                this.y = t + i - e.halfHeight
            }
        }), Object.defineProperty(i.Group.prototype, "left", {
            get: function() {
                return this.getBounds(this.parent).left
            },
            set: function(t) {
                var e = this.getBounds(this.parent),
                    i = this.x - e.x;
                this.x = t + i
            }
        }), Object.defineProperty(i.Group.prototype, "right", {
            get: function() {
                return this.getBounds(this.parent).right
            },
            set: function(t) {
                var e = this.getBounds(this.parent),
                    i = this.x - e.x;
                this.x = t + i - e.width
            }
        }), Object.defineProperty(i.Group.prototype, "top", {
            get: function() {
                return this.getBounds(this.parent).top
            },
            set: function(t) {
                var e = this.getBounds(this.parent),
                    i = this.y - e.y;
                this.y = t + i
            }
        }), Object.defineProperty(i.Group.prototype, "bottom", {
            get: function() {
                return this.getBounds(this.parent).bottom
            },
            set: function(t) {
                var e = this.getBounds(this.parent),
                    i = this.y - e.y;
                this.y = t + i - e.height
            }
        }), i.World = function(t) {
            i.Group.call(this, t, null, "__world", !1), this.bounds = new i.Rectangle(0, 0, t.width, t.height), this.camera = null, this._definedSize = !1, this._width = t.width, this._height = t.height, this.game.state.onStateChange.add(this.stateChange, this)
        }, i.World.prototype = Object.create(i.Group.prototype), i.World.prototype.constructor = i.World, i.World.prototype.boot = function() {
            this.camera = new i.Camera(this.game, 0, 0, 0, this.game.width, this.game.height), this.game.stage.addChild(this), this.camera.boot()
        }, i.World.prototype.stateChange = function() {
            this.x = 0, this.y = 0, this.camera.reset()
        }, i.World.prototype.setBounds = function(t, e, i, s) {
            this._definedSize = !0, this._width = i, this._height = s, this.bounds.setTo(t, e, i, s), this.x = t, this.y = e, this.camera.bounds && this.camera.bounds.setTo(t, e, Math.max(i, this.game.width), Math.max(s, this.game.height)), this.game.physics.setBoundsToWorld()
        }, i.World.prototype.resize = function(t, e) {
            this._definedSize && (t < this._width && (t = this._width), e < this._height && (e = this._height)), this.bounds.width = t, this.bounds.height = e, this.game.camera.setBoundsToWorld(), this.game.physics.setBoundsToWorld()
        }, i.World.prototype.shutdown = function() {
            this.destroy(!0, !0)
        }, i.World.prototype.wrap = function(t, e, i, s, o) {
            void 0 === e && (e = 0), void 0 === i && (i = !1), void 0 === s && (s = !0), void 0 === o && (o = !0), i ? (t.getBounds(), s && (t.x + t._currentBounds.width < this.bounds.x ? t.x = this.bounds.right : t.x > this.bounds.right && (t.x = this.bounds.left)), o && (t.y + t._currentBounds.height < this.bounds.top ? t.y = this.bounds.bottom : t.y > this.bounds.bottom && (t.y = this.bounds.top))) : (s && t.x + e < this.bounds.x ? t.x = this.bounds.right + e : s && t.x - e > this.bounds.right && (t.x = this.bounds.left - e), o && t.y + e < this.bounds.top ? t.y = this.bounds.bottom + e : o && t.y - e > this.bounds.bottom && (t.y = this.bounds.top - e))
        }, Object.defineProperty(i.World.prototype, "width", {
            get: function() {
                return this.bounds.width
            },
            set: function(t) {
                t < this.game.width && (t = this.game.width), this.bounds.width = t, this._width = t, this._definedSize = !0
            }
        }), Object.defineProperty(i.World.prototype, "height", {
            get: function() {
                return this.bounds.height
            },
            set: function(t) {
                t < this.game.height && (t = this.game.height), this.bounds.height = t, this._height = t, this._definedSize = !0
            }
        }), Object.defineProperty(i.World.prototype, "centerX", {
            get: function() {
                return this.bounds.halfWidth + this.bounds.x
            }
        }), Object.defineProperty(i.World.prototype, "centerY", {
            get: function() {
                return this.bounds.halfHeight + this.bounds.y
            }
        }), Object.defineProperty(i.World.prototype, "randomX", {
            get: function() {
                return this.bounds.x < 0 ? this.game.rnd.between(this.bounds.x, this.bounds.width - Math.abs(this.bounds.x)) : this.game.rnd.between(this.bounds.x, this.bounds.width)
            }
        }), Object.defineProperty(i.World.prototype, "randomY", {
            get: function() {
                return this.bounds.y < 0 ? this.game.rnd.between(this.bounds.y, this.bounds.height - Math.abs(this.bounds.y)) : this.game.rnd.between(this.bounds.y, this.bounds.height)
            }
        }), i.Game = function(t, e, s, o, n, a, r, h) {
            return this.id = i.GAMES.push(this) - 1, this.config = null, this.physicsConfig = h, this.parent = "", this.width = 800, this.height = 600, this.resolution = 1, this._width = 800, this._height = 600, this.transparent = !1, this.antialias = !0, this.preserveDrawingBuffer = !1, this.clearBeforeRender = !0, this.renderer = null, this.renderType = i.AUTO, this.state = null, this.isBooted = !1, this.isRunning = !1, this.raf = null, this.add = null, this.make = null, this.cache = null, this.input = null, this.load = null, this.math = null, this.net = null, this.scale = null, this.sound = null, this.stage = null, this.time = null, this.tweens = null, this.world = null, this.physics = null, this.plugins = null, this.rnd = null, this.device = i.Device, this.camera = null, this.canvas = null, this.context = null, this.debug = null, this.particles = null, this.create = null, this.lockRender = !1, this.stepping = !1, this.pendingStep = !1, this.stepCount = 0, this.onPause = null, this.onResume = null, this.onBlur = null, this.onFocus = null, this._paused = !1, this._codePaused = !1, this.currentUpdateID = 0, this.updatesThisFrame = 1, this._deltaTime = 0, this._lastCount = 0, this._spiraling = 0, this._kickstart = !0, this.fpsProblemNotifier = new i.Signal, this.forceSingleUpdate = !0, this._nextFpsNotification = 0, 1 === arguments.length && "object" == typeof arguments[0] ? this.parseConfig(arguments[0]) : (this.config = {
                enableDebug: !0
            }, void 0 !== t && (this._width = t), void 0 !== e && (this._height = e), void 0 !== s && (this.renderType = s), void 0 !== o && (this.parent = o), void 0 !== a && (this.transparent = a), void 0 !== r && (this.antialias = r), this.rnd = new i.RandomDataGenerator([(Date.now() * Math.random()).toString()]), this.state = new i.StateManager(this, n)), this.device.whenReady(this.boot, this), this
        }, i.Game.prototype = {
            parseConfig: function(t) {
                this.config = t, void 0 === t.enableDebug && (this.config.enableDebug = !0), t.width && (this._width = t.width), t.height && (this._height = t.height), t.renderer && (this.renderType = t.renderer), t.parent && (this.parent = t.parent), void 0 !== t.transparent && (this.transparent = t.transparent), void 0 !== t.antialias && (this.antialias = t.antialias), t.resolution && (this.resolution = t.resolution), void 0 !== t.preserveDrawingBuffer && (this.preserveDrawingBuffer = t.preserveDrawingBuffer), t.physicsConfig && (this.physicsConfig = t.physicsConfig);
                var e = [(Date.now() * Math.random()).toString()];
                t.seed && (e = t.seed), this.rnd = new i.RandomDataGenerator(e);
                var s = null;
                t.state && (s = t.state), this.state = new i.StateManager(this, s)
            },
            boot: function() {
                this.isBooted || (this.onPause = new i.Signal, this.onResume = new i.Signal, this.onBlur = new i.Signal, this.onFocus = new i.Signal, this.isBooted = !0, PIXI.game = this, this.math = i.Math, this.scale = new i.ScaleManager(this, this._width, this._height), this.stage = new i.Stage(this), this.setUpRenderer(), this.world = new i.World(this), this.add = new i.GameObjectFactory(this), this.make = new i.GameObjectCreator(this), this.cache = new i.Cache(this), this.load = new i.Loader(this), this.time = new i.Time(this), this.tweens = new i.TweenManager(this), this.input = new i.Input(this), this.sound = new i.SoundManager(this), this.physics = new i.Physics(this, this.physicsConfig), this.particles = new i.Particles(this), this.create = new i.Create(this), this.plugins = new i.PluginManager(this), this.net = new i.Net(this), this.time.boot(), this.stage.boot(), this.world.boot(), this.scale.boot(), this.input.boot(), this.sound.boot(), this.state.boot(), this.config.enableDebug ? (this.debug = new i.Utils.Debug(this), this.debug.boot()) : this.debug = {
                    preUpdate: function() {},
                    update: function() {},
                    reset: function() {}
                }, this.showDebugHeader(), this.isRunning = !0, this.config && this.config.forceSetTimeOut ? this.raf = new i.RequestAnimationFrame(this, this.config.forceSetTimeOut) : this.raf = new i.RequestAnimationFrame(this, !1), this._kickstart = !0, window.focus && (!window.PhaserGlobal || window.PhaserGlobal && !window.PhaserGlobal.stopFocus) && window.focus(), this.raf.start())
            },
            showDebugHeader: function() {
                if (!window.PhaserGlobal || !window.PhaserGlobal.hideBanner) {
                    var t = i.VERSION,
                        e = "Canvas",
                        s = "HTML Audio",
                        o = 1;
                    if (this.renderType === i.WEBGL ? (e = "WebGL", o++) : this.renderType === i.HEADLESS && (e = "Headless"), this.device.webAudio && (s = "WebAudio", o++), this.device.chrome) {
                        for (var n = ["%c %c %c Phaser v" + t + " | Pixi.js | " + e + " | " + s + "  %c %c %c http://phaser.io %c♥%c♥%c♥", "background: #fb8cb3", "background: #d44a52", "color: #ffffff; background: #871905;", "background: #d44a52", "background: #fb8cb3", "background: #ffffff"], a = 0; a < 3; a++) a < o ? n.push("color: #ff2424; background: #fff") : n.push("color: #959595; background: #fff");
                        console.log.apply(console, n)
                    } else window.console && console.log("Phaser v" + t + " | Pixi.js " + PIXI.VERSION + " | " + e + " | " + s + " | http://phaser.io")
                }
            },
            setUpRenderer: function() {
                if (this.config.canvas ? this.canvas = this.config.canvas : this.canvas = i.Canvas.create(this, this.width, this.height, this.config.canvasID, !0), this.config.canvasStyle ? this.canvas.style = this.config.canvasStyle : this.canvas.style["-webkit-full-screen"] = "width: 100%; height: 100%", this.renderType === i.HEADLESS || this.renderType === i.CANVAS || this.renderType === i.AUTO && !this.device.webGL) {
                    if (!this.device.canvas) throw new Error("Phaser.Game - Cannot create Canvas or WebGL context, aborting.");
                    this.renderType = i.CANVAS, this.renderer = new PIXI.CanvasRenderer(this), this.context = this.renderer.context
                } else this.renderType = i.WEBGL, this.renderer = new PIXI.WebGLRenderer(this), this.context = null, this.canvas.addEventListener("webglcontextlost", this.contextLost.bind(this), !1), this.canvas.addEventListener("webglcontextrestored", this.contextRestored.bind(this), !1);
                this.device.cocoonJS && (this.canvas.screencanvas = this.renderType === i.CANVAS), this.renderType !== i.HEADLESS && (this.stage.smoothed = this.antialias, i.Canvas.addToDOM(this.canvas, this.parent, !1), i.Canvas.setTouchAction(this.canvas))
            },
            contextLost: function(t) {
                t.preventDefault(), this.renderer.contextLost = !0
            },
            contextRestored: function() {
                this.renderer.initContext(), this.cache.clearGLTextures(), this.renderer.contextLost = !1
            },
            update: function(t) {
                if (this.time.update(t), this._kickstart) return this.updateLogic(this.time.desiredFpsMult), this.updateRender(this.time.slowMotion * this.time.desiredFps), void(this._kickstart = !1);
                if (this._spiraling > 1 && !this.forceSingleUpdate) this.time.time > this._nextFpsNotification && (this._nextFpsNotification = this.time.time + 1e4, this.fpsProblemNotifier.dispatch()), this._deltaTime = 0, this._spiraling = 0, this.updateRender(this.time.slowMotion * this.time.desiredFps);
                else {
                    var e = 1e3 * this.time.slowMotion / this.time.desiredFps;
                    this._deltaTime += Math.max(Math.min(3 * e, this.time.elapsed), 0);
                    var i = 0;
                    for (this.updatesThisFrame = Math.floor(this._deltaTime / e), this.forceSingleUpdate && (this.updatesThisFrame = Math.min(1, this.updatesThisFrame)); this._deltaTime >= e && (this._deltaTime -= e, this.currentUpdateID = i, this.updateLogic(this.time.desiredFpsMult), i++, !this.forceSingleUpdate || 1 !== i);) this.time.refresh();
                    i > this._lastCount ? this._spiraling++ : i < this._lastCount && (this._spiraling = 0), this._lastCount = i, this.updateRender(this._deltaTime / e)
                }
            },
            updateLogic: function(t) {
                this._paused || this.pendingStep ? (this.scale.pauseUpdate(), this.state.pauseUpdate(), this.debug.preUpdate()) : (this.stepping && (this.pendingStep = !0), this.scale.preUpdate(), this.debug.preUpdate(), this.camera.preUpdate(), this.physics.preUpdate(), this.state.preUpdate(t), this.plugins.preUpdate(t), this.stage.preUpdate(), this.state.update(), this.stage.update(), this.tweens.update(), this.sound.update(), this.input.update(), this.physics.update(), this.particles.update(), this.plugins.update(), this.stage.postUpdate(), this.plugins.postUpdate()), this.stage.updateTransform()
            },
            updateRender: function(t) {
                this.lockRender || (this.state.preRender(t), this.renderType !== i.HEADLESS && (this.renderer.render(this.stage), this.plugins.render(t), this.state.render(t)), this.plugins.postRender(t))
            },
            enableStep: function() {
                this.stepping = !0, this.pendingStep = !1, this.stepCount = 0
            },
            disableStep: function() {
                this.stepping = !1, this.pendingStep = !1
            },
            step: function() {
                this.pendingStep = !1, this.stepCount++
            },
            destroy: function() {
                this.raf.stop(), this.state.destroy(), this.sound.destroy(), this.scale.destroy(), this.stage.destroy(), this.input.destroy(), this.physics.destroy(), this.plugins.destroy(), this.state = null, this.sound = null, this.scale = null, this.stage = null, this.input = null, this.physics = null, this.plugins = null, this.cache = null, this.load = null, this.time = null, this.world = null, this.isBooted = !1, this.renderer.destroy(!1), i.Canvas.removeFromDOM(this.canvas), PIXI.defaultRenderer = null, i.GAMES[this.id] = null
            },
            gamePaused: function(t) {
                this._paused || (this._paused = !0, this.time.gamePaused(), this.sound.muteOnPause && this.sound.setMute(), this.onPause.dispatch(t), this.device.cordova && this.device.iOS && (this.lockRender = !0))
            },
            gameResumed: function(t) {
                this._paused && !this._codePaused && (this._paused = !1, this.time.gameResumed(), this.input.reset(), this.sound.muteOnPause && this.sound.unsetMute(), this.onResume.dispatch(t), this.device.cordova && this.device.iOS && (this.lockRender = !1))
            },
            focusLoss: function(t) {
                this.onBlur.dispatch(t), this.stage.disableVisibilityChange || this.gamePaused(t)
            },
            focusGain: function(t) {
                this.onFocus.dispatch(t), this.stage.disableVisibilityChange || this.gameResumed(t)
            }
        }, i.Game.prototype.constructor = i.Game, Object.defineProperty(i.Game.prototype, "paused", {
            get: function() {
                return this._paused
            },
            set: function(t) {
                !0 === t ? (!1 === this._paused && (this._paused = !0, this.sound.setMute(), this.time.gamePaused(), this.onPause.dispatch(this)), this._codePaused = !0) : (this._paused && (this._paused = !1, this.input.reset(), this.sound.unsetMute(), this.time.gameResumed(), this.onResume.dispatch(this)), this._codePaused = !1)
            }
        }), i.Input = function(t) {
            this.game = t, this.hitCanvas = null, this.hitContext = null, this.moveCallbacks = [], this.customCandidateHandler = null, this.customCandidateHandlerContext = null, this.pollRate = 0, this.enabled = !0, this.multiInputOverride = i.Input.MOUSE_TOUCH_COMBINE, this.position = null, this.speed = null, this.circle = null, this.scale = null, this.maxPointers = -1, this.tapRate = 200, this.doubleTapRate = 300, this.holdRate = 2e3, this.justPressedRate = 200, this.justReleasedRate = 200, this.recordPointerHistory = !1, this.recordRate = 100, this.recordLimit = 100, this.pointer1 = null, this.pointer2 = null, this.pointer3 = null, this.pointer4 = null, this.pointer5 = null, this.pointer6 = null, this.pointer7 = null, this.pointer8 = null, this.pointer9 = null, this.pointer10 = null, this.pointers = [], this.activePointer = null, this.mousePointer = null, this.mouse = null, this.keyboard = null, this.touch = null, this.mspointer = null, this.gamepad = null, this.resetLocked = !1, this.onDown = null, this.onUp = null, this.onTap = null, this.onHold = null, this.minPriorityID = 0, this.interactiveItems = new i.ArraySet, this._localPoint = new i.Point, this._pollCounter = 0, this._oldPosition = null, this._x = 0, this._y = 0
        }, i.Input.MOUSE_OVERRIDES_TOUCH = 0, i.Input.TOUCH_OVERRIDES_MOUSE = 1, i.Input.MOUSE_TOUCH_COMBINE = 2, i.Input.MAX_POINTERS = 10, i.Input.prototype = {
            boot: function() {
                this.mousePointer = new i.Pointer(this.game, 0, i.PointerMode.CURSOR), this.addPointer(), this.addPointer(), this.mouse = new i.Mouse(this.game), this.touch = new i.Touch(this.game), this.mspointer = new i.MSPointer(this.game), i.Keyboard && (this.keyboard = new i.Keyboard(this.game)), i.Gamepad && (this.gamepad = new i.Gamepad(this.game)), this.onDown = new i.Signal, this.onUp = new i.Signal, this.onTap = new i.Signal, this.onHold = new i.Signal, this.scale = new i.Point(1, 1), this.speed = new i.Point, this.position = new i.Point, this._oldPosition = new i.Point, this.circle = new i.Circle(0, 0, 44), this.activePointer = this.mousePointer, this.hitCanvas = PIXI.CanvasPool.create(this, 1, 1), this.hitContext = this.hitCanvas.getContext("2d"), this.mouse.start(), this.touch.start(), this.mspointer.start(), this.mousePointer.active = !0, this.keyboard && this.keyboard.start();
                var t = this;
                this._onClickTrampoline = function(e) {
                    t.onClickTrampoline(e)
                }, this.game.canvas.addEventListener("click", this._onClickTrampoline, !1)
            },
            destroy: function() {
                this.mouse.stop(), this.touch.stop(), this.mspointer.stop(), this.keyboard && this.keyboard.stop(), this.gamepad && this.gamepad.stop(), this.moveCallbacks = [], PIXI.CanvasPool.remove(this), this.game.canvas.removeEventListener("click", this._onClickTrampoline)
            },
            setInteractiveCandidateHandler: function(t, e) {
                this.customCandidateHandler = t, this.customCandidateHandlerContext = e
            },
            addMoveCallback: function(t, e) {
                this.moveCallbacks.push({
                    callback: t,
                    context: e
                })
            },
            deleteMoveCallback: function(t, e) {
                for (var i = this.moveCallbacks.length; i--;)
                    if (this.moveCallbacks[i].callback === t && this.moveCallbacks[i].context === e) return void this.moveCallbacks.splice(i, 1)
            },
            addPointer: function() {
                if (this.pointers.length >= i.Input.MAX_POINTERS) return console.warn("Phaser.Input.addPointer: Maximum limit of " + i.Input.MAX_POINTERS + " pointers reached."), null;
                var t = this.pointers.length + 1,
                    e = new i.Pointer(this.game, t, i.PointerMode.TOUCH);
                return this.pointers.push(e), this["pointer" + t] = e, e
            },
            update: function() {
                if (this.keyboard && this.keyboard.update(), this.pollRate > 0 && this._pollCounter < this.pollRate) this._pollCounter++;
                else {
                    this.speed.x = this.position.x - this._oldPosition.x, this.speed.y = this.position.y - this._oldPosition.y, this._oldPosition.copyFrom(this.position), this.mousePointer.update(), this.gamepad && this.gamepad.active && this.gamepad.update();
                    for (var t = 0; t < this.pointers.length; t++) this.pointers[t].update();
                    this._pollCounter = 0
                }
            },
            reset: function(t) {
                if (this.game.isBooted && !this.resetLocked) {
                    void 0 === t && (t = !1), this.mousePointer.reset(), this.keyboard && this.keyboard.reset(t), this.gamepad && this.gamepad.reset();
                    for (var e = 0; e < this.pointers.length; e++) this.pointers[e].reset();
                    "none" !== this.game.canvas.style.cursor && (this.game.canvas.style.cursor = "inherit"), t && (this.onDown.dispose(), this.onUp.dispose(), this.onTap.dispose(), this.onHold.dispose(), this.onDown = new i.Signal, this.onUp = new i.Signal, this.onTap = new i.Signal, this.onHold = new i.Signal, this.moveCallbacks = []), this._pollCounter = 0
                }
            },
            resetSpeed: function(t, e) {
                this._oldPosition.setTo(t, e), this.speed.setTo(0, 0)
            },
            startPointer: function(t) {
                if (this.maxPointers >= 0 && this.countActivePointers(this.maxPointers) >= this.maxPointers) return null;
                if (!this.pointer1.active) return this.pointer1.start(t);
                if (!this.pointer2.active) return this.pointer2.start(t);
                for (var e = 2; e < this.pointers.length; e++) {
                    var i = this.pointers[e];
                    if (!i.active) return i.start(t)
                }
                return null
            },
            updatePointer: function(t) {
                if (this.pointer1.active && this.pointer1.identifier === t.identifier) return this.pointer1.move(t);
                if (this.pointer2.active && this.pointer2.identifier === t.identifier) return this.pointer2.move(t);
                for (var e = 2; e < this.pointers.length; e++) {
                    var i = this.pointers[e];
                    if (i.active && i.identifier === t.identifier) return i.move(t)
                }
                return null
            },
            stopPointer: function(t) {
                if (this.pointer1.active && this.pointer1.identifier === t.identifier) return this.pointer1.stop(t);
                if (this.pointer2.active && this.pointer2.identifier === t.identifier) return this.pointer2.stop(t);
                for (var e = 2; e < this.pointers.length; e++) {
                    var i = this.pointers[e];
                    if (i.active && i.identifier === t.identifier) return i.stop(t)
                }
                return null
            },
            countActivePointers: function(t) {
                void 0 === t && (t = this.pointers.length);
                for (var e = t, i = 0; i < this.pointers.length && e > 0; i++) this.pointers[i].active && e--;
                return t - e
            },
            getPointer: function(t) {
                void 0 === t && (t = !1);
                for (var e = 0; e < this.pointers.length; e++) {
                    var i = this.pointers[e];
                    if (i.active === t) return i
                }
                return null
            },
            getPointerFromIdentifier: function(t) {
                for (var e = 0; e < this.pointers.length; e++) {
                    var i = this.pointers[e];
                    if (i.identifier === t) return i
                }
                return null
            },
            getPointerFromId: function(t) {
                for (var e = 0; e < this.pointers.length; e++) {
                    var i = this.pointers[e];
                    if (i.pointerId === t) return i
                }
                return null
            },
            getLocalPosition: function(t, e, s) {
                void 0 === s && (s = new i.Point);
                var o = t.worldTransform,
                    n = 1 / (o.a * o.d + o.c * -o.b);
                return s.setTo(o.d * n * e.x + -o.c * n * e.y + (o.ty * o.c - o.tx * o.d) * n, o.a * n * e.y + -o.b * n * e.x + (-o.ty * o.a + o.tx * o.b) * n)
            },
            hitTest: function(t, e, s) {
                if (!t.worldVisible) return !1;
                if (this.getLocalPosition(t, e, this._localPoint), s.copyFrom(this._localPoint), t.hitArea && t.hitArea.contains) return t.hitArea.contains(this._localPoint.x, this._localPoint.y);
                if (t instanceof i.TileSprite) {
                    var o = t.width,
                        n = t.height,
                        a = -o * t.anchor.x;
                    if (this._localPoint.x >= a && this._localPoint.x < a + o) {
                        r = -n * t.anchor.y;
                        if (this._localPoint.y >= r && this._localPoint.y < r + n) return !0
                    }
                } else if (t instanceof PIXI.Sprite) {
                    var o = t.texture.frame.width,
                        n = t.texture.frame.height,
                        a = -o * t.anchor.x;
                    if (this._localPoint.x >= a && this._localPoint.x < a + o) {
                        var r = -n * t.anchor.y;
                        if (this._localPoint.y >= r && this._localPoint.y < r + n) return !0
                    }
                } else if (t instanceof i.Graphics)
                    for (l = 0; l < t.graphicsData.length; l++) {
                        var h = t.graphicsData[l];
                        if (h.fill && h.shape && h.shape.contains(this._localPoint.x, this._localPoint.y)) return !0
                    }
                for (var l = 0; l < t.children.length; l++)
                    if (this.hitTest(t.children[l], e, s)) return !0;
                return !1
            },
            onClickTrampoline: function() {
                this.activePointer.processClickTrampolines()
            }
        }, i.Input.prototype.constructor = i.Input, Object.defineProperty(i.Input.prototype, "x", {
            get: function() {
                return this._x
            },
            set: function(t) {
                this._x = Math.floor(t)
            }
        }), Object.defineProperty(i.Input.prototype, "y", {
            get: function() {
                return this._y
            },
            set: function(t) {
                this._y = Math.floor(t)
            }
        }), Object.defineProperty(i.Input.prototype, "pollLocked", {
            get: function() {
                return this.pollRate > 0 && this._pollCounter < this.pollRate
            }
        }), Object.defineProperty(i.Input.prototype, "totalInactivePointers", {
            get: function() {
                return this.pointers.length - this.countActivePointers()
            }
        }), Object.defineProperty(i.Input.prototype, "totalActivePointers", {
            get: function() {
                return this.countActivePointers()
            }
        }), Object.defineProperty(i.Input.prototype, "worldX", {
            get: function() {
                return this.game.camera.view.x + this.x
            }
        }), Object.defineProperty(i.Input.prototype, "worldY", {
            get: function() {
                return this.game.camera.view.y + this.y
            }
        }), i.Mouse = function(t) {
            this.game = t, this.input = t.input, this.callbackContext = this.game, this.mouseDownCallback = null, this.mouseUpCallback = null, this.mouseOutCallback = null, this.mouseOverCallback = null, this.mouseWheelCallback = null, this.capture = !1, this.button = -1, this.wheelDelta = 0, this.enabled = !0, this.locked = !1, this.stopOnGameOut = !1, this.pointerLock = new i.Signal, this.event = null, this._onMouseDown = null, this._onMouseMove = null, this._onMouseUp = null, this._onMouseOut = null, this._onMouseOver = null, this._onMouseWheel = null, this._wheelEvent = null
        }, i.Mouse.NO_BUTTON = -1, i.Mouse.LEFT_BUTTON = 0, i.Mouse.MIDDLE_BUTTON = 1, i.Mouse.RIGHT_BUTTON = 2, i.Mouse.BACK_BUTTON = 3, i.Mouse.FORWARD_BUTTON = 4, i.Mouse.WHEEL_UP = 1, i.Mouse.WHEEL_DOWN = -1, i.Mouse.prototype = {
            start: function() {
                if ((!this.game.device.android || !1 !== this.game.device.chrome) && null === this._onMouseDown) {
                    var e = this;
                    this._onMouseDown = function(t) {
                        return e.onMouseDown(t)
                    }, this._onMouseMove = function(t) {
                        return e.onMouseMove(t)
                    }, this._onMouseUp = function(t) {
                        return e.onMouseUp(t)
                    }, this._onMouseUpGlobal = function(t) {
                        return e.onMouseUpGlobal(t)
                    }, this._onMouseOutGlobal = function(t) {
                        return e.onMouseOutGlobal(t)
                    }, this._onMouseOut = function(t) {
                        return e.onMouseOut(t)
                    }, this._onMouseOver = function(t) {
                        return e.onMouseOver(t)
                    }, this._onMouseWheel = function(t) {
                        return e.onMouseWheel(t)
                    };
                    var i = this.game.canvas;
                    i.addEventListener("mousedown", this._onMouseDown, !0), i.addEventListener("mousemove", this._onMouseMove, !0), i.addEventListener("mouseup", this._onMouseUp, !0), this.game.device.cocoonJS || (window.addEventListener("mouseup", this._onMouseUpGlobal, !0), window.addEventListener("mouseout", this._onMouseOutGlobal, !0), i.addEventListener("mouseover", this._onMouseOver, !0), i.addEventListener("mouseout", this._onMouseOut, !0));
                    var s = this.game.device.wheelEvent;
                    s && (i.addEventListener(s, this._onMouseWheel, !0), "mousewheel" === s ? this._wheelEvent = new t(-.025, 1) : "DOMMouseScroll" === s && (this._wheelEvent = new t(1, 1)))
                }
            },
            onMouseDown: function(t) {
                this.event = t, this.capture && t.preventDefault(), this.mouseDownCallback && this.mouseDownCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = 0, this.input.mousePointer.start(t))
            },
            onMouseMove: function(t) {
                this.event = t, this.capture && t.preventDefault(), this.mouseMoveCallback && this.mouseMoveCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = 0, this.input.mousePointer.move(t))
            },
            onMouseUp: function(t) {
                this.event = t, this.capture && t.preventDefault(), this.mouseUpCallback && this.mouseUpCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = 0, this.input.mousePointer.stop(t))
            },
            onMouseUpGlobal: function(t) {
                this.input.mousePointer.withinGame || (this.mouseUpCallback && this.mouseUpCallback.call(this.callbackContext, t), t.identifier = 0, this.input.mousePointer.stop(t))
            },
            onMouseOutGlobal: function(t) {
                this.event = t, this.capture && t.preventDefault(), this.input.mousePointer.withinGame = !1, this.input.enabled && this.enabled && (this.input.mousePointer.stop(t), this.input.mousePointer.leftButton.stop(t), this.input.mousePointer.rightButton.stop(t))
            },
            onMouseOut: function(t) {
                this.event = t, this.capture && t.preventDefault(), this.input.mousePointer.withinGame = !1, this.mouseOutCallback && this.mouseOutCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && this.stopOnGameOut && (t.identifier = 0, this.input.mousePointer.stop(t))
            },
            onMouseOver: function(t) {
                this.event = t, this.capture && t.preventDefault(), this.input.mousePointer.withinGame = !0, this.mouseOverCallback && this.mouseOverCallback.call(this.callbackContext, t)
            },
            onMouseWheel: function(t) {
                this._wheelEvent && (t = this._wheelEvent.bindEvent(t)), this.event = t, this.capture && t.preventDefault(), this.wheelDelta = i.Math.clamp(-t.deltaY, -1, 1), this.mouseWheelCallback && this.mouseWheelCallback.call(this.callbackContext, t)
            },
            requestPointerLock: function() {
                if (this.game.device.pointerLock) {
                    var t = this.game.canvas;
                    t.requestPointerLock = t.requestPointerLock || t.mozRequestPointerLock || t.webkitRequestPointerLock, t.requestPointerLock();
                    var e = this;
                    this._pointerLockChange = function(t) {
                        return e.pointerLockChange(t)
                    }, document.addEventListener("pointerlockchange", this._pointerLockChange, !0), document.addEventListener("mozpointerlockchange", this._pointerLockChange, !0), document.addEventListener("webkitpointerlockchange", this._pointerLockChange, !0)
                }
            },
            pointerLockChange: function(t) {
                var e = this.game.canvas;
                document.pointerLockElement === e || document.mozPointerLockElement === e || document.webkitPointerLockElement === e ? (this.locked = !0, this.pointerLock.dispatch(!0, t)) : (this.locked = !1, this.pointerLock.dispatch(!1, t))
            },
            releasePointerLock: function() {
                document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock, document.exitPointerLock(), document.removeEventListener("pointerlockchange", this._pointerLockChange, !0), document.removeEventListener("mozpointerlockchange", this._pointerLockChange, !0), document.removeEventListener("webkitpointerlockchange", this._pointerLockChange, !0)
            },
            stop: function() {
                var t = this.game.canvas;
                t.removeEventListener("mousedown", this._onMouseDown, !0), t.removeEventListener("mousemove", this._onMouseMove, !0), t.removeEventListener("mouseup", this._onMouseUp, !0), t.removeEventListener("mouseover", this._onMouseOver, !0), t.removeEventListener("mouseout", this._onMouseOut, !0);
                var e = this.game.device.wheelEvent;
                e && t.removeEventListener(e, this._onMouseWheel, !0), window.removeEventListener("mouseup", this._onMouseUpGlobal, !0), window.removeEventListener("mouseout", this._onMouseOutGlobal, !0), document.removeEventListener("pointerlockchange", this._pointerLockChange, !0), document.removeEventListener("mozpointerlockchange", this._pointerLockChange, !0), document.removeEventListener("webkitpointerlockchange", this._pointerLockChange, !0)
            }
        }, i.Mouse.prototype.constructor = i.Mouse, (t.prototype = {}).constructor = t, t.prototype.bindEvent = function(e) {
            if (!t._stubsGenerated && e) {
                for (var i in e) i in t.prototype || Object.defineProperty(t.prototype, i, {
                    get: function(t) {
                        return function() {
                            var e = this.originalEvent[t];
                            return "function" != typeof e ? e : e.bind(this.originalEvent)
                        }
                    }(i)
                });
                t._stubsGenerated = !0
            }
            return this.originalEvent = e, this
        }, Object.defineProperties(t.prototype, {
            type: {
                value: "wheel"
            },
            deltaMode: {
                get: function() {
                    return this._deltaMode
                }
            },
            deltaY: {
                get: function() {
                    return this._scaleFactor * (this.originalEvent.wheelDelta || this.originalEvent.detail) || 0
                }
            },
            deltaX: {
                get: function() {
                    return this._scaleFactor * this.originalEvent.wheelDeltaX || 0
                }
            },
            deltaZ: {
                value: 0
            }
        }), i.MSPointer = function(t) {
            this.game = t, this.input = t.input, this.callbackContext = this.game, this.pointerDownCallback = null, this.pointerMoveCallback = null, this.pointerUpCallback = null, this.capture = !0, this.button = -1, this.event = null, this.enabled = !0, this._onMSPointerDown = null, this._onMSPointerMove = null, this._onMSPointerUp = null, this._onMSPointerUpGlobal = null, this._onMSPointerOut = null, this._onMSPointerOver = null
        }, i.MSPointer.prototype = {
            start: function() {
                if (null === this._onMSPointerDown) {
                    var t = this;
                    if (this.game.device.mspointer) {
                        this._onMSPointerDown = function(e) {
                            return t.onPointerDown(e)
                        }, this._onMSPointerMove = function(e) {
                            return t.onPointerMove(e)
                        }, this._onMSPointerUp = function(e) {
                            return t.onPointerUp(e)
                        }, this._onMSPointerUpGlobal = function(e) {
                            return t.onPointerUpGlobal(e)
                        }, this._onMSPointerOut = function(e) {
                            return t.onPointerOut(e)
                        }, this._onMSPointerOver = function(e) {
                            return t.onPointerOver(e)
                        };
                        var e = this.game.canvas;
                        e.addEventListener("MSPointerDown", this._onMSPointerDown, !1), e.addEventListener("MSPointerMove", this._onMSPointerMove, !1), e.addEventListener("MSPointerUp", this._onMSPointerUp, !1), e.addEventListener("pointerdown", this._onMSPointerDown, !1), e.addEventListener("pointermove", this._onMSPointerMove, !1), e.addEventListener("pointerup", this._onMSPointerUp, !1), e.style["-ms-content-zooming"] = "none", e.style["-ms-touch-action"] = "none", this.game.device.cocoonJS || (window.addEventListener("MSPointerUp", this._onMSPointerUpGlobal, !0), e.addEventListener("MSPointerOver", this._onMSPointerOver, !0), e.addEventListener("MSPointerOut", this._onMSPointerOut, !0), window.addEventListener("pointerup", this._onMSPointerUpGlobal, !0), e.addEventListener("pointerover", this._onMSPointerOver, !0), e.addEventListener("pointerout", this._onMSPointerOut, !0))
                    }
                }
            },
            onPointerDown: function(t) {
                this.event = t, this.capture && t.preventDefault(), this.pointerDownCallback && this.pointerDownCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = t.pointerId, "mouse" === t.pointerType || 4 === t.pointerType ? this.input.mousePointer.start(t) : this.input.startPointer(t))
            },
            onPointerMove: function(t) {
                this.event = t, this.capture && t.preventDefault(), this.pointerMoveCallback && this.pointerMoveCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = t.pointerId, "mouse" === t.pointerType || 4 === t.pointerType ? this.input.mousePointer.move(t) : this.input.updatePointer(t))
            },
            onPointerUp: function(t) {
                this.event = t, this.capture && t.preventDefault(), this.pointerUpCallback && this.pointerUpCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = t.pointerId, "mouse" === t.pointerType || 4 === t.pointerType ? this.input.mousePointer.stop(t) : this.input.stopPointer(t))
            },
            onPointerUpGlobal: function(t) {
                if ("mouse" !== t.pointerType && 4 !== t.pointerType || this.input.mousePointer.withinGame) {
                    var e = this.input.getPointerFromIdentifier(t.identifier);
                    e && e.withinGame && this.onPointerUp(t)
                } else this.onPointerUp(t)
            },
            onPointerOut: function(t) {
                if (this.event = t, this.capture && t.preventDefault(), "mouse" === t.pointerType || 4 === t.pointerType) this.input.mousePointer.withinGame = !1;
                else {
                    var e = this.input.getPointerFromIdentifier(t.identifier);
                    e && (e.withinGame = !1)
                }
                this.input.mouse.mouseOutCallback && this.input.mouse.mouseOutCallback.call(this.input.mouse.callbackContext, t), this.input.enabled && this.enabled && this.input.mouse.stopOnGameOut && (t.identifier = 0, e ? e.stop(t) : this.input.mousePointer.stop(t))
            },
            onPointerOver: function(t) {
                if (this.event = t, this.capture && t.preventDefault(), "mouse" === t.pointerType || 4 === t.pointerType) this.input.mousePointer.withinGame = !0;
                else {
                    var e = this.input.getPointerFromIdentifier(t.identifier);
                    e && (e.withinGame = !0)
                }
                this.input.mouse.mouseOverCallback && this.input.mouse.mouseOverCallback.call(this.input.mouse.callbackContext, t)
            },
            stop: function() {
                var t = this.game.canvas;
                t.removeEventListener("MSPointerDown", this._onMSPointerDown, !1), t.removeEventListener("MSPointerMove", this._onMSPointerMove, !1), t.removeEventListener("MSPointerUp", this._onMSPointerUp, !1), t.removeEventListener("pointerdown", this._onMSPointerDown, !1), t.removeEventListener("pointermove", this._onMSPointerMove, !1), t.removeEventListener("pointerup", this._onMSPointerUp, !1), window.removeEventListener("MSPointerUp", this._onMSPointerUpGlobal, !0), t.removeEventListener("MSPointerOver", this._onMSPointerOver, !0), t.removeEventListener("MSPointerOut", this._onMSPointerOut, !0), window.removeEventListener("pointerup", this._onMSPointerUpGlobal, !0), t.removeEventListener("pointerover", this._onMSPointerOver, !0), t.removeEventListener("pointerout", this._onMSPointerOut, !0)
            }
        }, i.MSPointer.prototype.constructor = i.MSPointer, i.DeviceButton = function(t, e) {
            this.parent = t, this.game = t.game, this.event = null, this.isDown = !1, this.isUp = !0, this.timeDown = 0, this.timeUp = 0, this.repeats = 0, this.altKey = !1, this.shiftKey = !1, this.ctrlKey = !1, this.value = 0, this.buttonCode = e, this.onDown = new i.Signal, this.onUp = new i.Signal, this.onFloat = new i.Signal
        }, i.DeviceButton.prototype = {
            start: function(t, e) {
                this.isDown || (this.isDown = !0, this.isUp = !1, this.timeDown = this.game.time.time, this.repeats = 0, this.event = t, this.value = e, t && (this.altKey = t.altKey, this.shiftKey = t.shiftKey, this.ctrlKey = t.ctrlKey), this.onDown.dispatch(this, e))
            },
            stop: function(t, e) {
                this.isUp || (this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, this.event = t, this.value = e, t && (this.altKey = t.altKey, this.shiftKey = t.shiftKey, this.ctrlKey = t.ctrlKey), this.onUp.dispatch(this, e))
            },
            padFloat: function(t) {
                this.value = t, this.onFloat.dispatch(this, t)
            },
            justPressed: function(t) {
                return t = t || 250, this.isDown && this.timeDown + t > this.game.time.time
            },
            justReleased: function(t) {
                return t = t || 250, this.isUp && this.timeUp + t > this.game.time.time
            },
            reset: function() {
                this.isDown = !1, this.isUp = !0, this.timeDown = this.game.time.time, this.repeats = 0, this.altKey = !1, this.shiftKey = !1, this.ctrlKey = !1
            },
            destroy: function() {
                this.onDown.dispose(), this.onUp.dispose(), this.onFloat.dispose(), this.parent = null, this.game = null
            }
        }, i.DeviceButton.prototype.constructor = i.DeviceButton, Object.defineProperty(i.DeviceButton.prototype, "duration", {
            get: function() {
                return this.isUp ? -1 : this.game.time.time - this.timeDown
            }
        }), i.Pointer = function(t, e, s) {
            this.game = t, this.id = e, this.type = i.POINTER, this.exists = !0, this.identifier = 0, this.pointerId = null, this.pointerMode = s || i.PointerMode.CURSOR | i.PointerMode.CONTACT, this.target = null, this.button = null, this.leftButton = new i.DeviceButton(this, i.Pointer.LEFT_BUTTON), this.middleButton = new i.DeviceButton(this, i.Pointer.MIDDLE_BUTTON), this.rightButton = new i.DeviceButton(this, i.Pointer.RIGHT_BUTTON), this.backButton = new i.DeviceButton(this, i.Pointer.BACK_BUTTON), this.forwardButton = new i.DeviceButton(this, i.Pointer.FORWARD_BUTTON), this.eraserButton = new i.DeviceButton(this, i.Pointer.ERASER_BUTTON), this._holdSent = !1, this._history = [], this._nextDrop = 0, this._stateReset = !1, this.withinGame = !1, this.clientX = -1, this.clientY = -1, this.pageX = -1, this.pageY = -1, this.screenX = -1, this.screenY = -1, this.rawMovementX = 0, this.rawMovementY = 0, this.movementX = 0, this.movementY = 0, this.x = -1, this.y = -1, this.isMouse = 0 === e, this.isDown = !1, this.isUp = !0, this.timeDown = 0, this.timeUp = 0, this.previousTapTime = 0, this.totalTouches = 0, this.msSinceLastClick = Number.MAX_VALUE, this.targetObject = null, this.interactiveCandidates = [], this.active = !1, this.dirty = !1, this.position = new i.Point, this.positionDown = new i.Point, this.positionUp = new i.Point, this.circle = new i.Circle(0, 0, 44), this._clickTrampolines = null, this._trampolineTargetObject = null
        }, i.Pointer.NO_BUTTON = 0, i.Pointer.LEFT_BUTTON = 1, i.Pointer.RIGHT_BUTTON = 2, i.Pointer.MIDDLE_BUTTON = 4, i.Pointer.BACK_BUTTON = 8, i.Pointer.FORWARD_BUTTON = 16, i.Pointer.ERASER_BUTTON = 32, i.Pointer.prototype = {
            resetButtons: function() {
                this.isDown = !1, this.isUp = !0, this.isMouse && (this.leftButton.reset(), this.middleButton.reset(), this.rightButton.reset(), this.backButton.reset(), this.forwardButton.reset(), this.eraserButton.reset())
            },
            processButtonsDown: function(t, e) {
                i.Pointer.LEFT_BUTTON & t && this.leftButton.start(e), i.Pointer.RIGHT_BUTTON & t && this.rightButton.start(e), i.Pointer.MIDDLE_BUTTON & t && this.middleButton.start(e), i.Pointer.BACK_BUTTON & t && this.backButton.start(e), i.Pointer.FORWARD_BUTTON & t && this.forwardButton.start(e), i.Pointer.ERASER_BUTTON & t && this.eraserButton.start(e)
            },
            processButtonsUp: function(t, e) {
                t === i.Mouse.LEFT_BUTTON && this.leftButton.stop(e), t === i.Mouse.RIGHT_BUTTON && this.rightButton.stop(e), t === i.Mouse.MIDDLE_BUTTON && this.middleButton.stop(e), t === i.Mouse.BACK_BUTTON && this.backButton.stop(e), t === i.Mouse.FORWARD_BUTTON && this.forwardButton.stop(e), 5 === t && this.eraserButton.stop(e)
            },
            updateButtons: function(t) {
                this.button = t.button;
                var e = "down" === t.type.toLowerCase().substr(-4);
                void 0 !== t.buttons ? e ? this.processButtonsDown(t.buttons, t) : this.processButtonsUp(t.button, t) : e ? this.leftButton.start(t) : (this.leftButton.stop(t), this.rightButton.stop(t)), 1 === t.buttons && t.ctrlKey && this.leftButton.isDown && (this.leftButton.stop(t), this.rightButton.start(t)), this.isUp = !0, this.isDown = !1, (this.leftButton.isDown || this.rightButton.isDown || this.middleButton.isDown || this.backButton.isDown || this.forwardButton.isDown || this.eraserButton.isDown) && (this.isUp = !1, this.isDown = !0)
            },
            start: function(t) {
                var e = this.game.input;
                return t.pointerId && (this.pointerId = t.pointerId), this.identifier = t.identifier, this.target = t.target, this.isMouse ? this.updateButtons(t) : (this.isDown = !0, this.isUp = !1), this.active = !0, this.withinGame = !0, this.dirty = !1, this._history = [], this._clickTrampolines = null, this._trampolineTargetObject = null, this.msSinceLastClick = this.game.time.time - this.timeDown, this.timeDown = this.game.time.time, this._holdSent = !1, this.move(t, !0), this.positionDown.setTo(this.x, this.y), (e.multiInputOverride === i.Input.MOUSE_OVERRIDES_TOUCH || e.multiInputOverride === i.Input.MOUSE_TOUCH_COMBINE || e.multiInputOverride === i.Input.TOUCH_OVERRIDES_MOUSE && 0 === e.totalActivePointers) && (e.x = this.x, e.y = this.y, e.position.setTo(this.x, this.y), e.onDown.dispatch(this, t), e.resetSpeed(this.x, this.y)), this._stateReset = !1, this.totalTouches++, null !== this.targetObject && this.targetObject._touchedHandler(this), this
            },
            update: function() {
                var t = this.game.input;
                this.active && (this.dirty && (t.interactiveItems.total > 0 && this.processInteractiveObjects(!1), this.dirty = !1), !1 === this._holdSent && this.duration >= t.holdRate && ((t.multiInputOverride === i.Input.MOUSE_OVERRIDES_TOUCH || t.multiInputOverride === i.Input.MOUSE_TOUCH_COMBINE || t.multiInputOverride === i.Input.TOUCH_OVERRIDES_MOUSE && 0 === t.totalActivePointers) && t.onHold.dispatch(this), this._holdSent = !0), t.recordPointerHistory && this.game.time.time >= this._nextDrop && (this._nextDrop = this.game.time.time + t.recordRate, this._history.push({
                    x: this.position.x,
                    y: this.position.y
                }), this._history.length > t.recordLimit && this._history.shift()))
            },
            move: function(t, e) {
                var s = this.game.input;
                if (!s.pollLocked) {
                    if (void 0 === e && (e = !1), void 0 !== t.button && (this.button = t.button), e && this.isMouse && this.updateButtons(t), this.clientX = t.clientX, this.clientY = t.clientY, this.pageX = t.pageX, this.pageY = t.pageY, this.screenX = t.screenX, this.screenY = t.screenY, this.isMouse && s.mouse.locked && !e && (this.rawMovementX = t.movementX || t.mozMovementX || t.webkitMovementX || 0, this.rawMovementY = t.movementY || t.mozMovementY || t.webkitMovementY || 0, this.movementX += this.rawMovementX, this.movementY += this.rawMovementY), this.x = (this.pageX - this.game.scale.offset.x) * s.scale.x, this.y = (this.pageY - this.game.scale.offset.y) * s.scale.y, this.position.setTo(this.x, this.y), this.circle.x = this.x, this.circle.y = this.y, (s.multiInputOverride === i.Input.MOUSE_OVERRIDES_TOUCH || s.multiInputOverride === i.Input.MOUSE_TOUCH_COMBINE || s.multiInputOverride === i.Input.TOUCH_OVERRIDES_MOUSE && 0 === s.totalActivePointers) && (s.activePointer = this, s.x = this.x, s.y = this.y, s.position.setTo(s.x, s.y), s.circle.x = s.x, s.circle.y = s.y), this.withinGame = this.game.scale.bounds.contains(this.pageX, this.pageY), this.game.paused) return this;
                    for (var o = s.moveCallbacks.length; o--;) s.moveCallbacks[o].callback.call(s.moveCallbacks[o].context, this, this.x, this.y, e);
                    return null !== this.targetObject && !0 === this.targetObject.isDragged ? !1 === this.targetObject.update(this) && (this.targetObject = null) : s.interactiveItems.total > 0 && this.processInteractiveObjects(e), this
                }
            },
            processInteractiveObjects: function(t) {
                var e = 0,
                    i = -1,
                    s = null,
                    o = this.game.input.interactiveItems.first;
                for (this.interactiveCandidates = []; o;) o.checked = !1, o.validForInput(i, e, !1) && (o.checked = !0, (t && o.checkPointerDown(this, !0) || !t && o.checkPointerOver(this, !0)) && (e = o.sprite.renderOrderID, i = o.priorityID, s = o, this.interactiveCandidates.push(o))), o = this.game.input.interactiveItems.next;
                for (o = this.game.input.interactiveItems.first; o;) !o.checked && o.validForInput(i, e, !0) && (t && o.checkPointerDown(this, !1) || !t && o.checkPointerOver(this, !1)) && (e = o.sprite.renderOrderID, i = o.priorityID, s = o, this.interactiveCandidates.push(o)), o = this.game.input.interactiveItems.next;
                return this.game.input.customCandidateHandler && (s = this.game.input.customCandidateHandler.call(this.game.input.customCandidateHandlerContext, this, this.interactiveCandidates, s)), this.swapTarget(s, !1), null !== this.targetObject
            },
            swapTarget: function(t, e) {
                void 0 === e && (e = !1), null === t ? this.targetObject && (this.targetObject._pointerOutHandler(this, e), this.targetObject = null) : null === this.targetObject ? (this.targetObject = t, t._pointerOverHandler(this, e)) : this.targetObject === t ? !1 === t.update(this) && (this.targetObject = null) : (this.targetObject._pointerOutHandler(this, e), this.targetObject = t, this.targetObject._pointerOverHandler(this, e))
            },
            leave: function(t) {
                this.withinGame = !1, this.move(t, !1)
            },
            stop: function(t) {
                var e = this.game.input;
                return this._stateReset && this.withinGame ? void t.preventDefault() : (this.timeUp = this.game.time.time, (e.multiInputOverride === i.Input.MOUSE_OVERRIDES_TOUCH || e.multiInputOverride === i.Input.MOUSE_TOUCH_COMBINE || e.multiInputOverride === i.Input.TOUCH_OVERRIDES_MOUSE && 0 === e.totalActivePointers) && (e.onUp.dispatch(this, t), this.duration >= 0 && this.duration <= e.tapRate && (this.timeUp - this.previousTapTime < e.doubleTapRate ? e.onTap.dispatch(this, !0) : e.onTap.dispatch(this, !1), this.previousTapTime = this.timeUp)), this.isMouse ? this.updateButtons(t) : (this.isDown = !1, this.isUp = !0), this.id > 0 && (this.active = !1), this.withinGame = this.game.scale.bounds.contains(t.pageX, t.pageY), this.pointerId = null, this.identifier = null, this.positionUp.setTo(this.x, this.y), !1 === this.isMouse && e.currentPointers--, e.interactiveItems.callAll("_releasedHandler", this), this._clickTrampolines && (this._trampolineTargetObject = this.targetObject), this.targetObject = null, this)
            },
            justPressed: function(t) {
                return t = t || this.game.input.justPressedRate, !0 === this.isDown && this.timeDown + t > this.game.time.time
            },
            justReleased: function(t) {
                return t = t || this.game.input.justReleasedRate, this.isUp && this.timeUp + t > this.game.time.time
            },
            addClickTrampoline: function(t, e, i, s) {
                if (this.isDown) {
                    for (var o = this._clickTrampolines = this._clickTrampolines || [], n = 0; n < o.length; n++)
                        if (o[n].name === t) {
                            o.splice(n, 1);
                            break
                        }
                    o.push({
                        name: t,
                        targetObject: this.targetObject,
                        callback: e,
                        callbackContext: i,
                        callbackArgs: s
                    })
                }
            },
            processClickTrampolines: function() {
                var t = this._clickTrampolines;
                if (t) {
                    for (var e = 0; e < t.length; e++) {
                        var i = t[e];
                        i.targetObject === this._trampolineTargetObject && i.callback.apply(i.callbackContext, i.callbackArgs)
                    }
                    this._clickTrampolines = null, this._trampolineTargetObject = null
                }
            },
            reset: function() {
                !1 === this.isMouse && (this.active = !1), this.pointerId = null, this.identifier = null, this.dirty = !1, this.totalTouches = 0, this._holdSent = !1, this._history.length = 0, this._stateReset = !0, this.resetButtons(), this.targetObject && this.targetObject._releasedHandler(this), this.targetObject = null
            },
            resetMovement: function() {
                this.movementX = 0, this.movementY = 0
            }
        }, i.Pointer.prototype.constructor = i.Pointer, Object.defineProperty(i.Pointer.prototype, "duration", {
            get: function() {
                return this.isUp ? -1 : this.game.time.time - this.timeDown
            }
        }), Object.defineProperty(i.Pointer.prototype, "worldX", {
            get: function() {
                return this.game.world.camera.x + this.x
            }
        }), Object.defineProperty(i.Pointer.prototype, "worldY", {
            get: function() {
                return this.game.world.camera.y + this.y
            }
        }), i.PointerMode = {
            CURSOR: 1,
            CONTACT: 2
        }, i.Touch = function(t) {
            this.game = t, this.enabled = !0, this.touchLockCallbacks = [], this.callbackContext = this.game, this.touchStartCallback = null, this.touchMoveCallback = null, this.touchEndCallback = null, this.touchEnterCallback = null, this.touchLeaveCallback = null, this.touchCancelCallback = null, this.preventDefault = !0, this.event = null, this._onTouchStart = null, this._onTouchMove = null, this._onTouchEnd = null, this._onTouchEnter = null, this._onTouchLeave = null, this._onTouchCancel = null, this._onTouchMove = null
        }, i.Touch.prototype = {
            start: function() {
                if (null === this._onTouchStart) {
                    var t = this;
                    this.game.device.touch && (this._onTouchStart = function(e) {
                        return t.onTouchStart(e)
                    }, this._onTouchMove = function(e) {
                        return t.onTouchMove(e)
                    }, this._onTouchEnd = function(e) {
                        return t.onTouchEnd(e)
                    }, this._onTouchEnter = function(e) {
                        return t.onTouchEnter(e)
                    }, this._onTouchLeave = function(e) {
                        return t.onTouchLeave(e)
                    }, this._onTouchCancel = function(e) {
                        return t.onTouchCancel(e)
                    }, this.game.canvas.addEventListener("touchstart", this._onTouchStart, !1), this.game.canvas.addEventListener("touchmove", this._onTouchMove, !1), this.game.canvas.addEventListener("touchend", this._onTouchEnd, !1), this.game.canvas.addEventListener("touchcancel", this._onTouchCancel, !1), this.game.device.cocoonJS || (this.game.canvas.addEventListener("touchenter", this._onTouchEnter, !1), this.game.canvas.addEventListener("touchleave", this._onTouchLeave, !1)))
                }
            },
            consumeDocumentTouches: function() {
                this._documentTouchMove = function(t) {
                    t.preventDefault()
                }, document.addEventListener("touchmove", this._documentTouchMove, !1)
            },
            addTouchLockCallback: function(t, e, i) {
                void 0 === i && (i = !1), this.touchLockCallbacks.push({
                    callback: t,
                    context: e,
                    onEnd: i
                })
            },
            removeTouchLockCallback: function(t, e) {
                for (var i = this.touchLockCallbacks.length; i--;)
                    if (this.touchLockCallbacks[i].callback === t && this.touchLockCallbacks[i].context === e) return this.touchLockCallbacks.splice(i, 1), !0;
                return !1
            },
            onTouchStart: function(t) {
                for (i = this.touchLockCallbacks.length; i--;) {
                    var e = this.touchLockCallbacks[i];
                    !e.onEnd && e.callback.call(e.context, this, t) && this.touchLockCallbacks.splice(i, 1)
                }
                if (this.event = t, this.game.input.enabled && this.enabled) {
                    this.touchStartCallback && this.touchStartCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault();
                    for (var i = 0; i < t.changedTouches.length; i++) this.game.input.startPointer(t.changedTouches[i])
                }
            },
            onTouchCancel: function(t) {
                if (this.event = t, this.touchCancelCallback && this.touchCancelCallback.call(this.callbackContext, t), this.game.input.enabled && this.enabled) {
                    this.preventDefault && t.preventDefault();
                    for (var e = 0; e < t.changedTouches.length; e++) this.game.input.stopPointer(t.changedTouches[e])
                }
            },
            onTouchEnter: function(t) {
                this.event = t, this.touchEnterCallback && this.touchEnterCallback.call(this.callbackContext, t), this.game.input.enabled && this.enabled && this.preventDefault && t.preventDefault()
            },
            onTouchLeave: function(t) {
                this.event = t, this.touchLeaveCallback && this.touchLeaveCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault()
            },
            onTouchMove: function(t) {
                this.event = t, this.touchMoveCallback && this.touchMoveCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault();
                for (var e = 0; e < t.changedTouches.length; e++) this.game.input.updatePointer(t.changedTouches[e])
            },
            onTouchEnd: function(t) {
                for (i = this.touchLockCallbacks.length; i--;) {
                    var e = this.touchLockCallbacks[i];
                    e.onEnd && e.callback.call(e.context, this, t) && this.touchLockCallbacks.splice(i, 1)
                }
                this.event = t, this.touchEndCallback && this.touchEndCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault();
                for (var i = 0; i < t.changedTouches.length; i++) this.game.input.stopPointer(t.changedTouches[i])
            },
            stop: function() {
                this.game.device.touch && (this.game.canvas.removeEventListener("touchstart", this._onTouchStart), this.game.canvas.removeEventListener("touchmove", this._onTouchMove), this.game.canvas.removeEventListener("touchend", this._onTouchEnd), this.game.canvas.removeEventListener("touchenter", this._onTouchEnter), this.game.canvas.removeEventListener("touchleave", this._onTouchLeave), this.game.canvas.removeEventListener("touchcancel", this._onTouchCancel))
            }
        }, i.Touch.prototype.constructor = i.Touch, i.InputHandler = function(t) {
            this.sprite = t, this.game = t.game, this.enabled = !1, this.checked = !1, this.priorityID = 0, this.useHandCursor = !1, this._setHandCursor = !1, this.isDragged = !1, this.allowHorizontalDrag = !0, this.allowVerticalDrag = !0, this.bringToTop = !1, this.snapOffset = null, this.snapOnDrag = !1, this.snapOnRelease = !1, this.snapX = 0, this.snapY = 0, this.snapOffsetX = 0, this.snapOffsetY = 0, this.pixelPerfectOver = !1, this.pixelPerfectClick = !1, this.pixelPerfectAlpha = 255, this.draggable = !1, this.boundsRect = null, this.boundsSprite = null, this.scaleLayer = !1, this.dragOffset = new i.Point, this.dragFromCenter = !1, this.dragStopBlocksInputUp = !1, this.dragStartPoint = new i.Point, this.dragDistanceThreshold = 0, this.dragTimeThreshold = 0, this.downPoint = new i.Point, this.snapPoint = new i.Point, this._dragPoint = new i.Point, this._dragPhase = !1, this._pendingDrag = !1, this._dragTimePass = !1, this._dragDistancePass = !1, this._wasEnabled = !1, this._tempPoint = new i.Point, this._pointerData = [], this._pointerData.push({
                id: 0,
                x: 0,
                y: 0,
                camX: 0,
                camY: 0,
                isDown: !1,
                isUp: !1,
                isOver: !1,
                isOut: !1,
                timeOver: 0,
                timeOut: 0,
                timeDown: 0,
                timeUp: 0,
                downDuration: 0,
                isDragged: !1
            })
        }, i.InputHandler.prototype = {
            start: function(t, e) {
                if (t = t || 0, void 0 === e && (e = !1), !1 === this.enabled) {
                    this.game.input.interactiveItems.add(this), this.useHandCursor = e, this.priorityID = t;
                    for (var s = 0; s < 10; s++) this._pointerData[s] = {
                        id: s,
                        x: 0,
                        y: 0,
                        isDown: !1,
                        isUp: !1,
                        isOver: !1,
                        isOut: !1,
                        timeOver: 0,
                        timeOut: 0,
                        timeDown: 0,
                        timeUp: 0,
                        downDuration: 0,
                        isDragged: !1
                    };
                    this.snapOffset = new i.Point, this.enabled = !0, this._wasEnabled = !0
                }
                return this.sprite.events.onAddedToGroup.add(this.addedToGroup, this), this.sprite.events.onRemovedFromGroup.add(this.removedFromGroup, this), this.sprite
            },
            addedToGroup: function() {
                this._dragPhase || this._wasEnabled && !this.enabled && this.start()
            },
            removedFromGroup: function() {
                this._dragPhase || (this.enabled ? (this._wasEnabled = !0, this.stop()) : this._wasEnabled = !1)
            },
            reset: function() {
                this.enabled = !1;
                for (var t = 0; t < 10; t++) this._pointerData[t] = {
                    id: t,
                    x: 0,
                    y: 0,
                    isDown: !1,
                    isUp: !1,
                    isOver: !1,
                    isOut: !1,
                    timeOver: 0,
                    timeOut: 0,
                    timeDown: 0,
                    timeUp: 0,
                    downDuration: 0,
                    isDragged: !1
                }
            },
            stop: function() {
                !1 !== this.enabled && (this.enabled = !1, this.game.input.interactiveItems.remove(this))
            },
            destroy: function() {
                this.sprite && (this._setHandCursor && (this.game.canvas.style.cursor = "default", this._setHandCursor = !1), this.enabled = !1, this.game.input.interactiveItems.remove(this), this._pointerData.length = 0, this.boundsRect = null, this.boundsSprite = null, this.sprite = null)
            },
            validForInput: function(t, e, i) {
                return void 0 === i && (i = !0), !(!this.enabled || 0 === this.sprite.scale.x || 0 === this.sprite.scale.y || this.priorityID < this.game.input.minPriorityID || this.sprite.parent && this.sprite.parent.ignoreChildInput || !i && (this.pixelPerfectClick || this.pixelPerfectOver) || !(this.priorityID > t || this.priorityID === t && this.sprite.renderOrderID > e))
            },
            isPixelPerfect: function() {
                return this.pixelPerfectClick || this.pixelPerfectOver
            },
            pointerX: function(t) {
                return t = t || 0, this._pointerData[t].x
            },
            pointerY: function(t) {
                return t = t || 0, this._pointerData[t].y
            },
            pointerDown: function(t) {
                return t = t || 0, this._pointerData[t].isDown
            },
            pointerUp: function(t) {
                return t = t || 0, this._pointerData[t].isUp
            },
            pointerTimeDown: function(t) {
                return t = t || 0, this._pointerData[t].timeDown
            },
            pointerTimeUp: function(t) {
                return t = t || 0, this._pointerData[t].timeUp
            },
            pointerOver: function(t) {
                if (!this.enabled) return !1;
                if (void 0 === t) {
                    for (var e = 0; e < 10; e++)
                        if (this._pointerData[e].isOver) return !0;
                    return !1
                }
                return this._pointerData[t].isOver
            },
            pointerOut: function(t) {
                if (!this.enabled) return !1;
                if (void 0 !== t) return this._pointerData[t].isOut;
                for (var e = 0; e < 10; e++)
                    if (this._pointerData[e].isOut) return !0
            },
            pointerTimeOver: function(t) {
                return t = t || 0, this._pointerData[t].timeOver
            },
            pointerTimeOut: function(t) {
                return t = t || 0, this._pointerData[t].timeOut
            },
            pointerDragged: function(t) {
                return t = t || 0, this._pointerData[t].isDragged
            },
            checkPointerDown: function(t, e) {
                return !!(t.isDown && this.enabled && this.sprite && this.sprite.parent && this.sprite.visible && this.sprite.parent.visible && 0 !== this.sprite.worldScale.x && 0 !== this.sprite.worldScale.y) && !!this.game.input.hitTest(this.sprite, t, this._tempPoint) && (void 0 === e && (e = !1), !(!e && this.pixelPerfectClick) || this.checkPixel(this._tempPoint.x, this._tempPoint.y))
            },
            checkPointerOver: function(t, e) {
                return !!(this.enabled && this.sprite && this.sprite.parent && this.sprite.visible && this.sprite.parent.visible && 0 !== this.sprite.worldScale.x && 0 !== this.sprite.worldScale.y) && !!this.game.input.hitTest(this.sprite, t, this._tempPoint) && (void 0 === e && (e = !1), !(!e && this.pixelPerfectOver) || this.checkPixel(this._tempPoint.x, this._tempPoint.y))
            },
            checkPixel: function(t, e, i) {
                if (this.sprite.texture.baseTexture.source) {
                    if (null === t && null === e) {
                        this.game.input.getLocalPosition(this.sprite, i, this._tempPoint);
                        var t = this._tempPoint.x,
                            e = this._tempPoint.y
                    }
                    if (0 !== this.sprite.anchor.x && (t -= -this.sprite.texture.frame.width * this.sprite.anchor.x), 0 !== this.sprite.anchor.y && (e -= -this.sprite.texture.frame.height * this.sprite.anchor.y), t += this.sprite.texture.frame.x, e += this.sprite.texture.frame.y, this.sprite.texture.trim && (t -= this.sprite.texture.trim.x, e -= this.sprite.texture.trim.y, t < this.sprite.texture.crop.x || t > this.sprite.texture.crop.right || e < this.sprite.texture.crop.y || e > this.sprite.texture.crop.bottom)) return this._dx = t, this._dy = e, !1;
                    if (this._dx = t, this._dy = e, this.game.input.hitContext.clearRect(0, 0, 1, 1), this.game.input.hitContext.drawImage(this.sprite.texture.baseTexture.source, t, e, 1, 1, 0, 0, 1, 1), this.game.input.hitContext.getImageData(0, 0, 1, 1).data[3] >= this.pixelPerfectAlpha) return !0
                }
                return !1
            },
            update: function(t) {
                if (null !== this.sprite && void 0 !== this.sprite.parent) return this.enabled && this.sprite.visible && this.sprite.parent.visible ? this._pendingDrag ? (this._dragDistancePass || (this._dragDistancePass = i.Math.distance(t.x, t.y, this.downPoint.x, this.downPoint.y) >= this.dragDistanceThreshold), this._dragDistancePass && this._dragTimePass && this.startDrag(t), !0) : this.draggable && this._draggedPointerID === t.id ? this.updateDrag(t, !1) : this._pointerData[t.id].isOver ? this.checkPointerOver(t) ? (this._pointerData[t.id].x = t.x - this.sprite.x, this._pointerData[t.id].y = t.y - this.sprite.y, !0) : (this._pointerOutHandler(t), !1) : void 0 : (this._pointerOutHandler(t), !1)
            },
            _pointerOverHandler: function(t, e) {
                if (null !== this.sprite) {
                    var s = this._pointerData[t.id];
                    if (!1 === s.isOver || t.dirty) {
                        var o = !1 === s.isOver;
                        s.isOver = !0, s.isOut = !1, s.timeOver = this.game.time.time, s.x = t.x - this.sprite.x, s.y = t.y - this.sprite.y, this.useHandCursor && !1 === s.isDragged && (this.game.canvas.style.cursor = "pointer", this._setHandCursor = !0), !e && o && this.sprite && this.sprite.events && this.sprite.events.onInputOver$dispatch(this.sprite, t), this.sprite.parent && this.sprite.parent.type === i.GROUP && this.sprite.parent.onChildInputOver.dispatch(this.sprite, t)
                    }
                }
            },
            _pointerOutHandler: function(t, e) {
                if (null !== this.sprite) {
                    var s = this._pointerData[t.id];
                    s.isOver = !1, s.isOut = !0, s.timeOut = this.game.time.time, this.useHandCursor && !1 === s.isDragged && (this.game.canvas.style.cursor = "default", this._setHandCursor = !1), !e && this.sprite && this.sprite.events && (this.sprite.events.onInputOut$dispatch(this.sprite, t), this.sprite && this.sprite.parent && this.sprite.parent.type === i.GROUP && this.sprite.parent.onChildInputOut.dispatch(this.sprite, t))
                }
            },
            _touchedHandler: function(t) {
                if (null !== this.sprite) {
                    var e = this._pointerData[t.id];
                    if (!e.isDown && e.isOver) {
                        if (this.pixelPerfectClick && !this.checkPixel(null, null, t)) return;
                        if (e.isDown = !0, e.isUp = !1, e.timeDown = this.game.time.time, this.downPoint.set(t.x, t.y), t.dirty = !0, this.sprite && this.sprite.events && (this.sprite.events.onInputDown$dispatch(this.sprite, t), this.sprite && this.sprite.parent && this.sprite.parent.type === i.GROUP && this.sprite.parent.onChildInputDown.dispatch(this.sprite, t), null === this.sprite)) return;
                        this.draggable && !1 === this.isDragged && (0 === this.dragTimeThreshold && 0 === this.dragDistanceThreshold ? this.startDrag(t) : (this._pendingDrag = !0, this._dragDistancePass = 0 === this.dragDistanceThreshold, this.dragTimeThreshold > 0 ? (this._dragTimePass = !1, this.game.time.events.add(this.dragTimeThreshold, this.dragTimeElapsed, this, t)) : this._dragTimePass = !0)), this.bringToTop && this.sprite.bringToTop()
                    }
                }
            },
            dragTimeElapsed: function(t) {
                this._dragTimePass = !0, this._pendingDrag && this.sprite && this._dragDistancePass && this.startDrag(t)
            },
            _releasedHandler: function(t) {
                if (null !== this.sprite) {
                    var e = this._pointerData[t.id];
                    if (e.isDown && t.isUp) {
                        e.isDown = !1, e.isUp = !0, e.timeUp = this.game.time.time, e.downDuration = e.timeUp - e.timeDown;
                        var s = this.checkPointerOver(t);
                        this.sprite && this.sprite.events && (this.dragStopBlocksInputUp && (!this.dragStopBlocksInputUp || this.draggable && this.isDragged && this._draggedPointerID === t.id) || this.sprite.events.onInputUp$dispatch(this.sprite, t, s), this.sprite && this.sprite.parent && this.sprite.parent.type === i.GROUP && this.sprite.parent.onChildInputUp.dispatch(this.sprite, t, s), s && (s = this.checkPointerOver(t))), e.isOver = s, !s && this.useHandCursor && (this.game.canvas.style.cursor = "default", this._setHandCursor = !1), t.dirty = !0, this._pendingDrag = !1, this.draggable && this.isDragged && this._draggedPointerID === t.id && this.stopDrag(t)
                    }
                }
            },
            updateDrag: function(t, e) {
                if (void 0 === e && (e = !1), t.isUp) return this.stopDrag(t), !1;
                var i = this.globalToLocalX(t.x) + this._dragPoint.x + this.dragOffset.x,
                    s = this.globalToLocalY(t.y) + this._dragPoint.y + this.dragOffset.y;
                if (this.sprite.fixedToCamera) this.allowHorizontalDrag && (this.sprite.cameraOffset.x = i), this.allowVerticalDrag && (this.sprite.cameraOffset.y = s), this.boundsRect && this.checkBoundsRect(), this.boundsSprite && this.checkBoundsSprite(), this.snapOnDrag && (this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY, this.snapPoint.set(this.sprite.cameraOffset.x, this.sprite.cameraOffset.y));
                else {
                    var o = this.game.camera.x - this._pointerData[t.id].camX,
                        n = this.game.camera.y - this._pointerData[t.id].camY;
                    this.allowHorizontalDrag && (this.sprite.x = i + o), this.allowVerticalDrag && (this.sprite.y = s + n), this.boundsRect && this.checkBoundsRect(), this.boundsSprite && this.checkBoundsSprite(), this.snapOnDrag && (this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY, this.snapPoint.set(this.sprite.x, this.sprite.y))
                }
                return this.sprite.events.onDragUpdate.dispatch(this.sprite, t, i, s, this.snapPoint, e), !0
            },
            justOver: function(t, e) {
                return t = t || 0, e = e || 500, this._pointerData[t].isOver && this.overDuration(t) < e
            },
            justOut: function(t, e) {
                return t = t || 0, e = e || 500, this._pointerData[t].isOut && this.game.time.time - this._pointerData[t].timeOut < e
            },
            justPressed: function(t, e) {
                return t = t || 0, e = e || 500, this._pointerData[t].isDown && this.downDuration(t) < e
            },
            justReleased: function(t, e) {
                return t = t || 0, e = e || 500, this._pointerData[t].isUp && this.game.time.time - this._pointerData[t].timeUp < e
            },
            overDuration: function(t) {
                return t = t || 0, this._pointerData[t].isOver ? this.game.time.time - this._pointerData[t].timeOver : -1
            },
            downDuration: function(t) {
                return t = t || 0, this._pointerData[t].isDown ? this.game.time.time - this._pointerData[t].timeDown : -1
            },
            enableDrag: function(t, e, s, o, n, a) {
                void 0 === t && (t = !1), void 0 === e && (e = !1), void 0 === s && (s = !1), void 0 === o && (o = 255), void 0 === n && (n = null), void 0 === a && (a = null), this._dragPoint = new i.Point, this.draggable = !0, this.bringToTop = e, this.dragOffset = new i.Point, this.dragFromCenter = t, this.pixelPerfectClick = s, this.pixelPerfectAlpha = o, n && (this.boundsRect = n), a && (this.boundsSprite = a)
            },
            disableDrag: function() {
                if (this._pointerData)
                    for (var t = 0; t < 10; t++) this._pointerData[t].isDragged = !1;
                this.draggable = !1, this.isDragged = !1, this._draggedPointerID = -1, this._pendingDrag = !1
            },
            startDrag: function(t) {
                var e = this.sprite.x,
                    i = this.sprite.y;
                if (this.isDragged = !0, this._draggedPointerID = t.id, this._pointerData[t.id].camX = this.game.camera.x, this._pointerData[t.id].camY = this.game.camera.y, this._pointerData[t.id].isDragged = !0, this.sprite.fixedToCamera) {
                    if (this.dragFromCenter) {
                        s = this.sprite.getBounds();
                        this.sprite.cameraOffset.x = this.globalToLocalX(t.x) + (this.sprite.cameraOffset.x - s.centerX), this.sprite.cameraOffset.y = this.globalToLocalY(t.y) + (this.sprite.cameraOffset.y - s.centerY)
                    }
                    this._dragPoint.setTo(this.sprite.cameraOffset.x - t.x, this.sprite.cameraOffset.y - t.y)
                } else {
                    if (this.dragFromCenter) {
                        var s = this.sprite.getBounds();
                        this.sprite.x = this.globalToLocalX(t.x) + (this.sprite.x - s.centerX), this.sprite.y = this.globalToLocalY(t.y) + (this.sprite.y - s.centerY)
                    }
                    this._dragPoint.setTo(this.sprite.x - this.globalToLocalX(t.x), this.sprite.y - this.globalToLocalY(t.y))
                }
                this.updateDrag(t, !0), this.bringToTop && (this._dragPhase = !0, this.sprite.bringToTop()), this.dragStartPoint.set(e, i), this.sprite.events.onDragStart$dispatch(this.sprite, t, e, i), this._pendingDrag = !1
            },
            globalToLocalX: function(t) {
                return this.scaleLayer && (t -= this.game.scale.grid.boundsFluid.x, t *= this.game.scale.grid.scaleFluidInversed.x), t
            },
            globalToLocalY: function(t) {
                return this.scaleLayer && (t -= this.game.scale.grid.boundsFluid.y, t *= this.game.scale.grid.scaleFluidInversed.y), t
            },
            stopDrag: function(t) {
                this.isDragged = !1, this._draggedPointerID = -1, this._pointerData[t.id].isDragged = !1, this._dragPhase = !1, this._pendingDrag = !1, this.snapOnRelease && (this.sprite.fixedToCamera ? (this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY) : (this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY)), this.sprite.events.onDragStop$dispatch(this.sprite, t), !1 === this.checkPointerOver(t) && this._pointerOutHandler(t)
            },
            setDragLock: function(t, e) {
                void 0 === t && (t = !0), void 0 === e && (e = !0), this.allowHorizontalDrag = t, this.allowVerticalDrag = e
            },
            enableSnap: function(t, e, i, s, o, n) {
                void 0 === i && (i = !0), void 0 === s && (s = !1), void 0 === o && (o = 0), void 0 === n && (n = 0), this.snapX = t, this.snapY = e, this.snapOffsetX = o, this.snapOffsetY = n, this.snapOnDrag = i, this.snapOnRelease = s
            },
            disableSnap: function() {
                this.snapOnDrag = !1, this.snapOnRelease = !1
            },
            checkBoundsRect: function() {
                this.sprite.fixedToCamera ? (this.sprite.cameraOffset.x < this.boundsRect.left ? this.sprite.cameraOffset.x = this.boundsRect.left : this.sprite.cameraOffset.x + this.sprite.width > this.boundsRect.right && (this.sprite.cameraOffset.x = this.boundsRect.right - this.sprite.width), this.sprite.cameraOffset.y < this.boundsRect.top ? this.sprite.cameraOffset.y = this.boundsRect.top : this.sprite.cameraOffset.y + this.sprite.height > this.boundsRect.bottom && (this.sprite.cameraOffset.y = this.boundsRect.bottom - this.sprite.height)) : (this.sprite.left < this.boundsRect.left ? this.sprite.x = this.boundsRect.x + this.sprite.offsetX : this.sprite.right > this.boundsRect.right && (this.sprite.x = this.boundsRect.right - (this.sprite.width - this.sprite.offsetX)), this.sprite.top < this.boundsRect.top ? this.sprite.y = this.boundsRect.top + this.sprite.offsetY : this.sprite.bottom > this.boundsRect.bottom && (this.sprite.y = this.boundsRect.bottom - (this.sprite.height - this.sprite.offsetY)))
            },
            checkBoundsSprite: function() {
                this.sprite.fixedToCamera && this.boundsSprite.fixedToCamera ? (this.sprite.cameraOffset.x < this.boundsSprite.cameraOffset.x ? this.sprite.cameraOffset.x = this.boundsSprite.cameraOffset.x : this.sprite.cameraOffset.x + this.sprite.width > this.boundsSprite.cameraOffset.x + this.boundsSprite.width && (this.sprite.cameraOffset.x = this.boundsSprite.cameraOffset.x + this.boundsSprite.width - this.sprite.width), this.sprite.cameraOffset.y < this.boundsSprite.cameraOffset.y ? this.sprite.cameraOffset.y = this.boundsSprite.cameraOffset.y : this.sprite.cameraOffset.y + this.sprite.height > this.boundsSprite.cameraOffset.y + this.boundsSprite.height && (this.sprite.cameraOffset.y = this.boundsSprite.cameraOffset.y + this.boundsSprite.height - this.sprite.height)) : (this.sprite.left < this.boundsSprite.left ? this.sprite.x = this.boundsSprite.left + this.sprite.offsetX : this.sprite.right > this.boundsSprite.right && (this.sprite.x = this.boundsSprite.right - (this.sprite.width - this.sprite.offsetX)), this.sprite.top < this.boundsSprite.top ? this.sprite.y = this.boundsSprite.top + this.sprite.offsetY : this.sprite.bottom > this.boundsSprite.bottom && (this.sprite.y = this.boundsSprite.bottom - (this.sprite.height - this.sprite.offsetY)))
            }
        }, i.InputHandler.prototype.constructor = i.InputHandler, i.Gamepad = function(t) {
            this.game = t, this._gamepadIndexMap = {}, this._rawPads = [], this._active = !1, this.enabled = !0, this._gamepadSupportAvailable = !!navigator.webkitGetGamepads || !!navigator.webkitGamepads || -1 !== navigator.userAgent.indexOf("Firefox/") || !!navigator.getGamepads, this._prevRawGamepadTypes = [], this._prevTimestamps = [], this.callbackContext = this, this.onConnectCallback = null, this.onDisconnectCallback = null, this.onDownCallback = null, this.onUpCallback = null, this.onAxisCallback = null, this.onFloatCallback = null, this._ongamepadconnected = null, this._gamepaddisconnected = null, this._gamepads = [new i.SinglePad(t, this), new i.SinglePad(t, this), new i.SinglePad(t, this), new i.SinglePad(t, this)]
        }, i.Gamepad.prototype = {
            addCallbacks: function(t, e) {
                void 0 !== e && (this.onConnectCallback = "function" == typeof e.onConnect ? e.onConnect : this.onConnectCallback, this.onDisconnectCallback = "function" == typeof e.onDisconnect ? e.onDisconnect : this.onDisconnectCallback, this.onDownCallback = "function" == typeof e.onDown ? e.onDown : this.onDownCallback, this.onUpCallback = "function" == typeof e.onUp ? e.onUp : this.onUpCallback, this.onAxisCallback = "function" == typeof e.onAxis ? e.onAxis : this.onAxisCallback, this.onFloatCallback = "function" == typeof e.onFloat ? e.onFloat : this.onFloatCallback, this.callbackContext = t)
            },
            start: function() {
                if (!this._active) {
                    this._active = !0;
                    var t = this;
                    this._onGamepadConnected = function(e) {
                        return t.onGamepadConnected(e)
                    }, this._onGamepadDisconnected = function(e) {
                        return t.onGamepadDisconnected(e)
                    }, window.addEventListener("gamepadconnected", this._onGamepadConnected, !1), window.addEventListener("gamepaddisconnected", this._onGamepadDisconnected, !1)
                }
            },
            onGamepadConnected: function(t) {
                var e = t.gamepad;
                this._rawPads.push(e), this._gamepads[e.index].connect(e)
            },
            onGamepadDisconnected: function(t) {
                var e = t.gamepad;
                for (var i in this._rawPads) this._rawPads[i].index === e.index && this._rawPads.splice(i, 1);
                this._gamepads[e.index].disconnect()
            },
            update: function() {
                this._pollGamepads(), this.pad1.pollStatus(), this.pad2.pollStatus(), this.pad3.pollStatus(), this.pad4.pollStatus()
            },
            _pollGamepads: function() {
                if (this._active) {
                    if (navigator.getGamepads) t = navigator.getGamepads();
                    else if (navigator.webkitGetGamepads) t = navigator.webkitGetGamepads();
                    else if (navigator.webkitGamepads) var t = navigator.webkitGamepads();
                    if (t) {
                        this._rawPads = [];
                        for (var e = !1, i = 0; i < t.length && (typeof t[i] !== this._prevRawGamepadTypes[i] && (e = !0, this._prevRawGamepadTypes[i] = typeof t[i]), t[i] && this._rawPads.push(t[i]), 3 !== i); i++);
                        for (var s = 0; s < this._gamepads.length; s++) this._gamepads[s]._rawPad = this._rawPads[s];
                        if (e) {
                            for (var o, n = {
                                    rawIndices: {},
                                    padIndices: {}
                                }, a = 0; a < this._gamepads.length; a++)
                                if ((o = this._gamepads[a]).connected)
                                    for (var r = 0; r < this._rawPads.length; r++) this._rawPads[r].index === o.index && (n.rawIndices[o.index] = !0, n.padIndices[a] = !0);
                            for (var h = 0; h < this._gamepads.length; h++)
                                if (o = this._gamepads[h], !n.padIndices[h]) {
                                    this._rawPads.length < 1 && o.disconnect();
                                    for (var l = 0; l < this._rawPads.length && !n.padIndices[h]; l++) {
                                        var c = this._rawPads[l];
                                        if (c) {
                                            if (n.rawIndices[c.index]) {
                                                o.disconnect();
                                                continue
                                            }
                                            o.connect(c), n.rawIndices[c.index] = !0, n.padIndices[h] = !0
                                        } else o.disconnect()
                                    }
                                }
                        }
                    }
                }
            },
            setDeadZones: function(t) {
                for (var e = 0; e < this._gamepads.length; e++) this._gamepads[e].deadZone = t
            },
            stop: function() {
                this._active = !1, window.removeEventListener("gamepadconnected", this._onGamepadConnected), window.removeEventListener("gamepaddisconnected", this._onGamepadDisconnected)
            },
            reset: function() {
                this.update();
                for (var t = 0; t < this._gamepads.length; t++) this._gamepads[t].reset()
            },
            justPressed: function(t, e) {
                for (var i = 0; i < this._gamepads.length; i++)
                    if (!0 === this._gamepads[i].justPressed(t, e)) return !0;
                return !1
            },
            justReleased: function(t, e) {
                for (var i = 0; i < this._gamepads.length; i++)
                    if (!0 === this._gamepads[i].justReleased(t, e)) return !0;
                return !1
            },
            isDown: function(t) {
                for (var e = 0; e < this._gamepads.length; e++)
                    if (!0 === this._gamepads[e].isDown(t)) return !0;
                return !1
            },
            destroy: function() {
                this.stop();
                for (var t = 0; t < this._gamepads.length; t++) this._gamepads[t].destroy()
            }
        }, i.Gamepad.prototype.constructor = i.Gamepad, Object.defineProperty(i.Gamepad.prototype, "active", {
            get: function() {
                return this._active
            }
        }), Object.defineProperty(i.Gamepad.prototype, "supported", {
            get: function() {
                return this._gamepadSupportAvailable
            }
        }), Object.defineProperty(i.Gamepad.prototype, "padsConnected", {
            get: function() {
                return this._rawPads.length
            }
        }), Object.defineProperty(i.Gamepad.prototype, "pad1", {
            get: function() {
                return this._gamepads[0]
            }
        }), Object.defineProperty(i.Gamepad.prototype, "pad2", {
            get: function() {
                return this._gamepads[1]
            }
        }), Object.defineProperty(i.Gamepad.prototype, "pad3", {
            get: function() {
                return this._gamepads[2]
            }
        }), Object.defineProperty(i.Gamepad.prototype, "pad4", {
            get: function() {
                return this._gamepads[3]
            }
        }), i.Gamepad.BUTTON_0 = 0, i.Gamepad.BUTTON_1 = 1, i.Gamepad.BUTTON_2 = 2, i.Gamepad.BUTTON_3 = 3, i.Gamepad.BUTTON_4 = 4, i.Gamepad.BUTTON_5 = 5, i.Gamepad.BUTTON_6 = 6, i.Gamepad.BUTTON_7 = 7, i.Gamepad.BUTTON_8 = 8, i.Gamepad.BUTTON_9 = 9, i.Gamepad.BUTTON_10 = 10, i.Gamepad.BUTTON_11 = 11, i.Gamepad.BUTTON_12 = 12, i.Gamepad.BUTTON_13 = 13, i.Gamepad.BUTTON_14 = 14, i.Gamepad.BUTTON_15 = 15, i.Gamepad.AXIS_0 = 0, i.Gamepad.AXIS_1 = 1, i.Gamepad.AXIS_2 = 2, i.Gamepad.AXIS_3 = 3, i.Gamepad.AXIS_4 = 4, i.Gamepad.AXIS_5 = 5, i.Gamepad.AXIS_6 = 6, i.Gamepad.AXIS_7 = 7, i.Gamepad.AXIS_8 = 8, i.Gamepad.AXIS_9 = 9, i.Gamepad.XBOX360_A = 0, i.Gamepad.XBOX360_B = 1, i.Gamepad.XBOX360_X = 2, i.Gamepad.XBOX360_Y = 3, i.Gamepad.XBOX360_LEFT_BUMPER = 4, i.Gamepad.XBOX360_RIGHT_BUMPER = 5, i.Gamepad.XBOX360_LEFT_TRIGGER = 6, i.Gamepad.XBOX360_RIGHT_TRIGGER = 7, i.Gamepad.XBOX360_BACK = 8, i.Gamepad.XBOX360_START = 9, i.Gamepad.XBOX360_STICK_LEFT_BUTTON = 10, i.Gamepad.XBOX360_STICK_RIGHT_BUTTON = 11, i.Gamepad.XBOX360_DPAD_LEFT = 14, i.Gamepad.XBOX360_DPAD_RIGHT = 15, i.Gamepad.XBOX360_DPAD_UP = 12, i.Gamepad.XBOX360_DPAD_DOWN = 13, i.Gamepad.XBOX360_STICK_LEFT_X = 0, i.Gamepad.XBOX360_STICK_LEFT_Y = 1, i.Gamepad.XBOX360_STICK_RIGHT_X = 2, i.Gamepad.XBOX360_STICK_RIGHT_Y = 3, i.Gamepad.PS3XC_X = 0, i.Gamepad.PS3XC_CIRCLE = 1, i.Gamepad.PS3XC_SQUARE = 2, i.Gamepad.PS3XC_TRIANGLE = 3, i.Gamepad.PS3XC_L1 = 4, i.Gamepad.PS3XC_R1 = 5, i.Gamepad.PS3XC_L2 = 6, i.Gamepad.PS3XC_R2 = 7, i.Gamepad.PS3XC_SELECT = 8, i.Gamepad.PS3XC_START = 9, i.Gamepad.PS3XC_STICK_LEFT_BUTTON = 10, i.Gamepad.PS3XC_STICK_RIGHT_BUTTON = 11, i.Gamepad.PS3XC_DPAD_UP = 12, i.Gamepad.PS3XC_DPAD_DOWN = 13, i.Gamepad.PS3XC_DPAD_LEFT = 14, i.Gamepad.PS3XC_DPAD_RIGHT = 15, i.Gamepad.PS3XC_STICK_LEFT_X = 0, i.Gamepad.PS3XC_STICK_LEFT_Y = 1, i.Gamepad.PS3XC_STICK_RIGHT_X = 2, i.Gamepad.PS3XC_STICK_RIGHT_Y = 3, i.SinglePad = function(t, e) {
            this.game = t, this.index = null, this.connected = !1, this.callbackContext = this, this.onConnectCallback = null, this.onDisconnectCallback = null, this.onDownCallback = null, this.onUpCallback = null, this.onAxisCallback = null, this.onFloatCallback = null, this.deadZone = .26, this._padParent = e, this._rawPad = null, this._prevTimestamp = null, this._buttons = [], this._buttonsLen = 0, this._axes = [], this._axesLen = 0
        }, i.SinglePad.prototype = {
            addCallbacks: function(t, e) {
                void 0 !== e && (this.onConnectCallback = "function" == typeof e.onConnect ? e.onConnect : this.onConnectCallback, this.onDisconnectCallback = "function" == typeof e.onDisconnect ? e.onDisconnect : this.onDisconnectCallback, this.onDownCallback = "function" == typeof e.onDown ? e.onDown : this.onDownCallback, this.onUpCallback = "function" == typeof e.onUp ? e.onUp : this.onUpCallback, this.onAxisCallback = "function" == typeof e.onAxis ? e.onAxis : this.onAxisCallback, this.onFloatCallback = "function" == typeof e.onFloat ? e.onFloat : this.onFloatCallback, this.callbackContext = t)
            },
            getButton: function(t) {
                return this._buttons[t] ? this._buttons[t] : null
            },
            pollStatus: function() {
                if (this.connected && this.game.input.enabled && this.game.input.gamepad.enabled && (!this._rawPad.timestamp || this._rawPad.timestamp !== this._prevTimestamp)) {
                    for (var t = 0; t < this._buttonsLen; t++) {
                        var e = isNaN(this._rawPad.buttons[t]) ? this._rawPad.buttons[t].value : this._rawPad.buttons[t];
                        e !== this._buttons[t].value && (1 === e ? this.processButtonDown(t, e) : 0 === e ? this.processButtonUp(t, e) : this.processButtonFloat(t, e))
                    }
                    for (var i = 0; i < this._axesLen; i++) {
                        var s = this._rawPad.axes[i];
                        s > 0 && s > this.deadZone || s < 0 && s < -this.deadZone ? this.processAxisChange(i, s) : this.processAxisChange(i, 0)
                    }
                    this._prevTimestamp = this._rawPad.timestamp
                }
            },
            connect: function(t) {
                var e = !this.connected;
                this.connected = !0, this.index = t.index, this._rawPad = t, this._buttons = [], this._buttonsLen = t.buttons.length, this._axes = [], this._axesLen = t.axes.length;
                for (var s = 0; s < this._axesLen; s++) this._axes[s] = t.axes[s];
                for (var o in t.buttons) o = parseInt(o, 10), this._buttons[o] = new i.DeviceButton(this, o);
                e && this._padParent.onConnectCallback && this._padParent.onConnectCallback.call(this._padParent.callbackContext, this.index), e && this.onConnectCallback && this.onConnectCallback.call(this.callbackContext)
            },
            disconnect: function() {
                var t = this.connected,
                    e = this.index;
                this.connected = !1, this.index = null, this._rawPad = void 0;
                for (var i = 0; i < this._buttonsLen; i++) this._buttons[i].destroy();
                this._buttons = [], this._buttonsLen = 0, this._axes = [], this._axesLen = 0, t && this._padParent.onDisconnectCallback && this._padParent.onDisconnectCallback.call(this._padParent.callbackContext, e), t && this.onDisconnectCallback && this.onDisconnectCallback.call(this.callbackContext)
            },
            destroy: function() {
                this._rawPad = void 0;
                for (var t = 0; t < this._buttonsLen; t++) this._buttons[t].destroy();
                this._buttons = [], this._buttonsLen = 0, this._axes = [], this._axesLen = 0, this.onConnectCallback = null, this.onDisconnectCallback = null, this.onDownCallback = null, this.onUpCallback = null, this.onAxisCallback = null, this.onFloatCallback = null
            },
            processAxisChange: function(t, e) {
                this._axes[t] !== e && (this._axes[t] = e, this._padParent.onAxisCallback && this._padParent.onAxisCallback.call(this._padParent.callbackContext, this, t, e), this.onAxisCallback && this.onAxisCallback.call(this.callbackContext, this, t, e))
            },
            processButtonDown: function(t, e) {
                this._buttons[t] && this._buttons[t].start(null, e), this._padParent.onDownCallback && this._padParent.onDownCallback.call(this._padParent.callbackContext, t, e, this.index), this.onDownCallback && this.onDownCallback.call(this.callbackContext, t, e)
            },
            processButtonUp: function(t, e) {
                this._padParent.onUpCallback && this._padParent.onUpCallback.call(this._padParent.callbackContext, t, e, this.index), this.onUpCallback && this.onUpCallback.call(this.callbackContext, t, e), this._buttons[t] && this._buttons[t].stop(null, e)
            },
            processButtonFloat: function(t, e) {
                this._padParent.onFloatCallback && this._padParent.onFloatCallback.call(this._padParent.callbackContext, t, e, this.index), this.onFloatCallback && this.onFloatCallback.call(this.callbackContext, t, e), this._buttons[t] && this._buttons[t].padFloat(e)
            },
            axis: function(t) {
                return !!this._axes[t] && this._axes[t]
            },
            isDown: function(t) {
                return !!this._buttons[t] && this._buttons[t].isDown
            },
            isUp: function(t) {
                return !!this._buttons[t] && this._buttons[t].isUp
            },
            justReleased: function(t, e) {
                if (this._buttons[t]) return this._buttons[t].justReleased(e)
            },
            justPressed: function(t, e) {
                if (this._buttons[t]) return this._buttons[t].justPressed(e)
            },
            buttonValue: function(t) {
                return this._buttons[t] ? this._buttons[t].value : null
            },
            reset: function() {
                for (var t = 0; t < this._axes.length; t++) this._axes[t] = 0
            }
        }, i.SinglePad.prototype.constructor = i.SinglePad, i.Key = function(t, e) {
            this.game = t, this._enabled = !0, this.event = null, this.isDown = !1, this.isUp = !0, this.altKey = !1, this.ctrlKey = !1, this.shiftKey = !1, this.timeDown = 0, this.duration = 0, this.timeUp = -2500, this.repeats = 0, this.keyCode = e, this.onDown = new i.Signal, this.onHoldCallback = null, this.onHoldContext = null, this.onUp = new i.Signal, this._justDown = !1, this._justUp = !1
        }, i.Key.prototype = {
            update: function() {
                this._enabled && this.isDown && (this.duration = this.game.time.time - this.timeDown, this.repeats++, this.onHoldCallback && this.onHoldCallback.call(this.onHoldContext, this))
            },
            processKeyDown: function(t) {
                this._enabled && (this.event = t, this.isDown || (this.altKey = t.altKey, this.ctrlKey = t.ctrlKey, this.shiftKey = t.shiftKey, this.isDown = !0, this.isUp = !1, this.timeDown = this.game.time.time, this.duration = 0, this.repeats = 0, this._justDown = !0, this.onDown.dispatch(this)))
            },
            processKeyUp: function(t) {
                this._enabled && (this.event = t, this.isUp || (this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, this.duration = this.game.time.time - this.timeDown, this._justUp = !0, this.onUp.dispatch(this)))
            },
            reset: function(t) {
                void 0 === t && (t = !0), this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, this.duration = 0, this._enabled = !0, this._justDown = !1, this._justUp = !1, t && (this.onDown.removeAll(), this.onUp.removeAll(), this.onHoldCallback = null, this.onHoldContext = null)
            },
            downDuration: function(t) {
                return void 0 === t && (t = 50), this.isDown && this.duration < t
            },
            upDuration: function(t) {
                return void 0 === t && (t = 50), !this.isDown && this.game.time.time - this.timeUp < t
            }
        }, Object.defineProperty(i.Key.prototype, "justDown", {
            get: function() {
                var t = this._justDown;
                return this._justDown = !1, t
            }
        }), Object.defineProperty(i.Key.prototype, "justUp", {
            get: function() {
                var t = this._justUp;
                return this._justUp = !1, t
            }
        }), Object.defineProperty(i.Key.prototype, "enabled", {
            get: function() {
                return this._enabled
            },
            set: function(t) {
                (t = !!t) !== this._enabled && (t || this.reset(!1), this._enabled = t)
            }
        }), i.Key.prototype.constructor = i.Key, i.Keyboard = function(t) {
            this.game = t, this.enabled = !0, this.event = null, this.pressEvent = null, this.callbackContext = this, this.onDownCallback = null, this.onPressCallback = null, this.onUpCallback = null, this._keys = [], this._capture = [], this._onKeyDown = null, this._onKeyPress = null, this._onKeyUp = null, this._i = 0, this._k = 0
        }, i.Keyboard.prototype = {
            addCallbacks: function(t, e, i, s) {
                this.callbackContext = t, void 0 !== e && null !== e && (this.onDownCallback = e), void 0 !== i && null !== i && (this.onUpCallback = i), void 0 !== s && null !== s && (this.onPressCallback = s)
            },
            addKey: function(t) {
                return this._keys[t] || (this._keys[t] = new i.Key(this.game, t), this.addKeyCapture(t)), this._keys[t]
            },
            addKeys: function(t) {
                var e = {};
                for (var i in t) e[i] = this.addKey(t[i]);
                return e
            },
            removeKey: function(t) {
                this._keys[t] && (this._keys[t] = null, this.removeKeyCapture(t))
            },
            createCursorKeys: function() {
                return this.addKeys({
                    up: i.KeyCode.UP,
                    down: i.KeyCode.DOWN,
                    left: i.KeyCode.LEFT,
                    right: i.KeyCode.RIGHT
                })
            },
            start: function() {
                if (!this.game.device.cocoonJS && null === this._onKeyDown) {
                    var t = this;
                    this._onKeyDown = function(e) {
                        return t.processKeyDown(e)
                    }, this._onKeyUp = function(e) {
                        return t.processKeyUp(e)
                    }, this._onKeyPress = function(e) {
                        return t.processKeyPress(e)
                    }, window.addEventListener("keydown", this._onKeyDown, !1), window.addEventListener("keyup", this._onKeyUp, !1), window.addEventListener("keypress", this._onKeyPress, !1)
                }
            },
            stop: function() {
                window.removeEventListener("keydown", this._onKeyDown), window.removeEventListener("keyup", this._onKeyUp), window.removeEventListener("keypress", this._onKeyPress), this._onKeyDown = null, this._onKeyUp = null, this._onKeyPress = null
            },
            destroy: function() {
                this.stop(), this.clearCaptures(), this._keys.length = 0, this._i = 0
            },
            addKeyCapture: function(t) {
                if ("object" == typeof t)
                    for (var e in t) this._capture[t[e]] = !0;
                else this._capture[t] = !0
            },
            removeKeyCapture: function(t) {
                delete this._capture[t]
            },
            clearCaptures: function() {
                this._capture = {}
            },
            update: function() {
                for (this._i = this._keys.length; this._i--;) this._keys[this._i] && this._keys[this._i].update()
            },
            processKeyDown: function(t) {
                if (this.event = t, this.game.input.enabled && this.enabled) {
                    var e = t.keyCode;
                    this._capture[e] && t.preventDefault(), this._keys[e] || (this._keys[e] = new i.Key(this.game, e)), this._keys[e].processKeyDown(t), this._k = e, this.onDownCallback && this.onDownCallback.call(this.callbackContext, t)
                }
            },
            processKeyPress: function(t) {
                this.pressEvent = t, this.game.input.enabled && this.enabled && this.onPressCallback && this.onPressCallback.call(this.callbackContext, String.fromCharCode(t.charCode), t)
            },
            processKeyUp: function(t) {
                if (this.event = t, this.game.input.enabled && this.enabled) {
                    var e = t.keyCode;
                    this._capture[e] && t.preventDefault(), this._keys[e] || (this._keys[e] = new i.Key(this.game, e)), this._keys[e].processKeyUp(t), this.onUpCallback && this.onUpCallback.call(this.callbackContext, t)
                }
            },
            reset: function(t) {
                void 0 === t && (t = !0), this.event = null;
                for (var e = this._keys.length; e--;) this._keys[e] && this._keys[e].reset(t)
            },
            downDuration: function(t, e) {
                return this._keys[t] ? this._keys[t].downDuration(e) : null
            },
            upDuration: function(t, e) {
                return this._keys[t] ? this._keys[t].upDuration(e) : null
            },
            isDown: function(t) {
                return this._keys[t] ? this._keys[t].isDown : null
            }
        }, Object.defineProperty(i.Keyboard.prototype, "lastChar", {
            get: function() {
                return 32 === this.event.charCode ? "" : String.fromCharCode(this.pressEvent.charCode)
            }
        }), Object.defineProperty(i.Keyboard.prototype, "lastKey", {
            get: function() {
                return this._keys[this._k]
            }
        }), i.Keyboard.prototype.constructor = i.Keyboard, i.KeyCode = {
            A: "A".charCodeAt(0),
            B: "B".charCodeAt(0),
            C: "C".charCodeAt(0),
            D: "D".charCodeAt(0),
            E: "E".charCodeAt(0),
            F: "F".charCodeAt(0),
            G: "G".charCodeAt(0),
            H: "H".charCodeAt(0),
            I: "I".charCodeAt(0),
            J: "J".charCodeAt(0),
            K: "K".charCodeAt(0),
            L: "L".charCodeAt(0),
            M: "M".charCodeAt(0),
            N: "N".charCodeAt(0),
            O: "O".charCodeAt(0),
            P: "P".charCodeAt(0),
            Q: "Q".charCodeAt(0),
            R: "R".charCodeAt(0),
            S: "S".charCodeAt(0),
            T: "T".charCodeAt(0),
            U: "U".charCodeAt(0),
            V: "V".charCodeAt(0),
            W: "W".charCodeAt(0),
            X: "X".charCodeAt(0),
            Y: "Y".charCodeAt(0),
            Z: "Z".charCodeAt(0),
            ZERO: "0".charCodeAt(0),
            ONE: "1".charCodeAt(0),
            TWO: "2".charCodeAt(0),
            THREE: "3".charCodeAt(0),
            FOUR: "4".charCodeAt(0),
            FIVE: "5".charCodeAt(0),
            SIX: "6".charCodeAt(0),
            SEVEN: "7".charCodeAt(0),
            EIGHT: "8".charCodeAt(0),
            NINE: "9".charCodeAt(0),
            NUMPAD_0: 96,
            NUMPAD_1: 97,
            NUMPAD_2: 98,
            NUMPAD_3: 99,
            NUMPAD_4: 100,
            NUMPAD_5: 101,
            NUMPAD_6: 102,
            NUMPAD_7: 103,
            NUMPAD_8: 104,
            NUMPAD_9: 105,
            NUMPAD_MULTIPLY: 106,
            NUMPAD_ADD: 107,
            NUMPAD_ENTER: 108,
            NUMPAD_SUBTRACT: 109,
            NUMPAD_DECIMAL: 110,
            NUMPAD_DIVIDE: 111,
            F1: 112,
            F2: 113,
            F3: 114,
            F4: 115,
            F5: 116,
            F6: 117,
            F7: 118,
            F8: 119,
            F9: 120,
            F10: 121,
            F11: 122,
            F12: 123,
            F13: 124,
            F14: 125,
            F15: 126,
            COLON: 186,
            EQUALS: 187,
            COMMA: 188,
            UNDERSCORE: 189,
            PERIOD: 190,
            QUESTION_MARK: 191,
            TILDE: 192,
            OPEN_BRACKET: 219,
            BACKWARD_SLASH: 220,
            CLOSED_BRACKET: 221,
            QUOTES: 222,
            BACKSPACE: 8,
            TAB: 9,
            CLEAR: 12,
            ENTER: 13,
            SHIFT: 16,
            CONTROL: 17,
            ALT: 18,
            CAPS_LOCK: 20,
            ESC: 27,
            SPACEBAR: 32,
            PAGE_UP: 33,
            PAGE_DOWN: 34,
            END: 35,
            HOME: 36,
            LEFT: 37,
            UP: 38,
            RIGHT: 39,
            DOWN: 40,
            PLUS: 43,
            MINUS: 44,
            INSERT: 45,
            DELETE: 46,
            HELP: 47,
            NUM_LOCK: 144
        };
        for (var o in i.KeyCode) i.KeyCode.hasOwnProperty(o) && !o.match(/[a-z]/) && (i.Keyboard[o] = i.KeyCode[o]);
        i.Component = function() {}, i.Component.Angle = function() {}, i.Component.Angle.prototype = {
            angle: {
                get: function() {
                    return i.Math.wrapAngle(i.Math.radToDeg(this.rotation))
                },
                set: function(t) {
                    this.rotation = i.Math.degToRad(i.Math.wrapAngle(t))
                }
            }
        }, i.Component.Animation = function() {}, i.Component.Animation.prototype = {
            play: function(t, e, i, s) {
                if (this.animations) return this.animations.play(t, e, i, s)
            }
        }, i.Component.AutoCull = function() {}, i.Component.AutoCull.prototype = {
            autoCull: !1,
            inCamera: {
                get: function() {
                    return this.autoCull || this.checkWorldBounds || (this._bounds.copyFrom(this.getBounds()), this._bounds.x += this.game.camera.view.x, this._bounds.y += this.game.camera.view.y), this.game.world.camera.view.intersects(this._bounds)
                }
            }
        }, i.Component.Bounds = function() {}, i.Component.Bounds.prototype = {
            offsetX: {
                get: function() {
                    return this.anchor.x * this.width
                }
            },
            offsetY: {
                get: function() {
                    return this.anchor.y * this.height
                }
            },
            centerX: {
                get: function() {
                    return this.x - this.offsetX + .5 * this.width
                },
                set: function(t) {
                    this.x = t + this.offsetX - .5 * this.width
                }
            },
            centerY: {
                get: function() {
                    return this.y - this.offsetY + .5 * this.height
                },
                set: function(t) {
                    this.y = t + this.offsetY - .5 * this.height
                }
            },
            left: {
                get: function() {
                    return this.x - this.offsetX
                },
                set: function(t) {
                    this.x = t + this.offsetX
                }
            },
            right: {
                get: function() {
                    return this.x + this.width - this.offsetX
                },
                set: function(t) {
                    this.x = t - this.width + this.offsetX
                }
            },
            top: {
                get: function() {
                    return this.y - this.offsetY
                },
                set: function(t) {
                    this.y = t + this.offsetY
                }
            },
            bottom: {
                get: function() {
                    return this.y + this.height - this.offsetY
                },
                set: function(t) {
                    this.y = t - this.height + this.offsetY
                }
            },
            alignIn: function(t, e, s, o) {
                switch (void 0 === s && (s = 0), void 0 === o && (o = 0), e) {
                    default:
                        case i.TOP_LEFT:
                        this.left = t.left - s,
                    this.top = t.top - o;
                    break;
                    case i.TOP_CENTER:
                            this.centerX = t.centerX + s,
                        this.top = t.top - o;
                        break;
                    case i.TOP_RIGHT:
                            this.right = t.right + s,
                        this.top = t.top - o;
                        break;
                    case i.LEFT_CENTER:
                            this.left = t.left - s,
                        this.centerY = t.centerY + o;
                        break;
                    case i.CENTER:
                            this.centerX = t.centerX + s,
                        this.centerY = t.centerY + o;
                        break;
                    case i.RIGHT_CENTER:
                            this.right = t.right + s,
                        this.centerY = t.centerY + o;
                        break;
                    case i.BOTTOM_LEFT:
                            this.left = t.left - s,
                        this.bottom = t.bottom + o;
                        break;
                    case i.BOTTOM_CENTER:
                            this.centerX = t.centerX + s,
                        this.bottom = t.bottom + o;
                        break;
                    case i.BOTTOM_RIGHT:
                            this.right = t.right + s,
                        this.bottom = t.bottom + o
                }
                return this
            },
            alignTo: function(t, e, s, o) {
                switch (void 0 === s && (s = 0), void 0 === o && (o = 0), e) {
                    default:
                        case i.TOP_LEFT:
                        this.left = t.left - s,
                    this.bottom = t.top - o;
                    break;
                    case i.TOP_CENTER:
                            this.centerX = t.centerX + s,
                        this.bottom = t.top - o;
                        break;
                    case i.TOP_RIGHT:
                            this.right = t.right + s,
                        this.bottom = t.top - o;
                        break;
                    case i.LEFT_TOP:
                            this.right = t.left - s,
                        this.top = t.top - o;
                        break;
                    case i.LEFT_CENTER:
                            this.right = t.left - s,
                        this.centerY = t.centerY + o;
                        break;
                    case i.LEFT_BOTTOM:
                            this.right = t.left - s,
                        this.bottom = t.bottom + o;
                        break;
                    case i.RIGHT_TOP:
                            this.left = t.right + s,
                        this.top = t.top - o;
                        break;
                    case i.RIGHT_CENTER:
                            this.left = t.right + s,
                        this.centerY = t.centerY + o;
                        break;
                    case i.RIGHT_BOTTOM:
                            this.left = t.right + s,
                        this.bottom = t.bottom + o;
                        break;
                    case i.BOTTOM_LEFT:
                            this.left = t.left - s,
                        this.top = t.bottom + o;
                        break;
                    case i.BOTTOM_CENTER:
                            this.centerX = t.centerX + s,
                        this.top = t.bottom + o;
                        break;
                    case i.BOTTOM_RIGHT:
                            this.right = t.right + s,
                        this.top = t.bottom + o
                }
                return this
            }
        }, i.Group.prototype.alignIn = i.Component.Bounds.prototype.alignIn, i.Group.prototype.alignTo = i.Component.Bounds.prototype.alignTo, i.Component.BringToTop = function() {}, i.Component.BringToTop.prototype.bringToTop = function() {
            return this.parent && this.parent.bringToTop(this), this
        }, i.Component.BringToTop.prototype.sendToBack = function() {
            return this.parent && this.parent.sendToBack(this), this
        }, i.Component.BringToTop.prototype.moveUp = function() {
            return this.parent && this.parent.moveUp(this), this
        }, i.Component.BringToTop.prototype.moveDown = function() {
            return this.parent && this.parent.moveDown(this), this
        }, i.Component.Core = function() {}, i.Component.Core.install = function(t) {
            i.Utils.mixinPrototype(this, i.Component.Core.prototype), this.components = {};
            for (var e = 0; e < t.length; e++) {
                var s = t[e],
                    o = !1;
                "Destroy" === s && (o = !0), i.Utils.mixinPrototype(this, i.Component[s].prototype, o), this.components[s] = !0
            }
        }, i.Component.Core.init = function(t, e, s, o, n) {
            this.game = t, this.key = o, this.data = {}, this.position.set(e, s), this.world = new i.Point(e, s), this.previousPosition = new i.Point(e, s), this.events = new i.Events(this), this._bounds = new i.Rectangle, this.components.PhysicsBody && (this.body = this.body), this.components.Animation && (this.animations = new i.AnimationManager(this)), this.components.LoadTexture && null !== o && this.loadTexture(o, n), this.components.FixedToCamera && (this.cameraOffset = new i.Point(e, s))
        }, i.Component.Core.preUpdate = function() {
            if (!this.pendingDestroy) {
                if (this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, !this.exists || !this.parent.exists) return this.renderOrderID = -1, !1;
                this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty), this.visible && (this.renderOrderID = this.game.stage.currentRenderOrderID++), this.animations && this.animations.update(), this.body && this.body.preUpdate();
                for (var t = 0; t < this.children.length; t++) this.children[t].preUpdate();
                return !0
            }
            this.destroy()
        }, i.Component.Core.prototype = {
            game: null,
            name: "",
            data: {},
            components: {},
            z: 0,
            events: void 0,
            animations: void 0,
            key: "",
            world: null,
            debug: !1,
            previousPosition: null,
            previousRotation: 0,
            renderOrderID: 0,
            fresh: !0,
            pendingDestroy: !1,
            _bounds: null,
            _exists: !0,
            exists: {
                get: function() {
                    return this._exists
                },
                set: function(t) {
                    t ? (this._exists = !0, this.body && this.body.type === i.Physics.P2JS && this.body.addToWorld(), this.visible = !0) : (this._exists = !1, this.body && this.body.type === i.Physics.P2JS && this.body.removeFromWorld(), this.visible = !1)
                }
            },
            update: function() {},
            postUpdate: function() {
                this.customRender && this.key.render(), this.components.PhysicsBody && i.Component.PhysicsBody.postUpdate.call(this), this.components.FixedToCamera && i.Component.FixedToCamera.postUpdate.call(this);
                for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate()
            }
        }, i.Component.Crop = function() {}, i.Component.Crop.prototype = {
            cropRect: null,
            _crop: null,
            crop: function(t, e) {
                void 0 === e && (e = !1), t ? (e && null !== this.cropRect ? this.cropRect.setTo(t.x, t.y, t.width, t.height) : e && null === this.cropRect ? this.cropRect = new i.Rectangle(t.x, t.y, t.width, t.height) : this.cropRect = t, this.updateCrop()) : (this._crop = null, this.cropRect = null, this.resetFrame())
            },
            updateCrop: function() {
                if (this.cropRect) {
                    var t = this.texture.crop.x,
                        e = this.texture.crop.y,
                        s = this.texture.crop.width,
                        o = this.texture.crop.height;
                    this._crop = i.Rectangle.clone(this.cropRect, this._crop), this._crop.x += this._frame.x, this._crop.y += this._frame.y;
                    var n = Math.max(this._frame.x, this._crop.x),
                        a = Math.max(this._frame.y, this._crop.y),
                        r = Math.min(this._frame.right, this._crop.right) - n,
                        h = Math.min(this._frame.bottom, this._crop.bottom) - a;
                    this.texture.crop.x = n, this.texture.crop.y = a, this.texture.crop.width = r, this.texture.crop.height = h, this.texture.frame.width = Math.min(r, this.cropRect.width), this.texture.frame.height = Math.min(h, this.cropRect.height), this.texture.width = this.texture.frame.width, this.texture.height = this.texture.frame.height, this.texture._updateUvs(), 16777215 === this.tint || t === n && e === a && s === r && o === h || (this.texture.requiresReTint = !0)
                }
            }
        }, i.Component.Delta = function() {}, i.Component.Delta.prototype = {
            deltaX: {
                get: function() {
                    return this.world.x - this.previousPosition.x
                }
            },
            deltaY: {
                get: function() {
                    return this.world.y - this.previousPosition.y
                }
            },
            deltaZ: {
                get: function() {
                    return this.rotation - this.previousRotation
                }
            }
        }, i.Component.Destroy = function() {}, i.Component.Destroy.prototype = {
            destroyPhase: !1,
            destroy: function(t, e) {
                if (null !== this.game && !this.destroyPhase) {
                    void 0 === t && (t = !0), void 0 === e && (e = !1), this.destroyPhase = !0, this.events && this.events.onDestroy$dispatch(this), this.parent && (this.parent instanceof i.Group ? this.parent.remove(this) : this.parent.removeChild(this)), this.input && this.input.destroy(), this.animations && this.animations.destroy(), this.body && this.body.destroy(), this.events && this.events.destroy(), this.game.tweens.removeFrom(this);
                    var s = this.children.length;
                    if (t)
                        for (; s--;) this.children[s].destroy(t);
                    else
                        for (; s--;) this.removeChild(this.children[s]);
                    this._crop && (this._crop = null, this.cropRect = null), this._frame && (this._frame = null), i.Video && this.key instanceof i.Video && this.key.onChangeSource.remove(this.resizeFrame, this), i.BitmapText && this._glyphs && (this._glyphs = []), this.alive = !1, this.exists = !1, this.visible = !1, this.filters = null, this.mask = null, this.game = null, this.data = {}, this.renderable = !1, this.transformCallback && (this.transformCallback = null, this.transformCallbackContext = null), this.hitArea = null, this.parent = null, this.stage = null, this.worldTransform = null, this.filterArea = null, this._bounds = null, this._currentBounds = null, this._mask = null, this._destroyCachedSprite(), e && this.texture.destroy(!0), this.destroyPhase = !1, this.pendingDestroy = !1
                }
            }
        }, i.Events = function(t) {
            this.parent = t
        }, i.Events.prototype = {
            destroy: function() {
                this._parent = null, this._onDestroy && this._onDestroy.dispose(), this._onAddedToGroup && this._onAddedToGroup.dispose(), this._onRemovedFromGroup && this._onRemovedFromGroup.dispose(), this._onRemovedFromWorld && this._onRemovedFromWorld.dispose(), this._onKilled && this._onKilled.dispose(), this._onRevived && this._onRevived.dispose(), this._onEnterBounds && this._onEnterBounds.dispose(), this._onOutOfBounds && this._onOutOfBounds.dispose(), this._onInputOver && this._onInputOver.dispose(), this._onInputOut && this._onInputOut.dispose(), this._onInputDown && this._onInputDown.dispose(), this._onInputUp && this._onInputUp.dispose(), this._onDragStart && this._onDragStart.dispose(), this._onDragUpdate && this._onDragUpdate.dispose(), this._onDragStop && this._onDragStop.dispose(), this._onAnimationStart && this._onAnimationStart.dispose(), this._onAnimationComplete && this._onAnimationComplete.dispose(), this._onAnimationLoop && this._onAnimationLoop.dispose()
            },
            onAddedToGroup: null,
            onRemovedFromGroup: null,
            onRemovedFromWorld: null,
            onDestroy: null,
            onKilled: null,
            onRevived: null,
            onOutOfBounds: null,
            onEnterBounds: null,
            onInputOver: null,
            onInputOut: null,
            onInputDown: null,
            onInputUp: null,
            onDragStart: null,
            onDragUpdate: null,
            onDragStop: null,
            onAnimationStart: null,
            onAnimationComplete: null,
            onAnimationLoop: null
        }, i.Events.prototype.constructor = i.Events;
        for (var n in i.Events.prototype) i.Events.prototype.hasOwnProperty(n) && 0 === n.indexOf("on") && null === i.Events.prototype[n] && function(t, e) {
            Object.defineProperty(i.Events.prototype, t, {
                get: function() {
                    return this[e] || (this[e] = new i.Signal)
                }
            }), i.Events.prototype[t + "$dispatch"] = function() {
                return this[e] ? this[e].dispatch.apply(this[e], arguments) : null
            }
        }(n, "_" + n);
        i.Component.FixedToCamera = function() {}, i.Component.FixedToCamera.postUpdate = function() {
            this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y)
        }, i.Component.FixedToCamera.prototype = {
            _fixedToCamera: !1,
            fixedToCamera: {
                get: function() {
                    return this._fixedToCamera
                },
                set: function(t) {
                    t ? (this._fixedToCamera = !0, this.cameraOffset.set(this.x, this.y)) : this._fixedToCamera = !1
                }
            },
            cameraOffset: new i.Point
        }, i.Component.Health = function() {}, i.Component.Health.prototype = {
            health: 1,
            maxHealth: 100,
            damage: function(t) {
                return this.alive && (this.health -= t, this.health <= 0 && this.kill()), this
            },
            setHealth: function(t) {
                return this.health = t, this.health > this.maxHealth && (this.health = this.maxHealth), this
            },
            heal: function(t) {
                return this.alive && (this.health += t, this.health > this.maxHealth && (this.health = this.maxHealth)), this
            }
        }, i.Component.InCamera = function() {}, i.Component.InCamera.prototype = {
            inCamera: {
                get: function() {
                    return this.game.world.camera.view.intersects(this._bounds)
                }
            }
        }, i.Component.InputEnabled = function() {}, i.Component.InputEnabled.prototype = {
            input: null,
            inputEnabled: {
                get: function() {
                    return this.input && this.input.enabled
                },
                set: function(t) {
                    t ? null === this.input ? (this.input = new i.InputHandler(this), this.input.start()) : this.input && !this.input.enabled && this.input.start() : this.input && this.input.enabled && this.input.stop()
                }
            }
        }, i.Component.InWorld = function() {}, i.Component.InWorld.preUpdate = function() {
            if (this.autoCull || this.checkWorldBounds) {
                if (this._bounds.copyFrom(this.getBounds()), this._bounds.x += this.game.camera.view.x, this._bounds.y += this.game.camera.view.y, this.autoCull)
                    if (this.game.world.camera.view.intersects(this._bounds)) this.renderable = !0, this.game.world.camera.totalInView++;
                    else if (this.renderable = !1, this.outOfCameraBoundsKill) return this.kill(), !1;
                if (this.checkWorldBounds)
                    if (this._outOfBoundsFired && this.game.world.bounds.intersects(this._bounds)) this._outOfBoundsFired = !1, this.events.onEnterBounds$dispatch(this);
                    else if (!this._outOfBoundsFired && !this.game.world.bounds.intersects(this._bounds) && (this._outOfBoundsFired = !0, this.events.onOutOfBounds$dispatch(this), this.outOfBoundsKill)) return this.kill(), !1
            }
            return !0
        }, i.Component.InWorld.prototype = {
            checkWorldBounds: !1,
            outOfBoundsKill: !1,
            outOfCameraBoundsKill: !1,
            _outOfBoundsFired: !1,
            inWorld: {
                get: function() {
                    return this.game.world.bounds.intersects(this.getBounds())
                }
            }
        }, i.Component.LifeSpan = function() {}, i.Component.LifeSpan.preUpdate = function() {
            return !(this.lifespan > 0 && (this.lifespan -= this.game.time.physicsElapsedMS, this.lifespan <= 0) && (this.kill(), 1))
        }, i.Component.LifeSpan.prototype = {
            alive: !0,
            lifespan: 0,
            revive: function(t) {
                return void 0 === t && (t = 100), this.alive = !0, this.exists = !0, this.visible = !0, "function" == typeof this.setHealth && this.setHealth(t), this.events && this.events.onRevived$dispatch(this), this
            },
            kill: function() {
                return this.alive = !1, this.exists = !1, this.visible = !1, this.events && this.events.onKilled$dispatch(this), this
            }
        }, i.Component.LoadTexture = function() {}, i.Component.LoadTexture.prototype = {
            customRender: !1,
            _frame: null,
            loadTexture: function(t, e, s) {
                t === i.PENDING_ATLAS ? (t = e, e = 0) : e = e || 0, (s || void 0 === s) && this.animations && this.animations.stop(), this.key = t, this.customRender = !1;
                var o = this.game.cache,
                    n = !0,
                    a = !this.texture.baseTexture.scaleMode;
                if (i.RenderTexture && t instanceof i.RenderTexture) this.key = t.key, this.setTexture(t);
                else if (i.BitmapData && t instanceof i.BitmapData) this.customRender = !0, this.setTexture(t.texture), n = o.hasFrameData(t.key, i.Cache.BITMAPDATA) ? !this.animations.loadFrameData(o.getFrameData(t.key, i.Cache.BITMAPDATA), e) : !this.animations.loadFrameData(t.frameData, 0);
                else if (i.Video && t instanceof i.Video) {
                    this.customRender = !0;
                    var r = t.texture.valid;
                    this.setTexture(t.texture), this.setFrame(t.texture.frame.clone()), t.onChangeSource.add(this.resizeFrame, this), this.texture.valid = r
                } else if (i.Tilemap && t instanceof i.TilemapLayer) this.setTexture(PIXI.Texture.fromCanvas(t.canvas));
                else if (t instanceof PIXI.Texture) this.setTexture(t);
                else {
                    var h = o.getImage(t, !0);
                    this.key = h.key, this.setTexture(new PIXI.Texture(h.base)), this.texture.baseTexture.skipRender = "__default" === t, n = !this.animations.loadFrameData(h.frameData, e)
                }
                n && (this._frame = i.Rectangle.clone(this.texture.frame)), a || (this.texture.baseTexture.scaleMode = 1)
            },
            setFrame: function(t) {
                this._frame = t, this.texture.frame.x = t.x, this.texture.frame.y = t.y, this.texture.frame.width = t.width, this.texture.frame.height = t.height, this.texture.crop.x = t.x, this.texture.crop.y = t.y, this.texture.crop.width = t.width, this.texture.crop.height = t.height, t.trimmed ? (this.texture.trim ? (this.texture.trim.x = t.spriteSourceSizeX, this.texture.trim.y = t.spriteSourceSizeY, this.texture.trim.width = t.sourceSizeW, this.texture.trim.height = t.sourceSizeH) : this.texture.trim = {
                    x: t.spriteSourceSizeX,
                    y: t.spriteSourceSizeY,
                    width: t.sourceSizeW,
                    height: t.sourceSizeH
                }, this.texture.width = t.sourceSizeW, this.texture.height = t.sourceSizeH, this.texture.frame.width = t.sourceSizeW, this.texture.frame.height = t.sourceSizeH) : !t.trimmed && this.texture.trim && (this.texture.trim = null), this.cropRect && this.updateCrop(), this.texture.requiresReTint = !0, this.texture._updateUvs(), this.tilingTexture && (this.refreshTexture = !0)
            },
            resizeFrame: function(t, e, i) {
                this.texture.frame.resize(e, i), this.texture.setFrame(this.texture.frame)
            },
            resetFrame: function() {
                this._frame && this.setFrame(this._frame)
            },
            frame: {
                get: function() {
                    return this.animations.frame
                },
                set: function(t) {
                    this.animations.frame = t
                }
            },
            frameName: {
                get: function() {
                    return this.animations.frameName
                },
                set: function(t) {
                    this.animations.frameName = t
                }
            }
        }, i.Component.Overlap = function() {}, i.Component.Overlap.prototype = {
            overlap: function(t) {
                return i.Rectangle.intersects(this.getBounds(), t.getBounds())
            }
        }, i.Component.PhysicsBody = function() {}, i.Component.PhysicsBody.preUpdate = function() {
            return this.fresh && this.exists ? (this.world.setTo(this.parent.position.x + this.position.x, this.parent.position.y + this.position.y), this.worldTransform.tx = this.world.x, this.worldTransform.ty = this.world.y, this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, this.body && this.body.preUpdate(), this.fresh = !1, !1) : (this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, !(!this._exists || !this.parent.exists) || (this.renderOrderID = -1, !1))
        }, i.Component.PhysicsBody.postUpdate = function() {
            this.exists && this.body && this.body.postUpdate()
        }, i.Component.PhysicsBody.prototype = {
            body: null,
            x: {
                get: function() {
                    return this.position.x
                },
                set: function(t) {
                    this.position.x = t, this.body && !this.body.dirty && (this.body._reset = !0)
                }
            },
            y: {
                get: function() {
                    return this.position.y
                },
                set: function(t) {
                    this.position.y = t, this.body && !this.body.dirty && (this.body._reset = !0)
                }
            }
        }, i.Component.Reset = function() {}, i.Component.Reset.prototype.reset = function(t, e, i) {
            return void 0 === i && (i = 1), this.world.set(t, e), this.position.set(t, e), this.fresh = !0, this.exists = !0, this.visible = !0, this.renderable = !0, this.components.InWorld && (this._outOfBoundsFired = !1), this.components.LifeSpan && (this.alive = !0, this.health = i), this.components.PhysicsBody && this.body && this.body.reset(t, e, !1, !1), this
        }, i.Component.ScaleMinMax = function() {}, i.Component.ScaleMinMax.prototype = {
            transformCallback: null,
            transformCallbackContext: this,
            scaleMin: null,
            scaleMax: null,
            checkTransform: function(t) {
                this.scaleMin && (t.a < this.scaleMin.x && (t.a = this.scaleMin.x), t.d < this.scaleMin.y && (t.d = this.scaleMin.y)), this.scaleMax && (t.a > this.scaleMax.x && (t.a = this.scaleMax.x), t.d > this.scaleMax.y && (t.d = this.scaleMax.y))
            },
            setScaleMinMax: function(t, e, s, o) {
                void 0 === e ? e = s = o = t : void 0 === s && (s = o = e, e = t), null === t ? this.scaleMin = null : this.scaleMin ? this.scaleMin.set(t, e) : this.scaleMin = new i.Point(t, e), null === s ? this.scaleMax = null : this.scaleMax ? this.scaleMax.set(s, o) : this.scaleMax = new i.Point(s, o), null === this.scaleMin ? this.transformCallback = null : (this.transformCallback = this.checkTransform, this.transformCallbackContext = this)
            }
        }, i.Component.Smoothed = function() {}, i.Component.Smoothed.prototype = {
            smoothed: {
                get: function() {
                    return !this.texture.baseTexture.scaleMode
                },
                set: function(t) {
                    t ? this.texture && (this.texture.baseTexture.scaleMode = 0) : this.texture && (this.texture.baseTexture.scaleMode = 1)
                }
            }
        }, i.GameObjectFactory = function(t) {
            this.game = t, this.world = this.game.world
        }, i.GameObjectFactory.prototype = {
            existing: function(t) {
                return this.world.add(t)
            },
            weapon: function(t, e, s, o) {
                var n = this.game.plugins.add(i.Weapon);
                return n.createBullets(t, e, s, o), n
            },
            image: function(t, e, s, o, n) {
                return void 0 === n && (n = this.world), n.add(new i.Image(this.game, t, e, s, o))
            },
            sprite: function(t, e, i, s, o) {
                return void 0 === o && (o = this.world), o.create(t, e, i, s)
            },
            creature: function(t, e, s, o, n) {
                void 0 === n && (n = this.world);
                var a = new i.Creature(this.game, t, e, s, o);
                return n.add(a), a
            },
            tween: function(t) {
                return this.game.tweens.create(t)
            },
            group: function(t, e, s, o, n) {
                return new i.Group(this.game, t, e, s, o, n)
            },
            physicsGroup: function(t, e, s, o) {
                return new i.Group(this.game, e, s, o, !0, t)
            },
            spriteBatch: function(t, e, s) {
                return void 0 === t && (t = null), void 0 === e && (e = "group"), void 0 === s && (s = !1), new i.SpriteBatch(this.game, t, e, s)
            },
            audio: function(t, e, i, s) {
                return this.game.sound.add(t, e, i, s)
            },
            sound: function(t, e, i, s) {
                return this.game.sound.add(t, e, i, s)
            },
            audioSprite: function(t) {
                return this.game.sound.addSprite(t)
            },
            tileSprite: function(t, e, s, o, n, a, r) {
                return void 0 === r && (r = this.world), r.add(new i.TileSprite(this.game, t, e, s, o, n, a))
            },
            rope: function(t, e, s, o, n, a) {
                return void 0 === a && (a = this.world), a.add(new i.Rope(this.game, t, e, s, o, n))
            },
            text: function(t, e, s, o, n) {
                return void 0 === n && (n = this.world), n.add(new i.Text(this.game, t, e, s, o))
            },
            button: function(t, e, s, o, n, a, r, h, l, c) {
                return void 0 === c && (c = this.world), c.add(new i.Button(this.game, t, e, s, o, n, a, r, h, l))
            },
            graphics: function(t, e, s) {
                return void 0 === s && (s = this.world), s.add(new i.Graphics(this.game, t, e))
            },
            emitter: function(t, e, s) {
                return this.game.particles.add(new i.Particles.Arcade.Emitter(this.game, t, e, s))
            },
            retroFont: function(t, e, s, o, n, a, r, h, l) {
                return new i.RetroFont(this.game, t, e, s, o, n, a, r, h, l)
            },
            bitmapText: function(t, e, s, o, n, a) {
                return void 0 === a && (a = this.world), a.add(new i.BitmapText(this.game, t, e, s, o, n))
            },
            tilemap: function(t, e, s, o, n) {
                return new i.Tilemap(this.game, t, e, s, o, n)
            },
            renderTexture: function(t, e, s, o) {
                void 0 !== s && "" !== s || (s = this.game.rnd.uuid()), void 0 === o && (o = !1);
                var n = new i.RenderTexture(this.game, t, e, s);
                return o && this.game.cache.addRenderTexture(s, n), n
            },
            video: function(t, e) {
                return new i.Video(this.game, t, e)
            },
            bitmapData: function(t, e, s, o) {
                void 0 === o && (o = !1), void 0 !== s && "" !== s || (s = this.game.rnd.uuid());
                var n = new i.BitmapData(this.game, s, t, e);
                return o && this.game.cache.addBitmapData(s, n), n
            },
            filter: function(t) {
                var e = Array.prototype.slice.call(arguments, 1);
                return (t = new i.Filter[t](this.game)).init.apply(t, e), t
            },
            plugin: function(t) {
                return this.game.plugins.add(t)
            }
        }, i.GameObjectFactory.prototype.constructor = i.GameObjectFactory, i.GameObjectCreator = function(t) {
            this.game = t, this.world = this.game.world
        }, i.GameObjectCreator.prototype = {
            image: function(t, e, s, o) {
                return new i.Image(this.game, t, e, s, o)
            },
            sprite: function(t, e, s, o) {
                return new i.Sprite(this.game, t, e, s, o)
            },
            tween: function(t) {
                return new i.Tween(t, this.game, this.game.tweens)
            },
            group: function(t, e, s, o, n) {
                return new i.Group(this.game, t, e, s, o, n)
            },
            spriteBatch: function(t, e, s) {
                return void 0 === e && (e = "group"), void 0 === s && (s = !1), new i.SpriteBatch(this.game, t, e, s)
            },
            audio: function(t, e, i, s) {
                return this.game.sound.add(t, e, i, s)
            },
            audioSprite: function(t) {
                return this.game.sound.addSprite(t)
            },
            sound: function(t, e, i, s) {
                return this.game.sound.add(t, e, i, s)
            },
            tileSprite: function(t, e, s, o, n, a) {
                return new i.TileSprite(this.game, t, e, s, o, n, a)
            },
            rope: function(t, e, s, o, n) {
                return new i.Rope(this.game, t, e, s, o, n)
            },
            text: function(t, e, s, o) {
                return new i.Text(this.game, t, e, s, o)
            },
            button: function(t, e, s, o, n, a, r, h, l) {
                return new i.Button(this.game, t, e, s, o, n, a, r, h, l)
            },
            graphics: function(t, e) {
                return new i.Graphics(this.game, t, e)
            },
            emitter: function(t, e, s) {
                return new i.Particles.Arcade.Emitter(this.game, t, e, s)
            },
            retroFont: function(t, e, s, o, n, a, r, h, l) {
                return new i.RetroFont(this.game, t, e, s, o, n, a, r, h, l)
            },
            bitmapText: function(t, e, s, o, n, a) {
                return new i.BitmapText(this.game, t, e, s, o, n, a)
            },
            tilemap: function(t, e, s, o, n) {
                return new i.Tilemap(this.game, t, e, s, o, n)
            },
            renderTexture: function(t, e, s, o) {
                void 0 !== s && "" !== s || (s = this.game.rnd.uuid()), void 0 === o && (o = !1);
                var n = new i.RenderTexture(this.game, t, e, s);
                return o && this.game.cache.addRenderTexture(s, n), n
            },
            bitmapData: function(t, e, s, o) {
                void 0 === o && (o = !1), void 0 !== s && "" !== s || (s = this.game.rnd.uuid());
                var n = new i.BitmapData(this.game, s, t, e);
                return o && this.game.cache.addBitmapData(s, n), n
            },
            filter: function(t) {
                var e = Array.prototype.slice.call(arguments, 1);
                return (t = new i.Filter[t](this.game)).init.apply(t, e), t
            }
        }, i.GameObjectCreator.prototype.constructor = i.GameObjectCreator, i.Sprite = function(t, e, s, o, n) {
            e = e || 0, s = s || 0, o = o || null, n = n || null, this.type = i.SPRITE, this.physicsType = i.SPRITE, PIXI.Sprite.call(this, i.Cache.DEFAULT), i.Component.Core.init.call(this, t, e, s, o, n)
        }, i.Sprite.prototype = Object.create(PIXI.Sprite.prototype), i.Sprite.prototype.constructor = i.Sprite, i.Component.Core.install.call(i.Sprite.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Delta", "Destroy", "FixedToCamera", "Health", "InCamera", "InputEnabled", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "ScaleMinMax", "Smoothed"]), i.Sprite.prototype.preUpdatePhysics = i.Component.PhysicsBody.preUpdate, i.Sprite.prototype.preUpdateLifeSpan = i.Component.LifeSpan.preUpdate, i.Sprite.prototype.preUpdateInWorld = i.Component.InWorld.preUpdate, i.Sprite.prototype.preUpdateCore = i.Component.Core.preUpdate, i.Sprite.prototype.preUpdate = function() {
            return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        }, i.Image = function(t, e, s, o, n) {
            e = e || 0, s = s || 0, o = o || null, n = n || null, this.type = i.IMAGE, PIXI.Sprite.call(this, i.Cache.DEFAULT), i.Component.Core.init.call(this, t, e, s, o, n)
        }, i.Image.prototype = Object.create(PIXI.Sprite.prototype), i.Image.prototype.constructor = i.Image, i.Component.Core.install.call(i.Image.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Destroy", "FixedToCamera", "InputEnabled", "LifeSpan", "LoadTexture", "Overlap", "Reset", "ScaleMinMax", "Smoothed"]), i.Image.prototype.preUpdateInWorld = i.Component.InWorld.preUpdate, i.Image.prototype.preUpdateCore = i.Component.Core.preUpdate, i.Image.prototype.preUpdate = function() {
            return !!this.preUpdateInWorld() && this.preUpdateCore()
        }, i.Button = function(t, e, s, o, n, a, r, h, l, c) {
            e = e || 0, s = s || 0, o = o || null, n = n || null, a = a || this, i.Image.call(this, t, e, s, o, h), this.type = i.BUTTON, this.physicsType = i.SPRITE, this._onOverFrame = null, this._onOutFrame = null, this._onDownFrame = null, this._onUpFrame = null, this.onOverSound = null, this.onOutSound = null, this.onDownSound = null, this.onUpSound = null, this.onOverSoundMarker = "", this.onOutSoundMarker = "", this.onDownSoundMarker = "", this.onUpSoundMarker = "", this.onInputOver = new i.Signal, this.onInputOut = new i.Signal, this.onInputDown = new i.Signal, this.onInputUp = new i.Signal, this.onOverMouseOnly = !0, this.justReleasedPreventsOver = i.PointerMode.TOUCH, this.freezeFrames = !1, this.forceOut = !1, this.inputEnabled = !0, this.input.start(0, !0), this.input.useHandCursor = !0, this.setFrames(r, h, l, c), null !== n && this.onInputUp.add(n, a), this.events.onInputOver.add(this.onInputOverHandler, this), this.events.onInputOut.add(this.onInputOutHandler, this), this.events.onInputDown.add(this.onInputDownHandler, this), this.events.onInputUp.add(this.onInputUpHandler, this), this.events.onRemovedFromWorld.add(this.removedFromWorld, this)
        }, i.Button.prototype = Object.create(i.Image.prototype), i.Button.prototype.constructor = i.Button;
        var a = "Over",
            r = "Out",
            h = "Down",
            l = "Up";
        i.Button.prototype.clearFrames = function() {
            this.setFrames(null, null, null, null)
        }, i.Button.prototype.removedFromWorld = function() {
            this.inputEnabled = !1
        }, i.Button.prototype.setStateFrame = function(t, e, i) {
            var s = "_on" + t + "Frame";
            null !== e ? (this[s] = e, i && this.changeStateFrame(t)) : this[s] = null
        }, i.Button.prototype.changeStateFrame = function(t) {
            if (this.freezeFrames) return !1;
            var e = this["_on" + t + "Frame"];
            return "string" == typeof e ? (this.frameName = e, !0) : "number" == typeof e && (this.frame = e, !0)
        }, i.Button.prototype.setFrames = function(t, e, i, s) {
            this.setStateFrame(a, t, this.input.pointerOver()), this.setStateFrame(r, e, !this.input.pointerOver()), this.setStateFrame(h, i, this.input.pointerDown()), this.setStateFrame(l, s, this.input.pointerUp())
        }, i.Button.prototype.setStateSound = function(t, e, s) {
            var o = "on" + t + "Sound",
                n = "on" + t + "SoundMarker";
            e instanceof i.Sound || e instanceof i.AudioSprite ? (this[o] = e, this[n] = "string" == typeof s ? s : "") : (this[o] = null, this[n] = "")
        }, i.Button.prototype.playStateSound = function(t) {
            var e = this["on" + t + "Sound"];
            if (e) {
                var i = this["on" + t + "SoundMarker"];
                return e.play(i), !0
            }
            return !1
        }, i.Button.prototype.setSounds = function(t, e, i, s, o, n, c, p) {
            this.setStateSound(a, t, e), this.setStateSound(r, o, n), this.setStateSound(h, i, s), this.setStateSound(l, c, p)
        }, i.Button.prototype.setOverSound = function(t, e) {
            this.setStateSound(a, t, e)
        }, i.Button.prototype.setOutSound = function(t, e) {
            this.setStateSound(r, t, e)
        }, i.Button.prototype.setDownSound = function(t, e) {
            this.setStateSound(h, t, e)
        }, i.Button.prototype.setUpSound = function(t, e) {
            this.setStateSound(l, t, e)
        }, i.Button.prototype.onInputOverHandler = function(t, e) {
            e.justReleased() && (this.justReleasedPreventsOver & e.pointerMode) === e.pointerMode || (this.changeStateFrame(a), this.onOverMouseOnly && !e.isMouse || (this.playStateSound(a), this.onInputOver && this.onInputOver.dispatch(this, e)))
        }, i.Button.prototype.onInputOutHandler = function(t, e) {
            this.changeStateFrame(r), this.playStateSound(r), this.onInputOut && this.onInputOut.dispatch(this, e)
        }, i.Button.prototype.onInputDownHandler = function(t, e) {
            this.changeStateFrame(h), this.playStateSound(h), this.onInputDown && this.onInputDown.dispatch(this, e)
        }, i.Button.prototype.onInputUpHandler = function(t, e, i) {
            this.playStateSound(l), this.onInputUp && this.onInputUp.dispatch(this, e, i), this.freezeFrames || (!0 === this.forceOut || (this.forceOut & e.pointerMode) === e.pointerMode ? this.changeStateFrame(r) : this.changeStateFrame(l) || (i ? this.changeStateFrame(a) : this.changeStateFrame(r)))
        }, i.SpriteBatch = function(t, e, s, o) {
            void 0 !== e && null !== e || (e = t.world), PIXI.SpriteBatch.call(this), i.Group.call(this, t, e, s, o), this.type = i.SPRITEBATCH
        }, i.SpriteBatch.prototype = i.Utils.extend(!0, i.SpriteBatch.prototype, PIXI.SpriteBatch.prototype, i.Group.prototype), i.SpriteBatch.prototype.constructor = i.SpriteBatch, i.BitmapData = function(t, e, s, o, n) {
            void 0 !== s && 0 !== s || (s = 256), void 0 !== o && 0 !== o || (o = 256), void 0 === n && (n = !1), this.game = t, this.key = e, this.width = s, this.height = o, this.canvas = i.Canvas.create(this, s, o, null, n), this.context = this.canvas.getContext("2d", {
                alpha: !0
            }), this.ctx = this.context, this.smoothProperty = t.renderType === i.CANVAS ? t.renderer.renderSession.smoothProperty : i.Canvas.getSmoothingPrefix(this.context), this.imageData = this.context.getImageData(0, 0, s, o), this.data = null, this.imageData && (this.data = this.imageData.data), this.pixels = null, this.data && (this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data), this.baseTexture = new PIXI.BaseTexture(this.canvas), this.texture = new PIXI.Texture(this.baseTexture), this.frameData = new i.FrameData, this.textureFrame = this.frameData.addFrame(new i.Frame(0, 0, 0, s, o, "bitmapData")), this.texture.frame = this.textureFrame, this.type = i.BITMAPDATA, this.disableTextureUpload = !1, this.dirty = !1, this.cls = this.clear, this._image = null, this._pos = new i.Point, this._size = new i.Point, this._scale = new i.Point, this._rotate = 0, this._alpha = {
                prev: 1,
                current: 1
            }, this._anchor = new i.Point, this._tempR = 0, this._tempG = 0, this._tempB = 0, this._circle = new i.Circle, this._swapCanvas = void 0
        }, i.BitmapData.prototype = {
            move: function(t, e, i) {
                return 0 !== t && this.moveH(t, i), 0 !== e && this.moveV(e, i), this
            },
            moveH: function(t, e) {
                void 0 === e && (e = !0), void 0 === this._swapCanvas && (this._swapCanvas = PIXI.CanvasPool.create(this, this.width, this.height));
                var i = this._swapCanvas.getContext("2d"),
                    s = this.height,
                    o = this.canvas;
                if (i.clearRect(0, 0, this.width, this.height), t < 0) {
                    t = Math.abs(t);
                    n = this.width - t;
                    e && i.drawImage(o, 0, 0, t, s, n, 0, t, s), i.drawImage(o, t, 0, n, s, 0, 0, n, s)
                } else {
                    var n = this.width - t;
                    e && i.drawImage(o, n, 0, t, s, 0, 0, t, s), i.drawImage(o, 0, 0, n, s, t, 0, n, s)
                }
                return this.clear(), this.copy(this._swapCanvas)
            },
            moveV: function(t, e) {
                void 0 === e && (e = !0), void 0 === this._swapCanvas && (this._swapCanvas = PIXI.CanvasPool.create(this, this.width, this.height));
                var i = this._swapCanvas.getContext("2d"),
                    s = this.width,
                    o = this.canvas;
                if (i.clearRect(0, 0, this.width, this.height), t < 0) {
                    t = Math.abs(t);
                    n = this.height - t;
                    e && i.drawImage(o, 0, 0, s, t, 0, n, s, t), i.drawImage(o, 0, t, s, n, 0, 0, s, n)
                } else {
                    var n = this.height - t;
                    e && i.drawImage(o, 0, n, s, t, 0, 0, s, t), i.drawImage(o, 0, 0, s, n, 0, t, s, n)
                }
                return this.clear(), this.copy(this._swapCanvas)
            },
            add: function(t) {
                if (Array.isArray(t))
                    for (var e = 0; e < t.length; e++) t[e].loadTexture && t[e].loadTexture(this);
                else t.loadTexture(this);
                return this
            },
            load: function(t) {
                if ("string" == typeof t && (t = this.game.cache.getImage(t)), t) return this.resize(t.width, t.height), this.cls(), this.draw(t), this.update(), this
            },
            clear: function(t, e, i, s) {
                return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.width), void 0 === s && (s = this.height), this.context.clearRect(t, e, i, s), this.dirty = !0, this
            },
            fill: function(t, e, i, s) {
                return void 0 === s && (s = 1), this.context.fillStyle = "rgba(" + t + "," + e + "," + i + "," + s + ")", this.context.fillRect(0, 0, this.width, this.height), this.dirty = !0, this
            },
            generateTexture: function(t) {
                var e = new Image;
                e.src = this.canvas.toDataURL("image/png");
                var i = this.game.cache.addImage(t, "", e);
                return new PIXI.Texture(i.base)
            },
            resize: function(t, e) {
                return t === this.width && e === this.height || (this.width = t, this.height = e, this.canvas.width = t, this.canvas.height = e, void 0 !== this._swapCanvas && (this._swapCanvas.width = t, this._swapCanvas.height = e), this.baseTexture.width = t, this.baseTexture.height = e, this.textureFrame.width = t, this.textureFrame.height = e, this.texture.width = t, this.texture.height = e, this.texture.crop.width = t, this.texture.crop.height = e, this.update(), this.dirty = !0), this
            },
            update: function(t, e, i, s) {
                return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = Math.max(1, this.width)), void 0 === s && (s = Math.max(1, this.height)), this.imageData = this.context.getImageData(t, e, i, s), this.data = this.imageData.data, this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data, this
            },
            processPixelRGB: function(t, e, s, o, n, a) {
                void 0 === s && (s = 0), void 0 === o && (o = 0), void 0 === n && (n = this.width), void 0 === a && (a = this.height);
                for (var r = s + n, h = o + a, l = i.Color.createColor(), c = {
                        r: 0,
                        g: 0,
                        b: 0,
                        a: 0
                    }, p = !1, u = o; u < h; u++)
                    for (var d = s; d < r; d++) i.Color.unpackPixel(this.getPixel32(d, u), l), !1 !== (c = t.call(e, l, d, u)) && null !== c && void 0 !== c && (this.setPixel32(d, u, c.r, c.g, c.b, c.a, !1), p = !0);
                return p && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0), this
            },
            processPixel: function(t, e, i, s, o, n) {
                void 0 === i && (i = 0), void 0 === s && (s = 0), void 0 === o && (o = this.width), void 0 === n && (n = this.height);
                for (var a = i + o, r = s + n, h = 0, l = 0, c = !1, p = s; p < r; p++)
                    for (var u = i; u < a; u++) h = this.getPixel32(u, p), (l = t.call(e, h, u, p)) !== h && (this.pixels[p * this.width + u] = l, c = !0);
                return c && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0), this
            },
            replaceRGB: function(t, e, s, o, n, a, r, h, l) {
                var c = 0,
                    p = 0,
                    u = this.width,
                    d = this.height,
                    m = i.Color.packPixel(t, e, s, o);
                void 0 !== l && l instanceof i.Rectangle && (c = l.x, p = l.y, u = l.width, d = l.height);
                for (var y = 0; y < d; y++)
                    for (var f = 0; f < u; f++) this.getPixel32(c + f, p + y) === m && this.setPixel32(c + f, p + y, n, a, r, h, !1);
                return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this
            },
            setHSL: function(t, e, s, o) {
                var n = t || 0 === t,
                    a = e || 0 === e,
                    r = s || 0 === s;
                if (n || a || r) {
                    void 0 === o && (o = new i.Rectangle(0, 0, this.width, this.height));
                    for (var h = i.Color.createColor(), l = o.y; l < o.bottom; l++)
                        for (var c = o.x; c < o.right; c++) i.Color.unpackPixel(this.getPixel32(c, l), h, !0), n && (h.h = t), a && (h.s = e), r && (h.l = s), i.Color.HSLtoRGB(h.h, h.s, h.l, h), this.setPixel32(c, l, h.r, h.g, h.b, h.a, !1);
                    return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this
                }
            },
            shiftHSL: function(t, e, s, o) {
                if (void 0 !== t && null !== t || (t = !1), void 0 !== e && null !== e || (e = !1), void 0 !== s && null !== s || (s = !1), t || e || s) {
                    void 0 === o && (o = new i.Rectangle(0, 0, this.width, this.height));
                    for (var n = i.Color.createColor(), a = o.y; a < o.bottom; a++)
                        for (var r = o.x; r < o.right; r++) i.Color.unpackPixel(this.getPixel32(r, a), n, !0), t && (n.h = this.game.math.wrap(n.h + t, 0, 1)), e && (n.s = this.game.math.clamp(n.s + e, 0, 1)), s && (n.l = this.game.math.clamp(n.l + s, 0, 1)), i.Color.HSLtoRGB(n.h, n.s, n.l, n), this.setPixel32(r, a, n.r, n.g, n.b, n.a, !1);
                    return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this
                }
            },
            setPixel32: function(t, e, s, o, n, a, r) {
                return void 0 === r && (r = !0), t >= 0 && t <= this.width && e >= 0 && e <= this.height && (i.Device.LITTLE_ENDIAN ? this.pixels[e * this.width + t] = a << 24 | n << 16 | o << 8 | s : this.pixels[e * this.width + t] = s << 24 | o << 16 | n << 8 | a, r && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0)), this
            },
            setPixel: function(t, e, i, s, o, n) {
                return this.setPixel32(t, e, i, s, o, 255, n)
            },
            getPixel: function(t, e, s) {
                s || (s = i.Color.createColor());
                var o = ~~(t + e * this.width);
                return o *= 4, s.r = this.data[o], s.g = this.data[++o], s.b = this.data[++o], s.a = this.data[++o], s
            },
            getPixel32: function(t, e) {
                if (t >= 0 && t <= this.width && e >= 0 && e <= this.height) return this.pixels[e * this.width + t]
            },
            getPixelRGB: function(t, e, s, o, n) {
                return i.Color.unpackPixel(this.getPixel32(t, e), s, o, n)
            },
            getPixels: function(t) {
                return this.context.getImageData(t.x, t.y, t.width, t.height)
            },
            getFirstPixel: function(t) {
                void 0 === t && (t = 0);
                var e = i.Color.createColor(),
                    s = 0,
                    o = 0,
                    n = 1,
                    a = !1;
                1 === t ? (n = -1, o = this.height) : 3 === t && (n = -1, s = this.width);
                do {
                    i.Color.unpackPixel(this.getPixel32(s, o), e), 0 === t || 1 === t ? ++s === this.width && (s = 0, ((o += n) >= this.height || o <= 0) && (a = !0)) : 2 !== t && 3 !== t || ++o === this.height && (o = 0, ((s += n) >= this.width || s <= 0) && (a = !0))
                } while (0 === e.a && !a);
                return e.x = s, e.y = o, e
            },
            getBounds: function(t) {
                return void 0 === t && (t = new i.Rectangle), t.x = this.getFirstPixel(2).x, t.x === this.width ? t.setTo(0, 0, 0, 0) : (t.y = this.getFirstPixel(0).y, t.width = this.getFirstPixel(3).x - t.x + 1, t.height = this.getFirstPixel(1).y - t.y + 1, t)
            },
            addToWorld: function(t, e, i, s, o, n) {
                o = o || 1, n = n || 1;
                var a = this.game.add.image(t, e, this);
                return a.anchor.set(i, s), a.scale.set(o, n), a
            },
            copy: function(t, e, s, o, n, a, r, h, l, c, p, u, d, m, y, f, g) {
                if (void 0 !== t && null !== t || (t = this), (t instanceof i.RenderTexture || t instanceof PIXI.RenderTexture) && (t = t.getCanvas()), this._image = t, t instanceof i.Sprite || t instanceof i.Image || t instanceof i.Text || t instanceof PIXI.Sprite) this._pos.set(t.texture.crop.x, t.texture.crop.y), this._size.set(t.texture.crop.width, t.texture.crop.height), this._scale.set(t.scale.x, t.scale.y), this._anchor.set(t.anchor.x, t.anchor.y), this._rotate = t.rotation, this._alpha.current = t.alpha, t.texture instanceof i.RenderTexture || t.texture instanceof PIXI.RenderTexture ? this._image = t.texture.getCanvas() : this._image = t.texture.baseTexture.source, void 0 !== a && null !== a || (a = t.x), void 0 !== r && null !== r || (r = t.y), t.texture.trim && (a += t.texture.trim.x - t.anchor.x * t.texture.trim.width, r += t.texture.trim.y - t.anchor.y * t.texture.trim.height), 16777215 !== t.tint && (t.cachedTint !== t.tint && (t.cachedTint = t.tint, t.tintedTexture = PIXI.CanvasTinter.getTintedTexture(t, t.tint)), this._image = t.tintedTexture, this._pos.set(0));
                else {
                    if (this._pos.set(0), this._scale.set(1), this._anchor.set(0), this._rotate = 0, this._alpha.current = 1, t instanceof i.BitmapData) this._image = t.canvas;
                    else if ("string" == typeof t) {
                        if (null === (t = this.game.cache.getImage(t))) return;
                        this._image = t
                    }
                    this._size.set(this._image.width, this._image.height)
                }
                if (void 0 !== e && null !== e || (e = 0), void 0 !== s && null !== s || (s = 0), o && (this._size.x = o), n && (this._size.y = n), void 0 !== a && null !== a || (a = e), void 0 !== r && null !== r || (r = s), void 0 !== h && null !== h || (h = this._size.x), void 0 !== l && null !== l || (l = this._size.y), "number" == typeof c && (this._rotate = c), "number" == typeof p && (this._anchor.x = p), "number" == typeof u && (this._anchor.y = u), "number" == typeof d && (this._scale.x = d), "number" == typeof m && (this._scale.y = m), "number" == typeof y && (this._alpha.current = y), void 0 === f && (f = null), void 0 === g && (g = !1), !(this._alpha.current <= 0 || 0 === this._scale.x || 0 === this._scale.y || 0 === this._size.x || 0 === this._size.y)) {
                    var _ = this.context;
                    return this._alpha.prev = _.globalAlpha, _.save(), _.globalAlpha = this._alpha.current, f && (this.op = f), g && (a |= 0, r |= 0), _.translate(a, r), _.scale(this._scale.x, this._scale.y), _.rotate(this._rotate), _.drawImage(this._image, this._pos.x + e, this._pos.y + s, this._size.x, this._size.y, -h * this._anchor.x, -l * this._anchor.y, h, l), _.restore(), _.globalAlpha = this._alpha.prev, this.dirty = !0, this
                }
            },
            copyTransform: function(t, e, s) {
                if (void 0 === e && (e = null), void 0 === s && (s = !1), !t.hasOwnProperty("worldTransform") || !t.worldVisible || 0 === t.worldAlpha) return this;
                var o = t.worldTransform;
                if (this._pos.set(t.texture.crop.x, t.texture.crop.y), this._size.set(t.texture.crop.width, t.texture.crop.height), 0 === o.a || 0 === o.d || 0 === this._size.x || 0 === this._size.y) return this;
                t.texture instanceof i.RenderTexture || t.texture instanceof PIXI.RenderTexture ? this._image = t.texture.getCanvas() : this._image = t.texture.baseTexture.source;
                var n = o.tx,
                    a = o.ty;
                t.texture.trim && (n += t.texture.trim.x - t.anchor.x * t.texture.trim.width, a += t.texture.trim.y - t.anchor.y * t.texture.trim.height), 16777215 !== t.tint && (t.cachedTint !== t.tint && (t.cachedTint = t.tint, t.tintedTexture = PIXI.CanvasTinter.getTintedTexture(t, t.tint)), this._image = t.tintedTexture, this._pos.set(0)), s && (n |= 0, a |= 0);
                var r = this.context;
                return this._alpha.prev = r.globalAlpha, r.save(), r.globalAlpha = this._alpha.current, e && (this.op = e), r[this.smoothProperty] = t.texture.baseTexture.scaleMode === PIXI.scaleModes.LINEAR, r.setTransform(o.a, o.b, o.c, o.d, n, a), r.drawImage(this._image, this._pos.x, this._pos.y, this._size.x, this._size.y, -this._size.x * t.anchor.x, -this._size.y * t.anchor.y, this._size.x, this._size.y), r.restore(), r.globalAlpha = this._alpha.prev, this.dirty = !0, this
            },
            copyRect: function(t, e, i, s, o, n, a) {
                return this.copy(t, e.x, e.y, e.width, e.height, i, s, e.width, e.height, 0, 0, 0, 1, 1, o, n, a)
            },
            draw: function(t, e, i, s, o, n, a) {
                return this.copy(t, null, null, null, null, e, i, s, o, null, null, null, null, null, null, n, a)
            },
            drawGroup: function(t, e, i) {
                return t.total > 0 && t.forEachExists(this.drawGroupProxy, this, e, i), this
            },
            drawGroupProxy: function(t, e, s) {
                if (t.hasOwnProperty("texture") && this.copyTransform(t, e, s), t.type === i.GROUP && t.exists) this.drawGroup(t, e, s);
                else if (t.hasOwnProperty("children") && t.children.length > 0)
                    for (var o = 0; o < t.children.length; o++) t.children[o].exists && this.copyTransform(t.children[o], e, s)
            },
            drawFull: function(t, e, s) {
                if (!1 === t.worldVisible || 0 === t.worldAlpha || t.hasOwnProperty("exists") && !1 === t.exists) return this;
                if (t.type !== i.GROUP && t.type !== i.EMITTER && t.type !== i.BITMAPTEXT)
                    if (t.type === i.GRAPHICS) {
                        var o = t.getBounds();
                        this.ctx.save(), this.ctx.translate(o.x, o.y), PIXI.CanvasGraphics.renderGraphics(t, this.ctx), this.ctx.restore()
                    } else this.copy(t, null, null, null, null, t.worldPosition.x, t.worldPosition.y, null, null, t.worldRotation, null, null, t.worldScale.x, t.worldScale.y, t.worldAlpha, e, s);
                if (t.children)
                    for (var n = 0; n < t.children.length; n++) this.drawFull(t.children[n], e, s);
                return this
            },
            shadow: function(t, e, i, s) {
                var o = this.context;
                return void 0 === t || null === t ? o.shadowColor = "rgba(0,0,0,0)" : (o.shadowColor = t, o.shadowBlur = e || 5, o.shadowOffsetX = i || 10, o.shadowOffsetY = s || 10), this
            },
            alphaMask: function(t, e, i, s) {
                return void 0 === s || null === s ? this.draw(e).blendSourceAtop() : this.draw(e, s.x, s.y, s.width, s.height).blendSourceAtop(), void 0 === i || null === i ? this.draw(t).blendReset() : this.draw(t, i.x, i.y, i.width, i.height).blendReset(), this
            },
            extract: function(t, e, i, s, o, n, a, r, h) {
                return void 0 === o && (o = 255), void 0 === n && (n = !1), void 0 === a && (a = e), void 0 === r && (r = i), void 0 === h && (h = s), n && t.resize(this.width, this.height), this.processPixelRGB(function(n, l, c) {
                    return n.r === e && n.g === i && n.b === s && t.setPixel32(l, c, a, r, h, o, !1), !1
                }, this), t.context.putImageData(t.imageData, 0, 0), t.dirty = !0, t
            },
            rect: function(t, e, i, s, o) {
                return void 0 !== o && (this.context.fillStyle = o), this.context.fillRect(t, e, i, s), this
            },
            text: function(t, e, i, s, o, n) {
                void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = "14px Courier"), void 0 === o && (o = "rgb(255,255,255)"), void 0 === n && (n = !0);
                var a = this.context,
                    r = a.font;
                return a.font = s, n && (a.fillStyle = "rgb(0,0,0)", a.fillText(t, e + 1, i + 1)), a.fillStyle = o, a.fillText(t, e, i), a.font = r, this
            },
            circle: function(t, e, i, s) {
                var o = this.context;
                return void 0 !== s && (o.fillStyle = s), o.beginPath(), o.arc(t, e, i, 0, 2 * Math.PI, !1), o.closePath(), o.fill(), this
            },
            line: function(t, e, i, s, o, n) {
                void 0 === o && (o = "#fff"), void 0 === n && (n = 1);
                var a = this.context;
                return a.beginPath(), a.moveTo(t, e), a.lineTo(i, s), a.lineWidth = n, a.strokeStyle = o, a.stroke(), a.closePath(), this
            },
            textureLine: function(t, e, s) {
                if (void 0 === s && (s = "repeat-x"), "string" != typeof e || (e = this.game.cache.getImage(e))) {
                    var o = t.length;
                    "no-repeat" === s && o > e.width && (o = e.width);
                    var n = this.context;
                    return n.fillStyle = n.createPattern(e, s), this._circle = new i.Circle(t.start.x, t.start.y, e.height), this._circle.circumferencePoint(t.angle - 1.5707963267948966, !1, this._pos), n.save(), n.translate(this._pos.x, this._pos.y), n.rotate(t.angle), n.fillRect(0, 0, o, e.height), n.restore(), this.dirty = !0, this
                }
            },
            render: function() {
                return !this.disableTextureUpload && this.dirty && (this.baseTexture.dirty(), this.dirty = !1), this
            },
            destroy: function() {
                this.frameData.destroy(), this.texture.destroy(!0), PIXI.CanvasPool.remove(this)
            },
            blendReset: function() {
                return this.op = "source-over", this
            },
            blendSourceOver: function() {
                return this.op = "source-over", this
            },
            blendSourceIn: function() {
                return this.op = "source-in", this
            },
            blendSourceOut: function() {
                return this.op = "source-out", this
            },
            blendSourceAtop: function() {
                return this.op = "source-atop", this
            },
            blendDestinationOver: function() {
                return this.op = "destination-over", this
            },
            blendDestinationIn: function() {
                return this.op = "destination-in", this
            },
            blendDestinationOut: function() {
                return this.op = "destination-out", this
            },
            blendDestinationAtop: function() {
                return this.op = "destination-atop", this
            },
            blendXor: function() {
                return this.op = "xor", this
            },
            blendAdd: function() {
                return this.op = "lighter", this
            },
            blendMultiply: function() {
                return this.op = "multiply", this
            },
            blendScreen: function() {
                return this.op = "screen", this
            },
            blendOverlay: function() {
                return this.op = "overlay", this
            },
            blendDarken: function() {
                return this.op = "darken", this
            },
            blendLighten: function() {
                return this.op = "lighten", this
            },
            blendColorDodge: function() {
                return this.op = "color-dodge", this
            },
            blendColorBurn: function() {
                return this.op = "color-burn", this
            },
            blendHardLight: function() {
                return this.op = "hard-light", this
            },
            blendSoftLight: function() {
                return this.op = "soft-light", this
            },
            blendDifference: function() {
                return this.op = "difference", this
            },
            blendExclusion: function() {
                return this.op = "exclusion", this
            },
            blendHue: function() {
                return this.op = "hue", this
            },
            blendSaturation: function() {
                return this.op = "saturation", this
            },
            blendColor: function() {
                return this.op = "color", this
            },
            blendLuminosity: function() {
                return this.op = "luminosity", this
            }
        }, Object.defineProperty(i.BitmapData.prototype, "smoothed", {
            get: function() {
                i.Canvas.getSmoothingEnabled(this.context)
            },
            set: function(t) {
                i.Canvas.setSmoothingEnabled(this.context, t)
            }
        }), Object.defineProperty(i.BitmapData.prototype, "op", {
            get: function() {
                return this.context.globalCompositeOperation
            },
            set: function(t) {
                this.context.globalCompositeOperation = t
            }
        }), i.BitmapData.getTransform = function(t, e, i, s, o, n) {
            return "number" != typeof t && (t = 0), "number" != typeof e && (e = 0), "number" != typeof i && (i = 1), "number" != typeof s && (s = 1), "number" != typeof o && (o = 0), "number" != typeof n && (n = 0), {
                sx: i,
                sy: s,
                scaleX: i,
                scaleY: s,
                skewX: o,
                skewY: n,
                translateX: t,
                translateY: e,
                tx: t,
                ty: e
            }
        }, i.BitmapData.prototype.constructor = i.BitmapData, PIXI.Graphics = function() {
            PIXI.DisplayObjectContainer.call(this), this.renderable = !0, this.fillAlpha = 1, this.lineWidth = 0, this.lineColor = 0, this.graphicsData = [], this.tint = 16777215, this.blendMode = PIXI.blendModes.NORMAL, this.currentPath = null, this._webGL = [], this.isMask = !1, this.boundsPadding = 0, this._localBounds = new PIXI.Rectangle(0, 0, 1, 1), this.dirty = !0, this._boundsDirty = !1, this.webGLDirty = !1, this.cachedSpriteDirty = !1
        }, PIXI.Graphics.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), PIXI.Graphics.prototype.constructor = PIXI.Graphics, PIXI.Graphics.prototype.lineStyle = function(t, e, i) {
            return this.lineWidth = t || 0, this.lineColor = e || 0, this.lineAlpha = void 0 === i ? 1 : i, this.currentPath && (this.currentPath.shape.points.length ? this.drawShape(new PIXI.Polygon(this.currentPath.shape.points.slice(-2))) : (this.currentPath.lineWidth = this.lineWidth, this.currentPath.lineColor = this.lineColor, this.currentPath.lineAlpha = this.lineAlpha)), this
        }, PIXI.Graphics.prototype.moveTo = function(t, e) {
            return this.drawShape(new PIXI.Polygon([t, e])), this
        }, PIXI.Graphics.prototype.lineTo = function(t, e) {
            return this.currentPath || this.moveTo(0, 0), this.currentPath.shape.points.push(t, e), this.dirty = !0, this._boundsDirty = !0, this
        }, PIXI.Graphics.prototype.quadraticCurveTo = function(t, e, i, s) {
            this.currentPath ? 0 === this.currentPath.shape.points.length && (this.currentPath.shape.points = [0, 0]) : this.moveTo(0, 0);
            var o, n, a = this.currentPath.shape.points;
            0 === a.length && this.moveTo(0, 0);
            for (var r = a[a.length - 2], h = a[a.length - 1], l = 0, c = 1; c <= 20; ++c) l = c / 20, o = r + (t - r) * l, n = h + (e - h) * l, a.push(o + (t + (i - t) * l - o) * l, n + (e + (s - e) * l - n) * l);
            return this.dirty = !0, this._boundsDirty = !0, this
        }, PIXI.Graphics.prototype.bezierCurveTo = function(t, e, i, s, o, n) {
            this.currentPath ? 0 === this.currentPath.shape.points.length && (this.currentPath.shape.points = [0, 0]) : this.moveTo(0, 0);
            for (var a, r, h, l, c, p = this.currentPath.shape.points, u = p[p.length - 2], d = p[p.length - 1], m = 0, y = 1; y <= 20; ++y) m = y / 20, a = 1 - m, r = a * a, h = r * a, l = m * m, c = l * m, p.push(h * u + 3 * r * m * t + 3 * a * l * i + c * o, h * d + 3 * r * m * e + 3 * a * l * s + c * n);
            return this.dirty = !0, this._boundsDirty = !0, this
        }, PIXI.Graphics.prototype.arcTo = function(t, e, i, s, o) {
            this.currentPath ? 0 === this.currentPath.shape.points.length && this.currentPath.shape.points.push(t, e) : this.moveTo(t, e);
            var n = this.currentPath.shape.points,
                a = n[n.length - 2],
                r = n[n.length - 1] - e,
                h = a - t,
                l = s - e,
                c = i - t,
                p = Math.abs(r * c - h * l);
            if (p < 1e-8 || 0 === o) n[n.length - 2] === t && n[n.length - 1] === e || n.push(t, e);
            else {
                var u = r * r + h * h,
                    d = l * l + c * c,
                    m = r * l + h * c,
                    y = o * Math.sqrt(u) / p,
                    f = o * Math.sqrt(d) / p,
                    g = y * m / u,
                    _ = f * m / d,
                    v = y * c + f * h,
                    b = y * l + f * r,
                    x = h * (f + g),
                    C = r * (f + g),
                    S = c * (y + _),
                    w = l * (y + _),
                    A = Math.atan2(C - b, x - v),
                    T = Math.atan2(w - b, S - v);
                this.arc(v + t, b + e, o, A, T, h * l > c * r)
            }
            return this.dirty = !0, this._boundsDirty = !0, this
        }, PIXI.Graphics.prototype.arc = function(t, e, i, s, o, n, a) {
            if (s === o) return this;
            void 0 === n && (n = !1), void 0 === a && (a = 40), !n && o <= s ? o += 2 * Math.PI : n && s <= o && (s += 2 * Math.PI);
            var r = n ? -1 * (s - o) : o - s,
                h = Math.ceil(Math.abs(r) / (2 * Math.PI)) * a;
            if (0 === r) return this;
            var l = t + Math.cos(s) * i,
                c = e + Math.sin(s) * i;
            n && this.filling ? this.moveTo(t, e) : this.moveTo(l, c);
            for (var p = this.currentPath.shape.points, u = r / (2 * h), d = 2 * u, m = Math.cos(u), y = Math.sin(u), f = h - 1, g = f % 1 / f, _ = 0; _ <= f; _++) {
                var v = u + s + d * (_ + g * _),
                    b = Math.cos(v),
                    x = -Math.sin(v);
                p.push((m * b + y * x) * i + t, (m * -x + y * b) * i + e)
            }
            return this.dirty = !0, this._boundsDirty = !0, this
        }, PIXI.Graphics.prototype.beginFill = function(t, e) {
            return this.filling = !0, this.fillColor = t || 0, this.fillAlpha = void 0 === e ? 1 : e, this.currentPath && this.currentPath.shape.points.length <= 2 && (this.currentPath.fill = this.filling, this.currentPath.fillColor = this.fillColor, this.currentPath.fillAlpha = this.fillAlpha), this
        }, PIXI.Graphics.prototype.endFill = function() {
            return this.filling = !1, this.fillColor = null, this.fillAlpha = 1, this
        }, PIXI.Graphics.prototype.drawRect = function(t, e, i, s) {
            return this.drawShape(new PIXI.Rectangle(t, e, i, s)), this
        }, PIXI.Graphics.prototype.drawRoundedRect = function(t, e, i, s, o) {
            return this.drawShape(new PIXI.RoundedRectangle(t, e, i, s, o)), this
        }, PIXI.Graphics.prototype.drawCircle = function(t, e, i) {
            return this.drawShape(new PIXI.Circle(t, e, i)), this
        }, PIXI.Graphics.prototype.drawEllipse = function(t, e, i, s) {
            return this.drawShape(new PIXI.Ellipse(t, e, i, s)), this
        }, PIXI.Graphics.prototype.drawPolygon = function(t) {
            (t instanceof i.Polygon || t instanceof PIXI.Polygon) && (t = t.points);
            var e = t;
            if (!Array.isArray(e)) {
                e = new Array(arguments.length);
                for (var s = 0; s < e.length; ++s) e[s] = arguments[s]
            }
            return this.drawShape(new i.Polygon(e)), this
        }, PIXI.Graphics.prototype.clear = function() {
            return this.lineWidth = 0, this.filling = !1, this.dirty = !0, this._boundsDirty = !0, this.clearDirty = !0, this.graphicsData = [], this.updateLocalBounds(), this
        }, PIXI.Graphics.prototype.generateTexture = function(t, e, i) {
            void 0 === t && (t = 1), void 0 === e && (e = PIXI.scaleModes.DEFAULT), void 0 === i && (i = 0);
            var s = this.getBounds();
            s.width += i, s.height += i;
            var o = new PIXI.CanvasBuffer(s.width * t, s.height * t),
                n = PIXI.Texture.fromCanvas(o.canvas, e);
            return n.baseTexture.resolution = t, o.context.scale(t, t), o.context.translate(-s.x, -s.y), PIXI.CanvasGraphics.renderGraphics(this, o.context), n
        }, PIXI.Graphics.prototype._renderWebGL = function(t) {
            if (!1 !== this.visible && 0 !== this.alpha && !0 !== this.isMask) {
                if (this._cacheAsBitmap) return (this.dirty || this.cachedSpriteDirty) && (this._generateCachedSprite(), this.updateCachedSpriteTexture(), this.cachedSpriteDirty = !1, this.dirty = !1), this._cachedSprite.worldAlpha = this.worldAlpha, void PIXI.Sprite.prototype._renderWebGL.call(this._cachedSprite, t);
                if (t.spriteBatch.stop(), t.blendModeManager.setBlendMode(this.blendMode), this._mask && t.maskManager.pushMask(this._mask, t), this._filters && t.filterManager.pushFilter(this._filterBlock), this.blendMode !== t.spriteBatch.currentBlendMode) {
                    t.spriteBatch.currentBlendMode = this.blendMode;
                    var e = PIXI.blendModesWebGL[t.spriteBatch.currentBlendMode];
                    t.spriteBatch.gl.blendFunc(e[0], e[1])
                }
                if (this.webGLDirty && (this.dirty = !0, this.webGLDirty = !1), PIXI.WebGLGraphics.renderGraphics(this, t), this.children.length) {
                    t.spriteBatch.start();
                    for (var i = 0; i < this.children.length; i++) this.children[i]._renderWebGL(t);
                    t.spriteBatch.stop()
                }
                this._filters && t.filterManager.popFilter(), this._mask && t.maskManager.popMask(this.mask, t), t.drawCount++, t.spriteBatch.start()
            }
        }, PIXI.Graphics.prototype._renderCanvas = function(t) {
            if (!1 !== this.visible && 0 !== this.alpha && !0 !== this.isMask) {
                if (this._prevTint !== this.tint && (this.dirty = !0, this._prevTint = this.tint), this._cacheAsBitmap) return (this.dirty || this.cachedSpriteDirty) && (this._generateCachedSprite(), this.updateCachedSpriteTexture(), this.cachedSpriteDirty = !1, this.dirty = !1), this._cachedSprite.alpha = this.alpha, void PIXI.Sprite.prototype._renderCanvas.call(this._cachedSprite, t);
                var e = t.context,
                    i = this.worldTransform;
                this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode, e.globalCompositeOperation = PIXI.blendModesCanvas[t.currentBlendMode]), this._mask && t.maskManager.pushMask(this._mask, t);
                var s = t.resolution,
                    o = i.tx * t.resolution + t.shakeX,
                    n = i.ty * t.resolution + t.shakeY;
                e.setTransform(i.a * s, i.b * s, i.c * s, i.d * s, o, n), PIXI.CanvasGraphics.renderGraphics(this, e);
                for (var a = 0; a < this.children.length; a++) this.children[a]._renderCanvas(t);
                this._mask && t.maskManager.popMask(t)
            }
        }, PIXI.Graphics.prototype.getBounds = function(t) {
            if (!this._currentBounds) {
                if (!this.renderable) return PIXI.EmptyRectangle;
                this.dirty && (this.updateLocalBounds(), this.webGLDirty = !0, this.cachedSpriteDirty = !0, this.dirty = !1);
                var e = this._localBounds,
                    i = e.x,
                    s = e.width + e.x,
                    o = e.y,
                    n = e.height + e.y,
                    a = t || this.worldTransform,
                    r = a.a,
                    h = a.b,
                    l = a.c,
                    c = a.d,
                    p = a.tx,
                    u = a.ty,
                    d = r * s + l * n + p,
                    m = c * n + h * s + u,
                    y = r * i + l * n + p,
                    f = c * n + h * i + u,
                    g = r * i + l * o + p,
                    _ = c * o + h * i + u,
                    v = r * s + l * o + p,
                    b = c * o + h * s + u,
                    x = d,
                    C = m,
                    S = d,
                    w = m;
                S = v < (S = g < (S = y < S ? y : S) ? g : S) ? v : S, w = b < (w = _ < (w = f < w ? f : w) ? _ : w) ? b : w, x = v > (x = g > (x = y > x ? y : x) ? g : x) ? v : x, C = b > (C = _ > (C = f > C ? f : C) ? _ : C) ? b : C, this._bounds.x = S, this._bounds.width = x - S, this._bounds.y = w, this._bounds.height = C - w, this._currentBounds = this._bounds
            }
            return this._currentBounds
        }, PIXI.Graphics.prototype.getLocalBounds = function() {
            var t = this.worldTransform;
            this.worldTransform = PIXI.identityMatrix;
            for (var e = 0; e < this.children.length; e++) this.children[e].updateTransform();
            var i = this.getBounds();
            for (this.worldTransform = t, e = 0; e < this.children.length; e++) this.children[e].updateTransform();
            return i
        }, PIXI.Graphics.prototype.containsPoint = function(t) {
            this.worldTransform.applyInverse(t, tempPoint);
            for (var e = this.graphicsData, i = 0; i < e.length; i++) {
                var s = e[i];
                if (s.fill && s.shape && s.shape.contains(tempPoint.x, tempPoint.y)) return !0
            }
            return !1
        }, PIXI.Graphics.prototype.updateLocalBounds = function() {
            var t = 1 / 0,
                e = -1 / 0,
                s = 1 / 0,
                o = -1 / 0;
            if (this.graphicsData.length)
                for (var n, a, r, h, l, c, p = 0; p < this.graphicsData.length; p++) {
                    var u = this.graphicsData[p],
                        d = u.type,
                        m = u.lineWidth;
                    if (n = u.shape, d === PIXI.Graphics.RECT || d === PIXI.Graphics.RREC) r = n.x - m / 2, h = n.y - m / 2, l = n.width + m, c = n.height + m, t = r < t ? r : t, e = r + l > e ? r + l : e, s = h < s ? h : s, o = h + c > o ? h + c : o;
                    else if (d === PIXI.Graphics.CIRC) r = n.x, h = n.y, l = n.radius + m / 2, c = n.radius + m / 2, t = r - l < t ? r - l : t, e = r + l > e ? r + l : e, s = h - c < s ? h - c : s, o = h + c > o ? h + c : o;
                    else if (d === PIXI.Graphics.ELIP) r = n.x, h = n.y, l = n.width + m / 2, c = n.height + m / 2, t = r - l < t ? r - l : t, e = r + l > e ? r + l : e, s = h - c < s ? h - c : s, o = h + c > o ? h + c : o;
                    else {
                        a = n.points;
                        for (var y = 0; y < a.length; y++) a[y] instanceof i.Point ? (r = a[y].x, h = a[y].y) : (r = a[y], h = a[y + 1], y < a.length - 1 && y++), t = r - m < t ? r - m : t, e = r + m > e ? r + m : e, s = h - m < s ? h - m : s, o = h + m > o ? h + m : o
                    }
                } else t = 0, e = 0, s = 0, o = 0;
            var f = this.boundsPadding;
            this._localBounds.x = t - f, this._localBounds.width = e - t + 2 * f, this._localBounds.y = s - f, this._localBounds.height = o - s + 2 * f
        }, PIXI.Graphics.prototype._generateCachedSprite = function() {
            var t = this.getLocalBounds();
            if (this._cachedSprite) this._cachedSprite.buffer.resize(t.width, t.height);
            else {
                var e = new PIXI.CanvasBuffer(t.width, t.height),
                    i = PIXI.Texture.fromCanvas(e.canvas);
                this._cachedSprite = new PIXI.Sprite(i), this._cachedSprite.buffer = e, this._cachedSprite.worldTransform = this.worldTransform
            }
            this._cachedSprite.anchor.x = -t.x / t.width, this._cachedSprite.anchor.y = -t.y / t.height, this._cachedSprite.buffer.context.translate(-t.x, -t.y), this.worldAlpha = 1, PIXI.CanvasGraphics.renderGraphics(this, this._cachedSprite.buffer.context), this._cachedSprite.alpha = this.alpha
        }, PIXI.Graphics.prototype.updateCachedSpriteTexture = function() {
            var t = this._cachedSprite,
                e = t.texture,
                i = t.buffer.canvas;
            e.baseTexture.width = i.width, e.baseTexture.height = i.height, e.crop.width = e.frame.width = i.width, e.crop.height = e.frame.height = i.height, t._width = i.width, t._height = i.height, e.baseTexture.dirty()
        }, PIXI.Graphics.prototype.destroyCachedSprite = function() {
            this._cachedSprite.texture.destroy(!0), this._cachedSprite = null
        }, PIXI.Graphics.prototype.drawShape = function(t) {
            this.currentPath && this.currentPath.shape.points.length <= 2 && this.graphicsData.pop(), this.currentPath = null, t instanceof i.Polygon && (t = t.clone()).flatten();
            var e = new PIXI.GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.filling, t);
            return this.graphicsData.push(e), e.type === PIXI.Graphics.POLY && (e.shape.closed = this.filling, this.currentPath = e), this.dirty = !0, this._boundsDirty = !0, e
        }, Object.defineProperty(PIXI.Graphics.prototype, "cacheAsBitmap", {
            get: function() {
                return this._cacheAsBitmap
            },
            set: function(t) {
                this._cacheAsBitmap = t, this._cacheAsBitmap ? this._generateCachedSprite() : this.destroyCachedSprite(), this.dirty = !0, this.webGLDirty = !0
            }
        }), PIXI.GraphicsData = function(t, e, i, s, o, n, a) {
            this.lineWidth = t, this.lineColor = e, this.lineAlpha = i, this._lineTint = e, this.fillColor = s, this.fillAlpha = o, this._fillTint = s, this.fill = n, this.shape = a, this.type = a.type
        }, PIXI.GraphicsData.prototype.constructor = PIXI.GraphicsData, PIXI.GraphicsData.prototype.clone = function() {
            return new GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.fill, this.shape)
        }, PIXI.EarCut = {}, PIXI.EarCut.Triangulate = function(t, e, i) {
            i = i || 2;
            var s = e && e.length,
                o = s ? e[0] * i : t.length,
                n = PIXI.EarCut.linkedList(t, 0, o, i, !0),
                a = [];
            if (!n) return a;
            var r, h, l, c, p, u, d;
            if (s && (n = PIXI.EarCut.eliminateHoles(t, e, n, i)), t.length > 80 * i) {
                r = l = t[0], h = c = t[1];
                for (var m = i; m < o; m += i) p = t[m], u = t[m + 1], p < r && (r = p), u < h && (h = u), p > l && (l = p), u > c && (c = u);
                d = Math.max(l - r, c - h)
            }
            return PIXI.EarCut.earcutLinked(n, a, i, r, h, d), a
        }, PIXI.EarCut.linkedList = function(t, e, i, s, o) {
            var n, a, r, h = 0;
            for (n = e, a = i - s; n < i; n += s) h += (t[a] - t[n]) * (t[n + 1] + t[a + 1]), a = n;
            if (o === h > 0)
                for (n = e; n < i; n += s) r = PIXI.EarCut.insertNode(n, t[n], t[n + 1], r);
            else
                for (n = i - s; n >= e; n -= s) r = PIXI.EarCut.insertNode(n, t[n], t[n + 1], r);
            return r
        }, PIXI.EarCut.filterPoints = function(t, e) {
            if (!t) return t;
            e || (e = t);
            var i, s = t;
            do {
                if (i = !1, s.steiner || !PIXI.EarCut.equals(s, s.next) && 0 !== PIXI.EarCut.area(s.prev, s, s.next)) s = s.next;
                else {
                    if (PIXI.EarCut.removeNode(s), (s = e = s.prev) === s.next) return null;
                    i = !0
                }
            } while (i || s !== e);
            return e
        }, PIXI.EarCut.earcutLinked = function(t, e, i, s, o, n, a) {
            if (t) {
                !a && n && PIXI.EarCut.indexCurve(t, s, o, n);
                for (var r, h, l = t; t.prev !== t.next;)
                    if (r = t.prev, h = t.next, n ? PIXI.EarCut.isEarHashed(t, s, o, n) : PIXI.EarCut.isEar(t)) e.push(r.i / i), e.push(t.i / i), e.push(h.i / i), PIXI.EarCut.removeNode(t), t = h.next, l = h.next;
                    else if ((t = h) === l) {
                    a ? 1 === a ? (t = PIXI.EarCut.cureLocalIntersections(t, e, i), PIXI.EarCut.earcutLinked(t, e, i, s, o, n, 2)) : 2 === a && PIXI.EarCut.splitEarcut(t, e, i, s, o, n) : PIXI.EarCut.earcutLinked(PIXI.EarCut.filterPoints(t), e, i, s, o, n, 1);
                    break
                }
            }
        }, PIXI.EarCut.isEar = function(t) {
            var e = t.prev,
                i = t,
                s = t.next;
            if (PIXI.EarCut.area(e, i, s) >= 0) return !1;
            for (var o = t.next.next; o !== t.prev;) {
                if (PIXI.EarCut.pointInTriangle(e.x, e.y, i.x, i.y, s.x, s.y, o.x, o.y) && PIXI.EarCut.area(o.prev, o, o.next) >= 0) return !1;
                o = o.next
            }
            return !0
        }, PIXI.EarCut.isEarHashed = function(t, e, i, s) {
            var o = t.prev,
                n = t,
                a = t.next;
            if (PIXI.EarCut.area(o, n, a) >= 0) return !1;
            for (var r = o.x < n.x ? o.x < a.x ? o.x : a.x : n.x < a.x ? n.x : a.x, h = o.y < n.y ? o.y < a.y ? o.y : a.y : n.y < a.y ? n.y : a.y, l = o.x > n.x ? o.x > a.x ? o.x : a.x : n.x > a.x ? n.x : a.x, c = o.y > n.y ? o.y > a.y ? o.y : a.y : n.y > a.y ? n.y : a.y, p = PIXI.EarCut.zOrder(r, h, e, i, s), u = PIXI.EarCut.zOrder(l, c, e, i, s), d = t.nextZ; d && d.z <= u;) {
                if (d !== t.prev && d !== t.next && PIXI.EarCut.pointInTriangle(o.x, o.y, n.x, n.y, a.x, a.y, d.x, d.y) && PIXI.EarCut.area(d.prev, d, d.next) >= 0) return !1;
                d = d.nextZ
            }
            for (d = t.prevZ; d && d.z >= p;) {
                if (d !== t.prev && d !== t.next && PIXI.EarCut.pointInTriangle(o.x, o.y, n.x, n.y, a.x, a.y, d.x, d.y) && PIXI.EarCut.area(d.prev, d, d.next) >= 0) return !1;
                d = d.prevZ
            }
            return !0
        }, PIXI.EarCut.cureLocalIntersections = function(t, e, i) {
            var s = t;
            do {
                var o = s.prev,
                    n = s.next.next;
                PIXI.EarCut.intersects(o, s, s.next, n) && PIXI.EarCut.locallyInside(o, n) && PIXI.EarCut.locallyInside(n, o) && (e.push(o.i / i), e.push(s.i / i), e.push(n.i / i), PIXI.EarCut.removeNode(s), PIXI.EarCut.removeNode(s.next), s = t = n), s = s.next
            } while (s !== t);
            return s
        }, PIXI.EarCut.splitEarcut = function(t, e, i, s, o, n) {
            var a = t;
            do {
                for (var r = a.next.next; r !== a.prev;) {
                    if (a.i !== r.i && PIXI.EarCut.isValidDiagonal(a, r)) {
                        var h = PIXI.EarCut.splitPolygon(a, r);
                        return a = PIXI.EarCut.filterPoints(a, a.next), h = PIXI.EarCut.filterPoints(h, h.next), PIXI.EarCut.earcutLinked(a, e, i, s, o, n), void PIXI.EarCut.earcutLinked(h, e, i, s, o, n)
                    }
                    r = r.next
                }
                a = a.next
            } while (a !== t)
        }, PIXI.EarCut.eliminateHoles = function(t, e, i, s) {
            var o, n, a, r, h, l = [];
            for (o = 0, n = e.length; o < n; o++) a = e[o] * s, r = o < n - 1 ? e[o + 1] * s : t.length, (h = PIXI.EarCut.linkedList(t, a, r, s, !1)) === h.next && (h.steiner = !0), l.push(PIXI.EarCut.getLeftmost(h));
            for (l.sort(compareX), o = 0; o < l.length; o++) PIXI.EarCut.eliminateHole(l[o], i), i = PIXI.EarCut.filterPoints(i, i.next);
            return i
        }, PIXI.EarCut.compareX = function(t, e) {
            return t.x - e.x
        }, PIXI.EarCut.eliminateHole = function(t, e) {
            if (e = PIXI.EarCut.findHoleBridge(t, e)) {
                var i = PIXI.EarCut.splitPolygon(e, t);
                PIXI.EarCut.filterPoints(i, i.next)
            }
        }, PIXI.EarCut.findHoleBridge = function(t, e) {
            var i, s = e,
                o = t.x,
                n = t.y,
                a = -1 / 0;
            do {
                if (n <= s.y && n >= s.next.y) {
                    var r = s.x + (n - s.y) * (s.next.x - s.x) / (s.next.y - s.y);
                    r <= o && r > a && (a = r, i = s.x < s.next.x ? s : s.next)
                }
                s = s.next
            } while (s !== e);
            if (!i) return null;
            if (t.x === i.x) return i.prev;
            var h, l = i,
                c = 1 / 0;
            for (s = i.next; s !== l;) o >= s.x && s.x >= i.x && PIXI.EarCut.pointInTriangle(n < i.y ? o : a, n, i.x, i.y, n < i.y ? a : o, n, s.x, s.y) && ((h = Math.abs(n - s.y) / (o - s.x)) < c || h === c && s.x > i.x) && PIXI.EarCut.locallyInside(s, t) && (i = s, c = h), s = s.next;
            return i
        }, PIXI.EarCut.indexCurve = function(t, e, i, s) {
            var o = t;
            do {
                null === o.z && (o.z = PIXI.EarCut.zOrder(o.x, o.y, e, i, s)), o.prevZ = o.prev, o.nextZ = o.next, o = o.next
            } while (o !== t);
            o.prevZ.nextZ = null, o.prevZ = null, PIXI.EarCut.sortLinked(o)
        }, PIXI.EarCut.sortLinked = function(t) {
            var e, i, s, o, n, a, r, h, l = 1;
            do {
                for (i = t, t = null, n = null, a = 0; i;) {
                    for (a++, s = i, r = 0, e = 0; e < l && (r++, s = s.nextZ); e++);
                    for (h = l; r > 0 || h > 0 && s;) 0 === r ? (o = s, s = s.nextZ, h--) : 0 !== h && s ? i.z <= s.z ? (o = i, i = i.nextZ, r--) : (o = s, s = s.nextZ, h--) : (o = i, i = i.nextZ, r--), n ? n.nextZ = o : t = o, o.prevZ = n, n = o;
                    i = s
                }
                n.nextZ = null, l *= 2
            } while (a > 1);
            return t
        }, PIXI.EarCut.zOrder = function(t, e, i, s, o) {
            return t = 32767 * (t - i) / o, e = 32767 * (e - s) / o, t = 16711935 & (t | t << 8), t = 252645135 & (t | t << 4), t = 858993459 & (t | t << 2), t = 1431655765 & (t | t << 1), e = 16711935 & (e | e << 8), e = 252645135 & (e | e << 4), e = 858993459 & (e | e << 2), e = 1431655765 & (e | e << 1), t | e << 1
        }, PIXI.EarCut.getLeftmost = function(t) {
            var e = t,
                i = t;
            do {
                e.x < i.x && (i = e), e = e.next
            } while (e !== t);
            return i
        }, PIXI.EarCut.pointInTriangle = function(t, e, i, s, o, n, a, r) {
            return (o - a) * (e - r) - (t - a) * (n - r) >= 0 && (t - a) * (s - r) - (i - a) * (e - r) >= 0 && (i - a) * (n - r) - (o - a) * (s - r) >= 0
        }, PIXI.EarCut.isValidDiagonal = function(t, e) {
            return PIXI.EarCut.equals(t, e) || t.next.i !== e.i && t.prev.i !== e.i && !PIXI.EarCut.intersectsPolygon(t, e) && PIXI.EarCut.locallyInside(t, e) && PIXI.EarCut.locallyInside(e, t) && PIXI.EarCut.middleInside(t, e)
        }, PIXI.EarCut.area = function(t, e, i) {
            return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y)
        }, PIXI.EarCut.equals = function(t, e) {
            return t.x === e.x && t.y === e.y
        }, PIXI.EarCut.intersects = function(t, e, i, s) {
            return PIXI.EarCut.area(t, e, i) > 0 != PIXI.EarCut.area(t, e, s) > 0 && PIXI.EarCut.area(i, s, t) > 0 != PIXI.EarCut.area(i, s, e) > 0
        }, PIXI.EarCut.intersectsPolygon = function(t, e) {
            var i = t;
            do {
                if (i.i !== t.i && i.next.i !== t.i && i.i !== e.i && i.next.i !== e.i && PIXI.EarCut.intersects(i, i.next, t, e)) return !0;
                i = i.next
            } while (i !== t);
            return !1
        }, PIXI.EarCut.locallyInside = function(t, e) {
            return PIXI.EarCut.area(t.prev, t, t.next) < 0 ? PIXI.EarCut.area(t, e, t.next) >= 0 && PIXI.EarCut.area(t, t.prev, e) >= 0 : PIXI.EarCut.area(t, e, t.prev) < 0 || PIXI.EarCut.area(t, t.next, e) < 0
        }, PIXI.EarCut.middleInside = function(t, e) {
            var i = t,
                s = !1,
                o = (t.x + e.x) / 2,
                n = (t.y + e.y) / 2;
            do {
                i.y > n != i.next.y > n && o < (i.next.x - i.x) * (n - i.y) / (i.next.y - i.y) + i.x && (s = !s), i = i.next
            } while (i !== t);
            return s
        }, PIXI.EarCut.splitPolygon = function(t, e) {
            var i = new PIXI.EarCut.Node(t.i, t.x, t.y),
                s = new PIXI.EarCut.Node(e.i, e.x, e.y),
                o = t.next,
                n = e.prev;
            return t.next = e, e.prev = t, i.next = o, o.prev = i, s.next = i, i.prev = s, n.next = s, s.prev = n, s
        }, PIXI.EarCut.insertNode = function(t, e, i, s) {
            var o = new PIXI.EarCut.Node(t, e, i);
            return s ? (o.next = s.next, o.prev = s, s.next.prev = o, s.next = o) : (o.prev = o, o.next = o), o
        }, PIXI.EarCut.removeNode = function(t) {
            t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
        }, PIXI.EarCut.Node = function(t, e, i) {
            this.i = t, this.x = e, this.y = i, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
        }, PIXI.WebGLGraphics = function() {}, PIXI.WebGLGraphics.stencilBufferLimit = 6, PIXI.WebGLGraphics.renderGraphics = function(t, e) {
            var i, s = e.gl,
                o = e.projection,
                n = e.offset,
                a = e.shaderManager.primitiveShader;
            t.dirty && PIXI.WebGLGraphics.updateGraphics(t, s);
            for (var r = t._webGL[s.id], h = 0; h < r.data.length; h++) 1 === r.data[h].mode ? (i = r.data[h], e.stencilManager.pushStencil(t, i, e), s.drawElements(s.TRIANGLE_FAN, 4, s.UNSIGNED_SHORT, 2 * (i.indices.length - 4)), e.stencilManager.popStencil(t, i, e)) : (i = r.data[h], e.shaderManager.setShader(a), a = e.shaderManager.primitiveShader, s.uniformMatrix3fv(a.translationMatrix, !1, t.worldTransform.toArray(!0)), s.uniform1f(a.flipY, 1), s.uniform2f(a.projectionVector, o.x, -o.y), s.uniform2f(a.offsetVector, -n.x, -n.y), s.uniform3fv(a.tintColor, PIXI.hex2rgb(t.tint)), s.uniform1f(a.alpha, t.worldAlpha), s.bindBuffer(s.ARRAY_BUFFER, i.buffer), s.vertexAttribPointer(a.aVertexPosition, 2, s.FLOAT, !1, 24, 0), s.vertexAttribPointer(a.colorAttribute, 4, s.FLOAT, !1, 24, 8), s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, i.indexBuffer), s.drawElements(s.TRIANGLE_STRIP, i.indices.length, s.UNSIGNED_SHORT, 0))
        }, PIXI.WebGLGraphics.updateGraphics = function(t, e) {
            var i = t._webGL[e.id];
            i || (i = t._webGL[e.id] = {
                lastIndex: 0,
                data: [],
                gl: e
            }), t.dirty = !1;
            var s;
            if (t.clearDirty) {
                for (t.clearDirty = !1, s = 0; s < i.data.length; s++) {
                    var o = i.data[s];
                    o.reset(), PIXI.WebGLGraphics.graphicsDataPool.push(o)
                }
                i.data = [], i.lastIndex = 0
            }
            var n;
            for (s = i.lastIndex; s < t.graphicsData.length; s++) {
                var a = t.graphicsData[s];
                a.type === PIXI.Graphics.POLY ? (a.points = a.shape.points.slice(), a.shape.closed && (a.points[0] === a.points[a.points.length - 2] && a.points[1] === a.points[a.points.length - 1] || a.points.push(a.points[0], a.points[1])), a.fill && a.points.length >= PIXI.WebGLGraphics.stencilBufferLimit && (a.points.length < 2 * PIXI.WebGLGraphics.stencilBufferLimit ? (n = PIXI.WebGLGraphics.switchMode(i, 0), PIXI.WebGLGraphics.buildPoly(a, n) || (n = PIXI.WebGLGraphics.switchMode(i, 1), PIXI.WebGLGraphics.buildComplexPoly(a, n))) : (n = PIXI.WebGLGraphics.switchMode(i, 1), PIXI.WebGLGraphics.buildComplexPoly(a, n))), a.lineWidth > 0 && (n = PIXI.WebGLGraphics.switchMode(i, 0), PIXI.WebGLGraphics.buildLine(a, n))) : (n = PIXI.WebGLGraphics.switchMode(i, 0), a.type === PIXI.Graphics.RECT ? PIXI.WebGLGraphics.buildRectangle(a, n) : a.type === PIXI.Graphics.CIRC || a.type === PIXI.Graphics.ELIP ? PIXI.WebGLGraphics.buildCircle(a, n) : a.type === PIXI.Graphics.RREC && PIXI.WebGLGraphics.buildRoundedRectangle(a, n)), i.lastIndex++
            }
            for (s = 0; s < i.data.length; s++)(n = i.data[s]).dirty && n.upload()
        }, PIXI.WebGLGraphics.switchMode = function(t, e) {
            var i;
            return t.data.length ? (i = t.data[t.data.length - 1]).mode === e && 1 !== e || (i = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(t.gl), i.mode = e, t.data.push(i)) : (i = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(t.gl), i.mode = e, t.data.push(i)), i.dirty = !0, i
        }, PIXI.WebGLGraphics.buildRectangle = function(t, e) {
            var i = t.shape,
                s = i.x,
                o = i.y,
                n = i.width,
                a = i.height;
            if (t.fill) {
                var r = PIXI.hex2rgb(t.fillColor),
                    h = t.fillAlpha,
                    l = r[0] * h,
                    c = r[1] * h,
                    p = r[2] * h,
                    u = e.points,
                    d = e.indices,
                    m = u.length / 6;
                u.push(s, o), u.push(l, c, p, h), u.push(s + n, o), u.push(l, c, p, h), u.push(s, o + a), u.push(l, c, p, h), u.push(s + n, o + a), u.push(l, c, p, h), d.push(m, m, m + 1, m + 2, m + 3, m + 3)
            }
            if (t.lineWidth) {
                var y = t.points;
                t.points = [s, o, s + n, o, s + n, o + a, s, o + a, s, o], PIXI.WebGLGraphics.buildLine(t, e), t.points = y
            }
        }, PIXI.WebGLGraphics.buildRoundedRectangle = function(t, e) {
            var i = t.shape,
                s = i.x,
                o = i.y,
                n = i.width,
                a = i.height,
                r = i.radius,
                h = [];
            if (h.push(s, o + r), h = h.concat(PIXI.WebGLGraphics.quadraticBezierCurve(s, o + a - r, s, o + a, s + r, o + a)), h = h.concat(PIXI.WebGLGraphics.quadraticBezierCurve(s + n - r, o + a, s + n, o + a, s + n, o + a - r)), h = h.concat(PIXI.WebGLGraphics.quadraticBezierCurve(s + n, o + r, s + n, o, s + n - r, o)), h = h.concat(PIXI.WebGLGraphics.quadraticBezierCurve(s + r, o, s, o, s, o + r)), t.fill) {
                var l = PIXI.hex2rgb(t.fillColor),
                    c = t.fillAlpha,
                    p = l[0] * c,
                    u = l[1] * c,
                    d = l[2] * c,
                    m = e.points,
                    y = e.indices,
                    f = m.length / 6,
                    g = PIXI.EarCut.Triangulate(h, null, 2),
                    _ = 0;
                for (_ = 0; _ < g.length; _ += 3) y.push(g[_] + f), y.push(g[_] + f), y.push(g[_ + 1] + f), y.push(g[_ + 2] + f), y.push(g[_ + 2] + f);
                for (_ = 0; _ < h.length; _++) m.push(h[_], h[++_], p, u, d, c)
            }
            if (t.lineWidth) {
                var v = t.points;
                t.points = h, PIXI.WebGLGraphics.buildLine(t, e), t.points = v
            }
        }, PIXI.WebGLGraphics.quadraticBezierCurve = function(t, e, i, s, o, n) {
            function a(t, e, i) {
                return t + (e - t) * i
            }
            for (var r, h, l, c, p, u, d = [], m = 0, y = 0; y <= 20; y++) m = y / 20, r = a(t, i, m), h = a(e, s, m), l = a(i, o, m), c = a(s, n, m), p = a(r, l, m), u = a(h, c, m), d.push(p, u);
            return d
        }, PIXI.WebGLGraphics.buildCircle = function(t, e) {
            var i, s, o = t.shape,
                n = o.x,
                a = o.y;
            t.type === PIXI.Graphics.CIRC ? (i = o.radius, s = o.radius) : (i = o.width, s = o.height);
            var r = 2 * Math.PI / 40,
                h = 0;
            if (t.fill) {
                var l = PIXI.hex2rgb(t.fillColor),
                    c = t.fillAlpha,
                    p = l[0] * c,
                    u = l[1] * c,
                    d = l[2] * c,
                    m = e.points,
                    y = e.indices,
                    f = m.length / 6;
                for (y.push(f), h = 0; h < 41; h++) m.push(n, a, p, u, d, c), m.push(n + Math.sin(r * h) * i, a + Math.cos(r * h) * s, p, u, d, c), y.push(f++, f++);
                y.push(f - 1)
            }
            if (t.lineWidth) {
                var g = t.points;
                for (t.points = [], h = 0; h < 41; h++) t.points.push(n + Math.sin(r * h) * i, a + Math.cos(r * h) * s);
                PIXI.WebGLGraphics.buildLine(t, e), t.points = g
            }
        }, PIXI.WebGLGraphics.buildLine = function(t, e) {
            var i = 0,
                s = t.points;
            if (0 !== s.length) {
                if (t.lineWidth % 2)
                    for (i = 0; i < s.length; i++) s[i] += .5;
                var o = new PIXI.Point(s[0], s[1]),
                    n = new PIXI.Point(s[s.length - 2], s[s.length - 1]);
                if (o.x === n.x && o.y === n.y) {
                    (s = s.slice()).pop(), s.pop();
                    var a = (n = new PIXI.Point(s[s.length - 2], s[s.length - 1])).x + .5 * (o.x - n.x),
                        r = n.y + .5 * (o.y - n.y);
                    s.unshift(a, r), s.push(a, r)
                }
                var h, l, c, p, u, d, m, y, f, g, _, v, b, x, C, S, w, A, T, B, P, D, I = e.points,
                    E = e.indices,
                    L = s.length / 2,
                    M = s.length,
                    G = I.length / 6,
                    O = t.lineWidth / 2,
                    R = PIXI.hex2rgb(t.lineColor),
                    k = t.lineAlpha,
                    F = R[0] * k,
                    N = R[1] * k,
                    V = R[2] * k;
                for (c = s[0], p = s[1], u = s[2], f = -(p - (d = s[3])), g = c - u, f /= D = Math.sqrt(f * f + g * g), g /= D, f *= O, g *= O, I.push(c - f, p - g, F, N, V, k), I.push(c + f, p + g, F, N, V, k), i = 1; i < L - 1; i++) c = s[2 * (i - 1)], p = s[2 * (i - 1) + 1], u = s[2 * i], d = s[2 * i + 1], m = s[2 * (i + 1)], y = s[2 * (i + 1) + 1], f = -(p - d), g = c - u, D = Math.sqrt(f * f + g * g), f /= D, g /= D, f *= O, g *= O, _ = -(d - y), v = u - m, D = Math.sqrt(_ * _ + v * v), _ /= D, v /= D, _ *= O, v *= O, C = -g + p - (-g + d), S = -f + u - (-f + c), w = (-f + c) * (-g + d) - (-f + u) * (-g + p), A = -v + y - (-v + d), T = -_ + u - (-_ + m), B = (-_ + m) * (-v + d) - (-_ + u) * (-v + y), P = C * T - A * S, Math.abs(P) < .1 ? (P += 10.1, I.push(u - f, d - g, F, N, V, k), I.push(u + f, d + g, F, N, V, k)) : (h = (S * B - T * w) / P, l = (A * w - C * B) / P, (h - u) * (h - u) + (l - d) + (l - d) > 19600 ? (b = f - _, x = g - v, D = Math.sqrt(b * b + x * x), b /= D, x /= D, b *= O, x *= O, I.push(u - b, d - x), I.push(F, N, V, k), I.push(u + b, d + x), I.push(F, N, V, k), I.push(u - b, d - x), I.push(F, N, V, k), M++) : (I.push(h, l), I.push(F, N, V, k), I.push(u - (h - u), d - (l - d)), I.push(F, N, V, k)));
                for (c = s[2 * (L - 2)], p = s[2 * (L - 2) + 1], u = s[2 * (L - 1)], f = -(p - (d = s[2 * (L - 1) + 1])), g = c - u, f /= D = Math.sqrt(f * f + g * g), g /= D, f *= O, g *= O, I.push(u - f, d - g), I.push(F, N, V, k), I.push(u + f, d + g), I.push(F, N, V, k), E.push(G), i = 0; i < M; i++) E.push(G++);
                E.push(G - 1)
            }
        }, PIXI.WebGLGraphics.buildComplexPoly = function(t, e) {
            var i = t.points.slice();
            if (!(i.length < 6)) {
                var s = e.indices;
                e.points = i, e.alpha = t.fillAlpha, e.color = PIXI.hex2rgb(t.fillColor);
                for (var o, n, a = 1 / 0, r = -1 / 0, h = 1 / 0, l = -1 / 0, c = 0; c < i.length; c += 2) o = i[c], n = i[c + 1], a = o < a ? o : a, r = o > r ? o : r, h = n < h ? n : h, l = n > l ? n : l;
                i.push(a, h, r, h, r, l, a, l);
                var p = i.length / 2;
                for (c = 0; c < p; c++) s.push(c)
            }
        }, PIXI.WebGLGraphics.buildPoly = function(t, e) {
            var i = t.points;
            if (!(i.length < 6)) {
                var s = e.points,
                    o = e.indices,
                    n = i.length / 2,
                    a = PIXI.hex2rgb(t.fillColor),
                    r = t.fillAlpha,
                    h = a[0] * r,
                    l = a[1] * r,
                    c = a[2] * r,
                    p = PIXI.EarCut.Triangulate(i, null, 2);
                if (!p) return !1;
                var u = s.length / 6,
                    d = 0;
                for (d = 0; d < p.length; d += 3) o.push(p[d] + u), o.push(p[d] + u), o.push(p[d + 1] + u), o.push(p[d + 2] + u), o.push(p[d + 2] + u);
                for (d = 0; d < n; d++) s.push(i[2 * d], i[2 * d + 1], h, l, c, r);
                return !0
            }
        }, PIXI.WebGLGraphics.graphicsDataPool = [], PIXI.WebGLGraphicsData = function(t) {
            this.gl = t, this.color = [0, 0, 0], this.points = [], this.indices = [], this.buffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), this.mode = 1, this.alpha = 1, this.dirty = !0
        }, PIXI.WebGLGraphicsData.prototype.reset = function() {
            this.points = [], this.indices = []
        }, PIXI.WebGLGraphicsData.prototype.upload = function() {
            var t = this.gl;
            this.glPoints = new PIXI.Float32Array(this.points), t.bindBuffer(t.ARRAY_BUFFER, this.buffer), t.bufferData(t.ARRAY_BUFFER, this.glPoints, t.STATIC_DRAW), this.glIndicies = new PIXI.Uint16Array(this.indices), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.glIndicies, t.STATIC_DRAW), this.dirty = !1
        }, PIXI.CanvasGraphics = function() {}, PIXI.CanvasGraphics.renderGraphics = function(t, e) {
            var i = t.worldAlpha;
            t.dirty && (this.updateGraphicsTint(t), t.dirty = !1);
            for (var s = 0; s < t.graphicsData.length; s++) {
                var o = t.graphicsData[s],
                    n = o.shape,
                    a = o._fillTint,
                    r = o._lineTint;
                if (e.lineWidth = o.lineWidth, o.type === PIXI.Graphics.POLY) {
                    e.beginPath();
                    var h = n.points;
                    e.moveTo(h[0], h[1]);
                    for (var l = 1; l < h.length / 2; l++) e.lineTo(h[2 * l], h[2 * l + 1]);
                    n.closed && e.lineTo(h[0], h[1]), h[0] === h[h.length - 2] && h[1] === h[h.length - 1] && e.closePath(), o.fill && (e.globalAlpha = o.fillAlpha * i, e.fillStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), e.fill()), o.lineWidth && (e.globalAlpha = o.lineAlpha * i, e.strokeStyle = "#" + ("00000" + (0 | r).toString(16)).substr(-6), e.stroke())
                } else if (o.type === PIXI.Graphics.RECT)(o.fillColor || 0 === o.fillColor) && (e.globalAlpha = o.fillAlpha * i, e.fillStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), e.fillRect(n.x, n.y, n.width, n.height)), o.lineWidth && (e.globalAlpha = o.lineAlpha * i, e.strokeStyle = "#" + ("00000" + (0 | r).toString(16)).substr(-6), e.strokeRect(n.x, n.y, n.width, n.height));
                else if (o.type === PIXI.Graphics.CIRC) e.beginPath(), e.arc(n.x, n.y, n.radius, 0, 2 * Math.PI), e.closePath(), o.fill && (e.globalAlpha = o.fillAlpha * i, e.fillStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), e.fill()), o.lineWidth && (e.globalAlpha = o.lineAlpha * i, e.strokeStyle = "#" + ("00000" + (0 | r).toString(16)).substr(-6), e.stroke());
                else if (o.type === PIXI.Graphics.ELIP) {
                    var c = 2 * n.width,
                        p = 2 * n.height,
                        u = n.x - c / 2,
                        d = n.y - p / 2;
                    e.beginPath();
                    var m = .5522848,
                        y = c / 2 * m,
                        f = p / 2 * m,
                        g = u + c,
                        _ = d + p,
                        v = u + c / 2,
                        b = d + p / 2;
                    e.moveTo(u, b), e.bezierCurveTo(u, b - f, v - y, d, v, d), e.bezierCurveTo(v + y, d, g, b - f, g, b), e.bezierCurveTo(g, b + f, v + y, _, v, _), e.bezierCurveTo(v - y, _, u, b + f, u, b), e.closePath(), o.fill && (e.globalAlpha = o.fillAlpha * i, e.fillStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), e.fill()), o.lineWidth && (e.globalAlpha = o.lineAlpha * i, e.strokeStyle = "#" + ("00000" + (0 | r).toString(16)).substr(-6), e.stroke())
                } else if (o.type === PIXI.Graphics.RREC) {
                    var x = n.x,
                        C = n.y,
                        S = n.width,
                        w = n.height,
                        A = n.radius,
                        T = Math.min(S, w) / 2 | 0;
                    A = A > T ? T : A, e.beginPath(), e.moveTo(x, C + A), e.lineTo(x, C + w - A), e.quadraticCurveTo(x, C + w, x + A, C + w), e.lineTo(x + S - A, C + w), e.quadraticCurveTo(x + S, C + w, x + S, C + w - A), e.lineTo(x + S, C + A), e.quadraticCurveTo(x + S, C, x + S - A, C), e.lineTo(x + A, C), e.quadraticCurveTo(x, C, x, C + A), e.closePath(), (o.fillColor || 0 === o.fillColor) && (e.globalAlpha = o.fillAlpha * i, e.fillStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), e.fill()), o.lineWidth && (e.globalAlpha = o.lineAlpha * i, e.strokeStyle = "#" + ("00000" + (0 | r).toString(16)).substr(-6), e.stroke())
                }
            }
        }, PIXI.CanvasGraphics.renderGraphicsMask = function(t, e) {
            var i = t.graphicsData.length;
            if (0 !== i) {
                e.beginPath();
                for (var s = 0; s < i; s++) {
                    var o = t.graphicsData[s],
                        n = o.shape;
                    if (o.type === PIXI.Graphics.POLY) {
                        var a = n.points;
                        e.moveTo(a[0], a[1]);
                        for (var r = 1; r < a.length / 2; r++) e.lineTo(a[2 * r], a[2 * r + 1]);
                        a[0] === a[a.length - 2] && a[1] === a[a.length - 1] && e.closePath()
                    } else if (o.type === PIXI.Graphics.RECT) e.rect(n.x, n.y, n.width, n.height), e.closePath();
                    else if (o.type === PIXI.Graphics.CIRC) e.arc(n.x, n.y, n.radius, 0, 2 * Math.PI), e.closePath();
                    else if (o.type === PIXI.Graphics.ELIP) {
                        var h = 2 * n.width,
                            l = 2 * n.height,
                            c = n.x - h / 2,
                            p = n.y - l / 2,
                            u = .5522848,
                            d = h / 2 * u,
                            m = l / 2 * u,
                            y = c + h,
                            f = p + l,
                            g = c + h / 2,
                            _ = p + l / 2;
                        e.moveTo(c, _), e.bezierCurveTo(c, _ - m, g - d, p, g, p), e.bezierCurveTo(g + d, p, y, _ - m, y, _), e.bezierCurveTo(y, _ + m, g + d, f, g, f), e.bezierCurveTo(g - d, f, c, _ + m, c, _), e.closePath()
                    } else if (o.type === PIXI.Graphics.RREC) {
                        var v = n.x,
                            b = n.y,
                            x = n.width,
                            C = n.height,
                            S = n.radius,
                            w = Math.min(x, C) / 2 | 0;
                        S = S > w ? w : S, e.moveTo(v, b + S), e.lineTo(v, b + C - S), e.quadraticCurveTo(v, b + C, v + S, b + C), e.lineTo(v + x - S, b + C), e.quadraticCurveTo(v + x, b + C, v + x, b + C - S), e.lineTo(v + x, b + S), e.quadraticCurveTo(v + x, b, v + x - S, b), e.lineTo(v + S, b), e.quadraticCurveTo(v, b, v, b + S), e.closePath()
                    }
                }
            }
        }, PIXI.CanvasGraphics.updateGraphicsTint = function(t) {
            if (16777215 !== t.tint)
                for (var e = (t.tint >> 16 & 255) / 255, i = (t.tint >> 8 & 255) / 255, s = (255 & t.tint) / 255, o = 0; o < t.graphicsData.length; o++) {
                    var n = t.graphicsData[o],
                        a = 0 | n.fillColor,
                        r = 0 | n.lineColor;
                    n._fillTint = ((a >> 16 & 255) / 255 * e * 255 << 16) + ((a >> 8 & 255) / 255 * i * 255 << 8) + (255 & a) / 255 * s * 255, n._lineTint = ((r >> 16 & 255) / 255 * e * 255 << 16) + ((r >> 8 & 255) / 255 * i * 255 << 8) + (255 & r) / 255 * s * 255
                }
        }, i.Graphics = function(t, e, s) {
            void 0 === e && (e = 0), void 0 === s && (s = 0), this.type = i.GRAPHICS, this.physicsType = i.SPRITE, this.anchor = new i.Point, PIXI.Graphics.call(this), i.Component.Core.init.call(this, t, e, s, "", null)
        }, i.Graphics.prototype = Object.create(PIXI.Graphics.prototype), i.Graphics.prototype.constructor = i.Graphics, i.Component.Core.install.call(i.Graphics.prototype, ["Angle", "AutoCull", "Bounds", "Destroy", "FixedToCamera", "InputEnabled", "InWorld", "LifeSpan", "PhysicsBody", "Reset"]), i.Graphics.prototype.preUpdatePhysics = i.Component.PhysicsBody.preUpdate, i.Graphics.prototype.preUpdateLifeSpan = i.Component.LifeSpan.preUpdate, i.Graphics.prototype.preUpdateInWorld = i.Component.InWorld.preUpdate, i.Graphics.prototype.preUpdateCore = i.Component.Core.preUpdate, i.Graphics.prototype.preUpdate = function() {
            return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        }, i.Graphics.prototype.postUpdate = function() {
            i.Component.PhysicsBody.postUpdate.call(this), i.Component.FixedToCamera.postUpdate.call(this), this._boundsDirty && (this.updateLocalBounds(), this._boundsDirty = !1);
            for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate()
        }, i.Graphics.prototype.destroy = function(t) {
            this.clear(), i.Component.Destroy.prototype.destroy.call(this, t)
        }, i.Graphics.prototype.drawTriangle = function(t, e) {
            void 0 === e && (e = !1);
            var s = new i.Polygon(t);
            if (e) {
                var o = new i.Point(this.game.camera.x - t[0].x, this.game.camera.y - t[0].y),
                    n = new i.Point(t[1].x - t[0].x, t[1].y - t[0].y),
                    a = new i.Point(t[1].x - t[2].x, t[1].y - t[2].y).cross(n);
                o.dot(a) > 0 && this.drawPolygon(s)
            } else this.drawPolygon(s)
        }, i.Graphics.prototype.drawTriangles = function(t, e, s) {
            void 0 === s && (s = !1);
            var o, n = new i.Point,
                a = new i.Point,
                r = new i.Point,
                h = [];
            if (e)
                if (t[0] instanceof i.Point)
                    for (o = 0; o < e.length / 3; o++) h.push(t[e[3 * o]]), h.push(t[e[3 * o + 1]]), h.push(t[e[3 * o + 2]]), 3 === h.length && (this.drawTriangle(h, s), h = []);
                else
                    for (o = 0; o < e.length; o++) n.x = t[2 * e[o]], n.y = t[2 * e[o] + 1], h.push(n.copyTo({})), 3 === h.length && (this.drawTriangle(h, s), h = []);
            else if (t[0] instanceof i.Point)
                for (o = 0; o < t.length / 3; o++) this.drawTriangle([t[3 * o], t[3 * o + 1], t[3 * o + 2]], s);
            else
                for (o = 0; o < t.length / 6; o++) n.x = t[6 * o + 0], n.y = t[6 * o + 1], a.x = t[6 * o + 2], a.y = t[6 * o + 3], r.x = t[6 * o + 4], r.y = t[6 * o + 5], this.drawTriangle([n, a, r], s)
        }, i.RenderTexture = function(t, e, s, o, n, a) {
            void 0 === o && (o = ""), void 0 === n && (n = i.scaleModes.DEFAULT), void 0 === a && (a = 1), this.game = t, this.key = o, this.type = i.RENDERTEXTURE, this._tempMatrix = new PIXI.Matrix, PIXI.RenderTexture.call(this, e, s, this.game.renderer, n, a), this.render = i.RenderTexture.prototype.render
        }, i.RenderTexture.prototype = Object.create(PIXI.RenderTexture.prototype), i.RenderTexture.prototype.constructor = i.RenderTexture, i.RenderTexture.prototype.renderXY = function(t, e, i, s) {
            t.updateTransform(), this._tempMatrix.copyFrom(t.worldTransform), this._tempMatrix.tx = e, this._tempMatrix.ty = i, this.renderer.type === PIXI.WEBGL_RENDERER ? this.renderWebGL(t, this._tempMatrix, s) : this.renderCanvas(t, this._tempMatrix, s)
        }, i.RenderTexture.prototype.renderRawXY = function(t, e, i, s) {
            this._tempMatrix.identity().translate(e, i), this.renderer.type === PIXI.WEBGL_RENDERER ? this.renderWebGL(t, this._tempMatrix, s) : this.renderCanvas(t, this._tempMatrix, s)
        }, i.RenderTexture.prototype.render = function(t, e, i) {
            void 0 === e || null === e ? this._tempMatrix.copyFrom(t.worldTransform) : this._tempMatrix.copyFrom(e), this.renderer.type === PIXI.WEBGL_RENDERER ? this.renderWebGL(t, this._tempMatrix, i) : this.renderCanvas(t, this._tempMatrix, i)
        }, i.Text = function(t, e, s, o, n) {
            e = e || 0, s = s || 0, o = void 0 === o || null === o ? "" : o.toString(), n = i.Utils.extend({}, n), this.type = i.TEXT, this.physicsType = i.SPRITE, this.padding = new i.Point, this.textBounds = null, this.canvas = PIXI.CanvasPool.create(this), this.context = this.canvas.getContext("2d"), this.colors = [], this.strokeColors = [], this.fontStyles = [], this.fontWeights = [], this.autoRound = !1, this.useAdvancedWrap = !1, this._res = t.renderer.resolution, this._text = o, this._fontComponents = null, this._lineSpacing = 0, this._charCount = 0, this._width = 0, this._height = 0, i.Sprite.call(this, t, e, s, PIXI.Texture.fromCanvas(this.canvas)), this.setStyle(n), "" !== o && this.updateText()
        }, i.Text.prototype = Object.create(i.Sprite.prototype), i.Text.prototype.constructor = i.Text, i.Text.prototype.preUpdate = function() {
            return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        }, i.Text.prototype.update = function() {}, i.Text.prototype.destroy = function(t) {
            this.texture.destroy(!0), i.Component.Destroy.prototype.destroy.call(this, t)
        }, i.Text.prototype.setShadow = function(t, e, i, s, o, n) {
            return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = "rgba(0, 0, 0, 1)"), void 0 === s && (s = 0), void 0 === o && (o = !0), void 0 === n && (n = !0), this.style.shadowOffsetX = t, this.style.shadowOffsetY = e, this.style.shadowColor = i, this.style.shadowBlur = s, this.style.shadowStroke = o, this.style.shadowFill = n, this.dirty = !0, this
        }, i.Text.prototype.setStyle = function(t, e) {
            void 0 === e && (e = !1), (t = t || {}).font = t.font || "bold 20pt Arial", t.backgroundColor = t.backgroundColor || null, t.fill = t.fill || "black", t.align = t.align || "left", t.boundsAlignH = t.boundsAlignH || "left", t.boundsAlignV = t.boundsAlignV || "top", t.stroke = t.stroke || "black", t.strokeThickness = t.strokeThickness || 0, t.wordWrap = t.wordWrap || !1, t.wordWrapWidth = t.wordWrapWidth || 100, t.maxLines = t.maxLines || 0, t.shadowOffsetX = t.shadowOffsetX || 0, t.shadowOffsetY = t.shadowOffsetY || 0, t.shadowColor = t.shadowColor || "rgba(0,0,0,0)", t.shadowBlur = t.shadowBlur || 0, t.tabs = t.tabs || 0;
            var i = this.fontToComponents(t.font);
            return t.fontStyle && (i.fontStyle = t.fontStyle), t.fontVariant && (i.fontVariant = t.fontVariant), t.fontWeight && (i.fontWeight = t.fontWeight), t.fontSize && ("number" == typeof t.fontSize && (t.fontSize = t.fontSize + "px"), i.fontSize = t.fontSize), this._fontComponents = i, t.font = this.componentsToFont(this._fontComponents), this.style = t, this.dirty = !0, e && this.updateText(), this
        }, i.Text.prototype.updateText = function() {
            this.texture.baseTexture.resolution = this._res, this.context.font = this.style.font;
            var t = this.text;
            this.style.wordWrap && (t = this.runWordWrap(this.text));
            var e = t.split(/(?:\r\n|\r|\n)/),
                i = this.style.tabs,
                s = [],
                o = 0,
                n = this.determineFontProperties(this.style.font),
                a = e.length;
            this.style.maxLines > 0 && this.style.maxLines < e.length && (a = this.style.maxLines), this._charCount = 0;
            for (var r = 0; r < a; r++) {
                if (0 === i) {
                    l = this.style.strokeThickness + this.padding.x;
                    l += this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? this.measureLine(e[r]) : this.context.measureText(e[r]).width, this.style.wordWrap && (l -= this.context.measureText(" ").width)
                } else {
                    var h = e[r].split(/(?:\t)/),
                        l = this.padding.x + this.style.strokeThickness;
                    if (Array.isArray(i))
                        for (var c = 0, p = 0; p < h.length; p++) {
                            var u = 0;
                            u = this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? this.measureLine(h[p]) : Math.ceil(this.context.measureText(h[p]).width), p > 0 && (c += i[p - 1]), l = c + u
                        } else
                            for (p = 0; p < h.length; p++) l += this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? this.measureLine(h[p]) : Math.ceil(this.context.measureText(h[p]).width), l += this.game.math.snapToCeil(l, i) - l
                }
                s[r] = Math.ceil(l), o = Math.max(o, s[r])
            }
            this.canvas.width = o * this._res;
            var d = n.fontSize + this.style.strokeThickness + this.padding.y,
                m = d * a,
                y = this._lineSpacing;
            y < 0 && Math.abs(y) > d && (y = -d), 0 !== y && (m += y > 0 ? y * e.length : y * (e.length - 1)), this.canvas.height = m * this._res, this.context.scale(this._res, this._res), navigator.isCocoonJS && this.context.clearRect(0, 0, this.canvas.width, this.canvas.height), this.style.backgroundColor && (this.context.fillStyle = this.style.backgroundColor, this.context.fillRect(0, 0, this.canvas.width, this.canvas.height)), this.context.fillStyle = this.style.fill, this.context.font = this.style.font, this.context.strokeStyle = this.style.stroke, this.context.textBaseline = "alphabetic", this.context.lineWidth = this.style.strokeThickness, this.context.lineCap = "round", this.context.lineJoin = "round";
            var f, g;
            for (this._charCount = 0, r = 0; r < a; r++) f = this.style.strokeThickness / 2, g = this.style.strokeThickness / 2 + r * d + n.ascent, r > 0 && (g += y * r), "right" === this.style.align ? f += o - s[r] : "center" === this.style.align && (f += (o - s[r]) / 2), this.autoRound && (f = Math.round(f), g = Math.round(g)), this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? this.updateLine(e[r], f, g) : (this.style.stroke && this.style.strokeThickness && (this.updateShadow(this.style.shadowStroke), 0 === i ? this.context.strokeText(e[r], f, g) : this.renderTabLine(e[r], f, g, !1)), this.style.fill && (this.updateShadow(this.style.shadowFill), 0 === i ? this.context.fillText(e[r], f, g) : this.renderTabLine(e[r], f, g, !0)));
            this.updateTexture(), this.dirty = !1
        }, i.Text.prototype.renderTabLine = function(t, e, i, s) {
            var o = t.split(/(?:\t)/),
                n = this.style.tabs,
                a = 0;
            if (Array.isArray(n))
                for (var r = 0, h = 0; h < o.length; h++) h > 0 && (r += n[h - 1]), a = e + r, s ? this.context.fillText(o[h], a, i) : this.context.strokeText(o[h], a, i);
            else
                for (h = 0; h < o.length; h++) {
                    var l = Math.ceil(this.context.measureText(o[h]).width);
                    a = this.game.math.snapToCeil(e, n), s ? this.context.fillText(o[h], a, i) : this.context.strokeText(o[h], a, i), e = a + l
                }
        }, i.Text.prototype.updateShadow = function(t) {
            t ? (this.context.shadowOffsetX = this.style.shadowOffsetX, this.context.shadowOffsetY = this.style.shadowOffsetY, this.context.shadowColor = this.style.shadowColor, this.context.shadowBlur = this.style.shadowBlur) : (this.context.shadowOffsetX = 0, this.context.shadowOffsetY = 0, this.context.shadowColor = 0, this.context.shadowBlur = 0)
        }, i.Text.prototype.measureLine = function(t) {
            for (var e = 0, i = 0; i < t.length; i++) {
                var s = t[i];
                if (this.fontWeights.length > 0 || this.fontStyles.length > 0) {
                    var o = this.fontToComponents(this.context.font);
                    this.fontStyles[this._charCount] && (o.fontStyle = this.fontStyles[this._charCount]), this.fontWeights[this._charCount] && (o.fontWeight = this.fontWeights[this._charCount]), this.context.font = this.componentsToFont(o)
                }
                this.style.stroke && this.style.strokeThickness && (this.strokeColors[this._charCount] && (this.context.strokeStyle = this.strokeColors[this._charCount]), this.updateShadow(this.style.shadowStroke)), this.style.fill && (this.colors[this._charCount] && (this.context.fillStyle = this.colors[this._charCount]), this.updateShadow(this.style.shadowFill)), e += this.context.measureText(s).width, this._charCount++
            }
            return Math.ceil(e)
        }, i.Text.prototype.updateLine = function(t, e, i) {
            for (var s = 0; s < t.length; s++) {
                var o = t[s];
                if (this.fontWeights.length > 0 || this.fontStyles.length > 0) {
                    var n = this.fontToComponents(this.context.font);
                    this.fontStyles[this._charCount] && (n.fontStyle = this.fontStyles[this._charCount]), this.fontWeights[this._charCount] && (n.fontWeight = this.fontWeights[this._charCount]), this.context.font = this.componentsToFont(n)
                }
                this.style.stroke && this.style.strokeThickness && (this.strokeColors[this._charCount] && (this.context.strokeStyle = this.strokeColors[this._charCount]), this.updateShadow(this.style.shadowStroke), this.context.strokeText(o, e, i)), this.style.fill && (this.colors[this._charCount] && (this.context.fillStyle = this.colors[this._charCount]), this.updateShadow(this.style.shadowFill), this.context.fillText(o, e, i)), e += this.context.measureText(o).width, this._charCount++
            }
        }, i.Text.prototype.clearColors = function() {
            return this.colors = [], this.strokeColors = [], this.dirty = !0, this
        }, i.Text.prototype.clearFontValues = function() {
            return this.fontStyles = [], this.fontWeights = [], this.dirty = !0, this
        }, i.Text.prototype.addColor = function(t, e) {
            return this.colors[e] = t, this.dirty = !0, this
        }, i.Text.prototype.addStrokeColor = function(t, e) {
            return this.strokeColors[e] = t, this.dirty = !0, this
        }, i.Text.prototype.addFontStyle = function(t, e) {
            return this.fontStyles[e] = t, this.dirty = !0, this
        }, i.Text.prototype.addFontWeight = function(t, e) {
            return this.fontWeights[e] = t, this.dirty = !0, this
        }, i.Text.prototype.precalculateWordWrap = function(t) {
            return this.texture.baseTexture.resolution = this._res, this.context.font = this.style.font, this.runWordWrap(t).split(/(?:\r\n|\r|\n)/)
        }, i.Text.prototype.runWordWrap = function(t) {
            return this.useAdvancedWrap ? this.advancedWordWrap(t) : this.basicWordWrap(t)
        }, i.Text.prototype.advancedWordWrap = function(t) {
            for (var e = this.context, i = this.style.wordWrapWidth, s = "", o = t.replace(/ +/gi, " ").split(/\r?\n/gi), n = o.length, a = 0; a < n; a++) {
                var r = o[a],
                    h = "";
                if (r = r.replace(/^ *|\s*$/gi, ""), e.measureText(r).width < i) s += r + "\n";
                else {
                    for (var l = i, c = r.split(" "), p = 0; p < c.length; p++) {
                        var u = c[p],
                            d = u + " ",
                            m = e.measureText(d).width;
                        if (m > l) {
                            if (0 === p) {
                                for (var y = d; y.length && (y = y.slice(0, -1), !((m = e.measureText(y).width) <= l)););
                                if (!y.length) throw new Error("This text's wordWrapWidth setting is less than a single character!");
                                var f = u.substr(y.length);
                                c[p] = f, h += y
                            }
                            var g = c[p].length ? p : p + 1,
                                _ = c.slice(g).join(" ").replace(/[ \n]*$/gi, "");
                            o[a + 1] = _ + " " + (o[a + 1] || ""), n = o.length;
                            break
                        }
                        h += d, l -= m
                    }
                    s += h.replace(/[ \n]*$/gi, "") + "\n"
                }
            }
            return s = s.replace(/[\s|\n]*$/gi, "")
        }, i.Text.prototype.basicWordWrap = function(t) {
            for (var e = "", i = t.split("\n"), s = 0; s < i.length; s++) {
                for (var o = this.style.wordWrapWidth, n = i[s].split(" "), a = 0; a < n.length; a++) {
                    var r = this.context.measureText(n[a]).width,
                        h = r + this.context.measureText(" ").width;
                    h > o ? (a > 0 && (e += "\n"), e += n[a] + " ", o = this.style.wordWrapWidth - r) : (o -= h, e += n[a] + " ")
                }
                s < i.length - 1 && (e += "\n")
            }
            return e
        }, i.Text.prototype.updateFont = function(t) {
            var e = this.componentsToFont(t);
            this.style.font !== e && (this.style.font = e, this.dirty = !0, this.parent && this.updateTransform())
        }, i.Text.prototype.fontToComponents = function(t) {
            var e = t.match(/^\s*(?:\b(normal|italic|oblique|inherit)?\b)\s*(?:\b(normal|small-caps|inherit)?\b)\s*(?:\b(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit)?\b)\s*(?:\b(xx-small|x-small|small|medium|large|x-large|xx-large|larger|smaller|0|\d*(?:[.]\d*)?(?:%|[a-z]{2,5}))?\b)\s*(.*)\s*$/);
            if (e) {
                var i = e[5].trim();
                return /^(?:inherit|serif|sans-serif|cursive|fantasy|monospace)$/.exec(i) || /['",]/.exec(i) || (i = "'" + i + "'"), {
                    font: t,
                    fontStyle: e[1] || "normal",
                    fontVariant: e[2] || "normal",
                    fontWeight: e[3] || "normal",
                    fontSize: e[4] || "medium",
                    fontFamily: i
                }
            }
            return console.warn("Phaser.Text - unparsable CSS font: " + t), {
                font: t
            }
        }, i.Text.prototype.componentsToFont = function(t) {
            var e, i = [];
            return (e = t.fontStyle) && "normal" !== e && i.push(e), (e = t.fontVariant) && "normal" !== e && i.push(e), (e = t.fontWeight) && "normal" !== e && i.push(e), (e = t.fontSize) && "medium" !== e && i.push(e), (e = t.fontFamily) && i.push(e), i.length || i.push(t.font), i.join(" ")
        }, i.Text.prototype.setText = function(t, e) {
            return void 0 === e && (e = !1), this.text = t.toString() || "", e ? this.updateText() : this.dirty = !0, this
        }, i.Text.prototype.parseList = function(t) {
            if (!Array.isArray(t)) return this;
            for (var e = "", i = 0; i < t.length; i++) Array.isArray(t[i]) ? (e += t[i].join("\t"), i < t.length - 1 && (e += "\n")) : (e += t[i], i < t.length - 1 && (e += "\t"));
            return this.text = e, this.dirty = !0, this
        }, i.Text.prototype.setTextBounds = function(t, e, s, o) {
            return void 0 === t ? this.textBounds = null : (this.textBounds ? this.textBounds.setTo(t, e, s, o) : this.textBounds = new i.Rectangle(t, e, s, o), this.style.wordWrapWidth > s && (this.style.wordWrapWidth = s)), this.updateTexture(), this
        }, i.Text.prototype.updateTexture = function() {
            var t = this.texture.baseTexture,
                e = this.texture.crop,
                i = this.texture.frame,
                s = this.canvas.width,
                o = this.canvas.height;
            if (t.width = s, t.height = o, e.width = s, e.height = o, i.width = s, i.height = o, this.texture.width = s, this.texture.height = o, this._width = s, this._height = o, this.textBounds) {
                var n = this.textBounds.x,
                    a = this.textBounds.y;
                "right" === this.style.boundsAlignH ? n += this.textBounds.width - this.canvas.width / this.resolution : "center" === this.style.boundsAlignH && (n += this.textBounds.halfWidth - this.canvas.width / this.resolution / 2), "bottom" === this.style.boundsAlignV ? a += this.textBounds.height - this.canvas.height / this.resolution : "middle" === this.style.boundsAlignV && (a += this.textBounds.halfHeight - this.canvas.height / this.resolution / 2), this.pivot.x = -n, this.pivot.y = -a
            }
            this.renderable = 0 !== s && 0 !== o, this.texture.requiresReTint = !0, this.texture.baseTexture.dirty()
        }, i.Text.prototype._renderWebGL = function(t) {
            this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype._renderWebGL.call(this, t)
        }, i.Text.prototype._renderCanvas = function(t) {
            this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype._renderCanvas.call(this, t)
        }, i.Text.prototype.determineFontProperties = function(t) {
            var e = i.Text.fontPropertiesCache[t];
            if (!e) {
                e = {};
                var s = i.Text.fontPropertiesCanvas,
                    o = i.Text.fontPropertiesContext;
                o.font = t;
                var n = Math.ceil(o.measureText("|MÉq").width),
                    a = Math.ceil(o.measureText("|MÉq").width),
                    r = 2 * a;
                if (a = 1.4 * a | 0, s.width = n, s.height = r, o.fillStyle = "#f00", o.fillRect(0, 0, n, r), o.font = t, o.textBaseline = "alphabetic", o.fillStyle = "#000", o.fillText("|MÉq", 0, a), !o.getImageData(0, 0, n, r)) return e.ascent = a, e.descent = a + 6, e.fontSize = e.ascent + e.descent, i.Text.fontPropertiesCache[t] = e, e;
                var h, l, c = o.getImageData(0, 0, n, r).data,
                    p = c.length,
                    u = 4 * n,
                    d = 0,
                    m = !1;
                for (h = 0; h < a; h++) {
                    for (l = 0; l < u; l += 4)
                        if (255 !== c[d + l]) {
                            m = !0;
                            break
                        }
                    if (m) break;
                    d += u
                }
                for (e.ascent = a - h, d = p - u, m = !1, h = r; h > a; h--) {
                    for (l = 0; l < u; l += 4)
                        if (255 !== c[d + l]) {
                            m = !0;
                            break
                        }
                    if (m) break;
                    d -= u
                }
                e.descent = h - a, e.descent += 6, e.fontSize = e.ascent + e.descent, i.Text.fontPropertiesCache[t] = e
            }
            return e
        }, i.Text.prototype.getBounds = function(t) {
            return this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype.getBounds.call(this, t)
        }, Object.defineProperty(i.Text.prototype, "text", {
            get: function() {
                return this._text
            },
            set: function(t) {
                t !== this._text && (this._text = t.toString() || "", this.dirty = !0, this.parent && this.updateTransform())
            }
        }), Object.defineProperty(i.Text.prototype, "cssFont", {
            get: function() {
                return this.componentsToFont(this._fontComponents)
            },
            set: function(t) {
                t = t || "bold 20pt Arial", this._fontComponents = this.fontToComponents(t), this.updateFont(this._fontComponents)
            }
        }), Object.defineProperty(i.Text.prototype, "font", {
            get: function() {
                return this._fontComponents.fontFamily
            },
            set: function(t) {
                t = (t = t || "Arial").trim(), /^(?:inherit|serif|sans-serif|cursive|fantasy|monospace)$/.exec(t) || /['",]/.exec(t) || (t = "'" + t + "'"), this._fontComponents.fontFamily = t, this.updateFont(this._fontComponents)
            }
        }), Object.defineProperty(i.Text.prototype, "fontSize", {
            get: function() {
                var t = this._fontComponents.fontSize;
                return t && /(?:^0$|px$)/.exec(t) ? parseInt(t, 10) : t
            },
            set: function(t) {
                "number" == typeof(t = t || "0") && (t += "px"), this._fontComponents.fontSize = t, this.updateFont(this._fontComponents)
            }
        }), Object.defineProperty(i.Text.prototype, "fontWeight", {
            get: function() {
                return this._fontComponents.fontWeight || "normal"
            },
            set: function(t) {
                t = t || "normal", this._fontComponents.fontWeight = t, this.updateFont(this._fontComponents)
            }
        }), Object.defineProperty(i.Text.prototype, "fontStyle", {
            get: function() {
                return this._fontComponents.fontStyle || "normal"
            },
            set: function(t) {
                t = t || "normal", this._fontComponents.fontStyle = t, this.updateFont(this._fontComponents)
            }
        }), Object.defineProperty(i.Text.prototype, "fontVariant", {
            get: function() {
                return this._fontComponents.fontVariant || "normal"
            },
            set: function(t) {
                t = t || "normal", this._fontComponents.fontVariant = t, this.updateFont(this._fontComponents)
            }
        }), Object.defineProperty(i.Text.prototype, "fill", {
            get: function() {
                return this.style.fill
            },
            set: function(t) {
                t !== this.style.fill && (this.style.fill = t, this.dirty = !0)
            }
        }), Object.defineProperty(i.Text.prototype, "align", {
            get: function() {
                return this.style.align
            },
            set: function(t) {
                t !== this.style.align && (this.style.align = t, this.dirty = !0)
            }
        }), Object.defineProperty(i.Text.prototype, "resolution", {
            get: function() {
                return this._res
            },
            set: function(t) {
                t !== this._res && (this._res = t, this.dirty = !0)
            }
        }), Object.defineProperty(i.Text.prototype, "tabs", {
            get: function() {
                return this.style.tabs
            },
            set: function(t) {
                t !== this.style.tabs && (this.style.tabs = t, this.dirty = !0)
            }
        }), Object.defineProperty(i.Text.prototype, "boundsAlignH", {
            get: function() {
                return this.style.boundsAlignH
            },
            set: function(t) {
                t !== this.style.boundsAlignH && (this.style.boundsAlignH = t, this.dirty = !0)
            }
        }), Object.defineProperty(i.Text.prototype, "boundsAlignV", {
            get: function() {
                return this.style.boundsAlignV
            },
            set: function(t) {
                t !== this.style.boundsAlignV && (this.style.boundsAlignV = t, this.dirty = !0)
            }
        }), Object.defineProperty(i.Text.prototype, "stroke", {
            get: function() {
                return this.style.stroke
            },
            set: function(t) {
                t !== this.style.stroke && (this.style.stroke = t, this.dirty = !0)
            }
        }), Object.defineProperty(i.Text.prototype, "strokeThickness", {
            get: function() {
                return this.style.strokeThickness
            },
            set: function(t) {
                t !== this.style.strokeThickness && (this.style.strokeThickness = t, this.dirty = !0)
            }
        }), Object.defineProperty(i.Text.prototype, "wordWrap", {
            get: function() {
                return this.style.wordWrap
            },
            set: function(t) {
                t !== this.style.wordWrap && (this.style.wordWrap = t, this.dirty = !0)
            }
        }), Object.defineProperty(i.Text.prototype, "wordWrapWidth", {
            get: function() {
                return this.style.wordWrapWidth
            },
            set: function(t) {
                t !== this.style.wordWrapWidth && (this.style.wordWrapWidth = t, this.dirty = !0)
            }
        }), Object.defineProperty(i.Text.prototype, "lineSpacing", {
            get: function() {
                return this._lineSpacing
            },
            set: function(t) {
                t !== this._lineSpacing && (this._lineSpacing = parseFloat(t), this.dirty = !0, this.parent && this.updateTransform())
            }
        }), Object.defineProperty(i.Text.prototype, "shadowOffsetX", {
            get: function() {
                return this.style.shadowOffsetX
            },
            set: function(t) {
                t !== this.style.shadowOffsetX && (this.style.shadowOffsetX = t, this.dirty = !0)
            }
        }), Object.defineProperty(i.Text.prototype, "shadowOffsetY", {
            get: function() {
                return this.style.shadowOffsetY
            },
            set: function(t) {
                t !== this.style.shadowOffsetY && (this.style.shadowOffsetY = t, this.dirty = !0)
            }
        }), Object.defineProperty(i.Text.prototype, "shadowColor", {
            get: function() {
                return this.style.shadowColor
            },
            set: function(t) {
                t !== this.style.shadowColor && (this.style.shadowColor = t, this.dirty = !0)
            }
        }), Object.defineProperty(i.Text.prototype, "shadowBlur", {
            get: function() {
                return this.style.shadowBlur
            },
            set: function(t) {
                t !== this.style.shadowBlur && (this.style.shadowBlur = t, this.dirty = !0)
            }
        }), Object.defineProperty(i.Text.prototype, "shadowStroke", {
            get: function() {
                return this.style.shadowStroke
            },
            set: function(t) {
                t !== this.style.shadowStroke && (this.style.shadowStroke = t, this.dirty = !0)
            }
        }), Object.defineProperty(i.Text.prototype, "shadowFill", {
            get: function() {
                return this.style.shadowFill
            },
            set: function(t) {
                t !== this.style.shadowFill && (this.style.shadowFill = t, this.dirty = !0)
            }
        }), Object.defineProperty(i.Text.prototype, "width", {
            get: function() {
                return this.dirty && (this.updateText(), this.dirty = !1), this.scale.x * this.texture.frame.width
            },
            set: function(t) {
                this.scale.x = t / this.texture.frame.width, this._width = t
            }
        }), Object.defineProperty(i.Text.prototype, "height", {
            get: function() {
                return this.dirty && (this.updateText(), this.dirty = !1), this.scale.y * this.texture.frame.height
            },
            set: function(t) {
                this.scale.y = t / this.texture.frame.height, this._height = t
            }
        }), i.Text.fontPropertiesCache = {}, i.Text.fontPropertiesCanvas = document.createElement("canvas"), i.Text.fontPropertiesContext = i.Text.fontPropertiesCanvas.getContext("2d"), i.BitmapText = function(t, e, s, o, n, a, r) {
            e = e || 0, s = s || 0, o = o || "", n = n || "", a = a || 32, r = r || "left", PIXI.DisplayObjectContainer.call(this), this.type = i.BITMAPTEXT, this.physicsType = i.SPRITE, this.textWidth = 0, this.textHeight = 0, this.anchor = new i.Point, this._prevAnchor = new i.Point, this._glyphs = [], this._maxWidth = 0, this._text = n.toString() || "", this._data = t.cache.getBitmapFont(o), this._font = o, this._fontSize = a, this._align = r, this._tint = 16777215, this.updateText(), this.dirty = !1, i.Component.Core.init.call(this, t, e, s, "", null)
        }, i.BitmapText.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), i.BitmapText.prototype.constructor = i.BitmapText, i.Component.Core.install.call(i.BitmapText.prototype, ["Angle", "AutoCull", "Bounds", "Destroy", "FixedToCamera", "InputEnabled", "InWorld", "LifeSpan", "PhysicsBody", "Reset"]), i.BitmapText.prototype.preUpdatePhysics = i.Component.PhysicsBody.preUpdate, i.BitmapText.prototype.preUpdateLifeSpan = i.Component.LifeSpan.preUpdate, i.BitmapText.prototype.preUpdateInWorld = i.Component.InWorld.preUpdate, i.BitmapText.prototype.preUpdateCore = i.Component.Core.preUpdate, i.BitmapText.prototype.preUpdate = function() {
            return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        }, i.BitmapText.prototype.postUpdate = function() {
            i.Component.PhysicsBody.postUpdate.call(this), i.Component.FixedToCamera.postUpdate.call(this), this.body && this.body.type === i.Physics.ARCADE && (this.textWidth === this.body.sourceWidth && this.textHeight === this.body.sourceHeight || this.body.setSize(this.textWidth, this.textHeight))
        }, i.BitmapText.prototype.setText = function(t) {
            this.text = t
        }, i.BitmapText.prototype.scanLine = function(t, e, i) {
            for (var s = 0, o = 0, n = -1, a = 0, r = null, h = this._maxWidth > 0 ? this._maxWidth : null, l = [], c = 0; c < i.length; c++) {
                var p = c === i.length - 1;
                if (/(?:\r\n|\r|\n)/.test(i.charAt(c))) return {
                    width: o,
                    text: i.substr(0, c),
                    end: p,
                    chars: l
                };
                var u = i.charCodeAt(c),
                    d = t.chars[u],
                    m = 0;
                void 0 === d && (u = 32, d = t.chars[u]);
                var y = r && d.kerning[r] ? d.kerning[r] : 0;
                if (/(\s)/.test(i.charAt(c)) && (n = c, a = o), m = (y + d.texture.width + d.xOffset) * e, h && o + m >= h && n > -1) return {
                    width: a || o,
                    text: i.substr(0, c - (c - n)),
                    end: p,
                    chars: l
                };
                o += (d.xAdvance + y) * e, l.push(s + (d.xOffset + y) * e), s += (d.xAdvance + y) * e, r = u
            }
            return {
                width: o,
                text: i,
                end: p,
                chars: l
            }
        }, i.BitmapText.prototype.cleanText = function(t, e) {
            void 0 === e && (e = "");
            var i = this._data.font;
            if (!i) return "";
            for (var s = /\r\n|\n\r|\n|\r/g, o = t.replace(s, "\n").split("\n"), n = 0; n < o.length; n++) {
                for (var a = "", r = o[n], h = 0; h < r.length; h++) a = i.chars[r.charCodeAt(h)] ? a.concat(r[h]) : a.concat(e);
                o[n] = a
            }
            return o.join("\n")
        }, i.BitmapText.prototype.updateText = function() {
            var t = this._data.font;
            if (t) {
                var e = this.text,
                    i = this._fontSize / t.size,
                    s = [],
                    o = 0;
                this.textWidth = 0;
                do {
                    (c = this.scanLine(t, i, e)).y = o, s.push(c), c.width > this.textWidth && (this.textWidth = c.width), o += t.lineHeight * i, e = e.substr(c.text.length + 1)
                } while (!1 === c.end);
                this.textHeight = o;
                for (var n = 0, a = 0, r = this.textWidth * this.anchor.x, h = this.textHeight * this.anchor.y, l = 0; l < s.length; l++) {
                    var c = s[l];
                    "right" === this._align ? a = this.textWidth - c.width : "center" === this._align && (a = (this.textWidth - c.width) / 2);
                    for (var p = 0; p < c.text.length; p++) {
                        var u = c.text.charCodeAt(p),
                            d = t.chars[u];
                        void 0 === d && (u = 32, d = t.chars[u]);
                        var m = this._glyphs[n];
                        m ? m.texture = d.texture : (m = new PIXI.Sprite(d.texture), m.name = c.text[p], this._glyphs.push(m)), m.position.x = c.chars[p] + a - r, m.position.y = c.y + d.yOffset * i - h, m.scale.set(i), m.tint = this.tint, m.texture.requiresReTint = !0, m.parent || this.addChild(m), n++
                    }
                }
                for (l = n; l < this._glyphs.length; l++) this.removeChild(this._glyphs[l])
            }
        }, i.BitmapText.prototype.purgeGlyphs = function() {
            for (var t = this._glyphs.length, e = [], i = 0; i < this._glyphs.length; i++) this._glyphs[i].parent !== this ? this._glyphs[i].destroy() : e.push(this._glyphs[i]);
            return this._glyphs = [], this._glyphs = e, this.updateText(), t - e.length
        }, i.BitmapText.prototype.updateTransform = function() {
            !this.dirty && this.anchor.equals(this._prevAnchor) || (this.updateText(), this.dirty = !1, this._prevAnchor.copyFrom(this.anchor)), PIXI.DisplayObjectContainer.prototype.updateTransform.call(this)
        }, Object.defineProperty(i.BitmapText.prototype, "align", {
            get: function() {
                return this._align
            },
            set: function(t) {
                t === this._align || "left" !== t && "center" !== t && "right" !== t || (this._align = t, this.updateText())
            }
        }), Object.defineProperty(i.BitmapText.prototype, "tint", {
            get: function() {
                return this._tint
            },
            set: function(t) {
                t !== this._tint && (this._tint = t, this.updateText())
            }
        }), Object.defineProperty(i.BitmapText.prototype, "font", {
            get: function() {
                return this._font
            },
            set: function(t) {
                t !== this._font && (this._font = t.trim(), this._data = this.game.cache.getBitmapFont(this._font), this.updateText())
            }
        }), Object.defineProperty(i.BitmapText.prototype, "fontSize", {
            get: function() {
                return this._fontSize
            },
            set: function(t) {
                (t = parseInt(t, 10)) !== this._fontSize && t > 0 && (this._fontSize = t, this.updateText())
            }
        }), Object.defineProperty(i.BitmapText.prototype, "text", {
            get: function() {
                return this._text
            },
            set: function(t) {
                t !== this._text && (this._text = t.toString() || "", this.updateText())
            }
        }), Object.defineProperty(i.BitmapText.prototype, "maxWidth", {
            get: function() {
                return this._maxWidth
            },
            set: function(t) {
                t !== this._maxWidth && (this._maxWidth = t, this.updateText())
            }
        }), Object.defineProperty(i.BitmapText.prototype, "smoothed", {
            get: function() {
                return !this._data.base.scaleMode
            },
            set: function(t) {
                this._data.base.scaleMode = t ? 0 : 1
            }
        }), i.RetroFont = function(t, e, s, o, n, a, r, h, l, c) {
            if (!t.cache.checkImageKey(e)) return !1;
            void 0 !== a && null !== a || (a = t.cache.getImage(e).width / s), this.characterWidth = s, this.characterHeight = o, this.characterSpacingX = r || 0, this.characterSpacingY = h || 0, this.characterPerRow = a, this.offsetX = l || 0, this.offsetY = c || 0, this.align = "left", this.multiLine = !1, this.autoUpperCase = !0, this.customSpacingX = 0, this.customSpacingY = 0, this.fixedWidth = 0, this.fontSet = t.cache.getImage(e), this._text = "", this.grabData = [], this.frameData = new i.FrameData;
            for (var p = this.offsetX, u = this.offsetY, d = 0, m = 0; m < n.length; m++) {
                var y = this.frameData.addFrame(new i.Frame(m, p, u, this.characterWidth, this.characterHeight));
                this.grabData[n.charCodeAt(m)] = y.index, ++d === this.characterPerRow ? (d = 0, p = this.offsetX, u += this.characterHeight + this.characterSpacingY) : p += this.characterWidth + this.characterSpacingX
            }
            t.cache.updateFrameData(e, this.frameData), this.stamp = new i.Image(t, 0, 0, e, 0), i.RenderTexture.call(this, t, 100, 100, "", i.scaleModes.NEAREST), this.type = i.RETROFONT
        }, i.RetroFont.prototype = Object.create(i.RenderTexture.prototype), i.RetroFont.prototype.constructor = i.RetroFont, i.RetroFont.ALIGN_LEFT = "left", i.RetroFont.ALIGN_RIGHT = "right", i.RetroFont.ALIGN_CENTER = "center", i.RetroFont.TEXT_SET1 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~", i.RetroFont.TEXT_SET2 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ", i.RetroFont.TEXT_SET3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ", i.RetroFont.TEXT_SET4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789", i.RetroFont.TEXT_SET5 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789", i.RetroFont.TEXT_SET6 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789\"(),-.' ", i.RetroFont.TEXT_SET7 = "AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW\")28FLRX-'39", i.RetroFont.TEXT_SET8 = "0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ", i.RetroFont.TEXT_SET9 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'\"?!", i.RetroFont.TEXT_SET10 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ", i.RetroFont.TEXT_SET11 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,\"-+!?()':;0123456789", i.RetroFont.prototype.setFixedWidth = function(t, e) {
            void 0 === e && (e = "left"), this.fixedWidth = t, this.align = e
        }, i.RetroFont.prototype.setText = function(t, e, i, s, o, n) {
            this.multiLine = e || !1, this.customSpacingX = i || 0, this.customSpacingY = s || 0, this.align = o || "left", this.autoUpperCase = !n, t.length > 0 && (this.text = t)
        }, i.RetroFont.prototype.buildRetroFontText = function() {
            var t = 0,
                e = 0;
            if (this.clear(), this.multiLine) {
                var s = this._text.split("\n");
                this.fixedWidth > 0 ? this.resize(this.fixedWidth, s.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, !0) : this.resize(this.getLongestLine() * (this.characterWidth + this.customSpacingX), s.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, !0);
                for (var o = 0; o < s.length; o++) t = 0, this.align === i.RetroFont.ALIGN_RIGHT ? t = this.width - s[o].length * (this.characterWidth + this.customSpacingX) : this.align === i.RetroFont.ALIGN_CENTER && (t = this.width / 2 - s[o].length * (this.characterWidth + this.customSpacingX) / 2, t += this.customSpacingX / 2), t < 0 && (t = 0), this.pasteLine(s[o], t, e, this.customSpacingX), e += this.characterHeight + this.customSpacingY
            } else this.fixedWidth > 0 ? this.resize(this.fixedWidth, this.characterHeight, !0) : this.resize(this._text.length * (this.characterWidth + this.customSpacingX), this.characterHeight, !0), t = 0, this.align === i.RetroFont.ALIGN_RIGHT ? t = this.width - this._text.length * (this.characterWidth + this.customSpacingX) : this.align === i.RetroFont.ALIGN_CENTER && (t = this.width / 2 - this._text.length * (this.characterWidth + this.customSpacingX) / 2, t += this.customSpacingX / 2), t < 0 && (t = 0), this.pasteLine(this._text, t, 0, this.customSpacingX);
            this.requiresReTint = !0
        }, i.RetroFont.prototype.pasteLine = function(t, e, i, s) {
            for (var o = 0; o < t.length; o++)
                if (" " === t.charAt(o)) e += this.characterWidth + s;
                else if (this.grabData[t.charCodeAt(o)] >= 0 && (this.stamp.frame = this.grabData[t.charCodeAt(o)], this.renderXY(this.stamp, e, i, !1), (e += this.characterWidth + s) > this.width)) break
        }, i.RetroFont.prototype.getLongestLine = function() {
            var t = 0;
            if (this._text.length > 0)
                for (var e = this._text.split("\n"), i = 0; i < e.length; i++) e[i].length > t && (t = e[i].length);
            return t
        }, i.RetroFont.prototype.removeUnsupportedCharacters = function(t) {
            for (var e = "", i = 0; i < this._text.length; i++) {
                var s = this._text[i],
                    o = s.charCodeAt(0);
                (this.grabData[o] >= 0 || !t && "\n" === s) && (e = e.concat(s))
            }
            return e
        }, i.RetroFont.prototype.updateOffset = function(t, e) {
            if (this.offsetX !== t || this.offsetY !== e) {
                for (var i = t - this.offsetX, s = e - this.offsetY, o = this.game.cache.getFrameData(this.stamp.key).getFrames(), n = o.length; n--;) o[n].x += i, o[n].y += s;
                this.buildRetroFontText()
            }
        }, Object.defineProperty(i.RetroFont.prototype, "text", {
            get: function() {
                return this._text
            },
            set: function(t) {
                var e;
                (e = this.autoUpperCase ? t.toUpperCase() : t) !== this._text && (this._text = e, this.removeUnsupportedCharacters(this.multiLine), this.buildRetroFontText())
            }
        }), Object.defineProperty(i.RetroFont.prototype, "smoothed", {
            get: function() {
                return this.stamp.smoothed
            },
            set: function(t) {
                this.stamp.smoothed = t, this.buildRetroFontText()
            }
        }), i.Rope = function(t, e, s, o, n, a) {
            this.points = [], this.points = a, this._hasUpdateAnimation = !1, this._updateAnimationCallback = null, e = e || 0, s = s || 0, o = o || null, n = n || null, this.type = i.ROPE, PIXI.Rope.call(this, i.Cache.DEFAULT, this.points), i.Component.Core.init.call(this, t, e, s, o, n)
        }, i.Rope.prototype = Object.create(PIXI.Rope.prototype), i.Rope.prototype.constructor = i.Rope, i.Component.Core.install.call(i.Rope.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Delta", "Destroy", "FixedToCamera", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "ScaleMinMax", "Smoothed"]), i.Rope.prototype.preUpdatePhysics = i.Component.PhysicsBody.preUpdate, i.Rope.prototype.preUpdateLifeSpan = i.Component.LifeSpan.preUpdate, i.Rope.prototype.preUpdateInWorld = i.Component.InWorld.preUpdate, i.Rope.prototype.preUpdateCore = i.Component.Core.preUpdate, i.Rope.prototype.preUpdate = function() {
            return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        }, i.Rope.prototype.update = function() {
            this._hasUpdateAnimation && this.updateAnimation.call(this)
        }, i.Rope.prototype.reset = function(t, e) {
            return i.Component.Reset.prototype.reset.call(this, t, e), this
        }, Object.defineProperty(i.Rope.prototype, "updateAnimation", {
            get: function() {
                return this._updateAnimation
            },
            set: function(t) {
                t && "function" == typeof t ? (this._hasUpdateAnimation = !0, this._updateAnimation = t) : (this._hasUpdateAnimation = !1, this._updateAnimation = null)
            }
        }), Object.defineProperty(i.Rope.prototype, "segments", {
            get: function() {
                for (var t, e, s, o, n, a, r, h, l = [], c = 0; c < this.points.length; c++) t = 4 * c, e = this.vertices[t] * this.scale.x, s = this.vertices[t + 1] * this.scale.y, o = this.vertices[t + 4] * this.scale.x, n = this.vertices[t + 3] * this.scale.y, a = i.Math.difference(e, o), r = i.Math.difference(s, n), e += this.world.x, s += this.world.y, h = new i.Rectangle(e, s, a, r), l.push(h);
                return l
            }
        }), i.TileSprite = function(t, e, s, o, n, a, r) {
            e = e || 0, s = s || 0, o = o || 256, n = n || 256, a = a || null, r = r || null, this.type = i.TILESPRITE, this.physicsType = i.SPRITE, this._scroll = new i.Point;
            var h = t.cache.getImage("__default", !0);
            PIXI.TilingSprite.call(this, new PIXI.Texture(h.base), o, n), i.Component.Core.init.call(this, t, e, s, a, r)
        }, i.TileSprite.prototype = Object.create(PIXI.TilingSprite.prototype), i.TileSprite.prototype.constructor = i.TileSprite, i.Component.Core.install.call(i.TileSprite.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Destroy", "FixedToCamera", "Health", "InCamera", "InputEnabled", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "Smoothed"]), i.TileSprite.prototype.preUpdatePhysics = i.Component.PhysicsBody.preUpdate, i.TileSprite.prototype.preUpdateLifeSpan = i.Component.LifeSpan.preUpdate, i.TileSprite.prototype.preUpdateInWorld = i.Component.InWorld.preUpdate, i.TileSprite.prototype.preUpdateCore = i.Component.Core.preUpdate, i.TileSprite.prototype.preUpdate = function() {
            return 0 !== this._scroll.x && (this.tilePosition.x += this._scroll.x * this.game.time.physicsElapsed), 0 !== this._scroll.y && (this.tilePosition.y += this._scroll.y * this.game.time.physicsElapsed), !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        }, i.TileSprite.prototype.autoScroll = function(t, e) {
            this._scroll.set(t, e)
        }, i.TileSprite.prototype.stopScroll = function() {
            this._scroll.set(0, 0)
        }, i.TileSprite.prototype.destroy = function(t) {
            i.Component.Destroy.prototype.destroy.call(this, t), PIXI.TilingSprite.prototype.destroy.call(this)
        }, i.TileSprite.prototype.reset = function(t, e) {
            return i.Component.Reset.prototype.reset.call(this, t, e), this.tilePosition.x = 0, this.tilePosition.y = 0, this
        }, i.Device = function() {
            this.deviceReadyAt = 0, this.initialized = !1, this.desktop = !1, this.iOS = !1, this.iOSVersion = 0, this.cocoonJS = !1, this.cocoonJSApp = !1, this.cordova = !1, this.node = !1, this.nodeWebkit = !1, this.electron = !1, this.ejecta = !1, this.crosswalk = !1, this.android = !1, this.chromeOS = !1, this.linux = !1, this.macOS = !1, this.windows = !1, this.windowsPhone = !1, this.canvas = !1, this.canvasBitBltShift = null, this.webGL = !1, this.file = !1, this.fileSystem = !1, this.localStorage = !1, this.worker = !1, this.css3D = !1, this.pointerLock = !1, this.typedArray = !1, this.vibration = !1, this.getUserMedia = !0, this.quirksMode = !1, this.touch = !1, this.mspointer = !1, this.wheelEvent = null, this.arora = !1, this.chrome = !1, this.chromeVersion = 0, this.epiphany = !1, this.firefox = !1, this.firefoxVersion = 0, this.ie = !1, this.ieVersion = 0, this.trident = !1, this.tridentVersion = 0, this.edge = !1, this.mobileSafari = !1, this.midori = !1, this.opera = !1, this.safari = !1, this.safariVersion = 0, this.webApp = !1, this.silk = !1, this.audioData = !1, this.webAudio = !1, this.ogg = !1, this.opus = !1, this.mp3 = !1, this.wav = !1, this.m4a = !1, this.webm = !1, this.dolby = !1, this.oggVideo = !1, this.h264Video = !1, this.mp4Video = !1, this.webmVideo = !1, this.vp9Video = !1, this.hlsVideo = !1, this.iPhone = !1, this.iPhone4 = !1, this.iPad = !1, this.pixelRatio = 0, this.littleEndian = !1, this.LITTLE_ENDIAN = !1, this.support32bit = !1, this.fullscreen = !1, this.requestFullscreen = "", this.cancelFullscreen = "", this.fullscreenKeyboard = !1
        }, i.Device = new i.Device, i.Device.onInitialized = new i.Signal, i.Device.whenReady = function(t, e, i) {
            var s = this._readyCheck;
            if (this.deviceReadyAt || !s) t.call(e, this);
            else if (s._monitor || i) s._queue = s._queue || [], s._queue.push([t, e]);
            else {
                s._monitor = s.bind(this), s._queue = s._queue || [], s._queue.push([t, e]);
                var o = void 0 !== window.cordova,
                    n = navigator.isCocoonJS;
                "complete" === document.readyState || "interactive" === document.readyState ? window.setTimeout(s._monitor, 0) : o && !n ? document.addEventListener("deviceready", s._monitor, !1) : (document.addEventListener("DOMContentLoaded", s._monitor, !1), window.addEventListener("load", s._monitor, !1))
            }
        }, i.Device._readyCheck = function() {
            var t = this._readyCheck;
            if (document.body) {
                if (!this.deviceReadyAt) {
                    this.deviceReadyAt = Date.now(), document.removeEventListener("deviceready", t._monitor), document.removeEventListener("DOMContentLoaded", t._monitor), window.removeEventListener("load", t._monitor), this._initialize(), this.initialized = !0, this.onInitialized.dispatch(this);
                    for (var e; e = t._queue.shift();) {
                        var i = e[0],
                            s = e[1];
                        i.call(s, this)
                    }
                    this._readyCheck = null, this._initialize = null, this.onInitialized = null
                }
            } else window.setTimeout(t._monitor, 20)
        }, i.Device._initialize = function() {
            function t() {
                var t = new ArrayBuffer(4),
                    e = new Uint8Array(t),
                    i = new Uint32Array(t);
                return e[0] = 161, e[1] = 178, e[2] = 195, e[3] = 212, 3569595041 === i[0] || 2712847316 !== i[0] && null
            }

            function e() {
                if (void 0 === Uint8ClampedArray) return !1;
                var t = PIXI.CanvasPool.create(this, 1, 1).getContext("2d");
                if (!t) return !1;
                var e = t.createImageData(1, 1);
                return PIXI.CanvasPool.remove(this), e.data instanceof Uint8ClampedArray
            }
            var i = this;
            (function() {
                var t = navigator.userAgent;
                /Playstation Vita/.test(t) ? i.vita = !0 : /Kindle/.test(t) || /\bKF[A-Z][A-Z]+/.test(t) || /Silk.*Mobile Safari/.test(t) ? i.kindle = !0 : /Android/.test(t) ? i.android = !0 : /CrOS/.test(t) ? i.chromeOS = !0 : /iP[ao]d|iPhone/i.test(t) ? (i.iOS = !0, navigator.appVersion.match(/OS (\d+)/), i.iOSVersion = parseInt(RegExp.$1, 10)) : /Linux/.test(t) ? i.linux = !0 : /Mac OS/.test(t) ? i.macOS = !0 : /Windows/.test(t) && (i.windows = !0), (/Windows Phone/i.test(t) || /IEMobile/i.test(t)) && (i.android = !1, i.iOS = !1, i.macOS = !1, i.windows = !0, i.windowsPhone = !0);
                var e = /Silk/.test(t);
                (i.windows || i.macOS || i.linux && !e || i.chromeOS) && (i.desktop = !0), (i.windowsPhone || /Windows NT/i.test(t) && /Touch/i.test(t)) && (i.desktop = !1)
            })(),
            function() {
                var t = navigator.userAgent;
                if (/Arora/.test(t) ? i.arora = !0 : /Edge\/\d+/.test(t) ? i.edge = !0 : /Chrome\/(\d+)/.test(t) && !i.windowsPhone ? (i.chrome = !0, i.chromeVersion = parseInt(RegExp.$1, 10)) : /Epiphany/.test(t) ? i.epiphany = !0 : /Firefox\D+(\d+)/.test(t) ? (i.firefox = !0, i.firefoxVersion = parseInt(RegExp.$1, 10)) : /AppleWebKit/.test(t) && i.iOS ? i.mobileSafari = !0 : /MSIE (\d+\.\d+);/.test(t) ? (i.ie = !0, i.ieVersion = parseInt(RegExp.$1, 10)) : /Midori/.test(t) ? i.midori = !0 : /Opera/.test(t) ? i.opera = !0 : /Safari\/(\d+)/.test(t) && !i.windowsPhone ? (i.safari = !0, /Version\/(\d+)\./.test(t) && (i.safariVersion = parseInt(RegExp.$1, 10))) : /Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.test(t) && (i.ie = !0, i.trident = !0, i.tridentVersion = parseInt(RegExp.$1, 10), i.ieVersion = parseInt(RegExp.$3, 10)), /Silk/.test(t) && (i.silk = !0), navigator.standalone && (i.webApp = !0), void 0 !== window.cordova && (i.cordova = !0), "undefined" != typeof process && "undefined" != typeof require && (i.node = !0), i.node && "object" == typeof process.versions && (i.nodeWebkit = !!process.versions["node-webkit"], i.electron = !!process.versions.electron), navigator.isCocoonJS && (i.cocoonJS = !0), i.cocoonJS) try {
                    i.cocoonJSApp = "undefined" != typeof CocoonJS
                } catch (t) {
                    i.cocoonJSApp = !1
                }
                void 0 !== window.ejecta && (i.ejecta = !0), /Crosswalk/.test(t) && (i.crosswalk = !0)
            }(),
            function() {
                i.audioData = !!window.Audio, i.webAudio = !(!window.AudioContext && !window.webkitAudioContext);
                var t = document.createElement("audio");
                try {
                    if (t.canPlayType && (t.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, "") && (i.ogg = !0), (t.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, "") || t.canPlayType("audio/opus;").replace(/^no$/, "")) && (i.opus = !0), t.canPlayType("audio/mpeg;").replace(/^no$/, "") && (i.mp3 = !0), t.canPlayType('audio/wav; codecs="1"').replace(/^no$/, "") && (i.wav = !0), (t.canPlayType("audio/x-m4a;") || t.canPlayType("audio/aac;").replace(/^no$/, "")) && (i.m4a = !0), t.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "") && (i.webm = !0), "" !== t.canPlayType('audio/mp4;codecs="ec-3"')))
                        if (i.edge) i.dolby = !0;
                        else if (i.safari && i.safariVersion >= 9 && /Mac OS X (\d+)_(\d+)/.test(navigator.userAgent)) {
                        var e = parseInt(RegExp.$1, 10),
                            s = parseInt(RegExp.$2, 10);
                        (10 === e && s >= 11 || e > 10) && (i.dolby = !0)
                    }
                } catch (t) {}
            }(),
            function() {
                var t = document.createElement("video");
                try {
                    !!t.canPlayType && (t.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, "") && (i.oggVideo = !0), t.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, "") && (i.h264Video = !0, i.mp4Video = !0), t.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, "") && (i.webmVideo = !0), t.canPlayType('video/webm; codecs="vp9"').replace(/^no$/, "") && (i.vp9Video = !0), t.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(/^no$/, "") && (i.hlsVideo = !0))
                } catch (t) {}
            }(),
            function() {
                var t, e = document.createElement("p"),
                    s = {
                        webkitTransform: "-webkit-transform",
                        OTransform: "-o-transform",
                        msTransform: "-ms-transform",
                        MozTransform: "-moz-transform",
                        transform: "transform"
                    };
                document.body.insertBefore(e, null);
                for (var o in s) void 0 !== e.style[o] && (e.style[o] = "translate3d(1px,1px,1px)", t = window.getComputedStyle(e).getPropertyValue(s[o]));
                document.body.removeChild(e), i.css3D = void 0 !== t && t.length > 0 && "none" !== t
            }(), i.pixelRatio = window.devicePixelRatio || 1, i.iPhone = -1 !== navigator.userAgent.toLowerCase().indexOf("iphone"), i.iPhone4 = 2 === i.pixelRatio && i.iPhone, i.iPad = -1 !== navigator.userAgent.toLowerCase().indexOf("ipad"), "undefined" != typeof Int8Array ? i.typedArray = !0 : i.typedArray = !1, "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array && "undefined" != typeof Uint32Array && (i.littleEndian = t(), i.LITTLE_ENDIAN = i.littleEndian), i.support32bit = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8ClampedArray && "undefined" != typeof Int32Array && null !== i.littleEndian && e(), navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate, navigator.vibrate && (i.vibration = !0),
                function() {
                    i.canvas = !!window.CanvasRenderingContext2D || i.cocoonJS;
                    try {
                        i.localStorage = !!localStorage.getItem
                    } catch (t) {
                        i.localStorage = !1
                    }
                    i.file = !!(window.File && window.FileReader && window.FileList && window.Blob), i.fileSystem = !!window.requestFileSystem, i.webGL = function() {
                        try {
                            var t = document.createElement("canvas");
                            return t.screencanvas = !1, !!window.WebGLRenderingContext && (t.getContext("webgl") || t.getContext("experimental-webgl"))
                        } catch (t) {
                            return !1
                        }
                    }(), i.webGL = !!i.webGL, i.worker = !!window.Worker, i.pointerLock = "pointerLockElement" in document || "mozPointerLockElement" in document || "webkitPointerLockElement" in document, i.quirksMode = "CSS1Compat" !== document.compatMode, navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia, window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL, i.getUserMedia = i.getUserMedia && !!navigator.getUserMedia && !!window.URL, i.firefox && i.firefoxVersion < 21 && (i.getUserMedia = !1), !i.iOS && (i.ie || i.firefox || i.chrome) && (i.canvasBitBltShift = !0), (i.safari || i.mobileSafari) && (i.canvasBitBltShift = !1)
                }(),
                function() {
                    for (var t = ["requestFullscreen", "requestFullScreen", "webkitRequestFullscreen", "webkitRequestFullScreen", "msRequestFullscreen", "msRequestFullScreen", "mozRequestFullScreen", "mozRequestFullscreen"], e = document.createElement("div"), s = 0; s < t.length; s++)
                        if (e[t[s]]) {
                            i.fullscreen = !0, i.requestFullscreen = t[s];
                            break
                        }
                    var o = ["cancelFullScreen", "exitFullscreen", "webkitCancelFullScreen", "webkitExitFullscreen", "msCancelFullScreen", "msExitFullscreen", "mozCancelFullScreen", "mozExitFullscreen"];
                    if (i.fullscreen)
                        for (s = 0; s < o.length; s++)
                            if (document[o[s]]) {
                                i.cancelFullscreen = o[s];
                                break
                            }
                    window.Element && Element.ALLOW_KEYBOARD_INPUT && (i.fullscreenKeyboard = !0)
                }(), ("ontouchstart" in document.documentElement || window.navigator.maxTouchPoints && window.navigator.maxTouchPoints >= 1) && (i.touch = !0), (window.navigator.msPointerEnabled || window.navigator.pointerEnabled) && (i.mspointer = !0), i.cocoonJS || ("onwheel" in window || i.ie && "WheelEvent" in window ? i.wheelEvent = "wheel" : "onmousewheel" in window ? i.wheelEvent = "mousewheel" : i.firefox && "MouseScrollEvent" in window && (i.wheelEvent = "DOMMouseScroll"))
        }, i.Device.canPlayAudio = function(t) {
            return !!("mp3" === t && this.mp3 || "ogg" === t && (this.ogg || this.opus) || "m4a" === t && this.m4a || "opus" === t && this.opus || "wav" === t && this.wav || "webm" === t && this.webm || "mp4" === t && this.dolby)
        }, i.Device.canPlayVideo = function(t) {
            return !!("webm" === t && (this.webmVideo || this.vp9Video) || "mp4" === t && (this.mp4Video || this.h264Video) || ("ogg" === t || "ogv" === t) && this.oggVideo || "mpeg" === t && this.hlsVideo)
        }, i.Device.isConsoleOpen = function() {
            return !(!window.console || !window.console.firebug) || !(!window.console || (console.profile(), console.profileEnd(), console.clear && console.clear(), !console.profiles)) && console.profiles.length > 0
        }, i.Device.isAndroidStockBrowser = function() {
            var t = window.navigator.userAgent.match(/Android.*AppleWebKit\/([\d.]+)/);
            return t && t[1] < 537
        }, i.Canvas = {
            create: function(t, e, i, s, o) {
                e = e || 256, i = i || 256;
                var n = o ? document.createElement("canvas") : PIXI.CanvasPool.create(t, e, i);
                return "string" == typeof s && "" !== s && (n.id = s), n.width = e, n.height = i, n.style.display = "block", n
            },
            setBackgroundColor: function(t, e) {
                return e = e || "rgb(0,0,0)", t.style.backgroundColor = e, t
            },
            setTouchAction: function(t, e) {
                return e = e || "none", t.style.msTouchAction = e, t.style["ms-touch-action"] = e, t.style["touch-action"] = e, t
            },
            setUserSelect: function(t, e) {
                return e = e || "none", t.style["-webkit-touch-callout"] = e, t.style["-webkit-user-select"] = e, t.style["-khtml-user-select"] = e, t.style["-moz-user-select"] = e, t.style["-ms-user-select"] = e, t.style["user-select"] = e, t.style["-webkit-tap-highlight-color"] = "rgba(0, 0, 0, 0)", t
            },
            addToDOM: function(t, e, i) {
                var s;
                return void 0 === i && (i = !0), e && ("string" == typeof e ? s = document.getElementById(e) : "object" == typeof e && 1 === e.nodeType && (s = e)), s || (s = document.body), i && s.style && (s.style.overflow = "hidden"), s.appendChild(t), t
            },
            removeFromDOM: function(t) {
                t.parentNode && t.parentNode.removeChild(t)
            },
            setTransform: function(t, e, i, s, o, n, a) {
                return t.setTransform(s, n, a, o, e, i), t
            },
            setSmoothingEnabled: function(t, e) {
                var s = i.Canvas.getSmoothingPrefix(t);
                return s && (t[s] = e), t
            },
            getSmoothingPrefix: function(t) {
                var e = ["i", "webkitI", "msI", "mozI", "oI"];
                for (var i in e) {
                    var s = e[i] + "mageSmoothingEnabled";
                    if (s in t) return s
                }
                return null
            },
            getSmoothingEnabled: function(t) {
                var e = i.Canvas.getSmoothingPrefix(t);
                if (e) return t[e]
            },
            setImageRenderingCrisp: function(t) {
                for (var e = ["optimizeSpeed", "crisp-edges", "-moz-crisp-edges", "-webkit-optimize-contrast", "optimize-contrast", "pixelated"], i = 0; i < e.length; i++) t.style["image-rendering"] = e[i];
                return t.style.msInterpolationMode = "nearest-neighbor", t
            },
            setImageRenderingBicubic: function(t) {
                return t.style["image-rendering"] = "auto", t.style.msInterpolationMode = "bicubic", t
            }
        }, i.RequestAnimationFrame = function(t, e) {
            void 0 === e && (e = !1), this.game = t, this.isRunning = !1, this.forceSetTimeOut = e;
            for (var i = ["ms", "moz", "webkit", "o"], s = 0; s < i.length && !window.requestAnimationFrame; s++) window.requestAnimationFrame = window[i[s] + "RequestAnimationFrame"], window.cancelAnimationFrame = window[i[s] + "CancelAnimationFrame"];
            this._isSetTimeOut = !1, this._onLoop = null, this._timeOutID = null
        }, i.RequestAnimationFrame.prototype = {
            start: function() {
                this.isRunning = !0;
                var t = this;
                !window.requestAnimationFrame || this.forceSetTimeOut ? (this._isSetTimeOut = !0, this._onLoop = function() {
                    return t.updateSetTimeout()
                }, this._timeOutID = window.setTimeout(this._onLoop, 0)) : (this._isSetTimeOut = !1, this._onLoop = function(e) {
                    return t.updateRAF(e)
                }, this._timeOutID = window.requestAnimationFrame(this._onLoop))
            },
            updateRAF: function(t) {
                this.isRunning && (this.game.update(Math.floor(t)), this._timeOutID = window.requestAnimationFrame(this._onLoop))
            },
            updateSetTimeout: function() {
                this.isRunning && (this.game.update(Date.now()), this._timeOutID = window.setTimeout(this._onLoop, this.game.time.timeToCall))
            },
            stop: function() {
                this._isSetTimeOut ? clearTimeout(this._timeOutID) : window.cancelAnimationFrame(this._timeOutID), this.isRunning = !1
            },
            isSetTimeOut: function() {
                return this._isSetTimeOut
            },
            isRAF: function() {
                return !1 === this._isSetTimeOut
            }
        }, i.RequestAnimationFrame.prototype.constructor = i.RequestAnimationFrame, i.Math = {
            PI2: 2 * Math.PI,
            between: function(t, e) {
                return Math.floor(Math.random() * (e - t + 1) + t)
            },
            fuzzyEqual: function(t, e, i) {
                return void 0 === i && (i = 1e-4), Math.abs(t - e) < i
            },
            fuzzyLessThan: function(t, e, i) {
                return void 0 === i && (i = 1e-4), t < e + i
            },
            fuzzyGreaterThan: function(t, e, i) {
                return void 0 === i && (i = 1e-4), t > e - i
            },
            fuzzyCeil: function(t, e) {
                return void 0 === e && (e = 1e-4), Math.ceil(t - e)
            },
            fuzzyFloor: function(t, e) {
                return void 0 === e && (e = 1e-4), Math.floor(t + e)
            },
            average: function() {
                for (var t = 0, e = arguments.length, i = 0; i < e; i++) t += +arguments[i];
                return t / e
            },
            shear: function(t) {
                return t % 1
            },
            snapTo: function(t, e, i) {
                return void 0 === i && (i = 0), 0 === e ? t : (t -= i, t = e * Math.round(t / e), i + t)
            },
            snapToFloor: function(t, e, i) {
                return void 0 === i && (i = 0), 0 === e ? t : (t -= i, t = e * Math.floor(t / e), i + t)
            },
            snapToCeil: function(t, e, i) {
                return void 0 === i && (i = 0), 0 === e ? t : (t -= i, t = e * Math.ceil(t / e), i + t)
            },
            roundTo: function(t, e, i) {
                void 0 === e && (e = 0), void 0 === i && (i = 10);
                var s = Math.pow(i, -e);
                return Math.round(t * s) / s
            },
            floorTo: function(t, e, i) {
                void 0 === e && (e = 0), void 0 === i && (i = 10);
                var s = Math.pow(i, -e);
                return Math.floor(t * s) / s
            },
            ceilTo: function(t, e, i) {
                void 0 === e && (e = 0), void 0 === i && (i = 10);
                var s = Math.pow(i, -e);
                return Math.ceil(t * s) / s
            },
            rotateToAngle: function(t, e, s) {
                return void 0 === s && (s = .05), t === e ? t : (Math.abs(e - t) <= s || Math.abs(e - t) >= i.Math.PI2 - s ? t = e : (Math.abs(e - t) > Math.PI && (e < t ? e += i.Math.PI2 : e -= i.Math.PI2), e > t ? t += s : e < t && (t -= s)), t)
            },
            getShortestAngle: function(t, e) {
                var i = e - t;
                return 0 === i ? 0 : i - 360 * Math.floor((i - -180) / 360)
            },
            angleBetween: function(t, e, i, s) {
                return Math.atan2(s - e, i - t)
            },
            angleBetweenY: function(t, e, i, s) {
                return Math.atan2(i - t, s - e)
            },
            angleBetweenPoints: function(t, e) {
                return Math.atan2(e.y - t.y, e.x - t.x)
            },
            angleBetweenPointsY: function(t, e) {
                return Math.atan2(e.x - t.x, e.y - t.y)
            },
            reverseAngle: function(t) {
                return this.normalizeAngle(t + Math.PI, !0)
            },
            normalizeAngle: function(t) {
                return (t %= 2 * Math.PI) >= 0 ? t : t + 2 * Math.PI
            },
            maxAdd: function(t, e, i) {
                return Math.min(t + e, i)
            },
            minSub: function(t, e, i) {
                return Math.max(t - e, i)
            },
            wrap: function(t, e, i) {
                var s = i - e;
                if (s <= 0) return 0;
                var o = (t - e) % s;
                return o < 0 && (o += s), o + e
            },
            wrapValue: function(t, e, i) {
                return t = Math.abs(t), e = Math.abs(e), i = Math.abs(i), (t + e) % i
            },
            isOdd: function(t) {
                return !!(1 & t)
            },
            isEven: function(t) {
                return !(1 & t)
            },
            min: function() {
                if (1 === arguments.length && "object" == typeof arguments[0]) t = arguments[0];
                else var t = arguments;
                for (var e = 1, i = 0, s = t.length; e < s; e++) t[e] < t[i] && (i = e);
                return t[i]
            },
            max: function() {
                if (1 === arguments.length && "object" == typeof arguments[0]) t = arguments[0];
                else var t = arguments;
                for (var e = 1, i = 0, s = t.length; e < s; e++) t[e] > t[i] && (i = e);
                return t[i]
            },
            minProperty: function(t) {
                if (2 === arguments.length && "object" == typeof arguments[1]) e = arguments[1];
                else var e = arguments.slice(1);
                for (var i = 1, s = 0, o = e.length; i < o; i++) e[i][t] < e[s][t] && (s = i);
                return e[s][t]
            },
            maxProperty: function(t) {
                if (2 === arguments.length && "object" == typeof arguments[1]) e = arguments[1];
                else var e = arguments.slice(1);
                for (var i = 1, s = 0, o = e.length; i < o; i++) e[i][t] > e[s][t] && (s = i);
                return e[s][t]
            },
            wrapAngle: function(t, e) {
                return e ? this.wrap(t, -Math.PI, Math.PI) : this.wrap(t, -180, 180)
            },
            linearInterpolation: function(t, e) {
                var i = t.length - 1,
                    s = i * e,
                    o = Math.floor(s);
                return e < 0 ? this.linear(t[0], t[1], s) : e > 1 ? this.linear(t[i], t[i - 1], i - s) : this.linear(t[o], t[o + 1 > i ? i : o + 1], s - o)
            },
            bezierInterpolation: function(t, e) {
                for (var i = 0, s = t.length - 1, o = 0; o <= s; o++) i += Math.pow(1 - e, s - o) * Math.pow(e, o) * t[o] * this.bernstein(s, o);
                return i
            },
            catmullRomInterpolation: function(t, e) {
                var i = t.length - 1,
                    s = i * e,
                    o = Math.floor(s);
                return t[0] === t[i] ? (e < 0 && (o = Math.floor(s = i * (1 + e))), this.catmullRom(t[(o - 1 + i) % i], t[o], t[(o + 1) % i], t[(o + 2) % i], s - o)) : e < 0 ? t[0] - (this.catmullRom(t[0], t[0], t[1], t[1], -s) - t[0]) : e > 1 ? t[i] - (this.catmullRom(t[i], t[i], t[i - 1], t[i - 1], s - i) - t[i]) : this.catmullRom(t[o ? o - 1 : 0], t[o], t[i < o + 1 ? i : o + 1], t[i < o + 2 ? i : o + 2], s - o)
            },
            linear: function(t, e, i) {
                return (e - t) * i + t
            },
            bernstein: function(t, e) {
                return this.factorial(t) / this.factorial(e) / this.factorial(t - e)
            },
            factorial: function(t) {
                if (0 === t) return 1;
                for (var e = t; --t;) e *= t;
                return e
            },
            catmullRom: function(t, e, i, s, o) {
                var n = .5 * (i - t),
                    a = .5 * (s - e),
                    r = o * o;
                return (2 * e - 2 * i + n + a) * (o * r) + (-3 * e + 3 * i - 2 * n - a) * r + n * o + e
            },
            difference: function(t, e) {
                return Math.abs(t - e)
            },
            roundAwayFromZero: function(t) {
                return t > 0 ? Math.ceil(t) : Math.floor(t)
            },
            sinCosGenerator: function(t, e, i, s) {
                void 0 === e && (e = 1), void 0 === i && (i = 1), void 0 === s && (s = 1);
                for (var o = e, n = i, a = s * Math.PI / t, r = [], h = [], l = 0; l < t; l++) n -= o * a, o += n * a, r[l] = n, h[l] = o;
                return {
                    sin: h,
                    cos: r,
                    length: t
                }
            },
            distance: function(t, e, i, s) {
                var o = t - i,
                    n = e - s;
                return Math.sqrt(o * o + n * n)
            },
            distanceSq: function(t, e, i, s) {
                var o = t - i,
                    n = e - s;
                return o * o + n * n
            },
            distancePow: function(t, e, i, s, o) {
                return void 0 === o && (o = 2), Math.sqrt(Math.pow(i - t, o) + Math.pow(s - e, o))
            },
            clamp: function(t, e, i) {
                return t < e ? e : i < t ? i : t
            },
            clampBottom: function(t, e) {
                return t < e ? e : t
            },
            within: function(t, e, i) {
                return Math.abs(t - e) <= i
            },
            mapLinear: function(t, e, i, s, o) {
                return s + (t - e) * (o - s) / (i - e)
            },
            smoothstep: function(t, e, i) {
                return (t = Math.max(0, Math.min(1, (t - e) / (i - e)))) * t * (3 - 2 * t)
            },
            smootherstep: function(t, e, i) {
                return (t = Math.max(0, Math.min(1, (t - e) / (i - e)))) * t * t * (t * (6 * t - 15) + 10)
            },
            sign: function(t) {
                return t < 0 ? -1 : t > 0 ? 1 : 0
            },
            percent: function(t, e, i) {
                return void 0 === i && (i = 0), t > e || i > e ? 1 : t < i || i > t ? 0 : (t - i) / e
            }
        };
        var c = Math.PI / 180,
            p = 180 / Math.PI;
        return i.Math.degToRad = function(t) {
            return t * c
        }, i.Math.radToDeg = function(t) {
            return t * p
        }, i.RandomDataGenerator = function(t) {
            void 0 === t && (t = []), this.c = 1, this.s0 = 0, this.s1 = 0, this.s2 = 0, "string" == typeof t ? this.state(t) : this.sow(t)
        }, i.RandomDataGenerator.prototype = {
            rnd: function() {
                var t = 2091639 * this.s0 + 2.3283064365386963e-10 * this.c;
                return this.c = 0 | t, this.s0 = this.s1, this.s1 = this.s2, this.s2 = t - this.c, this.s2
            },
            sow: function(t) {
                if (this.s0 = this.hash(" "), this.s1 = this.hash(this.s0), this.s2 = this.hash(this.s1), this.c = 1, t)
                    for (var e = 0; e < t.length && null != t[e]; e++) {
                        var i = t[e];
                        this.s0 -= this.hash(i), this.s0 += ~~(this.s0 < 0), this.s1 -= this.hash(i), this.s1 += ~~(this.s1 < 0), this.s2 -= this.hash(i), this.s2 += ~~(this.s2 < 0)
                    }
            },
            hash: function(t) {
                var e, i, s;
                for (s = 4022871197, t = t.toString(), i = 0; i < t.length; i++) s += t.charCodeAt(i), e = .02519603282416938 * s, s = e >>> 0, e -= s, e *= s, s = e >>> 0, e -= s, s += 4294967296 * e;
                return 2.3283064365386963e-10 * (s >>> 0)
            },
            integer: function() {
                return 4294967296 * this.rnd.apply(this)
            },
            frac: function() {
                return this.rnd.apply(this) + 1.1102230246251565e-16 * (2097152 * this.rnd.apply(this) | 0)
            },
            real: function() {
                return this.integer() + this.frac()
            },
            integerInRange: function(t, e) {
                return Math.floor(this.realInRange(0, e - t + 1) + t)
            },
            between: function(t, e) {
                return this.integerInRange(t, e)
            },
            realInRange: function(t, e) {
                return this.frac() * (e - t) + t
            },
            normal: function() {
                return 1 - 2 * this.frac()
            },
            uuid: function() {
                var t = "",
                    e = "";
                for (e = t = ""; t++ < 36; e += ~t % 5 | 3 * t & 4 ? (15 ^ t ? 8 ^ this.frac() * (20 ^ t ? 16 : 4) : 4).toString(16) : "-");
                return e
            },
            pick: function(t) {
                return t[this.integerInRange(0, t.length - 1)]
            },
            sign: function() {
                return this.pick([-1, 1])
            },
            weightedPick: function(t) {
                return t[~~(Math.pow(this.frac(), 2) * (t.length - 1) + .5)]
            },
            timestamp: function(t, e) {
                return this.realInRange(t || 9466848e5, e || 1577862e6)
            },
            angle: function() {
                return this.integerInRange(-180, 180)
            },
            state: function(t) {
                return "string" == typeof t && t.match(/^!rnd/) && (t = t.split(","), this.c = parseFloat(t[1]), this.s0 = parseFloat(t[2]), this.s1 = parseFloat(t[3]), this.s2 = parseFloat(t[4])), ["!rnd", this.c, this.s0, this.s1, this.s2].join(",")
            }
        }, i.RandomDataGenerator.prototype.constructor = i.RandomDataGenerator, i.QuadTree = function(t, e, i, s, o, n, a) {
            this.maxObjects = 10, this.maxLevels = 4, this.level = 0, this.bounds = {}, this.objects = [], this.nodes = [], this._empty = [], this.reset(t, e, i, s, o, n, a)
        }, i.QuadTree.prototype = {
            reset: function(t, e, i, s, o, n, a) {
                this.maxObjects = o || 10, this.maxLevels = n || 4, this.level = a || 0, this.bounds = {
                    x: Math.round(t),
                    y: Math.round(e),
                    width: i,
                    height: s,
                    subWidth: Math.floor(i / 2),
                    subHeight: Math.floor(s / 2),
                    right: Math.round(t) + Math.floor(i / 2),
                    bottom: Math.round(e) + Math.floor(s / 2)
                }, this.objects.length = 0, this.nodes.length = 0
            },
            populate: function(t) {
                t.forEach(this.populateHandler, this, !0)
            },
            populateHandler: function(t) {
                t.body && t.exists && this.insert(t.body)
            },
            split: function() {
                this.nodes[0] = new i.QuadTree(this.bounds.right, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[1] = new i.QuadTree(this.bounds.x, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[2] = new i.QuadTree(this.bounds.x, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[3] = new i.QuadTree(this.bounds.right, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1)
            },
            insert: function(t) {
                var e, i = 0;
                if (null == this.nodes[0] || -1 === (e = this.getIndex(t))) {
                    if (this.objects.push(t), this.objects.length > this.maxObjects && this.level < this.maxLevels)
                        for (null == this.nodes[0] && this.split(); i < this.objects.length;) - 1 !== (e = this.getIndex(this.objects[i])) ? this.nodes[e].insert(this.objects.splice(i, 1)[0]) : i++
                } else this.nodes[e].insert(t)
            },
            getIndex: function(t) {
                var e = -1;
                return t.x < this.bounds.right && t.right < this.bounds.right ? t.y < this.bounds.bottom && t.bottom < this.bounds.bottom ? e = 1 : t.y > this.bounds.bottom && (e = 2) : t.x > this.bounds.right && (t.y < this.bounds.bottom && t.bottom < this.bounds.bottom ? e = 0 : t.y > this.bounds.bottom && (e = 3)), e
            },
            retrieve: function(t) {
                if (t instanceof i.Rectangle) var e = this.objects,
                    s = this.getIndex(t);
                else {
                    if (!t.body) return this._empty;
                    var e = this.objects,
                        s = this.getIndex(t.body)
                }
                return this.nodes[0] && (-1 !== s ? e = e.concat(this.nodes[s].retrieve(t)) : (e = e.concat(this.nodes[0].retrieve(t)), e = e.concat(this.nodes[1].retrieve(t)), e = e.concat(this.nodes[2].retrieve(t)), e = e.concat(this.nodes[3].retrieve(t)))), e
            },
            clear: function() {
                this.objects.length = 0;
                for (var t = this.nodes.length; t--;) this.nodes[t].clear(), this.nodes.splice(t, 1);
                this.nodes.length = 0
            }
        }, i.QuadTree.prototype.constructor = i.QuadTree, i.Net = function(t) {
            this.game = t
        }, i.Net.prototype = {
            getHostName: function() {
                return window.location && window.location.hostname ? window.location.hostname : null
            },
            checkDomainName: function(t) {
                return -1 !== window.location.hostname.indexOf(t)
            },
            updateQueryString: function(t, e, i, s) {
                void 0 === i && (i = !1), void 0 !== s && "" !== s || (s = window.location.href);
                var o = "",
                    n = new RegExp("([?|&])" + t + "=.*?(&|#|$)(.*)", "gi");
                if (n.test(s)) o = void 0 !== e && null !== e ? s.replace(n, "$1" + t + "=" + e + "$2$3") : s.replace(n, "$1$3").replace(/(&|\?)$/, "");
                else if (void 0 !== e && null !== e) {
                    var a = -1 !== s.indexOf("?") ? "&" : "?",
                        r = s.split("#");
                    s = r[0] + a + t + "=" + e, r[1] && (s += "#" + r[1]), o = s
                } else o = s;
                return i ? void(window.location.href = o) : o
            },
            getQueryString: function(t) {
                void 0 === t && (t = "");
                var e = {},
                    i = location.search.substring(1).split("&");
                for (var s in i) {
                    var o = i[s].split("=");
                    if (o.length > 1) {
                        if (t && t === this.decodeURI(o[0])) return this.decodeURI(o[1]);
                        e[this.decodeURI(o[0])] = this.decodeURI(o[1])
                    }
                }
                return e
            },
            decodeURI: function(t) {
                return decodeURIComponent(t.replace(/\+/g, " "))
            }
        }, i.Net.prototype.constructor = i.Net, i.TweenManager = function(t) {
            this.game = t, this.frameBased = !1, this._tweens = [], this._add = [], this.easeMap = {
                Power0: i.Easing.Power0,
                Power1: i.Easing.Power1,
                Power2: i.Easing.Power2,
                Power3: i.Easing.Power3,
                Power4: i.Easing.Power4,
                Linear: i.Easing.Linear.None,
                Quad: i.Easing.Quadratic.Out,
                Cubic: i.Easing.Cubic.Out,
                Quart: i.Easing.Quartic.Out,
                Quint: i.Easing.Quintic.Out,
                Sine: i.Easing.Sinusoidal.Out,
                Expo: i.Easing.Exponential.Out,
                Circ: i.Easing.Circular.Out,
                Elastic: i.Easing.Elastic.Out,
                Back: i.Easing.Back.Out,
                Bounce: i.Easing.Bounce.Out,
                "Quad.easeIn": i.Easing.Quadratic.In,
                "Cubic.easeIn": i.Easing.Cubic.In,
                "Quart.easeIn": i.Easing.Quartic.In,
                "Quint.easeIn": i.Easing.Quintic.In,
                "Sine.easeIn": i.Easing.Sinusoidal.In,
                "Expo.easeIn": i.Easing.Exponential.In,
                "Circ.easeIn": i.Easing.Circular.In,
                "Elastic.easeIn": i.Easing.Elastic.In,
                "Back.easeIn": i.Easing.Back.In,
                "Bounce.easeIn": i.Easing.Bounce.In,
                "Quad.easeOut": i.Easing.Quadratic.Out,
                "Cubic.easeOut": i.Easing.Cubic.Out,
                "Quart.easeOut": i.Easing.Quartic.Out,
                "Quint.easeOut": i.Easing.Quintic.Out,
                "Sine.easeOut": i.Easing.Sinusoidal.Out,
                "Expo.easeOut": i.Easing.Exponential.Out,
                "Circ.easeOut": i.Easing.Circular.Out,
                "Elastic.easeOut": i.Easing.Elastic.Out,
                "Back.easeOut": i.Easing.Back.Out,
                "Bounce.easeOut": i.Easing.Bounce.Out,
                "Quad.easeInOut": i.Easing.Quadratic.InOut,
                "Cubic.easeInOut": i.Easing.Cubic.InOut,
                "Quart.easeInOut": i.Easing.Quartic.InOut,
                "Quint.easeInOut": i.Easing.Quintic.InOut,
                "Sine.easeInOut": i.Easing.Sinusoidal.InOut,
                "Expo.easeInOut": i.Easing.Exponential.InOut,
                "Circ.easeInOut": i.Easing.Circular.InOut,
                "Elastic.easeInOut": i.Easing.Elastic.InOut,
                "Back.easeInOut": i.Easing.Back.InOut,
                "Bounce.easeInOut": i.Easing.Bounce.InOut
            }, this.game.onPause.add(this._pauseAll, this), this.game.onResume.add(this._resumeAll, this)
        }, i.TweenManager.prototype = {
            getAll: function() {
                return this._tweens
            },
            removeAll: function() {
                for (var t = 0; t < this._tweens.length; t++) this._tweens[t].pendingDelete = !0;
                this._add = []
            },
            removeFrom: function(t, e) {
                void 0 === e && (e = !0);
                if (Array.isArray(t))
                    for (s = 0, o = t.length; s < o; s++) this.removeFrom(t[s]);
                else if (t.type === i.GROUP && e)
                    for (var s = 0, o = t.children.length; s < o; s++) this.removeFrom(t.children[s]);
                else {
                    for (s = 0, o = this._tweens.length; s < o; s++) t === this._tweens[s].target && this.remove(this._tweens[s]);
                    for (s = 0, o = this._add.length; s < o; s++) t === this._add[s].target && this.remove(this._add[s])
                }
            },
            add: function(t) {
                t._manager = this, this._add.push(t)
            },
            create: function(t) {
                return new i.Tween(t, this.game, this)
            },
            remove: function(t) {
                var e = this._tweens.indexOf(t); - 1 !== e ? this._tweens[e].pendingDelete = !0 : -1 !== (e = this._add.indexOf(t)) && (this._add[e].pendingDelete = !0)
            },
            update: function() {
                var t = this._add.length,
                    e = this._tweens.length;
                if (0 === e && 0 === t) return !1;
                for (var i = 0; i < e;) this._tweens[i].update(this.game.time.time) ? i++ : (this._tweens.splice(i, 1), e--);
                return t > 0 && (this._tweens = this._tweens.concat(this._add), this._add.length = 0), !0
            },
            isTweening: function(t) {
                return this._tweens.some(function(e) {
                    return e.target === t
                })
            },
            _pauseAll: function() {
                for (var t = this._tweens.length - 1; t >= 0; t--) this._tweens[t]._pause()
            },
            _resumeAll: function() {
                for (var t = this._tweens.length - 1; t >= 0; t--) this._tweens[t]._resume()
            },
            pauseAll: function() {
                for (var t = this._tweens.length - 1; t >= 0; t--) this._tweens[t].pause()
            },
            resumeAll: function() {
                for (var t = this._tweens.length - 1; t >= 0; t--) this._tweens[t].resume(!0)
            }
        }, i.TweenManager.prototype.constructor = i.TweenManager, i.Tween = function(t, e, s) {
            this.game = e, this.target = t, this.manager = s, this.timeline = [], this.reverse = !1, this.timeScale = 1, this.repeatCounter = 0, this.pendingDelete = !1, this.onStart = new i.Signal, this.onLoop = new i.Signal, this.onRepeat = new i.Signal, this.onChildComplete = new i.Signal, this.onComplete = new i.Signal, this.isRunning = !1, this.current = 0, this.properties = {}, this.chainedTween = null, this.isPaused = !1, this.frameBased = s.frameBased, this._onUpdateCallback = null, this._onUpdateCallbackContext = null, this._pausedTime = 0, this._codePaused = !1, this._hasStarted = !1
        }, i.Tween.prototype = {
            to: function(t, e, s, o, n, a, r) {
                return (void 0 === e || e <= 0) && (e = 1e3), void 0 !== s && null !== s || (s = i.Easing.Default), void 0 === o && (o = !1), void 0 === n && (n = 0), void 0 === a && (a = 0), void 0 === r && (r = !1), "string" == typeof s && this.manager.easeMap[s] && (s = this.manager.easeMap[s]), this.isRunning ? (console.warn("Phaser.Tween.to cannot be called after Tween.start"), this) : (this.timeline.push(new i.TweenData(this).to(t, e, s, n, a, r)), o && this.start(), this)
            },
            from: function(t, e, s, o, n, a, r) {
                return void 0 === e && (e = 1e3), void 0 !== s && null !== s || (s = i.Easing.Default), void 0 === o && (o = !1), void 0 === n && (n = 0), void 0 === a && (a = 0), void 0 === r && (r = !1), "string" == typeof s && this.manager.easeMap[s] && (s = this.manager.easeMap[s]), this.isRunning ? (console.warn("Phaser.Tween.from cannot be called after Tween.start"), this) : (this.timeline.push(new i.TweenData(this).from(t, e, s, n, a, r)), o && this.start(), this)
            },
            start: function(t) {
                if (void 0 === t && (t = 0), null === this.game || null === this.target || 0 === this.timeline.length || this.isRunning) return this;
                for (i = 0; i < this.timeline.length; i++)
                    for (var e in this.timeline[i].vEnd) this.properties[e] = this.target[e] || 0, Array.isArray(this.properties[e]) || (this.properties[e] *= 1);
                for (var i = 0; i < this.timeline.length; i++) this.timeline[i].loadValues();
                return this.manager.add(this), this.isRunning = !0, (t < 0 || t > this.timeline.length - 1) && (t = 0), this.current = t, this.timeline[this.current].start(), this
            },
            stop: function(t) {
                return void 0 === t && (t = !1), this.isRunning = !1, this._onUpdateCallback = null, this._onUpdateCallbackContext = null, t && (this.onComplete.dispatch(this.target, this), this._hasStarted = !1, this.chainedTween && this.chainedTween.start()), this.manager.remove(this), this
            },
            updateTweenData: function(t, e, i) {
                if (0 === this.timeline.length) return this;
                if (void 0 === i && (i = 0), -1 === i)
                    for (var s = 0; s < this.timeline.length; s++) this.timeline[s][t] = e;
                else this.timeline[i][t] = e;
                return this
            },
            delay: function(t, e) {
                return this.updateTweenData("delay", t, e)
            },
            repeat: function(t, e, i) {
                return void 0 === e && (e = 0), this.updateTweenData("repeatCounter", t, i), this.updateTweenData("repeatDelay", e, i)
            },
            repeatDelay: function(t, e) {
                return this.updateTweenData("repeatDelay", t, e)
            },
            yoyo: function(t, e, i) {
                return void 0 === e && (e = 0), this.updateTweenData("yoyo", t, i), this.updateTweenData("yoyoDelay", e, i)
            },
            yoyoDelay: function(t, e) {
                return this.updateTweenData("yoyoDelay", t, e)
            },
            easing: function(t, e) {
                return "string" == typeof t && this.manager.easeMap[t] && (t = this.manager.easeMap[t]), this.updateTweenData("easingFunction", t, e)
            },
            interpolation: function(t, e, s) {
                return void 0 === e && (e = i.Math), this.updateTweenData("interpolationFunction", t, s), this.updateTweenData("interpolationContext", e, s)
            },
            repeatAll: function(t) {
                return void 0 === t && (t = 0), this.repeatCounter = t, this
            },
            chain: function() {
                for (var t = arguments.length; t--;) t > 0 ? arguments[t - 1].chainedTween = arguments[t] : this.chainedTween = arguments[t];
                return this
            },
            loop: function(t) {
                return void 0 === t && (t = !0), this.repeatCounter = t ? -1 : 0, this
            },
            onUpdateCallback: function(t, e) {
                return this._onUpdateCallback = t, this._onUpdateCallbackContext = e, this
            },
            pause: function() {
                this.isPaused = !0, this._codePaused = !0, this._pausedTime = this.game.time.time
            },
            _pause: function() {
                this._codePaused || (this.isPaused = !0, this._pausedTime = this.game.time.time)
            },
            resume: function() {
                if (this.isPaused) {
                    this.isPaused = !1, this._codePaused = !1;
                    for (var t = 0; t < this.timeline.length; t++) this.timeline[t].isRunning || (this.timeline[t].startTime += this.game.time.time - this._pausedTime)
                }
            },
            _resume: function() {
                this._codePaused || this.resume()
            },
            update: function(t) {
                if (this.pendingDelete || !this.target) return !1;
                if (this.isPaused) return !0;
                var e = this.timeline[this.current].update(t);
                if (e === i.TweenData.PENDING) return !0;
                if (e === i.TweenData.RUNNING) return this._hasStarted || (this.onStart.dispatch(this.target, this), this._hasStarted = !0), null !== this._onUpdateCallback && this._onUpdateCallback.call(this._onUpdateCallbackContext, this, this.timeline[this.current].value, this.timeline[this.current]), this.isRunning;
                if (e === i.TweenData.LOOPED) return -1 === this.timeline[this.current].repeatCounter ? this.onLoop.dispatch(this.target, this) : this.onRepeat.dispatch(this.target, this), !0;
                if (e === i.TweenData.COMPLETE) {
                    var s = !1;
                    return this.reverse ? --this.current < 0 && (this.current = this.timeline.length - 1, s = !0) : ++this.current === this.timeline.length && (this.current = 0, s = !0), s ? -1 === this.repeatCounter ? (this.timeline[this.current].start(), this.onLoop.dispatch(this.target, this), !0) : this.repeatCounter > 0 ? (this.repeatCounter--, this.timeline[this.current].start(), this.onRepeat.dispatch(this.target, this), !0) : (this.isRunning = !1, this.onComplete.dispatch(this.target, this), this._hasStarted = !1, this.chainedTween && this.chainedTween.start(), !1) : (this.onChildComplete.dispatch(this.target, this), this.timeline[this.current].start(), !0)
                }
            },
            generateData: function(t, e) {
                if (null === this.game || null === this.target) return null;
                void 0 === t && (t = 60), void 0 === e && (e = []);
                for (s = 0; s < this.timeline.length; s++)
                    for (var i in this.timeline[s].vEnd) this.properties[i] = this.target[i] || 0, Array.isArray(this.properties[i]) || (this.properties[i] *= 1);
                for (s = 0; s < this.timeline.length; s++) this.timeline[s].loadValues();
                for (var s = 0; s < this.timeline.length; s++) e = e.concat(this.timeline[s].generateData(t));
                return e
            }
        }, Object.defineProperty(i.Tween.prototype, "totalDuration", {
            get: function() {
                for (var t = 0, e = 0; e < this.timeline.length; e++) t += this.timeline[e].duration;
                return t
            }
        }), i.Tween.prototype.constructor = i.Tween, i.TweenData = function(t) {
            this.parent = t, this.game = t.game, this.vStart = {}, this.vStartCache = {}, this.vEnd = {}, this.vEndCache = {}, this.duration = 1e3, this.percent = 0, this.value = 0, this.repeatCounter = 0, this.repeatDelay = 0, this.repeatTotal = 0, this.interpolate = !1, this.yoyo = !1, this.yoyoDelay = 0, this.inReverse = !1, this.delay = 0, this.dt = 0, this.startTime = null, this.easingFunction = i.Easing.Default, this.interpolationFunction = i.Math.linearInterpolation, this.interpolationContext = i.Math, this.isRunning = !1, this.isFrom = !1
        }, i.TweenData.PENDING = 0, i.TweenData.RUNNING = 1, i.TweenData.LOOPED = 2, i.TweenData.COMPLETE = 3, i.TweenData.prototype = {
            to: function(t, e, i, s, o, n) {
                return this.vEnd = t, this.duration = e, this.easingFunction = i, this.delay = s, this.repeatTotal = o, this.yoyo = n, this.isFrom = !1, this
            },
            from: function(t, e, i, s, o, n) {
                return this.vEnd = t, this.duration = e, this.easingFunction = i, this.delay = s, this.repeatTotal = o, this.yoyo = n, this.isFrom = !0, this
            },
            start: function() {
                if (this.startTime = this.game.time.time + this.delay, this.parent.reverse ? this.dt = this.duration : this.dt = 0, this.delay > 0 ? this.isRunning = !1 : this.isRunning = !0, this.isFrom)
                    for (var t in this.vStartCache) this.vStart[t] = this.vEndCache[t], this.vEnd[t] = this.vStartCache[t], this.parent.target[t] = this.vStart[t];
                return this.value = 0, this.yoyoCounter = 0, this.repeatCounter = this.repeatTotal, this
            },
            loadValues: function() {
                for (var t in this.parent.properties) {
                    if (this.vStart[t] = this.parent.properties[t], Array.isArray(this.vEnd[t])) {
                        if (0 === this.vEnd[t].length) continue;
                        0 === this.percent && (this.vEnd[t] = [this.vStart[t]].concat(this.vEnd[t]))
                    }
                    void 0 !== this.vEnd[t] ? ("string" == typeof this.vEnd[t] && (this.vEnd[t] = this.vStart[t] + parseFloat(this.vEnd[t], 10)), this.parent.properties[t] = this.vEnd[t]) : this.vEnd[t] = this.vStart[t], this.vStartCache[t] = this.vStart[t], this.vEndCache[t] = this.vEnd[t]
                }
                return this
            },
            update: function(t) {
                if (this.isRunning) {
                    if (t < this.startTime) return i.TweenData.RUNNING
                } else {
                    if (!(t >= this.startTime)) return i.TweenData.PENDING;
                    this.isRunning = !0
                }
                var e = this.parent.frameBased ? this.game.time.physicsElapsedMS : this.game.time.elapsedMS;
                this.parent.reverse ? (this.dt -= e * this.parent.timeScale, this.dt = Math.max(this.dt, 0)) : (this.dt += e * this.parent.timeScale, this.dt = Math.min(this.dt, this.duration)), this.percent = this.dt / this.duration, this.value = this.easingFunction(this.percent);
                for (var s in this.vEnd) {
                    var o = this.vStart[s],
                        n = this.vEnd[s];
                    Array.isArray(n) ? this.parent.target[s] = this.interpolationFunction.call(this.interpolationContext, n, this.value) : this.parent.target[s] = o + (n - o) * this.value
                }
                return !this.parent.reverse && 1 === this.percent || this.parent.reverse && 0 === this.percent ? this.repeat() : i.TweenData.RUNNING
            },
            generateData: function(t) {
                this.parent.reverse ? this.dt = this.duration : this.dt = 0;
                var e = [],
                    i = !1,
                    s = 1 / t * 1e3;
                do {
                    this.parent.reverse ? (this.dt -= s, this.dt = Math.max(this.dt, 0)) : (this.dt += s, this.dt = Math.min(this.dt, this.duration)), this.percent = this.dt / this.duration, this.value = this.easingFunction(this.percent);
                    var o = {};
                    for (var n in this.vEnd) {
                        var a = this.vStart[n],
                            r = this.vEnd[n];
                        Array.isArray(r) ? o[n] = this.interpolationFunction(r, this.value) : o[n] = a + (r - a) * this.value
                    }
                    e.push(o), (!this.parent.reverse && 1 === this.percent || this.parent.reverse && 0 === this.percent) && (i = !0)
                } while (!i);
                if (this.yoyo) {
                    var h = e.slice();
                    h.reverse(), e = e.concat(h)
                }
                return e
            },
            repeat: function() {
                if (this.yoyo) {
                    if (this.inReverse && 0 === this.repeatCounter) {
                        for (var t in this.vStartCache) this.vStart[t] = this.vStartCache[t], this.vEnd[t] = this.vEndCache[t];
                        return this.inReverse = !1, i.TweenData.COMPLETE
                    }
                    this.inReverse = !this.inReverse
                } else if (0 === this.repeatCounter) return i.TweenData.COMPLETE;
                if (this.inReverse)
                    for (var t in this.vStartCache) this.vStart[t] = this.vEndCache[t], this.vEnd[t] = this.vStartCache[t];
                else {
                    for (var t in this.vStartCache) this.vStart[t] = this.vStartCache[t], this.vEnd[t] = this.vEndCache[t];
                    this.repeatCounter > 0 && this.repeatCounter--
                }
                return this.startTime = this.game.time.time, this.yoyo && this.inReverse ? this.startTime += this.yoyoDelay : this.inReverse || (this.startTime += this.repeatDelay), this.parent.reverse ? this.dt = this.duration : this.dt = 0, i.TweenData.LOOPED
            }
        }, i.TweenData.prototype.constructor = i.TweenData, i.Easing = {
            Linear: {
                None: function(t) {
                    return t
                }
            },
            Quadratic: {
                In: function(t) {
                    return t * t
                },
                Out: function(t) {
                    return t * (2 - t)
                },
                InOut: function(t) {
                    return (t *= 2) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1)
                }
            },
            Cubic: {
                In: function(t) {
                    return t * t * t
                },
                Out: function(t) {
                    return --t * t * t + 1
                },
                InOut: function(t) {
                    return (t *= 2) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2)
                }
            },
            Quartic: {
                In: function(t) {
                    return t * t * t * t
                },
                Out: function(t) {
                    return 1 - --t * t * t * t
                },
                InOut: function(t) {
                    return (t *= 2) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2)
                }
            },
            Quintic: {
                In: function(t) {
                    return t * t * t * t * t
                },
                Out: function(t) {
                    return --t * t * t * t * t + 1
                },
                InOut: function(t) {
                    return (t *= 2) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2)
                }
            },
            Sinusoidal: {
                In: function(t) {
                    return 0 === t ? 0 : 1 === t ? 1 : 1 - Math.cos(t * Math.PI / 2)
                },
                Out: function(t) {
                    return 0 === t ? 0 : 1 === t ? 1 : Math.sin(t * Math.PI / 2)
                },
                InOut: function(t) {
                    return 0 === t ? 0 : 1 === t ? 1 : .5 * (1 - Math.cos(Math.PI * t))
                }
            },
            Exponential: {
                In: function(t) {
                    return 0 === t ? 0 : Math.pow(1024, t - 1)
                },
                Out: function(t) {
                    return 1 === t ? 1 : 1 - Math.pow(2, -10 * t)
                },
                InOut: function(t) {
                    return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? .5 * Math.pow(1024, t - 1) : .5 * (2 - Math.pow(2, -10 * (t - 1)))
                }
            },
            Circular: {
                In: function(t) {
                    return 1 - Math.sqrt(1 - t * t)
                },
                Out: function(t) {
                    return Math.sqrt(1 - --t * t)
                },
                InOut: function(t) {
                    return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
                }
            },
            Elastic: {
                In: function(t) {
                    var e, i = .1;
                    return 0 === t ? 0 : 1 === t ? 1 : (!i || i < 1 ? (i = 1, e = .1) : e = .4 * Math.asin(1 / i) / (2 * Math.PI), -i * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / .4))
                },
                Out: function(t) {
                    var e, i = .1;
                    return 0 === t ? 0 : 1 === t ? 1 : (!i || i < 1 ? (i = 1, e = .1) : e = .4 * Math.asin(1 / i) / (2 * Math.PI), i * Math.pow(2, -10 * t) * Math.sin((t - e) * (2 * Math.PI) / .4) + 1)
                },
                InOut: function(t) {
                    var e, i = .1;
                    return 0 === t ? 0 : 1 === t ? 1 : (!i || i < 1 ? (i = 1, e = .1) : e = .4 * Math.asin(1 / i) / (2 * Math.PI), (t *= 2) < 1 ? i * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / .4) * -.5 : i * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / .4) * .5 + 1)
                }
            },
            Back: {
                In: function(t) {
                    var e = 1.70158;
                    return t * t * ((e + 1) * t - e)
                },
                Out: function(t) {
                    var e = 1.70158;
                    return --t * t * ((e + 1) * t + e) + 1
                },
                InOut: function(t) {
                    var e = 2.5949095;
                    return (t *= 2) < 1 ? t * t * ((e + 1) * t - e) * .5 : .5 * ((t -= 2) * t * ((e + 1) * t + e) + 2)
                }
            },
            Bounce: {
                In: function(t) {
                    return 1 - i.Easing.Bounce.Out(1 - t)
                },
                Out: function(t) {
                    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
                },
                InOut: function(t) {
                    return t < .5 ? .5 * i.Easing.Bounce.In(2 * t) : .5 * i.Easing.Bounce.Out(2 * t - 1) + .5
                }
            }
        }, i.Easing.Default = i.Easing.Linear.None, i.Easing.Power0 = i.Easing.Linear.None, i.Easing.Power1 = i.Easing.Quadratic.Out, i.Easing.Power2 = i.Easing.Cubic.Out, i.Easing.Power3 = i.Easing.Quartic.Out, i.Easing.Power4 = i.Easing.Quintic.Out, i.Time = function(t) {
            this.game = t, this.time = 0, this.prevTime = 0, this.now = 0, this.elapsed = 0, this.elapsedMS = 0, this.physicsElapsed = 1 / 60, this.physicsElapsedMS = 1 / 60 * 1e3, this.desiredFpsMult = 1 / 60, this._desiredFps = 60, this.suggestedFps = this.desiredFps, this.slowMotion = 1, this.advancedTiming = !1, this.frames = 0, this.fps = 0, this.fpsMin = 1e3, this.fpsMax = 0, this.msMin = 1e3, this.msMax = 0, this.pauseDuration = 0, this.timeToCall = 0, this.timeExpected = 0, this.events = new i.Timer(this.game, !1), this._frameCount = 0, this._elapsedAccumulator = 0, this._started = 0, this._timeLastSecond = 0, this._pauseStarted = 0, this._justResumed = !1, this._timers = []
        }, i.Time.prototype = {
            boot: function() {
                this._started = Date.now(), this.time = Date.now(), this.events.start(), this.timeExpected = this.time
            },
            add: function(t) {
                return this._timers.push(t), t
            },
            create: function(t) {
                void 0 === t && (t = !0);
                var e = new i.Timer(this.game, t);
                return this._timers.push(e), e
            },
            removeAll: function() {
                for (var t = 0; t < this._timers.length; t++) this._timers[t].destroy();
                this._timers = [], this.events.removeAll()
            },
            refresh: function() {
                var t = this.time;
                this.time = Date.now(), this.elapsedMS = this.time - t
            },
            update: function(t) {
                var e = this.time;
                this.time = Date.now(), this.elapsedMS = this.time - e, this.prevTime = this.now, this.now = t, this.elapsed = this.now - this.prevTime, this.game.raf._isSetTimeOut && (this.timeToCall = Math.floor(Math.max(0, 1e3 / this._desiredFps - (this.timeExpected - t))), this.timeExpected = t + this.timeToCall), this.advancedTiming && this.updateAdvancedTiming(), this.game.paused || (this.events.update(this.time), this._timers.length && this.updateTimers())
            },
            updateTimers: function() {
                for (var t = 0, e = this._timers.length; t < e;) this._timers[t].update(this.time) ? t++ : (this._timers.splice(t, 1), e--)
            },
            updateAdvancedTiming: function() {
                this._frameCount++, this._elapsedAccumulator += this.elapsed, this._frameCount >= 2 * this._desiredFps && (this.suggestedFps = 5 * Math.floor(200 / (this._elapsedAccumulator / this._frameCount)), this._frameCount = 0, this._elapsedAccumulator = 0), this.msMin = Math.min(this.msMin, this.elapsed), this.msMax = Math.max(this.msMax, this.elapsed), this.frames++, this.now > this._timeLastSecond + 1e3 && (this.fps = Math.round(1e3 * this.frames / (this.now - this._timeLastSecond)), this.fpsMin = Math.min(this.fpsMin, this.fps), this.fpsMax = Math.max(this.fpsMax, this.fps), this._timeLastSecond = this.now, this.frames = 0)
            },
            gamePaused: function() {
                this._pauseStarted = Date.now(), this.events.pause();
                for (var t = this._timers.length; t--;) this._timers[t]._pause()
            },
            gameResumed: function() {
                this.time = Date.now(), this.pauseDuration = this.time - this._pauseStarted, this.events.resume();
                for (var t = this._timers.length; t--;) this._timers[t]._resume()
            },
            totalElapsedSeconds: function() {
                return .001 * (this.time - this._started)
            },
            elapsedSince: function(t) {
                return this.time - t
            },
            elapsedSecondsSince: function(t) {
                return .001 * (this.time - t)
            },
            reset: function() {
                this._started = this.time, this.removeAll()
            }
        }, Object.defineProperty(i.Time.prototype, "desiredFps", {
            get: function() {
                return this._desiredFps
            },
            set: function(t) {
                this._desiredFps = t, this.physicsElapsed = 1 / t, this.physicsElapsedMS = 1e3 * this.physicsElapsed, this.desiredFpsMult = 1 / t
            }
        }), i.Time.prototype.constructor = i.Time, i.Timer = function(t, e) {
            void 0 === e && (e = !0), this.game = t, this.running = !1, this.autoDestroy = e, this.expired = !1, this.elapsed = 0, this.events = [], this.onComplete = new i.Signal, this.nextTick = 0, this.timeCap = 1e3, this.paused = !1, this._codePaused = !1, this._started = 0, this._pauseStarted = 0, this._pauseTotal = 0, this._now = Date.now(), this._len = 0, this._marked = 0, this._i = 0, this._diff = 0, this._newTick = 0
        }, i.Timer.MINUTE = 6e4, i.Timer.SECOND = 1e3, i.Timer.HALF = 500, i.Timer.QUARTER = 250, i.Timer.prototype = {
            create: function(t, e, s, o, n, a) {
                var r = t = Math.round(t);
                r += 0 === this._now ? this.game.time.time : this._now;
                var h = new i.TimerEvent(this, t, r, s, e, o, n, a);
                return this.events.push(h), this.order(), this.expired = !1, h
            },
            add: function(t, e, i) {
                return this.create(t, !1, 0, e, i, Array.prototype.slice.call(arguments, 3))
            },
            repeat: function(t, e, i, s) {
                return this.create(t, !1, e, i, s, Array.prototype.slice.call(arguments, 4))
            },
            loop: function(t, e, i) {
                return this.create(t, !0, 0, e, i, Array.prototype.slice.call(arguments, 3))
            },
            start: function(t) {
                if (!this.running) {
                    this._started = this.game.time.time + (t || 0), this.running = !0;
                    for (var e = 0; e < this.events.length; e++) this.events[e].tick = this.events[e].delay + this._started
                }
            },
            stop: function(t) {
                this.running = !1, void 0 === t && (t = !0), t && (this.events.length = 0)
            },
            remove: function(t) {
                for (var e = 0; e < this.events.length; e++)
                    if (this.events[e] === t) return this.events[e].pendingDelete = !0, !0;
                return !1
            },
            order: function() {
                this.events.length > 0 && (this.events.sort(this.sortHandler), this.nextTick = this.events[0].tick)
            },
            sortHandler: function(t, e) {
                return t.tick < e.tick ? -1 : t.tick > e.tick ? 1 : 0
            },
            clearPendingEvents: function() {
                for (this._i = this.events.length; this._i--;) this.events[this._i].pendingDelete && this.events.splice(this._i, 1);
                this._len = this.events.length, this._i = 0
            },
            update: function(t) {
                if (this.paused) return !0;
                if (this.elapsed = t - this._now, this._now = t, this.elapsed > this.timeCap && this.adjustEvents(t - this.elapsed), this._marked = 0, this.clearPendingEvents(), this.running && this._now >= this.nextTick && this._len > 0) {
                    for (; this._i < this._len && this.running && this._now >= this.events[this._i].tick && !this.events[this._i].pendingDelete;) this._newTick = this._now + this.events[this._i].delay - (this._now - this.events[this._i].tick), this._newTick < 0 && (this._newTick = this._now + this.events[this._i].delay), !0 === this.events[this._i].loop ? (this.events[this._i].tick = this._newTick, this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args)) : this.events[this._i].repeatCount > 0 ? (this.events[this._i].repeatCount--, this.events[this._i].tick = this._newTick, this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args)) : (this._marked++, this.events[this._i].pendingDelete = !0, this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args)), this._i++;
                    this.events.length > this._marked ? this.order() : (this.expired = !0, this.onComplete.dispatch(this))
                }
                return !this.expired || !this.autoDestroy
            },
            pause: function() {
                this.running && (this._codePaused = !0, this.paused || (this._pauseStarted = this.game.time.time, this.paused = !0))
            },
            _pause: function() {
                !this.paused && this.running && (this._pauseStarted = this.game.time.time, this.paused = !0)
            },
            adjustEvents: function(t) {
                for (var e = 0; e < this.events.length; e++)
                    if (!this.events[e].pendingDelete) {
                        var i = this.events[e].tick - t;
                        i < 0 && (i = 0), this.events[e].tick = this._now + i
                    }
                var s = this.nextTick - t;
                this.nextTick = s < 0 ? this._now : this._now + s
            },
            resume: function() {
                if (this.paused) {
                    var t = this.game.time.time;
                    this._pauseTotal += t - this._now, this._now = t, this.adjustEvents(this._pauseStarted), this.paused = !1, this._codePaused = !1
                }
            },
            _resume: function() {
                this._codePaused || this.resume()
            },
            removeAll: function() {
                this.onComplete.removeAll(), this.events.length = 0, this._len = 0, this._i = 0
            },
            destroy: function() {
                this.onComplete.removeAll(), this.running = !1, this.events = [], this._len = 0, this._i = 0
            }
        }, Object.defineProperty(i.Timer.prototype, "next", {
            get: function() {
                return this.nextTick
            }
        }), Object.defineProperty(i.Timer.prototype, "duration", {
            get: function() {
                return this.running && this.nextTick > this._now ? this.nextTick - this._now : 0
            }
        }), Object.defineProperty(i.Timer.prototype, "length", {
            get: function() {
                return this.events.length
            }
        }), Object.defineProperty(i.Timer.prototype, "ms", {
            get: function() {
                return this.running ? this._now - this._started - this._pauseTotal : 0
            }
        }), Object.defineProperty(i.Timer.prototype, "seconds", {
            get: function() {
                return this.running ? .001 * this.ms : 0
            }
        }), i.Timer.prototype.constructor = i.Timer, i.TimerEvent = function(t, e, i, s, o, n, a, r) {
            this.timer = t, this.delay = e, this.tick = i, this.repeatCount = s - 1, this.loop = o, this.callback = n, this.callbackContext = a, this.args = r, this.pendingDelete = !1
        }, i.TimerEvent.prototype.constructor = i.TimerEvent, i.AnimationManager = function(t) {
            this.sprite = t, this.game = t.game, this.currentFrame = null, this.currentAnim = null, this.updateIfVisible = !0, this.isLoaded = !1, this._frameData = null, this._anims = {}, this._outputFrames = []
        }, i.AnimationManager.prototype = {
            loadFrameData: function(t, e) {
                if (void 0 === t) return !1;
                if (this.isLoaded)
                    for (var i in this._anims) this._anims[i].updateFrameData(t);
                return this._frameData = t, void 0 === e || null === e ? this.frame = 0 : "string" == typeof e ? this.frameName = e : this.frame = e, this.isLoaded = !0, !0
            },
            copyFrameData: function(t, e) {
                if (this._frameData = t.clone(), this.isLoaded)
                    for (var i in this._anims) this._anims[i].updateFrameData(this._frameData);
                return void 0 === e || null === e ? this.frame = 0 : "string" == typeof e ? this.frameName = e : this.frame = e, this.isLoaded = !0, !0
            },
            add: function(t, e, s, o, n) {
                return e = e || [], s = s || 60, void 0 === o && (o = !1), void 0 === n && (n = !(!e || "number" != typeof e[0])), this._outputFrames = [], this._frameData.getFrameIndexes(e, n, this._outputFrames), this._anims[t] = new i.Animation(this.game, this.sprite, t, this._frameData, this._outputFrames, s, o), this.currentAnim = this._anims[t], this.sprite.tilingTexture && (this.sprite.refreshTexture = !0), this._anims[t]
            },
            validateFrames: function(t, e) {
                void 0 === e && (e = !0);
                for (var i = 0; i < t.length; i++)
                    if (!0 === e) {
                        if (t[i] > this._frameData.total) return !1
                    } else if (!1 === this._frameData.checkFrameName(t[i])) return !1;
                return !0
            },
            play: function(t, e, i, s) {
                if (this._anims[t]) return this.currentAnim === this._anims[t] ? !1 === this.currentAnim.isPlaying ? (this.currentAnim.paused = !1, this.currentAnim.play(e, i, s)) : this.currentAnim : (this.currentAnim && this.currentAnim.isPlaying && this.currentAnim.stop(), this.currentAnim = this._anims[t], this.currentAnim.paused = !1, this.currentFrame = this.currentAnim.currentFrame, this.currentAnim.play(e, i, s))
            },
            stop: function(t, e) {
                void 0 === e && (e = !1), !this.currentAnim || "string" == typeof t && t !== this.currentAnim.name || this.currentAnim.stop(e)
            },
            update: function() {
                return !(this.updateIfVisible && !this.sprite.visible || !this.currentAnim || !this.currentAnim.update() || (this.currentFrame = this.currentAnim.currentFrame, 0))
            },
            next: function(t) {
                this.currentAnim && (this.currentAnim.next(t), this.currentFrame = this.currentAnim.currentFrame)
            },
            previous: function(t) {
                this.currentAnim && (this.currentAnim.previous(t), this.currentFrame = this.currentAnim.currentFrame)
            },
            getAnimation: function(t) {
                return "string" == typeof t && this._anims[t] ? this._anims[t] : null
            },
            refreshFrame: function() {},
            destroy: function() {
                t = null;
                for (var t in this._anims) this._anims.hasOwnProperty(t) && this._anims[t].destroy();
                this._anims = {}, this._outputFrames = [], this._frameData = null, this.currentAnim = null, this.currentFrame = null, this.sprite = null, this.game = null
            }
        }, i.AnimationManager.prototype.constructor = i.AnimationManager, Object.defineProperty(i.AnimationManager.prototype, "frameData", {
            get: function() {
                return this._frameData
            }
        }), Object.defineProperty(i.AnimationManager.prototype, "frameTotal", {
            get: function() {
                return this._frameData.total
            }
        }), Object.defineProperty(i.AnimationManager.prototype, "paused", {
            get: function() {
                return this.currentAnim.isPaused
            },
            set: function(t) {
                this.currentAnim.paused = t
            }
        }), Object.defineProperty(i.AnimationManager.prototype, "name", {
            get: function() {
                if (this.currentAnim) return this.currentAnim.name
            }
        }), Object.defineProperty(i.AnimationManager.prototype, "frame", {
            get: function() {
                if (this.currentFrame) return this.currentFrame.index
            },
            set: function(t) {
                "number" == typeof t && this._frameData && null !== this._frameData.getFrame(t) && (this.currentFrame = this._frameData.getFrame(t), this.currentFrame && this.sprite.setFrame(this.currentFrame))
            }
        }), Object.defineProperty(i.AnimationManager.prototype, "frameName", {
            get: function() {
                if (this.currentFrame) return this.currentFrame.name
            },
            set: function(t) {
                "string" == typeof t && this._frameData && null !== this._frameData.getFrameByName(t) ? (this.currentFrame = this._frameData.getFrameByName(t), this.currentFrame && (this._frameIndex = this.currentFrame.index, this.sprite.setFrame(this.currentFrame))) : console.warn("Cannot set frameName: " + t)
            }
        }), i.Animation = function(t, e, s, o, n, a, r) {
            void 0 === r && (r = !1), this.game = t, this._parent = e, this._frameData = o, this.name = s, this._frames = [], this._frames = this._frames.concat(n), this.delay = 1e3 / a, this.loop = r, this.loopCount = 0, this.killOnComplete = !1, this.isFinished = !1, this.isPlaying = !1, this.isPaused = !1, this._pauseStartTime = 0, this._frameIndex = 0, this._frameDiff = 0, this._frameSkip = 1, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.onStart = new i.Signal, this.onUpdate = null, this.onComplete = new i.Signal, this.onLoop = new i.Signal, this.isReversed = !1, this.game.onPause.add(this.onPause, this), this.game.onResume.add(this.onResume, this)
        }, i.Animation.prototype = {
            play: function(t, e, i) {
                return "number" == typeof t && (this.delay = 1e3 / t), "boolean" == typeof e && (this.loop = e), void 0 !== i && (this.killOnComplete = i), this.isPlaying = !0, this.isFinished = !1, this.paused = !1, this.loopCount = 0, this._timeLastFrame = this.game.time.time, this._timeNextFrame = this.game.time.time + this.delay, this._frameIndex = this.isReversed ? this._frames.length - 1 : 0, this.updateCurrentFrame(!1, !0), this._parent.events.onAnimationStart$dispatch(this._parent, this), this.onStart.dispatch(this._parent, this), this._parent.animations.currentAnim = this, this._parent.animations.currentFrame = this.currentFrame, this
            },
            restart: function() {
                this.isPlaying = !0, this.isFinished = !1, this.paused = !1, this.loopCount = 0, this._timeLastFrame = this.game.time.time, this._timeNextFrame = this.game.time.time + this.delay, this._frameIndex = 0, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this._parent.setFrame(this.currentFrame), this._parent.animations.currentAnim = this, this._parent.animations.currentFrame = this.currentFrame, this.onStart.dispatch(this._parent, this)
            },
            reverse: function() {
                return this.reversed = !this.reversed, this
            },
            reverseOnce: function() {
                return this.onComplete.addOnce(this.reverse, this), this.reverse()
            },
            setFrame: function(t, e) {
                var i;
                if (void 0 === e && (e = !1), "string" == typeof t)
                    for (s = 0; s < this._frames.length; s++) this._frameData.getFrame(this._frames[s]).name === t && (i = s);
                else if ("number" == typeof t)
                    if (e) i = t;
                    else
                        for (var s = 0; s < this._frames.length; s++) this._frames[s] === t && (i = s);
                i && (this._frameIndex = i - 1, this._timeNextFrame = this.game.time.time, this.update())
            },
            stop: function(t, e) {
                void 0 === t && (t = !1), void 0 === e && (e = !1), this.isPlaying = !1, this.isFinished = !0, this.paused = !1, t && (this.currentFrame = this._frameData.getFrame(this._frames[0]), this._parent.setFrame(this.currentFrame)), e && (this._parent.events.onAnimationComplete$dispatch(this._parent, this), this.onComplete.dispatch(this._parent, this))
            },
            onPause: function() {
                this.isPlaying && (this._frameDiff = this._timeNextFrame - this.game.time.time)
            },
            onResume: function() {
                this.isPlaying && (this._timeNextFrame = this.game.time.time + this._frameDiff)
            },
            update: function() {
                return !this.isPaused && !!(this.isPlaying && this.game.time.time >= this._timeNextFrame) && (this._frameSkip = 1, this._frameDiff = this.game.time.time - this._timeNextFrame, this._timeLastFrame = this.game.time.time, this._frameDiff > this.delay && (this._frameSkip = Math.floor(this._frameDiff / this.delay), this._frameDiff -= this._frameSkip * this.delay), this._timeNextFrame = this.game.time.time + (this.delay - this._frameDiff), this.isReversed ? this._frameIndex -= this._frameSkip : this._frameIndex += this._frameSkip, !this.isReversed && this._frameIndex >= this._frames.length || this.isReversed && this._frameIndex <= -1 ? this.loop ? (this._frameIndex = Math.abs(this._frameIndex) % this._frames.length, this.isReversed && (this._frameIndex = this._frames.length - 1 - this._frameIndex), this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.currentFrame && this._parent.setFrame(this.currentFrame), this.loopCount++, this._parent.events.onAnimationLoop$dispatch(this._parent, this), this.onLoop.dispatch(this._parent, this), !this.onUpdate || (this.onUpdate.dispatch(this, this.currentFrame), !!this._frameData)) : (this.complete(), !1) : this.updateCurrentFrame(!0))
            },
            updateCurrentFrame: function(t, e) {
                if (void 0 === e && (e = !1), !this._frameData) return !1;
                var i = this.currentFrame.index;
                return this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.currentFrame && (e || !e && i !== this.currentFrame.index) && this._parent.setFrame(this.currentFrame), !this.onUpdate || !t || (this.onUpdate.dispatch(this, this.currentFrame), !!this._frameData)
            },
            next: function(t) {
                void 0 === t && (t = 1);
                var e = this._frameIndex + t;
                e >= this._frames.length && (this.loop ? e %= this._frames.length : e = this._frames.length - 1), e !== this._frameIndex && (this._frameIndex = e, this.updateCurrentFrame(!0))
            },
            previous: function(t) {
                void 0 === t && (t = 1);
                var e = this._frameIndex - t;
                e < 0 && (this.loop ? e = this._frames.length + e : e++), e !== this._frameIndex && (this._frameIndex = e, this.updateCurrentFrame(!0))
            },
            updateFrameData: function(t) {
                this._frameData = t, this.currentFrame = this._frameData ? this._frameData.getFrame(this._frames[this._frameIndex % this._frames.length]) : null
            },
            destroy: function() {
                this._frameData && (this.game.onPause.remove(this.onPause, this), this.game.onResume.remove(this.onResume, this), this.game = null, this._parent = null, this._frames = null, this._frameData = null, this.currentFrame = null, this.isPlaying = !1, this.onStart.dispose(), this.onLoop.dispose(), this.onComplete.dispose(), this.onUpdate && this.onUpdate.dispose())
            },
            complete: function() {
                this._frameIndex = this._frames.length - 1, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.isPlaying = !1, this.isFinished = !0, this.paused = !1, this._parent.events.onAnimationComplete$dispatch(this._parent, this), this.onComplete.dispatch(this._parent, this), this.killOnComplete && this._parent.kill()
            }
        }, i.Animation.prototype.constructor = i.Animation, Object.defineProperty(i.Animation.prototype, "paused", {
            get: function() {
                return this.isPaused
            },
            set: function(t) {
                this.isPaused = t, t ? this._pauseStartTime = this.game.time.time : this.isPlaying && (this._timeNextFrame = this.game.time.time + this.delay)
            }
        }), Object.defineProperty(i.Animation.prototype, "reversed", {
            get: function() {
                return this.isReversed
            },
            set: function(t) {
                this.isReversed = t
            }
        }), Object.defineProperty(i.Animation.prototype, "frameTotal", {
            get: function() {
                return this._frames.length
            }
        }), Object.defineProperty(i.Animation.prototype, "frame", {
            get: function() {
                return null !== this.currentFrame ? this.currentFrame.index : this._frameIndex
            },
            set: function(t) {
                this.currentFrame = this._frameData.getFrame(this._frames[t]), null !== this.currentFrame && (this._frameIndex = t, this._parent.setFrame(this.currentFrame), this.onUpdate && this.onUpdate.dispatch(this, this.currentFrame))
            }
        }), Object.defineProperty(i.Animation.prototype, "speed", {
            get: function() {
                return 1e3 / this.delay
            },
            set: function(t) {
                t > 0 && (this.delay = 1e3 / t)
            }
        }), Object.defineProperty(i.Animation.prototype, "enableUpdate", {
            get: function() {
                return null !== this.onUpdate
            },
            set: function(t) {
                t && null === this.onUpdate ? this.onUpdate = new i.Signal : t || null === this.onUpdate || (this.onUpdate.dispose(), this.onUpdate = null)
            }
        }), i.Animation.generateFrameNames = function(t, e, s, o, n) {
            void 0 === o && (o = "");
            var a = [],
                r = "";
            if (e < s)
                for (h = e; h <= s; h++) r = "number" == typeof n ? i.Utils.pad(h.toString(), n, "0", 1) : h.toString(), r = t + r + o, a.push(r);
            else
                for (var h = e; h >= s; h--) r = "number" == typeof n ? i.Utils.pad(h.toString(), n, "0", 1) : h.toString(), r = t + r + o, a.push(r);
            return a
        }, i.Frame = function(t, e, s, o, n, a) {
            this.index = t, this.x = e, this.y = s, this.width = o, this.height = n, this.name = a, this.centerX = Math.floor(o / 2), this.centerY = Math.floor(n / 2), this.distance = i.Math.distance(0, 0, o, n), this.rotated = !1, this.rotationDirection = "cw", this.trimmed = !1, this.sourceSizeW = o, this.sourceSizeH = n, this.spriteSourceSizeX = 0, this.spriteSourceSizeY = 0, this.spriteSourceSizeW = 0, this.spriteSourceSizeH = 0, this.right = this.x + this.width, this.bottom = this.y + this.height
        }, i.Frame.prototype = {
            resize: function(t, e) {
                this.width = t, this.height = e, this.centerX = Math.floor(t / 2), this.centerY = Math.floor(e / 2), this.distance = i.Math.distance(0, 0, t, e), this.sourceSizeW = t, this.sourceSizeH = e, this.right = this.x + t, this.bottom = this.y + e
            },
            setTrim: function(t, e, i, s, o, n, a) {
                this.trimmed = t, t && (this.sourceSizeW = e, this.sourceSizeH = i, this.centerX = Math.floor(e / 2), this.centerY = Math.floor(i / 2), this.spriteSourceSizeX = s, this.spriteSourceSizeY = o, this.spriteSourceSizeW = n, this.spriteSourceSizeH = a)
            },
            clone: function() {
                var t = new i.Frame(this.index, this.x, this.y, this.width, this.height, this.name);
                for (var e in this) this.hasOwnProperty(e) && (t[e] = this[e]);
                return t
            },
            getRect: function(t) {
                return void 0 === t ? t = new i.Rectangle(this.x, this.y, this.width, this.height) : t.setTo(this.x, this.y, this.width, this.height), t
            }
        }, i.Frame.prototype.constructor = i.Frame, i.FrameData = function() {
            this._frames = [], this._frameNames = []
        }, i.FrameData.prototype = {
            addFrame: function(t) {
                return t.index = this._frames.length, this._frames.push(t), "" !== t.name && (this._frameNames[t.name] = t.index), t
            },
            getFrame: function(t) {
                return t >= this._frames.length && (t = 0), this._frames[t]
            },
            getFrameByName: function(t) {
                return "number" == typeof this._frameNames[t] ? this._frames[this._frameNames[t]] : null
            },
            checkFrameName: function(t) {
                return null != this._frameNames[t]
            },
            clone: function() {
                for (var t = new i.FrameData, e = 0; e < this._frames.length; e++) t._frames.push(this._frames[e].clone());
                for (var s in this._frameNames) this._frameNames.hasOwnProperty(s) && t._frameNames.push(this._frameNames[s]);
                return t
            },
            getFrameRange: function(t, e, i) {
                void 0 === i && (i = []);
                for (var s = t; s <= e; s++) i.push(this._frames[s]);
                return i
            },
            getFrames: function(t, e, i) {
                if (void 0 === e && (e = !0), void 0 === i && (i = []), void 0 === t || 0 === t.length)
                    for (s = 0; s < this._frames.length; s++) i.push(this._frames[s]);
                else
                    for (var s = 0; s < t.length; s++) e ? i.push(this.getFrame(t[s])) : i.push(this.getFrameByName(t[s]));
                return i
            },
            getFrameIndexes: function(t, e, i) {
                if (void 0 === e && (e = !0), void 0 === i && (i = []), void 0 === t || 0 === t.length)
                    for (s = 0; s < this._frames.length; s++) i.push(this._frames[s].index);
                else
                    for (var s = 0; s < t.length; s++) e && this._frames[t[s]] ? i.push(this._frames[t[s]].index) : this.getFrameByName(t[s]) && i.push(this.getFrameByName(t[s]).index);
                return i
            },
            destroy: function() {
                this._frames = null, this._frameNames = null
            }
        }, i.FrameData.prototype.constructor = i.FrameData, Object.defineProperty(i.FrameData.prototype, "total", {
            get: function() {
                return this._frames.length
            }
        }), i.AnimationParser = {
            spriteSheet: function(t, e, s, o, n, a, r) {
                var h = e;
                if ("string" == typeof e && (h = t.cache.getImage(e)), null === h) return null;
                var l = h.width,
                    c = h.height;
                s <= 0 && (s = Math.floor(-l / Math.min(-1, s))), o <= 0 && (o = Math.floor(-c / Math.min(-1, o)));
                var p = Math.floor((l - a) / (s + r)) * Math.floor((c - a) / (o + r));
                if (-1 !== n && (p = n), 0 === l || 0 === c || l < s || c < o || 0 === p) return console.warn("Phaser.AnimationParser.spriteSheet: '" + e + "'s width/height zero or width/height < given frameWidth/frameHeight"), null;
                for (var u = new i.FrameData, d = a, m = a, y = 0; y < p; y++) u.addFrame(new i.Frame(y, d, m, s, o, "")), (d += s + r) + s > l && (d = a, m += o + r);
                return u
            },
            JSONData: function(t, e) {
                if (!e.frames) return console.warn("Phaser.AnimationParser.JSONData: Invalid Texture Atlas JSON given, missing 'frames' array"), void console.log(e);
                for (var s, o = new i.FrameData, n = e.frames, a = 0; a < n.length; a++) s = o.addFrame(new i.Frame(a, n[a].frame.x, n[a].frame.y, n[a].frame.w, n[a].frame.h, n[a].filename)), n[a].trimmed && s.setTrim(n[a].trimmed, n[a].sourceSize.w, n[a].sourceSize.h, n[a].spriteSourceSize.x, n[a].spriteSourceSize.y, n[a].spriteSourceSize.w, n[a].spriteSourceSize.h);
                return o
            },
            JSONDataPyxel: function(t, e) {
                if (["layers", "tilewidth", "tileheight", "tileswide", "tileshigh"].forEach(function(t) {
                        if (!e[t]) return console.warn('Phaser.AnimationParser.JSONDataPyxel: Invalid Pyxel Tilemap JSON given, missing "' + t + '" key.'), void console.log(e)
                    }), 1 !== e.layers.length) return console.warn("Phaser.AnimationParser.JSONDataPyxel: Too many layers, this parser only supports flat Tilemaps."), void console.log(e);
                for (var s = new i.FrameData, o = e.tileheight, n = e.tilewidth, a = e.layers[0].tiles, r = 0; r < a.length; r++) s.addFrame(new i.Frame(r, a[r].x, a[r].y, n, o, "frame_" + r)).setTrim(!1);
                return s
            },
            JSONDataHash: function(t, e) {
                if (!e.frames) return console.warn("Phaser.AnimationParser.JSONDataHash: Invalid Texture Atlas JSON given, missing 'frames' object"), void console.log(e);
                var s, o = new i.FrameData,
                    n = e.frames,
                    a = 0;
                for (var r in n) s = o.addFrame(new i.Frame(a, n[r].frame.x, n[r].frame.y, n[r].frame.w, n[r].frame.h, r)), n[r].trimmed && s.setTrim(n[r].trimmed, n[r].sourceSize.w, n[r].sourceSize.h, n[r].spriteSourceSize.x, n[r].spriteSourceSize.y, n[r].spriteSourceSize.w, n[r].spriteSourceSize.h), a++;
                return o
            },
            XMLData: function(t, e) {
                if (e.getElementsByTagName("TextureAtlas")) {
                    for (var s, o, n, a, r, h, l, c, p, u, d, m = new i.FrameData, y = e.getElementsByTagName("SubTexture"), f = 0; f < y.length; f++) n = y[f].attributes, o = n.name.value, a = parseInt(n.x.value, 10), r = parseInt(n.y.value, 10), h = parseInt(n.width.value, 10), l = parseInt(n.height.value, 10), c = null, p = null, n.frameX && (c = Math.abs(parseInt(n.frameX.value, 10)), p = Math.abs(parseInt(n.frameY.value, 10)), u = parseInt(n.frameWidth.value, 10), d = parseInt(n.frameHeight.value, 10)), s = m.addFrame(new i.Frame(f, a, r, h, l, o)), null === c && null === p || s.setTrim(!0, h, l, c, p, u, d);
                    return m
                }
                console.warn("Phaser.AnimationParser.XMLData: Invalid Texture Atlas XML given, missing <TextureAtlas> tag")
            }
        }, i.Cache = function(t) {
            this.game = t, this.autoResolveURL = !1, this._cache = {
                canvas: {},
                image: {},
                texture: {},
                sound: {},
                video: {},
                text: {},
                json: {},
                xml: {},
                physics: {},
                tilemap: {},
                binary: {},
                bitmapData: {},
                bitmapFont: {},
                shader: {},
                renderTexture: {}
            }, this._urlMap = {}, this._urlResolver = new Image, this._urlTemp = null, this.onSoundUnlock = new i.Signal, this._cacheMap = [], this._cacheMap[i.Cache.CANVAS] = this._cache.canvas, this._cacheMap[i.Cache.IMAGE] = this._cache.image, this._cacheMap[i.Cache.TEXTURE] = this._cache.texture, this._cacheMap[i.Cache.SOUND] = this._cache.sound, this._cacheMap[i.Cache.TEXT] = this._cache.text, this._cacheMap[i.Cache.PHYSICS] = this._cache.physics, this._cacheMap[i.Cache.TILEMAP] = this._cache.tilemap, this._cacheMap[i.Cache.BINARY] = this._cache.binary, this._cacheMap[i.Cache.BITMAPDATA] = this._cache.bitmapData, this._cacheMap[i.Cache.BITMAPFONT] = this._cache.bitmapFont, this._cacheMap[i.Cache.JSON] = this._cache.json, this._cacheMap[i.Cache.XML] = this._cache.xml, this._cacheMap[i.Cache.VIDEO] = this._cache.video, this._cacheMap[i.Cache.SHADER] = this._cache.shader, this._cacheMap[i.Cache.RENDER_TEXTURE] = this._cache.renderTexture, this.addDefaultImage(), this.addMissingImage()
        }, i.Cache.CANVAS = 1, i.Cache.IMAGE = 2, i.Cache.TEXTURE = 3, i.Cache.SOUND = 4, i.Cache.TEXT = 5, i.Cache.PHYSICS = 6, i.Cache.TILEMAP = 7, i.Cache.BINARY = 8, i.Cache.BITMAPDATA = 9, i.Cache.BITMAPFONT = 10, i.Cache.JSON = 11, i.Cache.XML = 12, i.Cache.VIDEO = 13, i.Cache.SHADER = 14, i.Cache.RENDER_TEXTURE = 15, i.Cache.DEFAULT = null, i.Cache.MISSING = null, i.Cache.prototype = {
            addCanvas: function(t, e, i) {
                void 0 === i && (i = e.getContext("2d")), this._cache.canvas[t] = {
                    canvas: e,
                    context: i
                }
            },
            addImage: function(t, e, s) {
                this.checkImageKey(t) && this.removeImage(t);
                var o = {
                    key: t,
                    url: e,
                    data: s,
                    base: new PIXI.BaseTexture(s),
                    frame: new i.Frame(0, 0, 0, s.width, s.height, t),
                    frameData: new i.FrameData
                };
                return o.frameData.addFrame(new i.Frame(0, 0, 0, s.width, s.height, e)), this._cache.image[t] = o, this._resolveURL(e, o), "__default" === t ? i.Cache.DEFAULT = new PIXI.Texture(o.base) : "__missing" === t && (i.Cache.MISSING = new PIXI.Texture(o.base)), o
            },
            addDefaultImage: function() {
                var t = new Image;
                t.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==";
                var e = this.addImage("__default", null, t);
                e.base.skipRender = !0, i.Cache.DEFAULT = new PIXI.Texture(e.base)
            },
            addMissingImage: function() {
                var t = new Image;
                t.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==";
                var e = this.addImage("__missing", null, t);
                i.Cache.MISSING = new PIXI.Texture(e.base)
            },
            addSound: function(t, e, i, s, o) {
                void 0 === s && (s = !0, o = !1), void 0 === o && (s = !1, o = !0);
                var n = !1;
                o && (n = !0), this._cache.sound[t] = {
                    url: e,
                    data: i,
                    isDecoding: !1,
                    decoded: n,
                    webAudio: s,
                    audioTag: o,
                    locked: this.game.sound.touchLocked
                }, this._resolveURL(e, this._cache.sound[t])
            },
            addText: function(t, e, i) {
                this._cache.text[t] = {
                    url: e,
                    data: i
                }, this._resolveURL(e, this._cache.text[t])
            },
            addPhysicsData: function(t, e, i, s) {
                this._cache.physics[t] = {
                    url: e,
                    data: i,
                    format: s
                }, this._resolveURL(e, this._cache.physics[t])
            },
            addTilemap: function(t, e, i, s) {
                this._cache.tilemap[t] = {
                    url: e,
                    data: i,
                    format: s
                }, this._resolveURL(e, this._cache.tilemap[t])
            },
            addBinary: function(t, e) {
                this._cache.binary[t] = e
            },
            addBitmapData: function(t, e, s) {
                return e.key = t, void 0 === s && (s = new i.FrameData).addFrame(e.textureFrame), this._cache.bitmapData[t] = {
                    data: e,
                    frameData: s
                }, e
            },
            addBitmapFont: function(t, e, s, o, n, a, r) {
                var h = {
                    url: e,
                    data: s,
                    font: null,
                    base: new PIXI.BaseTexture(s)
                };
                void 0 === a && (a = 0), void 0 === r && (r = 0), h.font = "json" === n ? i.LoaderParser.jsonBitmapFont(o, h.base, a, r) : i.LoaderParser.xmlBitmapFont(o, h.base, a, r), this._cache.bitmapFont[t] = h, this._resolveURL(e, h)
            },
            addJSON: function(t, e, i) {
                this._cache.json[t] = {
                    url: e,
                    data: i
                }, this._resolveURL(e, this._cache.json[t])
            },
            addXML: function(t, e, i) {
                this._cache.xml[t] = {
                    url: e,
                    data: i
                }, this._resolveURL(e, this._cache.xml[t])
            },
            addVideo: function(t, e, i, s) {
                this._cache.video[t] = {
                    url: e,
                    data: i,
                    isBlob: s,
                    locked: !0
                }, this._resolveURL(e, this._cache.video[t])
            },
            addShader: function(t, e, i) {
                this._cache.shader[t] = {
                    url: e,
                    data: i
                }, this._resolveURL(e, this._cache.shader[t])
            },
            addRenderTexture: function(t, e) {
                this._cache.renderTexture[t] = {
                    texture: e,
                    frame: new i.Frame(0, 0, 0, e.width, e.height, "", "")
                }
            },
            addSpriteSheet: function(t, e, s, o, n, a, r, h) {
                void 0 === a && (a = -1), void 0 === r && (r = 0), void 0 === h && (h = 0);
                var l = {
                    key: t,
                    url: e,
                    data: s,
                    frameWidth: o,
                    frameHeight: n,
                    margin: r,
                    spacing: h,
                    base: new PIXI.BaseTexture(s),
                    frameData: i.AnimationParser.spriteSheet(this.game, s, o, n, a, r, h)
                };
                this._cache.image[t] = l, this._resolveURL(e, l)
            },
            addTextureAtlas: function(t, e, s, o, n) {
                var a = {
                    key: t,
                    url: e,
                    data: s,
                    base: new PIXI.BaseTexture(s)
                };
                n === i.Loader.TEXTURE_ATLAS_XML_STARLING ? a.frameData = i.AnimationParser.XMLData(this.game, o, t) : n === i.Loader.TEXTURE_ATLAS_JSON_PYXEL ? a.frameData = i.AnimationParser.JSONDataPyxel(this.game, o, t) : Array.isArray(o.frames) ? a.frameData = i.AnimationParser.JSONData(this.game, o, t) : a.frameData = i.AnimationParser.JSONDataHash(this.game, o, t), this._cache.image[t] = a, this._resolveURL(e, a)
            },
            reloadSound: function(t) {
                var e = this,
                    i = this.getSound(t);
                i && (i.data.src = i.url, i.data.addEventListener("canplaythrough", function() {
                    return e.reloadSoundComplete(t)
                }, !1), i.data.load())
            },
            reloadSoundComplete: function(t) {
                var e = this.getSound(t);
                e && (e.locked = !1, this.onSoundUnlock.dispatch(t))
            },
            updateSound: function(t, e, i) {
                var s = this.getSound(t);
                s && (s[e] = i)
            },
            decodedSound: function(t, e) {
                var i = this.getSound(t);
                i.data = e, i.decoded = !0, i.isDecoding = !1
            },
            isSoundDecoded: function(t) {
                var e = this.getItem(t, i.Cache.SOUND, "isSoundDecoded");
                if (e) return e.decoded
            },
            isSoundReady: function(t) {
                var e = this.getItem(t, i.Cache.SOUND, "isSoundDecoded");
                if (e) return e.decoded && !this.game.sound.touchLocked
            },
            checkKey: function(t, e) {
                return !!this._cacheMap[t][e]
            },
            checkURL: function(t) {
                return !!this._urlMap[this._resolveURL(t)]
            },
            checkCanvasKey: function(t) {
                return this.checkKey(i.Cache.CANVAS, t)
            },
            checkImageKey: function(t) {
                return this.checkKey(i.Cache.IMAGE, t)
            },
            checkTextureKey: function(t) {
                return this.checkKey(i.Cache.TEXTURE, t)
            },
            checkSoundKey: function(t) {
                return this.checkKey(i.Cache.SOUND, t)
            },
            checkTextKey: function(t) {
                return this.checkKey(i.Cache.TEXT, t)
            },
            checkPhysicsKey: function(t) {
                return this.checkKey(i.Cache.PHYSICS, t)
            },
            checkTilemapKey: function(t) {
                return this.checkKey(i.Cache.TILEMAP, t)
            },
            checkBinaryKey: function(t) {
                return this.checkKey(i.Cache.BINARY, t)
            },
            checkBitmapDataKey: function(t) {
                return this.checkKey(i.Cache.BITMAPDATA, t)
            },
            checkBitmapFontKey: function(t) {
                return this.checkKey(i.Cache.BITMAPFONT, t)
            },
            checkJSONKey: function(t) {
                return this.checkKey(i.Cache.JSON, t)
            },
            checkXMLKey: function(t) {
                return this.checkKey(i.Cache.XML, t)
            },
            checkVideoKey: function(t) {
                return this.checkKey(i.Cache.VIDEO, t)
            },
            checkShaderKey: function(t) {
                return this.checkKey(i.Cache.SHADER, t)
            },
            checkRenderTextureKey: function(t) {
                return this.checkKey(i.Cache.RENDER_TEXTURE, t)
            },
            getItem: function(t, e, i, s) {
                return this.checkKey(e, t) ? void 0 === s ? this._cacheMap[e][t] : this._cacheMap[e][t][s] : (i && console.warn("Phaser.Cache." + i + ': Key "' + t + '" not found in Cache.'), null)
            },
            getCanvas: function(t) {
                return this.getItem(t, i.Cache.CANVAS, "getCanvas", "canvas")
            },
            getImage: function(t, e) {
                void 0 !== t && null !== t || (t = "__default"), void 0 === e && (e = !1);
                var s = this.getItem(t, i.Cache.IMAGE, "getImage");
                return null === s && (s = this.getItem("__missing", i.Cache.IMAGE, "getImage")), e ? s : s.data
            },
            getTextureFrame: function(t) {
                return this.getItem(t, i.Cache.TEXTURE, "getTextureFrame", "frame")
            },
            getSound: function(t) {
                return this.getItem(t, i.Cache.SOUND, "getSound")
            },
            getSoundData: function(t) {
                return this.getItem(t, i.Cache.SOUND, "getSoundData", "data")
            },
            getText: function(t) {
                return this.getItem(t, i.Cache.TEXT, "getText", "data")
            },
            getPhysicsData: function(t, e, s) {
                var o = this.getItem(t, i.Cache.PHYSICS, "getPhysicsData", "data");
                if (null === o || void 0 === e || null === e) return o;
                if (o[e]) {
                    var n = o[e];
                    if (!n || !s) return n;
                    for (var a in n)
                        if ((a = n[a]).fixtureKey === s) return a;
                    console.warn('Phaser.Cache.getPhysicsData: Could not find given fixtureKey: "' + s + " in " + t + '"')
                } else console.warn('Phaser.Cache.getPhysicsData: Invalid key/object: "' + t + " / " + e + '"');
                return null
            },
            getTilemapData: function(t) {
                return this.getItem(t, i.Cache.TILEMAP, "getTilemapData")
            },
            getBinary: function(t) {
                return this.getItem(t, i.Cache.BINARY, "getBinary")
            },
            getBitmapData: function(t) {
                return this.getItem(t, i.Cache.BITMAPDATA, "getBitmapData", "data")
            },
            getBitmapFont: function(t) {
                return this.getItem(t, i.Cache.BITMAPFONT, "getBitmapFont")
            },
            getJSON: function(t, e) {
                var s = this.getItem(t, i.Cache.JSON, "getJSON", "data");
                return s ? e ? i.Utils.extend(!0, Array.isArray(s) ? [] : {}, s) : s : null
            },
            getXML: function(t) {
                return this.getItem(t, i.Cache.XML, "getXML", "data")
            },
            getVideo: function(t) {
                return this.getItem(t, i.Cache.VIDEO, "getVideo")
            },
            getShader: function(t) {
                return this.getItem(t, i.Cache.SHADER, "getShader", "data")
            },
            getRenderTexture: function(t) {
                return this.getItem(t, i.Cache.RENDER_TEXTURE, "getRenderTexture")
            },
            getBaseTexture: function(t, e) {
                return void 0 === e && (e = i.Cache.IMAGE), this.getItem(t, e, "getBaseTexture", "base")
            },
            getFrame: function(t, e) {
                return void 0 === e && (e = i.Cache.IMAGE), this.getItem(t, e, "getFrame", "frame")
            },
            getFrameCount: function(t, e) {
                var i = this.getFrameData(t, e);
                return i ? i.total : 0
            },
            getFrameData: function(t, e) {
                return void 0 === e && (e = i.Cache.IMAGE), this.getItem(t, e, "getFrameData", "frameData")
            },
            hasFrameData: function(t, e) {
                return void 0 === e && (e = i.Cache.IMAGE), null !== this.getItem(t, e, "", "frameData")
            },
            updateFrameData: function(t, e, s) {
                void 0 === s && (s = i.Cache.IMAGE), this._cacheMap[s][t] && (this._cacheMap[s][t].frameData = e)
            },
            getFrameByIndex: function(t, e, i) {
                var s = this.getFrameData(t, i);
                return s ? s.getFrame(e) : null
            },
            getFrameByName: function(t, e, i) {
                var s = this.getFrameData(t, i);
                return s ? s.getFrameByName(e) : null
            },
            getURL: function(t) {
                return (t = this._resolveURL(t)) ? this._urlMap[t] : (console.warn('Phaser.Cache.getUrl: Invalid url: "' + t + '" or Cache.autoResolveURL was false'), null)
            },
            getKeys: function(t) {
                void 0 === t && (t = i.Cache.IMAGE);
                var e = [];
                if (this._cacheMap[t])
                    for (var s in this._cacheMap[t]) "__default" !== s && "__missing" !== s && e.push(s);
                return e
            },
            removeCanvas: function(t) {
                delete this._cache.canvas[t]
            },
            removeImage: function(t, e) {
                void 0 === e && (e = !0);
                var i = this.getImage(t, !0);
                e && i.base && i.base.destroy(), delete this._cache.image[t]
            },
            removeSound: function(t) {
                delete this._cache.sound[t]
            },
            removeText: function(t) {
                delete this._cache.text[t]
            },
            removePhysics: function(t) {
                delete this._cache.physics[t]
            },
            removeTilemap: function(t) {
                delete this._cache.tilemap[t]
            },
            removeBinary: function(t) {
                delete this._cache.binary[t]
            },
            removeBitmapData: function(t) {
                delete this._cache.bitmapData[t]
            },
            removeBitmapFont: function(t) {
                delete this._cache.bitmapFont[t]
            },
            removeJSON: function(t) {
                delete this._cache.json[t]
            },
            removeXML: function(t) {
                delete this._cache.xml[t]
            },
            removeVideo: function(t) {
                delete this._cache.video[t]
            },
            removeShader: function(t) {
                delete this._cache.shader[t]
            },
            removeRenderTexture: function(t) {
                delete this._cache.renderTexture[t]
            },
            removeSpriteSheet: function(t) {
                delete this._cache.spriteSheet[t]
            },
            removeTextureAtlas: function(t) {
                delete this._cache.atlas[t]
            },
            clearGLTextures: function() {
                for (var t in this._cache.image) this._cache.image[t].base._glTextures = []
            },
            _resolveURL: function(t, e) {
                return this.autoResolveURL ? (this._urlResolver.src = this.game.load.baseURL + t, this._urlTemp = this._urlResolver.src, this._urlResolver.src = "", e && (this._urlMap[this._urlTemp] = e), this._urlTemp) : null
            },
            destroy: function() {
                for (var t = 0; t < this._cacheMap.length; t++) {
                    var e = this._cacheMap[t];
                    for (var i in e) "__default" !== i && "__missing" !== i && (e[i].destroy && e[i].destroy(), delete e[i])
                }
                this._urlMap = null, this._urlResolver = null, this._urlTemp = null
            }
        }, i.Cache.prototype.constructor = i.Cache, i.Loader = function(t) {
            this.game = t, this.cache = t.cache, this.resetLocked = !1, this.isLoading = !1, this.hasLoaded = !1, this.preloadSprite = null, this.crossOrigin = !1, this.baseURL = "", this.path = "", this.headers = {
                requestedWith: !1,
                json: "application/json",
                xml: "application/xml"
            }, this.onLoadStart = new i.Signal, this.onLoadComplete = new i.Signal, this.onPackComplete = new i.Signal, this.onFileStart = new i.Signal, this.onFileComplete = new i.Signal, this.onFileError = new i.Signal, this.useXDomainRequest = !1, this._warnedAboutXDomainRequest = !1, this.enableParallel = !0, this.maxParallelDownloads = 4, this._withSyncPointDepth = 0, this._fileList = [], this._flightQueue = [], this._processingHead = 0, this._fileLoadStarted = !1, this._totalPackCount = 0, this._totalFileCount = 0, this._loadedPackCount = 0, this._loadedFileCount = 0
        }, i.Loader.TEXTURE_ATLAS_JSON_ARRAY = 0, i.Loader.TEXTURE_ATLAS_JSON_HASH = 1, i.Loader.TEXTURE_ATLAS_XML_STARLING = 2, i.Loader.PHYSICS_LIME_CORONA_JSON = 3, i.Loader.PHYSICS_PHASER_JSON = 4, i.Loader.TEXTURE_ATLAS_JSON_PYXEL = 5, i.Loader.prototype = {
            setPreloadSprite: function(t, e) {
                e = e || 0, this.preloadSprite = {
                    sprite: t,
                    direction: e,
                    width: t.width,
                    height: t.height,
                    rect: null
                }, this.preloadSprite.rect = 0 === e ? new i.Rectangle(0, 0, 1, t.height) : new i.Rectangle(0, 0, t.width, 1), t.crop(this.preloadSprite.rect), t.visible = !0
            },
            resize: function() {
                this.preloadSprite && this.preloadSprite.height !== this.preloadSprite.sprite.height && (this.preloadSprite.rect.height = this.preloadSprite.sprite.height)
            },
            checkKeyExists: function(t, e) {
                return this.getAssetIndex(t, e) > -1
            },
            getAssetIndex: function(t, e) {
                for (var i = -1, s = 0; s < this._fileList.length; s++) {
                    var o = this._fileList[s];
                    if (o.type === t && o.key === e && (i = s, !o.loaded && !o.loading)) break
                }
                return i
            },
            getAsset: function(t, e) {
                var i = this.getAssetIndex(t, e);
                return i > -1 && {
                    index: i,
                    file: this._fileList[i]
                }
            },
            reset: function(t, e) {
                void 0 === e && (e = !1), this.resetLocked || (t && (this.preloadSprite = null), this.isLoading = !1, this._processingHead = 0, this._fileList.length = 0, this._flightQueue.length = 0, this._fileLoadStarted = !1, this._totalFileCount = 0, this._totalPackCount = 0, this._loadedPackCount = 0, this._loadedFileCount = 0, e && (this.onLoadStart.removeAll(), this.onLoadComplete.removeAll(), this.onPackComplete.removeAll(), this.onFileStart.removeAll(), this.onFileComplete.removeAll(), this.onFileError.removeAll()))
            },
            addToFileList: function(t, e, i, s, o, n) {
                if (void 0 === o && (o = !1), void 0 === e || "" === e) return console.warn("Phaser.Loader: Invalid or no key given of type " + t), this;
                if (void 0 === i || null === i) {
                    if (!n) return console.warn("Phaser.Loader: No URL given for file type: " + t + " key: " + e), this;
                    i = e + n
                }
                var a = {
                    type: t,
                    key: e,
                    path: this.path,
                    url: i,
                    syncPoint: this._withSyncPointDepth > 0,
                    data: null,
                    loading: !1,
                    loaded: !1,
                    error: !1
                };
                if (s)
                    for (var r in s) a[r] = s[r];
                var h = this.getAssetIndex(t, e);
                if (o && h > -1) {
                    var l = this._fileList[h];
                    l.loading || l.loaded ? (this._fileList.push(a), this._totalFileCount++) : this._fileList[h] = a
                } else -1 === h && (this._fileList.push(a), this._totalFileCount++);
                return this
            },
            replaceInFileList: function(t, e, i, s) {
                return this.addToFileList(t, e, i, s, !0)
            },
            pack: function(t, e, i, s) {
                if (void 0 === e && (e = null), void 0 === i && (i = null), void 0 === s && (s = null), !e && !i) return console.warn("Phaser.Loader.pack - Both url and data are null. One must be set."), this;
                var o = {
                    type: "packfile",
                    key: t,
                    url: e,
                    path: this.path,
                    syncPoint: !0,
                    data: null,
                    loading: !1,
                    loaded: !1,
                    error: !1,
                    callbackContext: s
                };
                i && ("string" == typeof i && (i = JSON.parse(i)), o.data = i || {}, o.loaded = !0);
                for (var n = 0; n < this._fileList.length + 1; n++) {
                    var a = this._fileList[n];
                    if (!a || !a.loaded && !a.loading && "packfile" !== a.type) {
                        this._fileList.splice(n, 0, o), this._totalPackCount++;
                        break
                    }
                }
                return this
            },
            image: function(t, e, i) {
                return this.addToFileList("image", t, e, void 0, i, ".png")
            },
            images: function(t, e) {
                if (Array.isArray(e))
                    for (i = 0; i < t.length; i++) this.image(t[i], e[i]);
                else
                    for (var i = 0; i < t.length; i++) this.image(t[i]);
                return this
            },
            text: function(t, e, i) {
                return this.addToFileList("text", t, e, void 0, i, ".txt")
            },
            json: function(t, e, i) {
                return this.addToFileList("json", t, e, void 0, i, ".json")
            },
            shader: function(t, e, i) {
                return this.addToFileList("shader", t, e, void 0, i, ".frag")
            },
            xml: function(t, e, i) {
                return this.addToFileList("xml", t, e, void 0, i, ".xml")
            },
            script: function(t, e, i, s) {
                return void 0 === i && (i = !1), !1 !== i && void 0 === s && (s = this), this.addToFileList("script", t, e, {
                    syncPoint: !0,
                    callback: i,
                    callbackContext: s
                }, !1, ".js")
            },
            binary: function(t, e, i, s) {
                return void 0 === i && (i = !1), !1 !== i && void 0 === s && (s = i), this.addToFileList("binary", t, e, {
                    callback: i,
                    callbackContext: s
                }, !1, ".bin")
            },
            spritesheet: function(t, e, i, s, o, n, a) {
                return void 0 === o && (o = -1), void 0 === n && (n = 0), void 0 === a && (a = 0), this.addToFileList("spritesheet", t, e, {
                    frameWidth: i,
                    frameHeight: s,
                    frameMax: o,
                    margin: n,
                    spacing: a
                }, !1, ".png")
            },
            audio: function(t, e, i) {
                return this.game.sound.noAudio ? this : (void 0 === i && (i = !0), "string" == typeof e && (e = [e]), this.addToFileList("audio", t, e, {
                    buffer: null,
                    autoDecode: i
                }))
            },
            audioSprite: function(t, e, i, s, o) {
                return this.game.sound.noAudio ? this : (void 0 === i && (i = null), void 0 === s && (s = null), void 0 === o && (o = !0), this.audio(t, e, o), i ? this.json(t + "-audioatlas", i) : s ? ("string" == typeof s && (s = JSON.parse(s)), this.cache.addJSON(t + "-audioatlas", "", s)) : console.warn("Phaser.Loader.audiosprite - You must specify either a jsonURL or provide a jsonData object"), this)
            },
            audiosprite: function(t, e, i, s, o) {
                return this.audioSprite(t, e, i, s, o)
            },
            video: function(t, e, i, s) {
                return void 0 === i && (i = this.game.device.firefox ? "loadeddata" : "canplaythrough"), void 0 === s && (s = !1), "string" == typeof e && (e = [e]), this.addToFileList("video", t, e, {
                    buffer: null,
                    asBlob: s,
                    loadEvent: i
                })
            },
            tilemap: function(t, e, s, o) {
                if (void 0 === e && (e = null), void 0 === s && (s = null), void 0 === o && (o = i.Tilemap.CSV), e || s || (e = o === i.Tilemap.CSV ? t + ".csv" : t + ".json"), s) {
                    switch (o) {
                        case i.Tilemap.CSV:
                            break;
                        case i.Tilemap.TILED_JSON:
                            "string" == typeof s && (s = JSON.parse(s))
                    }
                    this.cache.addTilemap(t, null, s, o)
                } else this.addToFileList("tilemap", t, e, {
                    format: o
                });
                return this
            },
            physics: function(t, e, s, o) {
                return void 0 === e && (e = null), void 0 === s && (s = null), void 0 === o && (o = i.Physics.LIME_CORONA_JSON), e || s || (e = t + ".json"), s ? ("string" == typeof s && (s = JSON.parse(s)), this.cache.addPhysicsData(t, null, s, o)) : this.addToFileList("physics", t, e, {
                    format: o
                }), this
            },
            bitmapFont: function(t, e, i, s, o, n) {
                if (void 0 !== e && null !== e || (e = t + ".png"), void 0 === i && (i = null), void 0 === s && (s = null), null === i && null === s && (i = t + ".xml"), void 0 === o && (o = 0), void 0 === n && (n = 0), i) this.addToFileList("bitmapfont", t, e, {
                    atlasURL: i,
                    xSpacing: o,
                    ySpacing: n
                });
                else if ("string" == typeof s) {
                    var a, r;
                    try {
                        a = JSON.parse(s)
                    } catch (t) {
                        r = this.parseXml(s)
                    }
                    if (!r && !a) throw new Error("Phaser.Loader. Invalid Bitmap Font atlas given");
                    this.addToFileList("bitmapfont", t, e, {
                        atlasURL: null,
                        atlasData: a || r,
                        atlasType: a ? "json" : "xml",
                        xSpacing: o,
                        ySpacing: n
                    })
                }
                return this
            },
            atlasJSONArray: function(t, e, s, o) {
                return this.atlas(t, e, s, o, i.Loader.TEXTURE_ATLAS_JSON_ARRAY)
            },
            atlasJSONHash: function(t, e, s, o) {
                return this.atlas(t, e, s, o, i.Loader.TEXTURE_ATLAS_JSON_HASH)
            },
            atlasXML: function(t, e, s, o) {
                return void 0 === s && (s = null), void 0 === o && (o = null), s || o || (s = t + ".xml"), this.atlas(t, e, s, o, i.Loader.TEXTURE_ATLAS_XML_STARLING)
            },
            atlas: function(t, e, s, o, n) {
                if (void 0 !== e && null !== e || (e = t + ".png"), void 0 === s && (s = null), void 0 === o && (o = null), void 0 === n && (n = i.Loader.TEXTURE_ATLAS_JSON_ARRAY), s || o || (s = n === i.Loader.TEXTURE_ATLAS_XML_STARLING ? t + ".xml" : t + ".json"), s) this.addToFileList("textureatlas", t, e, {
                    atlasURL: s,
                    format: n
                });
                else {
                    switch (n) {
                        case i.Loader.TEXTURE_ATLAS_JSON_ARRAY:
                            "string" == typeof o && (o = JSON.parse(o));
                            break;
                        case i.Loader.TEXTURE_ATLAS_XML_STARLING:
                            if ("string" == typeof o) {
                                var a = this.parseXml(o);
                                if (!a) throw new Error("Phaser.Loader. Invalid Texture Atlas XML given");
                                o = a
                            }
                    }
                    this.addToFileList("textureatlas", t, e, {
                        atlasURL: null,
                        atlasData: o,
                        format: n
                    })
                }
                return this
            },
            withSyncPoint: function(t, e) {
                this._withSyncPointDepth++;
                try {
                    t.call(e || this, this)
                } finally {
                    this._withSyncPointDepth--
                }
                return this
            },
            addSyncPoint: function(t, e) {
                var i = this.getAsset(t, e);
                return i && (i.file.syncPoint = !0), this
            },
            removeFile: function(t, e) {
                var i = this.getAsset(t, e);
                i && (i.loaded || i.loading || this._fileList.splice(i.index, 1))
            },
            removeAll: function() {
                this._fileList.length = 0, this._flightQueue.length = 0
            },
            start: function() {
                this.isLoading || (this.hasLoaded = !1, this.isLoading = !0, this.updateProgress(), this.processLoadQueue())
            },
            processLoadQueue: function() {
                if (!this.isLoading) return console.warn("Phaser.Loader - active loading canceled / reset"), void this.finishedLoading(!0);
                for (s = 0; s < this._flightQueue.length; s++)((o = this._flightQueue[s]).loaded || o.error) && (this._flightQueue.splice(s, 1), s--, o.loading = !1, o.requestUrl = null, o.requestObject = null, o.error && this.onFileError.dispatch(o.key, o), "packfile" !== o.type ? (this._loadedFileCount++, this.onFileComplete.dispatch(this.progress, o.key, !o.error, this._loadedFileCount, this._totalFileCount)) : "packfile" === o.type && o.error && (this._loadedPackCount++, this.onPackComplete.dispatch(o.key, !o.error, this._loadedPackCount, this._totalPackCount)));
                for (var t = !1, e = this.enableParallel ? i.Math.clamp(this.maxParallelDownloads, 1, 12) : 1, s = this._processingHead; s < this._fileList.length; s++) {
                    var o = this._fileList[s];
                    if ("packfile" === o.type && !o.error && o.loaded && s === this._processingHead && (this.processPack(o), this._loadedPackCount++, this.onPackComplete.dispatch(o.key, !o.error, this._loadedPackCount, this._totalPackCount)), o.loaded || o.error ? s === this._processingHead && (this._processingHead = s + 1) : !o.loading && this._flightQueue.length < e && ("packfile" !== o.type || o.data ? t || (this._fileLoadStarted || (this._fileLoadStarted = !0, this.onLoadStart.dispatch()), this._flightQueue.push(o), o.loading = !0, this.onFileStart.dispatch(this.progress, o.key, o.url), this.loadFile(o)) : (this._flightQueue.push(o), o.loading = !0, this.loadFile(o))), !o.loaded && o.syncPoint && (t = !0), this._flightQueue.length >= e || t && this._loadedPackCount === this._totalPackCount) break
                }
                if (this.updateProgress(), this._processingHead >= this._fileList.length) this.finishedLoading();
                else if (!this._flightQueue.length) {
                    console.warn("Phaser.Loader - aborting: processing queue empty, loading may have stalled");
                    var n = this;
                    setTimeout(function() {
                        n.finishedLoading(!0)
                    }, 2e3)
                }
            },
            finishedLoading: function(t) {
                this.hasLoaded || (this.hasLoaded = !0, this.isLoading = !1, t || this._fileLoadStarted || (this._fileLoadStarted = !0, this.onLoadStart.dispatch()), this.onLoadComplete.dispatch(), this.game.state.loadComplete(), this.reset())
            },
            asyncComplete: function(t, e) {
                void 0 === e && (e = ""), t.loaded = !0, t.error = !!e, e && (t.errorMessage = e, console.warn("Phaser.Loader - " + t.type + "[" + t.key + "]: " + e)), this.processLoadQueue()
            },
            processPack: function(t) {
                var e = t.data[t.key];
                if (e)
                    for (var s = 0; s < e.length; s++) {
                        var o = e[s];
                        switch (o.type) {
                            case "image":
                                this.image(o.key, o.url, o.overwrite);
                                break;
                            case "text":
                                this.text(o.key, o.url, o.overwrite);
                                break;
                            case "json":
                                this.json(o.key, o.url, o.overwrite);
                                break;
                            case "xml":
                                this.xml(o.key, o.url, o.overwrite);
                                break;
                            case "script":
                                this.script(o.key, o.url, o.callback, t.callbackContext || this);
                                break;
                            case "binary":
                                this.binary(o.key, o.url, o.callback, t.callbackContext || this);
                                break;
                            case "spritesheet":
                                this.spritesheet(o.key, o.url, o.frameWidth, o.frameHeight, o.frameMax, o.margin, o.spacing);
                                break;
                            case "video":
                                this.video(o.key, o.urls);
                                break;
                            case "audio":
                                this.audio(o.key, o.urls, o.autoDecode);
                                break;
                            case "audiosprite":
                                this.audiosprite(o.key, o.urls, o.jsonURL, o.jsonData, o.autoDecode);
                                break;
                            case "tilemap":
                                this.tilemap(o.key, o.url, o.data, i.Tilemap[o.format]);
                                break;
                            case "physics":
                                this.physics(o.key, o.url, o.data, i.Loader[o.format]);
                                break;
                            case "bitmapFont":
                                this.bitmapFont(o.key, o.textureURL, o.atlasURL, o.atlasData, o.xSpacing, o.ySpacing);
                                break;
                            case "atlasJSONArray":
                                this.atlasJSONArray(o.key, o.textureURL, o.atlasURL, o.atlasData);
                                break;
                            case "atlasJSONHash":
                                this.atlasJSONHash(o.key, o.textureURL, o.atlasURL, o.atlasData);
                                break;
                            case "atlasXML":
                                this.atlasXML(o.key, o.textureURL, o.atlasURL, o.atlasData);
                                break;
                            case "atlas":
                                this.atlas(o.key, o.textureURL, o.atlasURL, o.atlasData, i.Loader[o.format]);
                                break;
                            case "shader":
                                this.shader(o.key, o.url, o.overwrite)
                        }
                    } else console.warn("Phaser.Loader - " + t.key + ": pack has data, but not for pack key")
            },
            transformUrl: function(t, e) {
                return !!t && (t.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/) ? t : this.baseURL + e.path + t)
            },
            loadFile: function(t) {
                switch (t.type) {
                    case "packfile":
                        this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.fileComplete);
                        break;
                    case "image":
                    case "spritesheet":
                    case "textureatlas":
                    case "bitmapfont":
                        this.loadImageTag(t);
                        break;
                    case "audio":
                        t.url = this.getAudioURL(t.url), t.url ? this.game.sound.usingWebAudio ? this.xhrLoad(t, this.transformUrl(t.url, t), "arraybuffer", this.fileComplete) : this.game.sound.usingAudioTag && this.loadAudioTag(t) : this.fileError(t, null, "No supported audio URL specified or device does not have audio playback support");
                        break;
                    case "video":
                        t.url = this.getVideoURL(t.url), t.url ? t.asBlob ? this.xhrLoad(t, this.transformUrl(t.url, t), "blob", this.fileComplete) : this.loadVideoTag(t) : this.fileError(t, null, "No supported video URL specified or device does not have video playback support");
                        break;
                    case "json":
                        this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.jsonLoadComplete);
                        break;
                    case "xml":
                        this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.xmlLoadComplete);
                        break;
                    case "tilemap":
                        t.format === i.Tilemap.TILED_JSON ? this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.jsonLoadComplete) : t.format === i.Tilemap.CSV ? this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.csvLoadComplete) : this.asyncComplete(t, "invalid Tilemap format: " + t.format);
                        break;
                    case "text":
                    case "script":
                    case "shader":
                    case "physics":
                        this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.fileComplete);
                        break;
                    case "binary":
                        this.xhrLoad(t, this.transformUrl(t.url, t), "arraybuffer", this.fileComplete)
                }
            },
            loadImageTag: function(t) {
                var e = this;
                t.data = new Image, t.data.name = t.key, this.crossOrigin && (t.data.crossOrigin = this.crossOrigin), t.data.onload = function() {
                    t.data.onload && (t.data.onload = null, t.data.onerror = null, e.fileComplete(t))
                }, t.data.onerror = function() {
                    t.data.onload && (t.data.onload = null, t.data.onerror = null, e.fileError(t))
                }, t.data.src = this.transformUrl(t.url, t), t.data.complete && t.data.width && t.data.height && (t.data.onload = null, t.data.onerror = null, this.fileComplete(t))
            },
            loadVideoTag: function(t) {
                var e = this;
                t.data = document.createElement("video"), t.data.name = t.key, t.data.controls = !1, t.data.autoplay = !1;
                var s = function() {
                    t.data.removeEventListener(t.loadEvent, s, !1), t.data.onerror = null, t.data.canplay = !0, i.GAMES[e.game.id].load.fileComplete(t)
                };
                t.data.onerror = function() {
                    t.data.removeEventListener(t.loadEvent, s, !1), t.data.onerror = null, t.data.canplay = !1, e.fileError(t)
                }, t.data.addEventListener(t.loadEvent, s, !1), t.data.src = this.transformUrl(t.url, t), t.data.load()
            },
            loadAudioTag: function(t) {
                var e = this;
                if (this.game.sound.touchLocked) t.data = new Audio, t.data.name = t.key, t.data.preload = "auto", t.data.src = this.transformUrl(t.url, t), this.fileComplete(t);
                else {
                    t.data = new Audio, t.data.name = t.key;
                    var i = function() {
                        t.data.removeEventListener("canplaythrough", i, !1), t.data.onerror = null, e.fileComplete(t)
                    };
                    t.data.onerror = function() {
                        t.data.removeEventListener("canplaythrough", i, !1), t.data.onerror = null, e.fileError(t)
                    }, t.data.preload = "auto", t.data.src = this.transformUrl(t.url, t), t.data.addEventListener("canplaythrough", i, !1), t.data.load()
                }
            },
            xhrLoad: function(t, e, i, s, o) {
                if (this.useXDomainRequest && window.XDomainRequest) this.xhrLoadWithXDR(t, e, i, s, o);
                else {
                    var n = new XMLHttpRequest;
                    n.open("GET", e, !0), n.responseType = i, !1 !== this.headers.requestedWith && n.setRequestHeader("X-Requested-With", this.headers.requestedWith), this.headers[t.type] && n.setRequestHeader("Accept", this.headers[t.type]), o = o || this.fileError;
                    var a = this;
                    n.onload = function() {
                        try {
                            return 4 === n.readyState && n.status >= 400 && n.status <= 599 ? o.call(a, t, n) : s.call(a, t, n)
                        } catch (e) {
                            a.hasLoaded ? window.console && console.error(e) : a.asyncComplete(t, e.message || "Exception")
                        }
                    }, n.onerror = function() {
                        try {
                            return o.call(a, t, n)
                        } catch (e) {
                            a.hasLoaded ? window.console && console.error(e) : a.asyncComplete(t, e.message || "Exception")
                        }
                    }, t.requestObject = n, t.requestUrl = e, n.send()
                }
            },
            xhrLoadWithXDR: function(t, e, i, s, o) {
                this._warnedAboutXDomainRequest || this.game.device.ie && !(this.game.device.ieVersion >= 10) || (this._warnedAboutXDomainRequest = !0, console.warn("Phaser.Loader - using XDomainRequest outside of IE 9"));
                var n = new window.XDomainRequest;
                n.open("GET", e, !0), n.responseType = i, n.timeout = 3e3, o = o || this.fileError;
                var a = this;
                n.onerror = function() {
                    try {
                        return o.call(a, t, n)
                    } catch (e) {
                        a.asyncComplete(t, e.message || "Exception")
                    }
                }, n.ontimeout = function() {
                    try {
                        return o.call(a, t, n)
                    } catch (e) {
                        a.asyncComplete(t, e.message || "Exception")
                    }
                }, n.onprogress = function() {}, n.onload = function() {
                    try {
                        return 4 === n.readyState && n.status >= 400 && n.status <= 599 ? o.call(a, t, n) : s.call(a, t, n)
                    } catch (e) {
                        a.asyncComplete(t, e.message || "Exception")
                    }
                }, t.requestObject = n, t.requestUrl = e, setTimeout(function() {
                    n.send()
                }, 0)
            },
            getVideoURL: function(t) {
                for (var e = 0; e < t.length; e++) {
                    var i, s = t[e];
                    if (s.uri) {
                        if (i = s.type, s = s.uri, this.game.device.canPlayVideo(i)) return s
                    } else {
                        if (0 === s.indexOf("blob:") || 0 === s.indexOf("data:")) return s;
                        if (s.indexOf("?") >= 0 && (s = s.substr(0, s.indexOf("?"))), i = s.substr((Math.max(0, s.lastIndexOf(".")) || 1 / 0) + 1).toLowerCase(), this.game.device.canPlayVideo(i)) return t[e]
                    }
                }
                return null
            },
            getAudioURL: function(t) {
                if (this.game.sound.noAudio) return null;
                for (var e = 0; e < t.length; e++) {
                    var i, s = t[e];
                    if (s.uri) {
                        if (i = s.type, s = s.uri, this.game.device.canPlayAudio(i)) return s
                    } else {
                        if (0 === s.indexOf("blob:") || 0 === s.indexOf("data:")) return s;
                        if (s.indexOf("?") >= 0 && (s = s.substr(0, s.indexOf("?"))), i = s.substr((Math.max(0, s.lastIndexOf(".")) || 1 / 0) + 1).toLowerCase(), this.game.device.canPlayAudio(i)) return t[e]
                    }
                }
                return null
            },
            fileError: function(t, e, i) {
                var s = "error loading asset from URL " + (t.requestUrl || this.transformUrl(t.url, t));
                !i && e && (i = e.status), i && (s = s + " (" + i + ")"), this.asyncComplete(t, s)
            },
            fileComplete: function(t, e) {
                var s = !0;
                switch (t.type) {
                    case "packfile":
                        o = JSON.parse(e.responseText);
                        t.data = o || {};
                        break;
                    case "image":
                        this.cache.addImage(t.key, t.url, t.data);
                        break;
                    case "spritesheet":
                        this.cache.addSpriteSheet(t.key, t.url, t.data, t.frameWidth, t.frameHeight, t.frameMax, t.margin, t.spacing);
                        break;
                    case "textureatlas":
                        if (null == t.atlasURL) this.cache.addTextureAtlas(t.key, t.url, t.data, t.atlasData, t.format);
                        else if (s = !1, t.format === i.Loader.TEXTURE_ATLAS_JSON_ARRAY || t.format === i.Loader.TEXTURE_ATLAS_JSON_HASH || t.format === i.Loader.TEXTURE_ATLAS_JSON_PYXEL) this.xhrLoad(t, this.transformUrl(t.atlasURL, t), "text", this.jsonLoadComplete);
                        else {
                            if (t.format !== i.Loader.TEXTURE_ATLAS_XML_STARLING) throw new Error("Phaser.Loader. Invalid Texture Atlas format: " + t.format);
                            this.xhrLoad(t, this.transformUrl(t.atlasURL, t), "text", this.xmlLoadComplete)
                        }
                        break;
                    case "bitmapfont":
                        t.atlasURL ? (s = !1, this.xhrLoad(t, this.transformUrl(t.atlasURL, t), "text", function(t, e) {
                            var i;
                            try {
                                i = JSON.parse(e.responseText)
                            } catch (t) {}
                            i ? (t.atlasType = "json", this.jsonLoadComplete(t, e)) : (t.atlasType = "xml", this.xmlLoadComplete(t, e))
                        })) : this.cache.addBitmapFont(t.key, t.url, t.data, t.atlasData, t.atlasType, t.xSpacing, t.ySpacing);
                        break;
                    case "video":
                        if (t.asBlob) try {
                            t.data = e.response
                        } catch (e) {
                            throw new Error("Phaser.Loader. Unable to parse video file as Blob: " + t.key)
                        }
                        this.cache.addVideo(t.key, t.url, t.data, t.asBlob);
                        break;
                    case "audio":
                        this.game.sound.usingWebAudio ? (t.data = e.response, this.cache.addSound(t.key, t.url, t.data, !0, !1), t.autoDecode && this.game.sound.decode(t.key)) : this.cache.addSound(t.key, t.url, t.data, !1, !0);
                        break;
                    case "text":
                        t.data = e.responseText, this.cache.addText(t.key, t.url, t.data);
                        break;
                    case "shader":
                        t.data = e.responseText, this.cache.addShader(t.key, t.url, t.data);
                        break;
                    case "physics":
                        var o = JSON.parse(e.responseText);
                        this.cache.addPhysicsData(t.key, t.url, o, t.format);
                        break;
                    case "script":
                        t.data = document.createElement("script"), t.data.language = "javascript", t.data.type = "text/javascript", t.data.defer = !1, t.data.text = e.responseText, document.head.appendChild(t.data), t.callback && (t.data = t.callback.call(t.callbackContext, t.key, e.responseText));
                        break;
                    case "binary":
                        t.callback ? t.data = t.callback.call(t.callbackContext, t.key, e.response) : t.data = e.response, this.cache.addBinary(t.key, t.data)
                }
                s && this.asyncComplete(t)
            },
            jsonLoadComplete: function(t, e) {
                var i = JSON.parse(e.responseText);
                "tilemap" === t.type ? this.cache.addTilemap(t.key, t.url, i, t.format) : "bitmapfont" === t.type ? this.cache.addBitmapFont(t.key, t.url, t.data, i, t.atlasType, t.xSpacing, t.ySpacing) : "json" === t.type ? this.cache.addJSON(t.key, t.url, i) : this.cache.addTextureAtlas(t.key, t.url, t.data, i, t.format), this.asyncComplete(t)
            },
            csvLoadComplete: function(t, e) {
                var i = e.responseText;
                this.cache.addTilemap(t.key, t.url, i, t.format), this.asyncComplete(t)
            },
            xmlLoadComplete: function(t, e) {
                var i = e.responseText,
                    s = this.parseXml(i);
                if (!s) {
                    var o = e.responseType || e.contentType;
                    return console.warn("Phaser.Loader - " + t.key + ": invalid XML (" + o + ")"), void this.asyncComplete(t, "invalid XML")
                }
                "bitmapfont" === t.type ? this.cache.addBitmapFont(t.key, t.url, t.data, s, t.atlasType, t.xSpacing, t.ySpacing) : "textureatlas" === t.type ? this.cache.addTextureAtlas(t.key, t.url, t.data, s, t.format) : "xml" === t.type && this.cache.addXML(t.key, t.url, s), this.asyncComplete(t)
            },
            parseXml: function(t) {
                var e;
                try {
                    if (window.DOMParser) {
                        var i = new DOMParser;
                        e = i.parseFromString(t, "text/xml")
                    } else e = new ActiveXObject("Microsoft.XMLDOM"), e.async = "false", e.loadXML(t)
                } catch (t) {
                    e = null
                }
                return e && e.documentElement && !e.getElementsByTagName("parsererror").length ? e : null
            },
            updateProgress: function() {
                this.preloadSprite && (0 === this.preloadSprite.direction ? this.preloadSprite.rect.width = Math.floor(this.preloadSprite.width / 100 * this.progress) : this.preloadSprite.rect.height = Math.floor(this.preloadSprite.height / 100 * this.progress), this.preloadSprite.sprite ? this.preloadSprite.sprite.updateCrop() : this.preloadSprite = null)
            },
            totalLoadedFiles: function() {
                return this._loadedFileCount
            },
            totalQueuedFiles: function() {
                return this._totalFileCount - this._loadedFileCount
            },
            totalLoadedPacks: function() {
                return this._totalPackCount
            },
            totalQueuedPacks: function() {
                return this._totalPackCount - this._loadedPackCount
            }
        }, Object.defineProperty(i.Loader.prototype, "progressFloat", {
            get: function() {
                var t = this._loadedFileCount / this._totalFileCount * 100;
                return i.Math.clamp(t || 0, 0, 100)
            }
        }), Object.defineProperty(i.Loader.prototype, "progress", {
            get: function() {
                return Math.round(this.progressFloat)
            }
        }), i.Loader.prototype.constructor = i.Loader, i.LoaderParser = {
            bitmapFont: function(t, e, i, s) {
                return this.xmlBitmapFont(t, e, i, s)
            },
            xmlBitmapFont: function(t, e, i, s) {
                var o = {},
                    n = t.getElementsByTagName("info")[0],
                    a = t.getElementsByTagName("common")[0];
                o.font = n.getAttribute("face"), o.size = parseInt(n.getAttribute("size"), 10), o.lineHeight = parseInt(a.getAttribute("lineHeight"), 10) + s, o.chars = {};
                for (var r = t.getElementsByTagName("char"), h = 0; h < r.length; h++) {
                    var l = parseInt(r[h].getAttribute("id"), 10);
                    o.chars[l] = {
                        x: parseInt(r[h].getAttribute("x"), 10),
                        y: parseInt(r[h].getAttribute("y"), 10),
                        width: parseInt(r[h].getAttribute("width"), 10),
                        height: parseInt(r[h].getAttribute("height"), 10),
                        xOffset: parseInt(r[h].getAttribute("xoffset"), 10),
                        yOffset: parseInt(r[h].getAttribute("yoffset"), 10),
                        xAdvance: parseInt(r[h].getAttribute("xadvance"), 10) + i,
                        kerning: {}
                    }
                }
                var c = t.getElementsByTagName("kerning");
                for (h = 0; h < c.length; h++) {
                    var p = parseInt(c[h].getAttribute("first"), 10),
                        u = parseInt(c[h].getAttribute("second"), 10),
                        d = parseInt(c[h].getAttribute("amount"), 10);
                    o.chars[u].kerning[p] = d
                }
                return this.finalizeBitmapFont(e, o)
            },
            jsonBitmapFont: function(t, e, i, s) {
                var o = {
                    font: t.font.info._face,
                    size: parseInt(t.font.info._size, 10),
                    lineHeight: parseInt(t.font.common._lineHeight, 10) + s,
                    chars: {}
                };
                return t.font.chars.char.forEach(function(t) {
                    var e = parseInt(t._id, 10);
                    o.chars[e] = {
                        x: parseInt(t._x, 10),
                        y: parseInt(t._y, 10),
                        width: parseInt(t._width, 10),
                        height: parseInt(t._height, 10),
                        xOffset: parseInt(t._xoffset, 10),
                        yOffset: parseInt(t._yoffset, 10),
                        xAdvance: parseInt(t._xadvance, 10) + i,
                        kerning: {}
                    }
                }), t.font.kernings && t.font.kernings.kerning && t.font.kernings.kerning.forEach(function(t) {
                    o.chars[t._second].kerning[t._first] = parseInt(t._amount, 10)
                }), this.finalizeBitmapFont(e, o)
            },
            finalizeBitmapFont: function(t, e) {
                return Object.keys(e.chars).forEach(function(s) {
                    var o = e.chars[s];
                    o.texture = new PIXI.Texture(t, new i.Rectangle(o.x, o.y, o.width, o.height))
                }), e
            }
        }, i.AudioSprite = function(t, e) {
            this.game = t, this.key = e, this.config = this.game.cache.getJSON(e + "-audioatlas"), this.autoplayKey = null, this.autoplay = !1, this.sounds = {};
            for (var i in this.config.spritemap) {
                var s = this.config.spritemap[i],
                    o = this.game.add.sound(this.key);
                o.addMarker(i, s.start, s.end - s.start, null, s.loop), this.sounds[i] = o
            }
            this.config.autoplay && (this.autoplayKey = this.config.autoplay, this.play(this.autoplayKey), this.autoplay = this.sounds[this.autoplayKey])
        }, i.AudioSprite.prototype = {
            play: function(t, e) {
                return void 0 === e && (e = 1), this.sounds[t].play(t, null, e)
            },
            stop: function(t) {
                if (t) this.sounds[t].stop();
                else
                    for (var e in this.sounds) this.sounds[e].stop()
            },
            get: function(t) {
                return this.sounds[t]
            }
        }, i.AudioSprite.prototype.constructor = i.AudioSprite, i.Sound = function(t, e, s, o, n) {
            void 0 === s && (s = 1), void 0 === o && (o = !1), void 0 === n && (n = t.sound.connectToMaster), this.game = t, this.name = e, this.key = e, this.loop = o, this.markers = {}, this.context = null, this.autoplay = !1, this.totalDuration = 0, this.startTime = 0, this.currentTime = 0, this.duration = 0, this.durationMS = 0, this.position = 0, this.stopTime = 0, this.paused = !1, this.pausedPosition = 0, this.pausedTime = 0, this.isPlaying = !1, this.currentMarker = "", this.fadeTween = null, this.pendingPlayback = !1, this.override = !1, this.allowMultiple = !1, this.usingWebAudio = this.game.sound.usingWebAudio, this.usingAudioTag = this.game.sound.usingAudioTag, this.externalNode = null, this.masterGainNode = null, this.gainNode = null, this._sound = null, this.usingWebAudio ? (this.context = this.game.sound.context, this.masterGainNode = this.game.sound.masterGain, void 0 === this.context.createGain ? this.gainNode = this.context.createGainNode() : this.gainNode = this.context.createGain(), this.gainNode.gain.value = s * this.game.sound.volume, n && this.gainNode.connect(this.masterGainNode)) : this.usingAudioTag && (this.game.cache.getSound(e) && this.game.cache.isSoundReady(e) ? (this._sound = this.game.cache.getSoundData(e), this.totalDuration = 0, this._sound.duration && (this.totalDuration = this._sound.duration)) : this.game.cache.onSoundUnlock.add(this.soundHasUnlocked, this)), this.onDecoded = new i.Signal, this.onPlay = new i.Signal, this.onPause = new i.Signal, this.onResume = new i.Signal, this.onLoop = new i.Signal, this.onStop = new i.Signal, this.onMute = new i.Signal, this.onMarkerComplete = new i.Signal, this.onFadeComplete = new i.Signal, this._volume = s, this._buffer = null, this._muted = !1, this._tempMarker = 0, this._tempPosition = 0, this._tempVolume = 0, this._tempPause = 0, this._muteVolume = 0, this._tempLoop = 0, this._paused = !1, this._onDecodedEventDispatched = !1
        }, i.Sound.prototype = {
            soundHasUnlocked: function(t) {
                t === this.key && (this._sound = this.game.cache.getSoundData(this.key), this.totalDuration = this._sound.duration)
            },
            addMarker: function(t, e, i, s, o) {
                void 0 !== i && null !== i || (i = 1), void 0 !== s && null !== s || (s = 1), void 0 === o && (o = !1), this.markers[t] = {
                    name: t,
                    start: e,
                    stop: e + i,
                    volume: s,
                    duration: i,
                    durationMS: 1e3 * i,
                    loop: o
                }
            },
            removeMarker: function(t) {
                delete this.markers[t]
            },
            onEndedHandler: function() {
                this._sound.onended = null, this.isPlaying = !1, this.currentTime = this.durationMS, this.stop()
            },
            update: function() {
                return this.game.cache.checkSoundKey(this.key) ? (this.isDecoded && !this._onDecodedEventDispatched && (this.onDecoded.dispatch(this), this._onDecodedEventDispatched = !0), this.pendingPlayback && this.game.cache.isSoundReady(this.key) && (this.pendingPlayback = !1, this.play(this._tempMarker, this._tempPosition, this._tempVolume, this._tempLoop)), void(this.isPlaying && (this.currentTime = this.game.time.time - this.startTime, this.currentTime >= this.durationMS && (this.usingWebAudio ? this.loop ? (this.onLoop.dispatch(this), this.isPlaying = !1, "" === this.currentMarker ? (this.currentTime = 0, this.startTime = this.game.time.time, this.isPlaying = !0) : (this.onMarkerComplete.dispatch(this.currentMarker, this), this.play(this.currentMarker, 0, this.volume, !0, !0))) : "" !== this.currentMarker && this.stop() : this.loop ? (this.onLoop.dispatch(this), "" === this.currentMarker && (this.currentTime = 0, this.startTime = this.game.time.time), this.isPlaying = !1, this.play(this.currentMarker, 0, this.volume, !0, !0)) : this.stop())))) : void this.destroy()
            },
            loopFull: function(t) {
                return this.play(null, 0, t, !0)
            },
            play: function(t, e, i, s, o) {
                if (void 0 !== t && !1 !== t && null !== t || (t = ""), void 0 === o && (o = !0), this.isPlaying && !this.allowMultiple && !o && !this.override) return this;
                if (this._sound && this.isPlaying && !this.allowMultiple && (this.override || o)) {
                    if (this.usingWebAudio) {
                        if (void 0 === this._sound.stop) this._sound.noteOff(0);
                        else try {
                            this._sound.stop(0)
                        } catch (t) {}
                        this.externalNode ? this._sound.disconnect(this.externalNode) : this.gainNode && this._sound.disconnect(this.gainNode)
                    } else this.usingAudioTag && (this._sound.pause(), this._sound.currentTime = 0);
                    this.isPlaying = !1
                }
                if ("" === t && Object.keys(this.markers).length > 0) return this;
                if ("" !== t) {
                    if (!this.markers[t]) return console.warn("Phaser.Sound.play: audio marker " + t + " doesn't exist"), this;
                    this.currentMarker = t, this.position = this.markers[t].start, this.volume = this.markers[t].volume, this.loop = this.markers[t].loop, this.duration = this.markers[t].duration, this.durationMS = this.markers[t].durationMS, void 0 !== i && (this.volume = i), void 0 !== s && (this.loop = s), this._tempMarker = t, this._tempPosition = this.position, this._tempVolume = this.volume, this._tempLoop = this.loop
                } else e = e || 0, void 0 === i && (i = this._volume), void 0 === s && (s = this.loop), this.position = Math.max(0, e), this.volume = i, this.loop = s, this.duration = 0, this.durationMS = 0, this._tempMarker = t, this._tempPosition = e, this._tempVolume = i, this._tempLoop = s;
                return this.usingWebAudio ? this.game.cache.isSoundDecoded(this.key) ? (this._sound = this.context.createBufferSource(), this.externalNode ? this._sound.connect(this.externalNode) : this._sound.connect(this.gainNode), this._buffer = this.game.cache.getSoundData(this.key), this._sound.buffer = this._buffer, this.loop && "" === t && (this._sound.loop = !0), this.loop || "" !== t || (this._sound.onended = this.onEndedHandler.bind(this)), this.totalDuration = this._sound.buffer.duration, 0 === this.duration && (this.duration = this.totalDuration, this.durationMS = Math.ceil(1e3 * this.totalDuration)), void 0 === this._sound.start ? this._sound.noteGrainOn(0, this.position, this.duration) : this.loop && "" === t ? this._sound.start(0, 0) : this._sound.start(0, this.position, this.duration), this.isPlaying = !0, this.startTime = this.game.time.time, this.currentTime = 0, this.stopTime = this.startTime + this.durationMS, this.onPlay.dispatch(this)) : (this.pendingPlayback = !0, this.game.cache.getSound(this.key) && !1 === this.game.cache.getSound(this.key).isDecoding && this.game.sound.decode(this.key, this)) : this.game.cache.getSound(this.key) && this.game.cache.getSound(this.key).locked ? (this.game.cache.reloadSound(this.key), this.pendingPlayback = !0) : this._sound && (this.game.device.cocoonJS || 4 === this._sound.readyState) ? (this._sound.play(), this.totalDuration = this._sound.duration, 0 === this.duration && (this.duration = this.totalDuration, this.durationMS = 1e3 * this.totalDuration), this._sound.currentTime = this.position, this._sound.muted = this._muted, this._muted || this.game.sound.mute ? this._sound.volume = 0 : this._sound.volume = this._volume, this.isPlaying = !0, this.startTime = this.game.time.time, this.currentTime = 0, this.stopTime = this.startTime + this.durationMS, this.onPlay.dispatch(this)) : this.pendingPlayback = !0, this
            },
            restart: function(t, e, i, s) {
                t = t || "", e = e || 0, i = i || 1, void 0 === s && (s = !1), this.play(t, e, i, s, !0)
            },
            pause: function() {
                this.isPlaying && this._sound && (this.paused = !0, this.pausedPosition = this.currentTime, this.pausedTime = this.game.time.time, this._tempPause = this._sound.currentTime, this.onPause.dispatch(this), this.stop())
            },
            resume: function() {
                if (this.paused && this._sound) {
                    if (this.usingWebAudio) {
                        var t = Math.max(0, this.position + this.pausedPosition / 1e3);
                        this._sound = this.context.createBufferSource(), this._sound.buffer = this._buffer, this.externalNode ? this._sound.connect(this.externalNode) : this._sound.connect(this.gainNode), this.loop && (this._sound.loop = !0), this.loop || "" !== this.currentMarker || (this._sound.onended = this.onEndedHandler.bind(this));
                        var e = this.duration - this.pausedPosition / 1e3;
                        void 0 === this._sound.start ? this._sound.noteGrainOn(0, t, e) : this.loop && this.game.device.chrome ? 42 === this.game.device.chromeVersion ? this._sound.start(0) : this._sound.start(0, t) : this._sound.start(0, t, e)
                    } else this._sound.currentTime = this._tempPause, this._sound.play();
                    this.isPlaying = !0, this.paused = !1, this.startTime += this.game.time.time - this.pausedTime, this.onResume.dispatch(this)
                }
            },
            stop: function() {
                if (this.isPlaying && this._sound)
                    if (this.usingWebAudio) {
                        if (void 0 === this._sound.stop) this._sound.noteOff(0);
                        else try {
                            this._sound.stop(0)
                        } catch (t) {}
                        this.externalNode ? this._sound.disconnect(this.externalNode) : this.gainNode && this._sound.disconnect(this.gainNode)
                    } else this.usingAudioTag && (this._sound.pause(), this._sound.currentTime = 0);
                if (this.pendingPlayback = !1, this.isPlaying = !1, !this.paused) {
                    var t = this.currentMarker;
                    "" !== this.currentMarker && this.onMarkerComplete.dispatch(this.currentMarker, this), this.currentMarker = "", null !== this.fadeTween && this.fadeTween.stop(), this.onStop.dispatch(this, t)
                }
            },
            fadeIn: function(t, e, i) {
                void 0 === e && (e = !1), void 0 === i && (i = this.currentMarker), this.paused || (this.play(i, 0, 0, e), this.fadeTo(t, 1))
            },
            fadeOut: function(t) {
                this.fadeTo(t, 0)
            },
            fadeTo: function(t, e) {
                if (this.isPlaying && !this.paused && e !== this.volume) {
                    if (void 0 === t && (t = 1e3), void 0 === e) return void console.warn("Phaser.Sound.fadeTo: No Volume Specified.");
                    this.fadeTween = this.game.add.tween(this).to({
                        volume: e
                    }, t, i.Easing.Linear.None, !0), this.fadeTween.onComplete.add(this.fadeComplete, this)
                }
            },
            fadeComplete: function() {
                this.onFadeComplete.dispatch(this, this.volume), 0 === this.volume && this.stop()
            },
            updateGlobalVolume: function(t) {
                this.usingAudioTag && this._sound && (this._sound.volume = t * this._volume)
            },
            destroy: function(t) {
                void 0 === t && (t = !0), this.stop(), t ? this.game.sound.remove(this) : (this.markers = {}, this.context = null, this._buffer = null, this.externalNode = null, this.onDecoded.dispose(), this.onPlay.dispose(), this.onPause.dispose(), this.onResume.dispose(), this.onLoop.dispose(), this.onStop.dispose(), this.onMute.dispose(), this.onMarkerComplete.dispose())
            }
        }, i.Sound.prototype.constructor = i.Sound, Object.defineProperty(i.Sound.prototype, "isDecoding", {
            get: function() {
                return this.game.cache.getSound(this.key).isDecoding
            }
        }), Object.defineProperty(i.Sound.prototype, "isDecoded", {
            get: function() {
                return this.game.cache.isSoundDecoded(this.key)
            }
        }), Object.defineProperty(i.Sound.prototype, "mute", {
            get: function() {
                return this._muted || this.game.sound.mute
            },
            set: function(t) {
                (t = t || !1) !== this._muted && (t ? (this._muted = !0, this._muteVolume = this._tempVolume, this.usingWebAudio ? this.gainNode.gain.value = 0 : this.usingAudioTag && this._sound && (this._sound.volume = 0)) : (this._muted = !1, this.usingWebAudio ? this.gainNode.gain.value = this._muteVolume : this.usingAudioTag && this._sound && (this._sound.volume = this._muteVolume)), this.onMute.dispatch(this))
            }
        }), Object.defineProperty(i.Sound.prototype, "volume", {
            get: function() {
                return this._volume
            },
            set: function(t) {
                return this.game.device.firefox && this.usingAudioTag && (t = this.game.math.clamp(t, 0, 1)), this._muted ? void(this._muteVolume = t) : (this._tempVolume = t, this._volume = t, void(this.usingWebAudio ? this.gainNode.gain.value = t : this.usingAudioTag && this._sound && (this._sound.volume = t)))
            }
        }), i.SoundManager = function(t) {
            this.game = t, this.onSoundDecode = new i.Signal, this.onVolumeChange = new i.Signal, this.onMute = new i.Signal, this.onUnMute = new i.Signal, this.context = null, this.usingWebAudio = !1, this.usingAudioTag = !1, this.noAudio = !1, this.connectToMaster = !0, this.touchLocked = !1, this.channels = 32, this.muteOnPause = !0, this._codeMuted = !1, this._muted = !1, this._unlockSource = null, this._volume = 1, this._sounds = [], this._watchList = new i.ArraySet, this._watching = !1, this._watchCallback = null, this._watchContext = null
        }, i.SoundManager.prototype = {
            boot: function() {
                if (this.game.device.iOS && !1 === this.game.device.webAudio && (this.channels = 1), window.PhaserGlobal) {
                    if (!0 === window.PhaserGlobal.disableAudio) return this.noAudio = !0, void(this.touchLocked = !1);
                    if (!0 === window.PhaserGlobal.disableWebAudio) return this.usingAudioTag = !0, void(this.touchLocked = !1)
                }
                if (window.PhaserGlobal && window.PhaserGlobal.audioContext) this.context = window.PhaserGlobal.audioContext;
                else if (window.AudioContext) try {
                    this.context = new window.AudioContext
                } catch (t) {
                    this.context = null, this.usingWebAudio = !1, this.touchLocked = !1
                } else if (window.webkitAudioContext) try {
                    this.context = new window.webkitAudioContext
                } catch (t) {
                    this.context = null, this.usingWebAudio = !1, this.touchLocked = !1
                }
                if (null === this.context) {
                    if (void 0 === window.Audio) return void(this.noAudio = !0);
                    this.usingAudioTag = !0
                } else this.usingWebAudio = !0, void 0 === this.context.createGain ? this.masterGain = this.context.createGainNode() : this.masterGain = this.context.createGain(), this.masterGain.gain.value = 1, this.masterGain.connect(this.context.destination);
                this.noAudio || (!this.game.device.cocoonJS && this.game.device.iOS || window.PhaserGlobal && window.PhaserGlobal.fakeiOSTouchLock) && this.setTouchLock()
            },
            setTouchLock: function() {
                this.noAudio || window.PhaserGlobal && !0 === window.PhaserGlobal.disableAudio || (this.game.device.iOSVersion > 8 ? this.game.input.touch.addTouchLockCallback(this.unlock, this, !0) : this.game.input.touch.addTouchLockCallback(this.unlock, this), this.touchLocked = !0)
            },
            unlock: function() {
                if (this.noAudio || !this.touchLocked || null !== this._unlockSource) return !0;
                if (this.usingAudioTag) this.touchLocked = !1, this._unlockSource = null;
                else if (this.usingWebAudio) {
                    var t = this.context.createBuffer(1, 1, 22050);
                    this._unlockSource = this.context.createBufferSource(), this._unlockSource.buffer = t, this._unlockSource.connect(this.context.destination), void 0 === this._unlockSource.start ? this._unlockSource.noteOn(0) : this._unlockSource.start(0)
                }
                return !0
            },
            stopAll: function() {
                if (!this.noAudio)
                    for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].stop()
            },
            pauseAll: function() {
                if (!this.noAudio)
                    for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].pause()
            },
            resumeAll: function() {
                if (!this.noAudio)
                    for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].resume()
            },
            decode: function(t, e) {
                e = e || null;
                var i = this.game.cache.getSoundData(t);
                if (i && !1 === this.game.cache.isSoundDecoded(t)) {
                    this.game.cache.updateSound(t, "isDecoding", !0);
                    var s = this;
                    try {
                        this.context.decodeAudioData(i, function(i) {
                            i && (s.game.cache.decodedSound(t, i), s.onSoundDecode.dispatch(t, e))
                        })
                    } catch (t) {}
                }
            },
            setDecodedCallback: function(t, e, s) {
                "string" == typeof t && (t = [t]), this._watchList.reset();
                for (var o = 0; o < t.length; o++) t[o] instanceof i.Sound ? this.game.cache.isSoundDecoded(t[o].key) || this._watchList.add(t[o].key) : this.game.cache.isSoundDecoded(t[o]) || this._watchList.add(t[o]);
                0 === this._watchList.total ? (this._watching = !1, e.call(s)) : (this._watching = !0, this._watchCallback = e, this._watchContext = s)
            },
            update: function() {
                if (!this.noAudio) {
                    !this.touchLocked || null === this._unlockSource || this._unlockSource.playbackState !== this._unlockSource.PLAYING_STATE && this._unlockSource.playbackState !== this._unlockSource.FINISHED_STATE || (this.touchLocked = !1, this._unlockSource = null);
                    for (var t = 0; t < this._sounds.length; t++) this._sounds[t].update();
                    if (this._watching) {
                        for (var e = this._watchList.first; e;) this.game.cache.isSoundDecoded(e) && this._watchList.remove(e), e = this._watchList.next;
                        0 === this._watchList.total && (this._watching = !1, this._watchCallback.call(this._watchContext))
                    }
                }
            },
            add: function(t, e, s, o) {
                void 0 === e && (e = 1), void 0 === s && (s = !1), void 0 === o && (o = this.connectToMaster);
                var n = new i.Sound(this.game, t, e, s, o);
                return this._sounds.push(n), n
            },
            addSprite: function(t) {
                return new i.AudioSprite(this.game, t)
            },
            remove: function(t) {
                for (var e = this._sounds.length; e--;)
                    if (this._sounds[e] === t) return this._sounds[e].destroy(!1), this._sounds.splice(e, 1), !0;
                return !1
            },
            removeByKey: function(t) {
                for (var e = this._sounds.length, i = 0; e--;) this._sounds[e].key === t && (this._sounds[e].destroy(!1), this._sounds.splice(e, 1), i++);
                return i
            },
            play: function(t, e, i) {
                if (!this.noAudio) {
                    var s = this.add(t, e, i);
                    return s.play(), s
                }
            },
            setMute: function() {
                if (!this._muted) {
                    this._muted = !0, this.usingWebAudio && (this._muteVolume = this.masterGain.gain.value, this.masterGain.gain.value = 0);
                    for (var t = 0; t < this._sounds.length; t++) this._sounds[t].usingAudioTag && (this._sounds[t].mute = !0);
                    this.onMute.dispatch()
                }
            },
            unsetMute: function() {
                if (this._muted && !this._codeMuted) {
                    this._muted = !1, this.usingWebAudio && (this.masterGain.gain.value = this._muteVolume);
                    for (var t = 0; t < this._sounds.length; t++) this._sounds[t].usingAudioTag && (this._sounds[t].mute = !1);
                    this.onUnMute.dispatch()
                }
            },
            destroy: function() {
                this.stopAll();
                for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].destroy();
                this._sounds = [], this.onSoundDecode.dispose(), this.context && (window.PhaserGlobal ? window.PhaserGlobal.audioContext = this.context : this.context.close && this.context.close())
            }
        }, i.SoundManager.prototype.constructor = i.SoundManager, Object.defineProperty(i.SoundManager.prototype, "mute", {
            get: function() {
                return this._muted
            },
            set: function(t) {
                if (t = t || !1) {
                    if (this._muted) return;
                    this._codeMuted = !0, this.setMute()
                } else {
                    if (!this._muted) return;
                    this._codeMuted = !1, this.unsetMute()
                }
            }
        }), Object.defineProperty(i.SoundManager.prototype, "volume", {
            get: function() {
                return this._volume
            },
            set: function(t) {
                if (t < 0 ? t = 0 : t > 1 && (t = 1), this._volume !== t) {
                    if (this._volume = t, this.usingWebAudio) this.masterGain.gain.value = t;
                    else
                        for (var e = 0; e < this._sounds.length; e++) this._sounds[e].usingAudioTag && this._sounds[e].updateGlobalVolume(t);
                    this.onVolumeChange.dispatch(t)
                }
            }
        }), i.ScaleManager = function(t, e, s) {
            this.game = t, this.dom = i.DOM, this.grid = null, this.width = 0, this.height = 0, this.minWidth = null, this.maxWidth = null, this.minHeight = null, this.maxHeight = null, this.offset = new i.Point, this.forceLandscape = !1, this.forcePortrait = !1, this.incorrectOrientation = !1, this._pageAlignHorizontally = !1, this._pageAlignVertically = !1, this.onOrientationChange = new i.Signal, this.enterIncorrectOrientation = new i.Signal, this.leaveIncorrectOrientation = new i.Signal, this.hasPhaserSetFullScreen = !1, this.fullScreenTarget = null, this._createdFullScreenTarget = null, this.onFullScreenInit = new i.Signal, this.onFullScreenChange = new i.Signal, this.onFullScreenError = new i.Signal, this.screenOrientation = this.dom.getScreenOrientation(), this.scaleFactor = new i.Point(1, 1), this.scaleFactorInversed = new i.Point(1, 1), this.margin = {
                left: 0,
                top: 0,
                right: 0,
                bottom: 0,
                x: 0,
                y: 0
            }, this.bounds = new i.Rectangle, this.aspectRatio = 0, this.sourceAspectRatio = 0, this.event = null, this.windowConstraints = {
                right: "layout",
                bottom: ""
            }, this.compatibility = {
                supportsFullScreen: !1,
                orientationFallback: null,
                noMargins: !1,
                scrollTo: null,
                forceMinimumDocumentHeight: !1,
                canExpandParent: !0,
                clickTrampoline: ""
            }, this._scaleMode = i.ScaleManager.NO_SCALE, this._fullScreenScaleMode = i.ScaleManager.NO_SCALE, this.parentIsWindow = !1, this.parentNode = null, this.parentScaleFactor = new i.Point(1, 1), this.trackParentInterval = 2e3, this.onSizeChange = new i.Signal, this.onResize = null, this.onResizeContext = null, this._pendingScaleMode = null, this._fullScreenRestore = null, this._gameSize = new i.Rectangle, this._userScaleFactor = new i.Point(1, 1), this._userScaleTrim = new i.Point(0, 0), this._lastUpdate = 0, this._updateThrottle = 0, this._updateThrottleReset = 100, this._parentBounds = new i.Rectangle, this._tempBounds = new i.Rectangle, this._lastReportedCanvasSize = new i.Rectangle, this._lastReportedGameSize = new i.Rectangle, this._booted = !1, t.config && this.parseConfig(t.config), this.setupScale(e, s)
        }, i.ScaleManager.EXACT_FIT = 0, i.ScaleManager.NO_SCALE = 1, i.ScaleManager.SHOW_ALL = 2, i.ScaleManager.RESIZE = 3, i.ScaleManager.USER_SCALE = 4, i.ScaleManager.prototype = {
            boot: function() {
                var t = this.compatibility;
                t.supportsFullScreen = this.game.device.fullscreen && !this.game.device.cocoonJS, this.game.device.iPad || this.game.device.webApp || this.game.device.desktop || (this.game.device.android && !this.game.device.chrome ? t.scrollTo = new i.Point(0, 1) : t.scrollTo = new i.Point(0, 0)), this.game.device.desktop ? (t.orientationFallback = "screen", t.clickTrampoline = "when-not-mouse") : (t.orientationFallback = "", t.clickTrampoline = "");
                var e = this;
                this._orientationChange = function(t) {
                    return e.orientationChange(t)
                }, this._windowResize = function(t) {
                    return e.windowResize(t)
                }, window.addEventListener("orientationchange", this._orientationChange, !1), window.addEventListener("resize", this._windowResize, !1), this.compatibility.supportsFullScreen && (this._fullScreenChange = function(t) {
                    return e.fullScreenChange(t)
                }, this._fullScreenError = function(t) {
                    return e.fullScreenError(t)
                }, document.addEventListener("webkitfullscreenchange", this._fullScreenChange, !1), document.addEventListener("mozfullscreenchange", this._fullScreenChange, !1), document.addEventListener("MSFullscreenChange", this._fullScreenChange, !1), document.addEventListener("fullscreenchange", this._fullScreenChange, !1), document.addEventListener("webkitfullscreenerror", this._fullScreenError, !1), document.addEventListener("mozfullscreenerror", this._fullScreenError, !1), document.addEventListener("MSFullscreenError", this._fullScreenError, !1), document.addEventListener("fullscreenerror", this._fullScreenError, !1)), this.game.onResume.add(this._gameResumed, this), this.dom.getOffset(this.game.canvas, this.offset), this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height), this.setGameSize(this.game.width, this.game.height), this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback), i.FlexGrid && (this.grid = new i.FlexGrid(this, this.width, this.height)), this._booted = !0, null !== this._pendingScaleMode && (this.scaleMode = this._pendingScaleMode, this._pendingScaleMode = null)
            },
            parseConfig: function(t) {
                void 0 !== t.scaleMode && (this._booted ? this.scaleMode = t.scaleMode : this._pendingScaleMode = t.scaleMode), void 0 !== t.fullScreenScaleMode && (this.fullScreenScaleMode = t.fullScreenScaleMode), t.fullScreenTarget && (this.fullScreenTarget = t.fullScreenTarget)
            },
            setupScale: function(t, e) {
                var s, o = new i.Rectangle;
                "" !== this.game.parent && ("string" == typeof this.game.parent ? s = document.getElementById(this.game.parent) : this.game.parent && 1 === this.game.parent.nodeType && (s = this.game.parent)), s ? (this.parentNode = s, this.parentIsWindow = !1, this.getParentBounds(this._parentBounds), o.width = this._parentBounds.width, o.height = this._parentBounds.height, this.offset.set(this._parentBounds.x, this._parentBounds.y)) : (this.parentNode = null, this.parentIsWindow = !0, o.width = this.dom.visualBounds.width, o.height = this.dom.visualBounds.height, this.offset.set(0, 0));
                var n = 0,
                    a = 0;
                "number" == typeof t ? n = t : (this.parentScaleFactor.x = parseInt(t, 10) / 100, n = o.width * this.parentScaleFactor.x), "number" == typeof e ? a = e : (this.parentScaleFactor.y = parseInt(e, 10) / 100, a = o.height * this.parentScaleFactor.y), n = Math.floor(n), a = Math.floor(a), this._gameSize.setTo(0, 0, n, a), this.updateDimensions(n, a, !1)
            },
            _gameResumed: function() {
                this.queueUpdate(!0)
            },
            setGameSize: function(t, e) {
                this._gameSize.setTo(0, 0, t, e), this.currentScaleMode !== i.ScaleManager.RESIZE && this.updateDimensions(t, e, !0), this.queueUpdate(!0)
            },
            setUserScale: function(t, e, i, s) {
                this._userScaleFactor.setTo(t, e), this._userScaleTrim.setTo(0 | i, 0 | s), this.queueUpdate(!0)
            },
            setResizeCallback: function(t, e) {
                this.onResize = t, this.onResizeContext = e
            },
            signalSizeChange: function() {
                if (!i.Rectangle.sameDimensions(this, this._lastReportedCanvasSize) || !i.Rectangle.sameDimensions(this.game, this._lastReportedGameSize)) {
                    var t = this.width,
                        e = this.height;
                    this._lastReportedCanvasSize.setTo(0, 0, t, e), this._lastReportedGameSize.setTo(0, 0, this.game.width, this.game.height), this.grid && this.grid.onResize(t, e), this.onSizeChange.dispatch(this, t, e), this.currentScaleMode === i.ScaleManager.RESIZE && (this.game.state.resize(t, e), this.game.load.resize(t, e))
                }
            },
            setMinMax: function(t, e, i, s) {
                this.minWidth = t, this.minHeight = e, void 0 !== i && (this.maxWidth = i), void 0 !== s && (this.maxHeight = s)
            },
            preUpdate: function() {
                if (!(this.game.time.time < this._lastUpdate + this._updateThrottle)) {
                    var t = this._updateThrottle;
                    this._updateThrottleReset = t >= 400 ? 0 : 100, this.dom.getOffset(this.game.canvas, this.offset);
                    var e = this._parentBounds.width,
                        s = this._parentBounds.height,
                        o = this.getParentBounds(this._parentBounds),
                        n = o.width !== e || o.height !== s,
                        a = this.updateOrientationState();
                    (n || a) && (this.onResize && this.onResize.call(this.onResizeContext, this, o), this.updateLayout(), this.signalSizeChange());
                    var r = 2 * this._updateThrottle;
                    this._updateThrottle < t && (r = Math.min(t, this._updateThrottleReset)), this._updateThrottle = i.Math.clamp(r, 25, this.trackParentInterval), this._lastUpdate = this.game.time.time
                }
            },
            pauseUpdate: function() {
                this.preUpdate(), this._updateThrottle = this.trackParentInterval
            },
            updateDimensions: function(t, e, i) {
                this.width = t * this.parentScaleFactor.x, this.height = e * this.parentScaleFactor.y, this.game.width = this.width, this.game.height = this.height, this.sourceAspectRatio = this.width / this.height, this.updateScalingAndBounds(), i && (this.game.renderer.resize(this.width, this.height), this.game.camera.setSize(this.width, this.height), this.game.world.resize(this.width, this.height))
            },
            updateScalingAndBounds: function() {
                this.scaleFactor.x = this.game.width / this.width, this.scaleFactor.y = this.game.height / this.height, this.scaleFactorInversed.x = this.width / this.game.width, this.scaleFactorInversed.y = this.height / this.game.height, this.aspectRatio = this.width / this.height, this.game.canvas && this.dom.getOffset(this.game.canvas, this.offset), this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height), this.game.input && this.game.input.scale && this.game.input.scale.setTo(this.scaleFactor.x, this.scaleFactor.y)
            },
            forceOrientation: function(t, e) {
                void 0 === e && (e = !1), this.forceLandscape = t, this.forcePortrait = e, this.queueUpdate(!0)
            },
            classifyOrientation: function(t) {
                return "portrait-primary" === t || "portrait-secondary" === t ? "portrait" : "landscape-primary" === t || "landscape-secondary" === t ? "landscape" : null
            },
            updateOrientationState: function() {
                var t = this.screenOrientation,
                    e = this.incorrectOrientation;
                this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback), this.incorrectOrientation = this.forceLandscape && !this.isLandscape || this.forcePortrait && !this.isPortrait;
                var i = t !== this.screenOrientation,
                    s = e !== this.incorrectOrientation;
                return s && (this.incorrectOrientation ? this.enterIncorrectOrientation.dispatch() : this.leaveIncorrectOrientation.dispatch()), (i || s) && this.onOrientationChange.dispatch(this, t, e), i || s
            },
            orientationChange: function(t) {
                this.event = t, this.queueUpdate(!0)
            },
            windowResize: function(t) {
                this.event = t, this.queueUpdate(!0)
            },
            scrollTop: function() {
                var t = this.compatibility.scrollTo;
                t && window.scrollTo(t.x, t.y)
            },
            refresh: function() {
                this.scrollTop(), this.queueUpdate(!0)
            },
            updateLayout: function() {
                var t = this.currentScaleMode;
                if (t !== i.ScaleManager.RESIZE) {
                    if (this.scrollTop(), this.compatibility.forceMinimumDocumentHeight && (document.documentElement.style.minHeight = window.innerHeight + "px"), this.incorrectOrientation ? this.setMaximum() : t === i.ScaleManager.EXACT_FIT ? this.setExactFit() : t === i.ScaleManager.SHOW_ALL ? !this.isFullScreen && this.boundingParent && this.compatibility.canExpandParent ? (this.setShowAll(!0), this.resetCanvas(), this.setShowAll()) : this.setShowAll() : t === i.ScaleManager.NO_SCALE ? (this.width = this.game.width, this.height = this.game.height) : t === i.ScaleManager.USER_SCALE && (this.width = this.game.width * this._userScaleFactor.x - this._userScaleTrim.x, this.height = this.game.height * this._userScaleFactor.y - this._userScaleTrim.y), !this.compatibility.canExpandParent && (t === i.ScaleManager.SHOW_ALL || t === i.ScaleManager.USER_SCALE)) {
                        var e = this.getParentBounds(this._tempBounds);
                        this.width = Math.min(this.width, e.width), this.height = Math.min(this.height, e.height)
                    }
                    this.width = 0 | this.width, this.height = 0 | this.height, this.reflowCanvas()
                } else this.reflowGame()
            },
            getParentBounds: function(t) {
                var e = t || new i.Rectangle,
                    s = this.boundingParent,
                    o = this.dom.visualBounds,
                    n = this.dom.layoutBounds;
                if (s) {
                    var a = s.getBoundingClientRect(),
                        r = s.offsetParent ? s.offsetParent.getBoundingClientRect() : s.getBoundingClientRect();
                    e.setTo(a.left - r.left, a.top - r.top, a.width, a.height);
                    var h = this.windowConstraints;
                    if (h.right) {
                        l = "layout" === h.right ? n : o;
                        e.right = Math.min(e.right, l.width)
                    }
                    if (h.bottom) {
                        var l = "layout" === h.bottom ? n : o;
                        e.bottom = Math.min(e.bottom, l.height)
                    }
                } else e.setTo(0, 0, o.width, o.height);
                return e.setTo(Math.round(e.x), Math.round(e.y), Math.round(e.width), Math.round(e.height)), e
            },
            alignCanvas: function(t, e) {
                var i = this.getParentBounds(this._tempBounds),
                    s = this.game.canvas,
                    o = this.margin;
                if (t) {
                    o.left = o.right = 0;
                    h = s.getBoundingClientRect();
                    if (this.width < i.width && !this.incorrectOrientation) {
                        var n = h.left - i.x,
                            a = i.width / 2 - this.width / 2,
                            r = (a = Math.max(a, 0)) - n;
                        o.left = Math.round(r)
                    }
                    s.style.marginLeft = o.left + "px", 0 !== o.left && (o.right = -(i.width - h.width - o.left), s.style.marginRight = o.right + "px")
                }
                if (e) {
                    o.top = o.bottom = 0;
                    var h = s.getBoundingClientRect();
                    if (this.height < i.height && !this.incorrectOrientation) {
                        var n = h.top - i.y,
                            a = i.height / 2 - this.height / 2,
                            r = (a = Math.max(a, 0)) - n;
                        o.top = Math.round(r)
                    }
                    s.style.marginTop = o.top + "px", 0 !== o.top && (o.bottom = -(i.height - h.height - o.top), s.style.marginBottom = o.bottom + "px")
                }
                o.x = o.left, o.y = o.top
            },
            reflowGame: function() {
                this.resetCanvas("", "");
                var t = this.getParentBounds(this._tempBounds);
                this.updateDimensions(t.width, t.height, !0)
            },
            reflowCanvas: function() {
                this.incorrectOrientation || (this.width = i.Math.clamp(this.width, this.minWidth || 0, this.maxWidth || this.width), this.height = i.Math.clamp(this.height, this.minHeight || 0, this.maxHeight || this.height)), this.resetCanvas(), this.compatibility.noMargins || (this.isFullScreen && this._createdFullScreenTarget ? this.alignCanvas(!0, !0) : this.alignCanvas(this.pageAlignHorizontally, this.pageAlignVertically)), this.updateScalingAndBounds()
            },
            resetCanvas: function(t, e) {
                void 0 === t && (t = this.width + "px"), void 0 === e && (e = this.height + "px");
                var i = this.game.canvas;
                this.compatibility.noMargins || (i.style.marginLeft = "", i.style.marginTop = "", i.style.marginRight = "", i.style.marginBottom = ""), i.style.width = t, i.style.height = e
            },
            queueUpdate: function(t) {
                t && (this._parentBounds.width = 0, this._parentBounds.height = 0), this._updateThrottle = this._updateThrottleReset
            },
            reset: function(t) {
                t && this.grid && this.grid.reset()
            },
            setMaximum: function() {
                this.width = this.dom.visualBounds.width, this.height = this.dom.visualBounds.height
            },
            setShowAll: function(t) {
                var e, i = this.getParentBounds(this._tempBounds),
                    s = i.width,
                    o = i.height;
                e = t ? Math.max(o / this.game.height, s / this.game.width) : Math.min(o / this.game.height, s / this.game.width), this.width = Math.round(this.game.width * e), this.height = Math.round(this.game.height * e)
            },
            setExactFit: function() {
                var t = this.getParentBounds(this._tempBounds);
                this.width = t.width, this.height = t.height, this.isFullScreen || (this.maxWidth && (this.width = Math.min(this.width, this.maxWidth)), this.maxHeight && (this.height = Math.min(this.height, this.maxHeight)))
            },
            createFullScreenTarget: function() {
                var t = document.createElement("div");
                return t.style.margin = "0", t.style.padding = "0", t.style.background = "#000", t
            },
            startFullScreen: function(t, e) {
                if (this.isFullScreen) return !1; {
                    if (this.compatibility.supportsFullScreen) {
                        if ("when-not-mouse" === this.compatibility.clickTrampoline) {
                            var s = this.game.input;
                            if (s.activePointer && s.activePointer !== s.mousePointer && (e || !1 !== e)) return void s.activePointer.addClickTrampoline("startFullScreen", this.startFullScreen, this, [t, !1])
                        }
                        void 0 !== t && this.game.renderType === i.CANVAS && (this.game.stage.smoothed = t);
                        var o = this.fullScreenTarget;
                        o || (this.cleanupCreatedTarget(), this._createdFullScreenTarget = this.createFullScreenTarget(), o = this._createdFullScreenTarget);
                        var n = {
                            targetElement: o
                        };
                        if (this.hasPhaserSetFullScreen = !0, this.onFullScreenInit.dispatch(this, n), this._createdFullScreenTarget) {
                            var a = this.game.canvas;
                            a.parentNode.insertBefore(o, a), o.appendChild(a)
                        }
                        return this.game.device.fullscreenKeyboard ? o[this.game.device.requestFullscreen](Element.ALLOW_KEYBOARD_INPUT) : o[this.game.device.requestFullscreen](), !0
                    }
                    var r = this;
                    setTimeout(function() {
                        r.fullScreenError()
                    }, 10)
                }
            },
            stopFullScreen: function() {
                return !(!this.isFullScreen || !this.compatibility.supportsFullScreen || (this.hasPhaserSetFullScreen = !1, document[this.game.device.cancelFullscreen](), 0))
            },
            cleanupCreatedTarget: function() {
                var t = this._createdFullScreenTarget;
                if (t && t.parentNode) {
                    var e = t.parentNode;
                    e.insertBefore(this.game.canvas, t), e.removeChild(t)
                }
                this._createdFullScreenTarget = null
            },
            prepScreenMode: function(t) {
                var e = !!this._createdFullScreenTarget,
                    s = this._createdFullScreenTarget || this.fullScreenTarget;
                t ? (e || this.fullScreenScaleMode === i.ScaleManager.EXACT_FIT) && s !== this.game.canvas && (this._fullScreenRestore = {
                    targetWidth: s.style.width,
                    targetHeight: s.style.height
                }, s.style.width = "100%", s.style.height = "100%") : (this._fullScreenRestore && (s.style.width = this._fullScreenRestore.targetWidth, s.style.height = this._fullScreenRestore.targetHeight, this._fullScreenRestore = null), this.updateDimensions(this._gameSize.width, this._gameSize.height, !0), this.resetCanvas())
            },
            fullScreenChange: function(t) {
                this.event = t, this.isFullScreen ? (this.prepScreenMode(!0), this.updateLayout(), this.queueUpdate(!0)) : (this.prepScreenMode(!1), this.cleanupCreatedTarget(), this.updateLayout(), this.queueUpdate(!0)), this.onFullScreenChange.dispatch(this, this.width, this.height)
            },
            fullScreenError: function(t) {
                this.event = t, this.cleanupCreatedTarget(), console.warn("Phaser.ScaleManager: requestFullscreen failed or device does not support the Fullscreen API"), this.onFullScreenError.dispatch(this)
            },
            scaleSprite: function(t, e, i, s) {
                if (void 0 === e && (e = this.width), void 0 === i && (i = this.height), void 0 === s && (s = !1), !t || !t.scale) return t;
                if (t.scale.x = 1, t.scale.y = 1, t.width <= 0 || t.height <= 0 || e <= 0 || i <= 0) return t;
                var o = e,
                    n = t.height * e / t.width,
                    a = t.width * i / t.height,
                    r = i,
                    h = a > e;
                return (h = h ? s : !s) ? (t.width = Math.floor(o), t.height = Math.floor(n)) : (t.width = Math.floor(a), t.height = Math.floor(r)), t
            },
            destroy: function() {
                this.game.onResume.remove(this._gameResumed, this), window.removeEventListener("orientationchange", this._orientationChange, !1), window.removeEventListener("resize", this._windowResize, !1), this.compatibility.supportsFullScreen && (document.removeEventListener("webkitfullscreenchange", this._fullScreenChange, !1), document.removeEventListener("mozfullscreenchange", this._fullScreenChange, !1), document.removeEventListener("MSFullscreenChange", this._fullScreenChange, !1), document.removeEventListener("fullscreenchange", this._fullScreenChange, !1), document.removeEventListener("webkitfullscreenerror", this._fullScreenError, !1), document.removeEventListener("mozfullscreenerror", this._fullScreenError, !1), document.removeEventListener("MSFullscreenError", this._fullScreenError, !1), document.removeEventListener("fullscreenerror", this._fullScreenError, !1))
            }
        }, i.ScaleManager.prototype.constructor = i.ScaleManager, Object.defineProperty(i.ScaleManager.prototype, "boundingParent", {
            get: function() {
                return this.parentIsWindow || this.isFullScreen && this.hasPhaserSetFullScreen && !this._createdFullScreenTarget ? null : this.game.canvas && this.game.canvas.parentNode || null
            }
        }), Object.defineProperty(i.ScaleManager.prototype, "scaleMode", {
            get: function() {
                return this._scaleMode
            },
            set: function(t) {
                return t !== this._scaleMode && (this.isFullScreen || (this.updateDimensions(this._gameSize.width, this._gameSize.height, !0), this.queueUpdate(!0)), this._scaleMode = t), this._scaleMode
            }
        }), Object.defineProperty(i.ScaleManager.prototype, "fullScreenScaleMode", {
            get: function() {
                return this._fullScreenScaleMode
            },
            set: function(t) {
                return t !== this._fullScreenScaleMode && (this.isFullScreen ? (this.prepScreenMode(!1), this._fullScreenScaleMode = t, this.prepScreenMode(!0), this.queueUpdate(!0)) : this._fullScreenScaleMode = t), this._fullScreenScaleMode
            }
        }), Object.defineProperty(i.ScaleManager.prototype, "currentScaleMode", {
            get: function() {
                return this.isFullScreen ? this._fullScreenScaleMode : this._scaleMode
            }
        }), Object.defineProperty(i.ScaleManager.prototype, "pageAlignHorizontally", {
            get: function() {
                return this._pageAlignHorizontally
            },
            set: function(t) {
                t !== this._pageAlignHorizontally && (this._pageAlignHorizontally = t, this.queueUpdate(!0))
            }
        }), Object.defineProperty(i.ScaleManager.prototype, "pageAlignVertically", {
            get: function() {
                return this._pageAlignVertically
            },
            set: function(t) {
                t !== this._pageAlignVertically && (this._pageAlignVertically = t, this.queueUpdate(!0))
            }
        }), Object.defineProperty(i.ScaleManager.prototype, "isFullScreen", {
            get: function() {
                return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement)
            }
        }), Object.defineProperty(i.ScaleManager.prototype, "isPortrait", {
            get: function() {
                return "portrait" === this.classifyOrientation(this.screenOrientation)
            }
        }), Object.defineProperty(i.ScaleManager.prototype, "isLandscape", {
            get: function() {
                return "landscape" === this.classifyOrientation(this.screenOrientation)
            }
        }), Object.defineProperty(i.ScaleManager.prototype, "isGamePortrait", {
            get: function() {
                return this.height > this.width
            }
        }), Object.defineProperty(i.ScaleManager.prototype, "isGameLandscape", {
            get: function() {
                return this.width > this.height
            }
        }), i.Utils.Debug = function(t) {
            this.game = t, this.sprite = null, this.bmd = null, this.canvas = null, this.context = null, this.font = "14px Courier", this.columnWidth = 100, this.lineHeight = 16, this.renderShadow = !0, this.currentX = 0, this.currentY = 0, this.currentAlpha = 1, this.dirty = !1
        }, i.Utils.Debug.prototype = {
            boot: function() {
                this.game.renderType === i.CANVAS ? this.context = this.game.context : (this.bmd = new i.BitmapData(this.game, "__DEBUG", this.game.width, this.game.height, !0), this.sprite = this.game.make.image(0, 0, this.bmd), this.game.stage.addChild(this.sprite), this.game.scale.onSizeChange.add(this.resize, this), this.canvas = PIXI.CanvasPool.create(this, this.game.width, this.game.height), this.context = this.canvas.getContext("2d"))
            },
            resize: function(t, e, i) {
                this.bmd.resize(e, i), this.canvas.width = e, this.canvas.height = i
            },
            preUpdate: function() {
                this.dirty && this.sprite && (this.bmd.clear(), this.bmd.draw(this.canvas, 0, 0), this.context.clearRect(0, 0, this.game.width, this.game.height), this.dirty = !1)
            },
            reset: function() {
                this.context && this.context.clearRect(0, 0, this.game.width, this.game.height), this.sprite && this.bmd.clear()
            },
            start: function(t, e, i, s) {
                "number" != typeof t && (t = 0), "number" != typeof e && (e = 0), i = i || "rgb(255,255,255)", void 0 === s && (s = 0), this.currentX = t, this.currentY = e, this.currentColor = i, this.columnWidth = s, this.dirty = !0, this.context.save(), this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.strokeStyle = i, this.context.fillStyle = i, this.context.font = this.font, this.context.globalAlpha = this.currentAlpha
            },
            stop: function() {
                this.context.restore()
            },
            line: function() {
                for (var t = this.currentX, e = 0; e < arguments.length; e++) this.renderShadow && (this.context.fillStyle = "rgb(0,0,0)", this.context.fillText(arguments[e], t + 1, this.currentY + 1), this.context.fillStyle = this.currentColor), this.context.fillText(arguments[e], t, this.currentY), t += this.columnWidth;
                this.currentY += this.lineHeight
            },
            soundInfo: function(t, e, i, s) {
                this.start(e, i, s), this.line("Sound: " + t.key + " Locked: " + t.game.sound.touchLocked), this.line("Is Ready?: " + this.game.cache.isSoundReady(t.key) + " Pending Playback: " + t.pendingPlayback), this.line("Decoded: " + t.isDecoded + " Decoding: " + t.isDecoding), this.line("Total Duration: " + t.totalDuration + " Playing: " + t.isPlaying), this.line("Time: " + t.currentTime), this.line("Volume: " + t.volume + " Muted: " + t.mute), this.line("WebAudio: " + t.usingWebAudio + " Audio: " + t.usingAudioTag), "" !== t.currentMarker && (this.line("Marker: " + t.currentMarker + " Duration: " + t.duration + " (ms: " + t.durationMS + ")"), this.line("Start: " + t.markers[t.currentMarker].start + " Stop: " + t.markers[t.currentMarker].stop), this.line("Position: " + t.position)), this.stop()
            },
            cameraInfo: function(t, e, i, s) {
                this.start(e, i, s), this.line("Camera (" + t.width + " x " + t.height + ")"), this.line("X: " + t.x + " Y: " + t.y), t.bounds && this.line("Bounds x: " + t.bounds.x + " Y: " + t.bounds.y + " w: " + t.bounds.width + " h: " + t.bounds.height), this.line("View x: " + t.view.x + " Y: " + t.view.y + " w: " + t.view.width + " h: " + t.view.height), this.line("Total in view: " + t.totalInView), this.stop()
            },
            timer: function(t, e, i, s) {
                this.start(e, i, s), this.line("Timer (running: " + t.running + " expired: " + t.expired + ")"), this.line("Next Tick: " + t.next + " Duration: " + t.duration), this.line("Paused: " + t.paused + " Length: " + t.length), this.stop()
            },
            pointer: function(t, e, i, s, o) {
                null != t && (void 0 === e && (e = !1), i = i || "rgba(0,255,0,0.5)", s = s || "rgba(255,0,0,0.5)", !0 === e && !0 === t.isUp || (this.start(t.x, t.y - 100, o), this.context.beginPath(), this.context.arc(t.x, t.y, t.circle.radius, 0, 2 * Math.PI), t.active ? this.context.fillStyle = i : this.context.fillStyle = s, this.context.fill(), this.context.closePath(), this.context.beginPath(), this.context.moveTo(t.positionDown.x, t.positionDown.y), this.context.lineTo(t.position.x, t.position.y), this.context.lineWidth = 2, this.context.stroke(), this.context.closePath(), this.line("ID: " + t.id + " Active: " + t.active), this.line("World X: " + t.worldX + " World Y: " + t.worldY), this.line("Screen X: " + t.x + " Screen Y: " + t.y + " In: " + t.withinGame), this.line("Duration: " + t.duration + " ms"), this.line("is Down: " + t.isDown + " is Up: " + t.isUp), this.stop()))
            },
            spriteInputInfo: function(t, e, i, s) {
                this.start(e, i, s), this.line("Sprite Input: (" + t.width + " x " + t.height + ")"), this.line("x: " + t.input.pointerX().toFixed(1) + " y: " + t.input.pointerY().toFixed(1)), this.line("over: " + t.input.pointerOver() + " duration: " + t.input.overDuration().toFixed(0)), this.line("down: " + t.input.pointerDown() + " duration: " + t.input.downDuration().toFixed(0)), this.line("just over: " + t.input.justOver() + " just out: " + t.input.justOut()), this.stop()
            },
            key: function(t, e, i, s) {
                this.start(e, i, s, 150), this.line("Key:", t.keyCode, "isDown:", t.isDown), this.line("justDown:", t.justDown, "justUp:", t.justUp), this.line("Time Down:", t.timeDown.toFixed(0), "duration:", t.duration.toFixed(0)), this.stop()
            },
            inputInfo: function(t, e, i) {
                this.start(t, e, i), this.line("Input"), this.line("X: " + this.game.input.x + " Y: " + this.game.input.y), this.line("World X: " + this.game.input.worldX + " World Y: " + this.game.input.worldY), this.line("Scale X: " + this.game.input.scale.x.toFixed(1) + " Scale Y: " + this.game.input.scale.x.toFixed(1)), this.line("Screen X: " + this.game.input.activePointer.screenX + " Screen Y: " + this.game.input.activePointer.screenY), this.stop()
            },
            spriteBounds: function(t, e, i) {
                var s = t.getBounds();
                s.x += this.game.camera.x, s.y += this.game.camera.y, this.rectangle(s, e, i)
            },
            ropeSegments: function(t, e, i) {
                var s = this;
                t.segments.forEach(function(t) {
                    s.rectangle(t, e, i)
                }, this)
            },
            spriteInfo: function(t, e, i, s) {
                this.start(e, i, s), this.line("Sprite:  (" + t.width + " x " + t.height + ") anchor: " + t.anchor.x + " x " + t.anchor.y), this.line("x: " + t.x.toFixed(1) + " y: " + t.y.toFixed(1)), this.line("angle: " + t.angle.toFixed(1) + " rotation: " + t.rotation.toFixed(1)), this.line("visible: " + t.visible + " in camera: " + t.inCamera), this.line("bounds x: " + t._bounds.x.toFixed(1) + " y: " + t._bounds.y.toFixed(1) + " w: " + t._bounds.width.toFixed(1) + " h: " + t._bounds.height.toFixed(1)), this.stop()
            },
            spriteCoords: function(t, e, i, s) {
                this.start(e, i, s, 100), t.name && this.line(t.name), this.line("x:", t.x.toFixed(2), "y:", t.y.toFixed(2)), this.line("pos x:", t.position.x.toFixed(2), "pos y:", t.position.y.toFixed(2)), this.line("world x:", t.world.x.toFixed(2), "world y:", t.world.y.toFixed(2)), this.stop()
            },
            lineInfo: function(t, e, i, s) {
                this.start(e, i, s, 80), this.line("start.x:", t.start.x.toFixed(2), "start.y:", t.start.y.toFixed(2)), this.line("end.x:", t.end.x.toFixed(2), "end.y:", t.end.y.toFixed(2)), this.line("length:", t.length.toFixed(2), "angle:", t.angle), this.stop()
            },
            pixel: function(t, e, i, s) {
                s = s || 2, this.start(), this.context.fillStyle = i, this.context.fillRect(t, e, s, s), this.stop()
            },
            geom: function(t, e, s, o) {
                void 0 === s && (s = !0), void 0 === o && (o = 0), e = e || "rgba(0,255,0,0.4)", this.start(), this.context.fillStyle = e, this.context.strokeStyle = e, t instanceof i.Rectangle || 1 === o ? s ? this.context.fillRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height) : this.context.strokeRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height) : t instanceof i.Circle || 2 === o ? (this.context.beginPath(), this.context.arc(t.x - this.game.camera.x, t.y - this.game.camera.y, t.radius, 0, 2 * Math.PI, !1), this.context.closePath(), s ? this.context.fill() : this.context.stroke()) : t instanceof i.Point || 3 === o ? this.context.fillRect(t.x - this.game.camera.x, t.y - this.game.camera.y, 4, 4) : (t instanceof i.Line || 4 === o) && (this.context.lineWidth = 1, this.context.beginPath(), this.context.moveTo(t.start.x + .5 - this.game.camera.x, t.start.y + .5 - this.game.camera.y), this.context.lineTo(t.end.x + .5 - this.game.camera.x, t.end.y + .5 - this.game.camera.y), this.context.closePath(), this.context.stroke()), this.stop()
            },
            rectangle: function(t, e, i) {
                void 0 === i && (i = !0), e = e || "rgba(0, 255, 0, 0.4)", this.start(), i ? (this.context.fillStyle = e, this.context.fillRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height)) : (this.context.strokeStyle = e, this.context.strokeRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height)), this.stop()
            },
            text: function(t, e, i, s, o) {
                s = s || "rgb(255,255,255)", o = o || "16px Courier", this.start(), this.context.font = o, this.renderShadow && (this.context.fillStyle = "rgb(0,0,0)", this.context.fillText(t, e + 1, i + 1)), this.context.fillStyle = s, this.context.fillText(t, e, i), this.stop()
            },
            quadTree: function(t, e) {
                e = e || "rgba(255,0,0,0.3)", this.start();
                var i = t.bounds;
                if (0 === t.nodes.length) {
                    this.context.strokeStyle = e, this.context.strokeRect(i.x, i.y, i.width, i.height), this.text("size: " + t.objects.length, i.x + 4, i.y + 16, "rgb(0,200,0)", "12px Courier"), this.context.strokeStyle = "rgb(0,255,0)";
                    for (s = 0; s < t.objects.length; s++) this.context.strokeRect(t.objects[s].x, t.objects[s].y, t.objects[s].width, t.objects[s].height)
                } else
                    for (var s = 0; s < t.nodes.length; s++) this.quadTree(t.nodes[s]);
                this.stop()
            },
            body: function(t, e, s) {
                t.body && (this.start(), t.body.type === i.Physics.ARCADE ? i.Physics.Arcade.Body.render(this.context, t.body, e, s) : t.body.type === i.Physics.NINJA ? i.Physics.Ninja.Body.render(this.context, t.body, e, s) : t.body.type === i.Physics.BOX2D && i.Physics.Box2D.renderBody(this.context, t.body, e), this.stop())
            },
            bodyInfo: function(t, e, s, o) {
                t.body && (this.start(e, s, o, 210), t.body.type === i.Physics.ARCADE ? i.Physics.Arcade.Body.renderBodyInfo(this, t.body) : t.body.type === i.Physics.BOX2D && this.game.physics.box2d.renderBodyInfo(this, t.body), this.stop())
            },
            box2dWorld: function() {
                this.start(), this.context.translate(-this.game.camera.view.x, -this.game.camera.view.y, 0), this.game.physics.box2d.renderDebugDraw(this.context), this.stop()
            },
            box2dBody: function(t, e) {
                this.start(), i.Physics.Box2D.renderBody(this.context, t, e), this.stop()
            },
            displayList: function(t) {
                if (void 0 === t && (t = this.game.world), t.hasOwnProperty("renderOrderID") ? console.log("[" + t.renderOrderID + "]", t) : console.log("[]", t), t.children && t.children.length > 0)
                    for (var e = 0; e < t.children.length; e++) this.game.debug.displayList(t.children[e])
            },
            destroy: function() {
                PIXI.CanvasPool.remove(this)
            }
        }, i.Utils.Debug.prototype.constructor = i.Utils.Debug, i.DOM = {
            getOffset: function(t, e) {
                e = e || new i.Point;
                var s = t.getBoundingClientRect(),
                    o = i.DOM.scrollY,
                    n = i.DOM.scrollX,
                    a = document.documentElement.clientTop,
                    r = document.documentElement.clientLeft;
                return e.x = s.left + n - r, e.y = s.top + o - a, e
            },
            getBounds: function(t, e) {
                return void 0 === e && (e = 0), !(!(t = t && !t.nodeType ? t[0] : t) || 1 !== t.nodeType) && this.calibrate(t.getBoundingClientRect(), e)
            },
            calibrate: function(t, e) {
                e = +e || 0;
                var i = {
                    width: 0,
                    height: 0,
                    left: 0,
                    right: 0,
                    top: 0,
                    bottom: 0
                };
                return i.width = (i.right = t.right + e) - (i.left = t.left - e), i.height = (i.bottom = t.bottom + e) - (i.top = t.top - e), i
            },
            getAspectRatio: function(t) {
                var e = (t = null == t ? this.visualBounds : 1 === t.nodeType ? this.getBounds(t) : t).width,
                    i = t.height;
                return "function" == typeof e && (e = e.call(t)), "function" == typeof i && (i = i.call(t)), e / i
            },
            inLayoutViewport: function(t, e) {
                var i = this.getBounds(t, e);
                return !!i && i.bottom >= 0 && i.right >= 0 && i.top <= this.layoutBounds.width && i.left <= this.layoutBounds.height
            },
            getScreenOrientation: function(t) {
                var e = window.screen,
                    i = e.orientation || e.mozOrientation || e.msOrientation;
                if (i && "string" == typeof i.type) return i.type;
                if ("string" == typeof i) return i;
                var s = "portrait-primary",
                    o = "landscape-primary";
                if ("screen" === t) return e.height > e.width ? s : o;
                if ("viewport" === t) return this.visualBounds.height > this.visualBounds.width ? s : o;
                if ("window.orientation" === t && "number" == typeof window.orientation) return 0 === window.orientation || 180 === window.orientation ? s : o;
                if (window.matchMedia) {
                    if (window.matchMedia("(orientation: portrait)").matches) return s;
                    if (window.matchMedia("(orientation: landscape)").matches) return o
                }
                return this.visualBounds.height > this.visualBounds.width ? s : o
            },
            visualBounds: new i.Rectangle,
            layoutBounds: new i.Rectangle,
            documentBounds: new i.Rectangle
        }, i.Device.whenReady(function(t) {
            var e = window && "pageXOffset" in window ? function() {
                    return window.pageXOffset
                } : function() {
                    return document.documentElement.scrollLeft
                },
                s = window && "pageYOffset" in window ? function() {
                    return window.pageYOffset
                } : function() {
                    return document.documentElement.scrollTop
                };
            if (Object.defineProperty(i.DOM, "scrollX", {
                    get: e
                }), Object.defineProperty(i.DOM, "scrollY", {
                    get: s
                }), Object.defineProperty(i.DOM.visualBounds, "x", {
                    get: e
                }), Object.defineProperty(i.DOM.visualBounds, "y", {
                    get: s
                }), Object.defineProperty(i.DOM.layoutBounds, "x", {
                    value: 0
                }), Object.defineProperty(i.DOM.layoutBounds, "y", {
                    value: 0
                }), t.desktop && document.documentElement.clientWidth <= window.innerWidth && document.documentElement.clientHeight <= window.innerHeight) {
                var o = function() {
                        return Math.max(window.innerWidth, document.documentElement.clientWidth)
                    },
                    n = function() {
                        return Math.max(window.innerHeight, document.documentElement.clientHeight)
                    };
                Object.defineProperty(i.DOM.visualBounds, "width", {
                    get: o
                }), Object.defineProperty(i.DOM.visualBounds, "height", {
                    get: n
                }), Object.defineProperty(i.DOM.layoutBounds, "width", {
                    get: o
                }), Object.defineProperty(i.DOM.layoutBounds, "height", {
                    get: n
                })
            } else Object.defineProperty(i.DOM.visualBounds, "width", {
                get: function() {
                    return window.innerWidth
                }
            }), Object.defineProperty(i.DOM.visualBounds, "height", {
                get: function() {
                    return window.innerHeight
                }
            }), Object.defineProperty(i.DOM.layoutBounds, "width", {
                get: function() {
                    var t = document.documentElement.clientWidth,
                        e = window.innerWidth;
                    return t < e ? e : t
                }
            }), Object.defineProperty(i.DOM.layoutBounds, "height", {
                get: function() {
                    var t = document.documentElement.clientHeight,
                        e = window.innerHeight;
                    return t < e ? e : t
                }
            });
            Object.defineProperty(i.DOM.documentBounds, "x", {
                value: 0
            }), Object.defineProperty(i.DOM.documentBounds, "y", {
                value: 0
            }), Object.defineProperty(i.DOM.documentBounds, "width", {
                get: function() {
                    var t = document.documentElement;
                    return Math.max(t.clientWidth, t.offsetWidth, t.scrollWidth)
                }
            }), Object.defineProperty(i.DOM.documentBounds, "height", {
                get: function() {
                    var t = document.documentElement;
                    return Math.max(t.clientHeight, t.offsetHeight, t.scrollHeight)
                }
            })
        }, null, !0), i.ArraySet = function(t) {
            this.position = 0, this.list = t || []
        }, i.ArraySet.prototype = {
            add: function(t) {
                return this.exists(t) || this.list.push(t), t
            },
            getIndex: function(t) {
                return this.list.indexOf(t)
            },
            getByKey: function(t, e) {
                for (var i = this.list.length; i--;)
                    if (this.list[i][t] === e) return this.list[i];
                return null
            },
            exists: function(t) {
                return this.list.indexOf(t) > -1
            },
            reset: function() {
                this.list.length = 0
            },
            remove: function(t) {
                var e = this.list.indexOf(t);
                if (e > -1) return this.list.splice(e, 1), t
            },
            setAll: function(t, e) {
                for (var i = this.list.length; i--;) this.list[i] && (this.list[i][t] = e)
            },
            callAll: function(t) {
                for (var e = Array.prototype.slice.call(arguments, 1), i = this.list.length; i--;) this.list[i] && this.list[i][t] && this.list[i][t].apply(this.list[i], e)
            },
            removeAll: function(t) {
                void 0 === t && (t = !1);
                for (var e = this.list.length; e--;)
                    if (this.list[e]) {
                        var i = this.remove(this.list[e]);
                        t && i.destroy()
                    }
                this.position = 0, this.list = []
            }
        }, Object.defineProperty(i.ArraySet.prototype, "total", {
            get: function() {
                return this.list.length
            }
        }), Object.defineProperty(i.ArraySet.prototype, "first", {
            get: function() {
                return this.position = 0, this.list.length > 0 ? this.list[0] : null
            }
        }), Object.defineProperty(i.ArraySet.prototype, "next", {
            get: function() {
                return this.position < this.list.length ? (this.position++, this.list[this.position]) : null
            }
        }), i.ArraySet.prototype.constructor = i.ArraySet, i.ArrayUtils = {
            getRandomItem: function(t, e, i) {
                if (null === t) return null;
                void 0 === e && (e = 0), void 0 === i && (i = t.length);
                var s = e + Math.floor(Math.random() * i);
                return void 0 === t[s] ? null : t[s]
            },
            removeRandomItem: function(t, e, i) {
                if (null == t) return null;
                void 0 === e && (e = 0), void 0 === i && (i = t.length);
                var s = e + Math.floor(Math.random() * i);
                if (s < t.length) {
                    var o = t.splice(s, 1);
                    return void 0 === o[0] ? null : o[0]
                }
                return null
            },
            shuffle: function(t) {
                for (var e = t.length - 1; e > 0; e--) {
                    var i = Math.floor(Math.random() * (e + 1)),
                        s = t[e];
                    t[e] = t[i], t[i] = s
                }
                return t
            },
            transposeMatrix: function(t) {
                for (var e = t.length, i = t[0].length, s = new Array(i), o = 0; o < i; o++) {
                    s[o] = new Array(e);
                    for (var n = e - 1; n > -1; n--) s[o][n] = t[n][o]
                }
                return s
            },
            rotateMatrix: function(t, e) {
                if ("string" != typeof e && (e = (e % 360 + 360) % 360), 90 === e || -270 === e || "rotateLeft" === e) t = i.ArrayUtils.transposeMatrix(t), t = t.reverse();
                else if (-90 === e || 270 === e || "rotateRight" === e) t = t.reverse(), t = i.ArrayUtils.transposeMatrix(t);
                else if (180 === Math.abs(e) || "rotate180" === e) {
                    for (var s = 0; s < t.length; s++) t[s].reverse();
                    t = t.reverse()
                }
                return t
            },
            findClosest: function(t, e) {
                if (!e.length) return NaN;
                if (1 === e.length || t < e[0]) return e[0];
                for (var i = 1; e[i] < t;) i++;
                var s = e[i - 1],
                    o = i < e.length ? e[i] : Number.POSITIVE_INFINITY;
                return o - t <= t - s ? o : s
            },
            rotateRight: function(t) {
                var e = t.pop();
                return t.unshift(e), e
            },
            rotateLeft: function(t) {
                var e = t.shift();
                return t.push(e), e
            },
            rotate: function(t) {
                var e = t.shift();
                return t.push(e), e
            },
            numberArray: function(t, e) {
                for (var i = [], s = t; s <= e; s++) i.push(s);
                return i
            },
            numberArrayStep: function(t, e, s) {
                void 0 !== t && null !== t || (t = 0), void 0 !== e && null !== e || (e = t, t = 0), void 0 === s && (s = 1);
                for (var o = [], n = Math.max(i.Math.roundAwayFromZero((e - t) / (s || 1)), 0), a = 0; a < n; a++) o.push(t), t += s;
                return o
            }
        }, i.LinkedList = function() {
            this.next = null, this.prev = null, this.first = null, this.last = null, this.total = 0
        }, i.LinkedList.prototype = {
            add: function(t) {
                return 0 === this.total && null === this.first && null === this.last ? (this.first = t, this.last = t, this.next = t, t.prev = this, this.total++, t) : (this.last.next = t, t.prev = this.last, this.last = t, this.total++, t)
            },
            reset: function() {
                this.first = null, this.last = null, this.next = null, this.prev = null, this.total = 0
            },
            remove: function(t) {
                return 1 === this.total ? (this.reset(), void(t.next = t.prev = null)) : (t === this.first ? this.first = this.first.next : t === this.last && (this.last = this.last.prev), t.prev && (t.prev.next = t.next), t.next && (t.next.prev = t.prev), t.next = t.prev = null, null === this.first && (this.last = null), void this.total--)
            },
            callAll: function(t) {
                if (this.first && this.last) {
                    var e = this.first;
                    do {
                        e && e[t] && e[t].call(e), e = e.next
                    } while (e !== this.last.next)
                }
            }
        }, i.LinkedList.prototype.constructor = i.LinkedList, i.Create = function(t) {
            this.game = t, this.bmd = null, this.canvas = null, this.ctx = null, this.palettes = [{
                0: "#000",
                1: "#9D9D9D",
                2: "#FFF",
                3: "#BE2633",
                4: "#E06F8B",
                5: "#493C2B",
                6: "#A46422",
                7: "#EB8931",
                8: "#F7E26B",
                9: "#2F484E",
                A: "#44891A",
                B: "#A3CE27",
                C: "#1B2632",
                D: "#005784",
                E: "#31A2F2",
                F: "#B2DCEF"
            }, {
                0: "#000",
                1: "#191028",
                2: "#46af45",
                3: "#a1d685",
                4: "#453e78",
                5: "#7664fe",
                6: "#833129",
                7: "#9ec2e8",
                8: "#dc534b",
                9: "#e18d79",
                A: "#d6b97b",
                B: "#e9d8a1",
                C: "#216c4b",
                D: "#d365c8",
                E: "#afaab9",
                F: "#f5f4eb"
            }, {
                0: "#000",
                1: "#2234d1",
                2: "#0c7e45",
                3: "#44aacc",
                4: "#8a3622",
                5: "#5c2e78",
                6: "#aa5c3d",
                7: "#b5b5b5",
                8: "#5e606e",
                9: "#4c81fb",
                A: "#6cd947",
                B: "#7be2f9",
                C: "#eb8a60",
                D: "#e23d69",
                E: "#ffd93f",
                F: "#fff"
            }, {
                0: "#000",
                1: "#fff",
                2: "#8b4131",
                3: "#7bbdc5",
                4: "#8b41ac",
                5: "#6aac41",
                6: "#3931a4",
                7: "#d5de73",
                8: "#945a20",
                9: "#5a4100",
                A: "#bd736a",
                B: "#525252",
                C: "#838383",
                D: "#acee8b",
                E: "#7b73de",
                F: "#acacac"
            }, {
                0: "#000",
                1: "#191028",
                2: "#46af45",
                3: "#a1d685",
                4: "#453e78",
                5: "#7664fe",
                6: "#833129",
                7: "#9ec2e8",
                8: "#dc534b",
                9: "#e18d79",
                A: "#d6b97b",
                B: "#e9d8a1",
                C: "#216c4b",
                D: "#d365c8",
                E: "#afaab9",
                F: "#fff"
            }]
        }, i.Create.PALETTE_ARNE = 0, i.Create.PALETTE_JMP = 1, i.Create.PALETTE_CGA = 2, i.Create.PALETTE_C64 = 3, i.Create.PALETTE_JAPANESE_MACHINE = 4, i.Create.prototype = {
            texture: function(t, e, i, s, o) {
                void 0 === i && (i = 8), void 0 === s && (s = i), void 0 === o && (o = 0);
                var n = e[0].length * i,
                    a = e.length * s;
                null === this.bmd && (this.bmd = this.game.make.bitmapData(), this.canvas = this.bmd.canvas, this.ctx = this.bmd.context), this.bmd.resize(n, a), this.bmd.clear();
                for (var r = 0; r < e.length; r++)
                    for (var h = e[r], l = 0; l < h.length; l++) {
                        var c = h[l];
                        "." !== c && " " !== c && (this.ctx.fillStyle = this.palettes[o][c], this.ctx.fillRect(l * i, r * s, i, s))
                    }
                return this.bmd.generateTexture(t)
            },
            grid: function(t, e, i, s, o, n) {
                null === this.bmd && (this.bmd = this.game.make.bitmapData(), this.canvas = this.bmd.canvas, this.ctx = this.bmd.context), this.bmd.resize(e, i), this.ctx.fillStyle = n;
                for (var a = 0; a < i; a += o) this.ctx.fillRect(0, a, e, 1);
                for (var r = 0; r < e; r += s) this.ctx.fillRect(r, 0, 1, i);
                return this.bmd.generateTexture(t)
            }
        }, i.Create.prototype.constructor = i.Create, i.FlexGrid = function(t, e, s) {
            this.game = t.game, this.manager = t, this.width = e, this.height = s, this.boundsCustom = new i.Rectangle(0, 0, e, s), this.boundsFluid = new i.Rectangle(0, 0, e, s), this.boundsFull = new i.Rectangle(0, 0, e, s), this.boundsNone = new i.Rectangle(0, 0, e, s), this.positionCustom = new i.Point(0, 0), this.positionFluid = new i.Point(0, 0), this.positionFull = new i.Point(0, 0), this.positionNone = new i.Point(0, 0), this.scaleCustom = new i.Point(1, 1), this.scaleFluid = new i.Point(1, 1), this.scaleFluidInversed = new i.Point(1, 1), this.scaleFull = new i.Point(1, 1), this.scaleNone = new i.Point(1, 1), this.customWidth = 0, this.customHeight = 0, this.customOffsetX = 0, this.customOffsetY = 0, this.ratioH = e / s, this.ratioV = s / e, this.multiplier = 0, this.layers = []
        }, i.FlexGrid.prototype = {
            setSize: function(t, e) {
                this.width = t, this.height = e, this.ratioH = t / e, this.ratioV = e / t, this.scaleNone = new i.Point(1, 1), this.boundsNone.width = this.width, this.boundsNone.height = this.height, this.refresh()
            },
            createCustomLayer: function(t, e, s, o) {
                void 0 === o && (o = !0), this.customWidth = t, this.customHeight = e, this.boundsCustom.width = t, this.boundsCustom.height = e;
                var n = new i.FlexLayer(this, this.positionCustom, this.boundsCustom, this.scaleCustom);
                return o && this.game.world.add(n), this.layers.push(n), void 0 !== s && null !== typeof s && n.addMultiple(s), n
            },
            createFluidLayer: function(t, e) {
                void 0 === e && (e = !0);
                var s = new i.FlexLayer(this, this.positionFluid, this.boundsFluid, this.scaleFluid);
                return e && this.game.world.add(s), this.layers.push(s), void 0 !== t && null !== typeof t && s.addMultiple(t), s
            },
            createFullLayer: function(t) {
                var e = new i.FlexLayer(this, this.positionFull, this.boundsFull, this.scaleFluid);
                return this.game.world.add(e), this.layers.push(e), void 0 !== t && e.addMultiple(t), e
            },
            createFixedLayer: function(t) {
                var e = new i.FlexLayer(this, this.positionNone, this.boundsNone, this.scaleNone);
                return this.game.world.add(e), this.layers.push(e), void 0 !== t && e.addMultiple(t), e
            },
            reset: function() {
                for (var t = this.layers.length; t--;) this.layers[t].persist || (this.layers[t].position = null, this.layers[t].scale = null, this.layers.slice(t, 1))
            },
            onResize: function(t, e) {
                this.ratioH = t / e, this.ratioV = e / t, this.refresh(t, e)
            },
            refresh: function() {
                this.multiplier = Math.min(this.manager.height / this.height, this.manager.width / this.width), this.boundsFluid.width = Math.round(this.width * this.multiplier), this.boundsFluid.height = Math.round(this.height * this.multiplier), this.scaleFluid.set(this.boundsFluid.width / this.width, this.boundsFluid.height / this.height), this.scaleFluidInversed.set(this.width / this.boundsFluid.width, this.height / this.boundsFluid.height), this.scaleFull.set(this.boundsFull.width / this.width, this.boundsFull.height / this.height), this.boundsFull.width = Math.round(this.manager.width * this.scaleFluidInversed.x), this.boundsFull.height = Math.round(this.manager.height * this.scaleFluidInversed.y), this.boundsFluid.centerOn(this.manager.bounds.centerX, this.manager.bounds.centerY), this.boundsNone.centerOn(this.manager.bounds.centerX, this.manager.bounds.centerY), this.positionFluid.set(this.boundsFluid.x, this.boundsFluid.y), this.positionNone.set(this.boundsNone.x, this.boundsNone.y)
            },
            fitSprite: function(t) {
                this.manager.scaleSprite(t), t.x = this.manager.bounds.centerX, t.y = this.manager.bounds.centerY
            },
            debug: function() {
                this.game.debug.text(this.boundsFluid.width + " x " + this.boundsFluid.height, this.boundsFluid.x + 4, this.boundsFluid.y + 16), this.game.debug.geom(this.boundsFluid, "rgba(255,0,0,0.9", !1)
            }
        }, i.FlexGrid.prototype.constructor = i.FlexGrid, i.FlexLayer = function(t, e, s, o) {
            i.Group.call(this, t.game, null, "__flexLayer" + t.game.rnd.uuid(), !1), this.manager = t.manager, this.grid = t, this.persist = !1, this.position = e, this.bounds = s, this.scale = o, this.topLeft = s.topLeft, this.topMiddle = new i.Point(s.halfWidth, 0), this.topRight = s.topRight, this.bottomLeft = s.bottomLeft, this.bottomMiddle = new i.Point(s.halfWidth, s.bottom), this.bottomRight = s.bottomRight
        }, i.FlexLayer.prototype = Object.create(i.Group.prototype), i.FlexLayer.prototype.constructor = i.FlexLayer, i.FlexLayer.prototype.resize = function() {}, i.FlexLayer.prototype.debug = function() {
            this.game.debug.text(this.bounds.width + " x " + this.bounds.height, this.bounds.x + 4, this.bounds.y + 16), this.game.debug.geom(this.bounds, "rgba(0,0,255,0.9", !1), this.game.debug.geom(this.topLeft, "rgba(255,255,255,0.9"), this.game.debug.geom(this.topMiddle, "rgba(255,255,255,0.9"), this.game.debug.geom(this.topRight, "rgba(255,255,255,0.9")
        }, i.Color = {
            packPixel: function(t, e, s, o) {
                return i.Device.LITTLE_ENDIAN ? (o << 24 | s << 16 | e << 8 | t) >>> 0 : (t << 24 | e << 16 | s << 8 | o) >>> 0
            },
            unpackPixel: function(t, e, s, o) {
                return void 0 !== e && null !== e || (e = i.Color.createColor()), void 0 !== s && null !== s || (s = !1), void 0 !== o && null !== o || (o = !1), i.Device.LITTLE_ENDIAN ? (e.a = (4278190080 & t) >>> 24, e.b = (16711680 & t) >>> 16, e.g = (65280 & t) >>> 8, e.r = 255 & t) : (e.r = (4278190080 & t) >>> 24, e.g = (16711680 & t) >>> 16, e.b = (65280 & t) >>> 8, e.a = 255 & t), e.color = t, e.rgba = "rgba(" + e.r + "," + e.g + "," + e.b + "," + e.a / 255 + ")", s && i.Color.RGBtoHSL(e.r, e.g, e.b, e), o && i.Color.RGBtoHSV(e.r, e.g, e.b, e), e
            },
            fromRGBA: function(t, e) {
                return e || (e = i.Color.createColor()), e.r = (4278190080 & t) >>> 24, e.g = (16711680 & t) >>> 16, e.b = (65280 & t) >>> 8, e.a = 255 & t, e.rgba = "rgba(" + e.r + "," + e.g + "," + e.b + "," + e.a + ")", e
            },
            toRGBA: function(t, e, i, s) {
                return t << 24 | e << 16 | i << 8 | s
            },
            toABGR: function(t, e, i, s) {
                return (s << 24 | i << 16 | e << 8 | t) >>> 0
            },
            RGBtoHSL: function(t, e, s, o) {
                o || (o = i.Color.createColor(t, e, s, 1)), t /= 255, e /= 255, s /= 255;
                var n = Math.min(t, e, s),
                    a = Math.max(t, e, s);
                if (o.h = 0, o.s = 0, o.l = (a + n) / 2, a !== n) {
                    var r = a - n;
                    o.s = o.l > .5 ? r / (2 - a - n) : r / (a + n), a === t ? o.h = (e - s) / r + (e < s ? 6 : 0) : a === e ? o.h = (s - t) / r + 2 : a === s && (o.h = (t - e) / r + 4), o.h /= 6
                }
                return o
            },
            HSLtoRGB: function(t, e, s, o) {
                if (o ? (o.r = s, o.g = s, o.b = s) : o = i.Color.createColor(s, s, s), 0 !== e) {
                    var n = s < .5 ? s * (1 + e) : s + e - s * e,
                        a = 2 * s - n;
                    o.r = i.Color.hueToColor(a, n, t + 1 / 3), o.g = i.Color.hueToColor(a, n, t), o.b = i.Color.hueToColor(a, n, t - 1 / 3)
                }
                return o.r = Math.floor(255 * o.r | 0), o.g = Math.floor(255 * o.g | 0), o.b = Math.floor(255 * o.b | 0), i.Color.updateColor(o), o
            },
            RGBtoHSV: function(t, e, s, o) {
                o || (o = i.Color.createColor(t, e, s, 255)), t /= 255, e /= 255, s /= 255;
                var n = Math.min(t, e, s),
                    a = Math.max(t, e, s),
                    r = a - n;
                return o.h = 0, o.s = 0 === a ? 0 : r / a, o.v = a, a !== n && (a === t ? o.h = (e - s) / r + (e < s ? 6 : 0) : a === e ? o.h = (s - t) / r + 2 : a === s && (o.h = (t - e) / r + 4), o.h /= 6), o
            },
            HSVtoRGB: function(t, e, s, o) {
                void 0 === o && (o = i.Color.createColor(0, 0, 0, 1, t, e, 0, s));
                var n, a, r, h = Math.floor(6 * t),
                    l = 6 * t - h,
                    c = s * (1 - e),
                    p = s * (1 - l * e),
                    u = s * (1 - (1 - l) * e);
                switch (h % 6) {
                    case 0:
                        n = s, a = u, r = c;
                        break;
                    case 1:
                        n = p, a = s, r = c;
                        break;
                    case 2:
                        n = c, a = s, r = u;
                        break;
                    case 3:
                        n = c, a = p, r = s;
                        break;
                    case 4:
                        n = u, a = c, r = s;
                        break;
                    case 5:
                        n = s, a = c, r = p
                }
                return o.r = Math.floor(255 * n), o.g = Math.floor(255 * a), o.b = Math.floor(255 * r), i.Color.updateColor(o), o
            },
            hueToColor: function(t, e, i) {
                return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? t + 6 * (e - t) * i : i < .5 ? e : i < 2 / 3 ? t + (e - t) * (2 / 3 - i) * 6 : t
            },
            createColor: function(t, e, s, o, n, a, r, h) {
                var l = {
                    r: t || 0,
                    g: e || 0,
                    b: s || 0,
                    a: o || 1,
                    h: n || 0,
                    s: a || 0,
                    l: r || 0,
                    v: h || 0,
                    color: 0,
                    color32: 0,
                    rgba: ""
                };
                return i.Color.updateColor(l)
            },
            updateColor: function(t) {
                return t.rgba = "rgba(" + t.r.toString() + "," + t.g.toString() + "," + t.b.toString() + "," + t.a.toString() + ")", t.color = i.Color.getColor(t.r, t.g, t.b), t.color32 = i.Color.getColor32(255 * t.a, t.r, t.g, t.b), t
            },
            getColor32: function(t, e, i, s) {
                return t << 24 | e << 16 | i << 8 | s
            },
            getColor: function(t, e, i) {
                return t << 16 | e << 8 | i
            },
            RGBtoString: function(t, e, s, o, n) {
                return void 0 === o && (o = 255), void 0 === n && (n = "#"), "#" === n ? "#" + ((1 << 24) + (t << 16) + (e << 8) + s).toString(16).slice(1) : "0x" + i.Color.componentToHex(o) + i.Color.componentToHex(t) + i.Color.componentToHex(e) + i.Color.componentToHex(s)
            },
            hexToRGB: function(t) {
                var e = i.Color.hexToColor(t);
                if (e) return i.Color.getColor32(e.a, e.r, e.g, e.b)
            },
            hexToColor: function(t, e) {
                t = t.replace(/^(?:#|0x)?([a-f\d])([a-f\d])([a-f\d])$/i, function(t, e, i, s) {
                    return e + e + i + i + s + s
                });
                var s = /^(?:#|0x)?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t);
                if (s) {
                    var o = parseInt(s[1], 16),
                        n = parseInt(s[2], 16),
                        a = parseInt(s[3], 16);
                    e ? (e.r = o, e.g = n, e.b = a) : e = i.Color.createColor(o, n, a)
                }
                return e
            },
            webToColor: function(t, e) {
                e || (e = i.Color.createColor());
                var s = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d+(?:\.\d+)?))?\s*\)$/.exec(t);
                return s && (e.r = parseInt(s[1], 10), e.g = parseInt(s[2], 10), e.b = parseInt(s[3], 10), e.a = void 0 !== s[4] ? parseFloat(s[4]) : 1, i.Color.updateColor(e)), e
            },
            valueToColor: function(t, e) {
                if (e || (e = i.Color.createColor()), "string" == typeof t) return 0 === t.indexOf("rgb") ? i.Color.webToColor(t, e) : (e.a = 1, i.Color.hexToColor(t, e));
                if ("number" == typeof t) {
                    var s = i.Color.getRGB(t);
                    return e.r = s.r, e.g = s.g, e.b = s.b, e.a = s.a / 255, e
                }
                return e
            },
            componentToHex: function(t) {
                var e = t.toString(16);
                return 1 === e.length ? "0" + e : e
            },
            HSVColorWheel: function(t, e) {
                void 0 === t && (t = 1), void 0 === e && (e = 1);
                for (var s = [], o = 0; o <= 359; o++) s.push(i.Color.HSVtoRGB(o / 359, t, e));
                return s
            },
            HSLColorWheel: function(t, e) {
                void 0 === t && (t = .5), void 0 === e && (e = .5);
                for (var s = [], o = 0; o <= 359; o++) s.push(i.Color.HSLtoRGB(o / 359, t, e));
                return s
            },
            interpolateColor: function(t, e, s, o, n) {
                void 0 === n && (n = 255);
                var a = i.Color.getRGB(t),
                    r = i.Color.getRGB(e),
                    h = (r.red - a.red) * o / s + a.red,
                    l = (r.green - a.green) * o / s + a.green,
                    c = (r.blue - a.blue) * o / s + a.blue;
                return i.Color.getColor32(n, h, l, c)
            },
            interpolateColorWithRGB: function(t, e, s, o, n, a) {
                var r = i.Color.getRGB(t),
                    h = (e - r.red) * a / n + r.red,
                    l = (s - r.green) * a / n + r.green,
                    c = (o - r.blue) * a / n + r.blue;
                return i.Color.getColor(h, l, c)
            },
            interpolateRGB: function(t, e, s, o, n, a, r, h) {
                var l = (o - t) * h / r + t,
                    c = (n - e) * h / r + e,
                    p = (a - s) * h / r + s;
                return i.Color.getColor(l, c, p)
            },
            getRandomColor: function(t, e, s) {
                if (void 0 === t && (t = 0), void 0 === e && (e = 255), void 0 === s && (s = 255), e > 255 || t > e) return i.Color.getColor(255, 255, 255);
                var o = t + Math.round(Math.random() * (e - t)),
                    n = t + Math.round(Math.random() * (e - t)),
                    a = t + Math.round(Math.random() * (e - t));
                return i.Color.getColor32(s, o, n, a)
            },
            getRGB: function(t) {
                return t > 16777215 ? {
                    alpha: t >>> 24,
                    red: t >> 16 & 255,
                    green: t >> 8 & 255,
                    blue: 255 & t,
                    a: t >>> 24,
                    r: t >> 16 & 255,
                    g: t >> 8 & 255,
                    b: 255 & t
                } : {
                    alpha: 255,
                    red: t >> 16 & 255,
                    green: t >> 8 & 255,
                    blue: 255 & t,
                    a: 255,
                    r: t >> 16 & 255,
                    g: t >> 8 & 255,
                    b: 255 & t
                }
            },
            getWebRGB: function(t) {
                if ("object" == typeof t) return "rgba(" + t.r.toString() + "," + t.g.toString() + "," + t.b.toString() + "," + (t.a / 255).toString() + ")";
                var e = i.Color.getRGB(t);
                return "rgba(" + e.r.toString() + "," + e.g.toString() + "," + e.b.toString() + "," + (e.a / 255).toString() + ")"
            },
            getAlpha: function(t) {
                return t >>> 24
            },
            getAlphaFloat: function(t) {
                return (t >>> 24) / 255
            },
            getRed: function(t) {
                return t >> 16 & 255
            },
            getGreen: function(t) {
                return t >> 8 & 255
            },
            getBlue: function(t) {
                return 255 & t
            },
            blendNormal: function(t) {
                return t
            },
            blendLighten: function(t, e) {
                return e > t ? e : t
            },
            blendDarken: function(t, e) {
                return e > t ? t : e
            },
            blendMultiply: function(t, e) {
                return t * e / 255
            },
            blendAverage: function(t, e) {
                return (t + e) / 2
            },
            blendAdd: function(t, e) {
                return Math.min(255, t + e)
            },
            blendSubtract: function(t, e) {
                return Math.max(0, t + e - 255)
            },
            blendDifference: function(t, e) {
                return Math.abs(t - e)
            },
            blendNegation: function(t, e) {
                return 255 - Math.abs(255 - t - e)
            },
            blendScreen: function(t, e) {
                return 255 - ((255 - t) * (255 - e) >> 8)
            },
            blendExclusion: function(t, e) {
                return t + e - 2 * t * e / 255
            },
            blendOverlay: function(t, e) {
                return e < 128 ? 2 * t * e / 255 : 255 - 2 * (255 - t) * (255 - e) / 255
            },
            blendSoftLight: function(t, e) {
                return e < 128 ? 2 * (64 + (t >> 1)) * (e / 255) : 255 - 2 * (255 - (64 + (t >> 1))) * (255 - e) / 255
            },
            blendHardLight: function(t, e) {
                return i.Color.blendOverlay(e, t)
            },
            blendColorDodge: function(t, e) {
                return 255 === e ? e : Math.min(255, (t << 8) / (255 - e))
            },
            blendColorBurn: function(t, e) {
                return 0 === e ? e : Math.max(0, 255 - (255 - t << 8) / e)
            },
            blendLinearDodge: function(t, e) {
                return i.Color.blendAdd(t, e)
            },
            blendLinearBurn: function(t, e) {
                return i.Color.blendSubtract(t, e)
            },
            blendLinearLight: function(t, e) {
                return e < 128 ? i.Color.blendLinearBurn(t, 2 * e) : i.Color.blendLinearDodge(t, 2 * (e - 128))
            },
            blendVividLight: function(t, e) {
                return e < 128 ? i.Color.blendColorBurn(t, 2 * e) : i.Color.blendColorDodge(t, 2 * (e - 128))
            },
            blendPinLight: function(t, e) {
                return e < 128 ? i.Color.blendDarken(t, 2 * e) : i.Color.blendLighten(t, 2 * (e - 128))
            },
            blendHardMix: function(t, e) {
                return i.Color.blendVividLight(t, e) < 128 ? 0 : 255
            },
            blendReflect: function(t, e) {
                return 255 === e ? e : Math.min(255, t * t / (255 - e))
            },
            blendGlow: function(t, e) {
                return i.Color.blendReflect(e, t)
            },
            blendPhoenix: function(t, e) {
                return Math.min(t, e) - Math.max(t, e) + 255
            }
        }, i.Physics = function(t, e) {
            e = e || {}, this.game = t, this.config = e, this.arcade = null, this.p2 = null, this.ninja = null, this.box2d = null, this.chipmunk = null, this.matter = null, this.parseConfig()
        }, i.Physics.ARCADE = 0, i.Physics.P2JS = 1, i.Physics.NINJA = 2, i.Physics.BOX2D = 3, i.Physics.CHIPMUNK = 4, i.Physics.MATTERJS = 5, i.Physics.prototype = {
            parseConfig: function() {
                this.config.hasOwnProperty("arcade") && !0 !== this.config.arcade || !i.Physics.hasOwnProperty("Arcade") || (this.arcade = new i.Physics.Arcade(this.game)), this.config.hasOwnProperty("ninja") && !0 === this.config.ninja && i.Physics.hasOwnProperty("Ninja") && (this.ninja = new i.Physics.Ninja(this.game)), this.config.hasOwnProperty("p2") && !0 === this.config.p2 && i.Physics.hasOwnProperty("P2") && (this.p2 = new i.Physics.P2(this.game, this.config)), this.config.hasOwnProperty("box2d") && !0 === this.config.box2d && i.Physics.hasOwnProperty("BOX2D") && (this.box2d = new i.Physics.BOX2D(this.game, this.config)), this.config.hasOwnProperty("matter") && !0 === this.config.matter && i.Physics.hasOwnProperty("Matter") && (this.matter = new i.Physics.Matter(this.game, this.config))
            },
            startSystem: function(t) {
                t === i.Physics.ARCADE ? this.arcade = new i.Physics.Arcade(this.game) : t === i.Physics.P2JS ? null === this.p2 ? this.p2 = new i.Physics.P2(this.game, this.config) : this.p2.reset() : t === i.Physics.NINJA ? this.ninja = new i.Physics.Ninja(this.game) : t === i.Physics.BOX2D ? null === this.box2d ? this.box2d = new i.Physics.Box2D(this.game, this.config) : this.box2d.reset() : t === i.Physics.MATTERJS && (null === this.matter ? this.matter = new i.Physics.Matter(this.game, this.config) : this.matter.reset())
            },
            enable: function(t, e, s) {
                void 0 === e && (e = i.Physics.ARCADE), void 0 === s && (s = !1), e === i.Physics.ARCADE ? this.arcade.enable(t) : e === i.Physics.P2JS && this.p2 ? this.p2.enable(t, s) : e === i.Physics.NINJA && this.ninja ? this.ninja.enableAABB(t) : e === i.Physics.BOX2D && this.box2d ? this.box2d.enable(t) : e === i.Physics.MATTERJS && this.matter ? this.matter.enable(t) : console.warn(t.key + " is attempting to enable a physics body using an unknown physics system.")
            },
            preUpdate: function() {
                this.p2 && this.p2.preUpdate(), this.box2d && this.box2d.preUpdate(), this.matter && this.matter.preUpdate()
            },
            update: function() {
                this.p2 && this.p2.update(), this.box2d && this.box2d.update(), this.matter && this.matter.update()
            },
            setBoundsToWorld: function() {
                this.arcade && this.arcade.setBoundsToWorld(), this.ninja && this.ninja.setBoundsToWorld(), this.p2 && this.p2.setBoundsToWorld(), this.box2d && this.box2d.setBoundsToWorld(), this.matter && this.matter.setBoundsToWorld()
            },
            clear: function() {
                this.p2 && this.p2.clear(), this.box2d && this.box2d.clear(), this.matter && this.matter.clear()
            },
            reset: function() {
                this.p2 && this.p2.reset(), this.box2d && this.box2d.reset(), this.matter && this.matter.reset()
            },
            destroy: function() {
                this.p2 && this.p2.destroy(), this.box2d && this.box2d.destroy(), this.matter && this.matter.destroy(), this.arcade = null, this.ninja = null, this.p2 = null, this.box2d = null, this.matter = null
            }
        }, i.Physics.prototype.constructor = i.Physics, i.Physics.Arcade = function(t) {
            this.game = t, this.gravity = new i.Point, this.bounds = new i.Rectangle(0, 0, t.world.width, t.world.height), this.checkCollision = {
                up: !0,
                down: !0,
                left: !0,
                right: !0
            }, this.maxObjects = 10, this.maxLevels = 4, this.OVERLAP_BIAS = 4, this.forceX = !1, this.sortDirection = i.Physics.Arcade.LEFT_RIGHT, this.skipQuadTree = !0, this.isPaused = !1, this.quadTree = new i.QuadTree(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels), this._total = 0, this.setBoundsToWorld()
        }, i.Physics.Arcade.prototype.constructor = i.Physics.Arcade, i.Physics.Arcade.SORT_NONE = 0, i.Physics.Arcade.LEFT_RIGHT = 1, i.Physics.Arcade.RIGHT_LEFT = 2, i.Physics.Arcade.TOP_BOTTOM = 3, i.Physics.Arcade.BOTTOM_TOP = 4, i.Physics.Arcade.prototype = {
            setBounds: function(t, e, i, s) {
                this.bounds.setTo(t, e, i, s)
            },
            setBoundsToWorld: function() {
                this.bounds.copyFrom(this.game.world.bounds)
            },
            enable: function(t, e) {
                void 0 === e && (e = !0);
                var s = 1;
                if (Array.isArray(t))
                    for (s = t.length; s--;) t[s] instanceof i.Group ? this.enable(t[s].children, e) : (this.enableBody(t[s]), e && t[s].hasOwnProperty("children") && t[s].children.length > 0 && this.enable(t[s], !0));
                else t instanceof i.Group ? this.enable(t.children, e) : (this.enableBody(t), e && t.hasOwnProperty("children") && t.children.length > 0 && this.enable(t.children, !0))
            },
            enableBody: function(t) {
                t.hasOwnProperty("body") && null === t.body && (t.body = new i.Physics.Arcade.Body(t), t.parent && t.parent instanceof i.Group && t.parent.addToHash(t))
            },
            updateMotion: function(t) {
                var e = this.computeVelocity(0, t, t.angularVelocity, t.angularAcceleration, t.angularDrag, t.maxAngular) - t.angularVelocity;
                t.angularVelocity += e, t.rotation += t.angularVelocity * this.game.time.physicsElapsed, t.velocity.x = this.computeVelocity(1, t, t.velocity.x, t.acceleration.x, t.drag.x, t.maxVelocity.x), t.velocity.y = this.computeVelocity(2, t, t.velocity.y, t.acceleration.y, t.drag.y, t.maxVelocity.y)
            },
            computeVelocity: function(t, e, i, s, o, n) {
                return void 0 === n && (n = 1e4), 1 === t && e.allowGravity ? i += (this.gravity.x + e.gravity.x) * this.game.time.physicsElapsed : 2 === t && e.allowGravity && (i += (this.gravity.y + e.gravity.y) * this.game.time.physicsElapsed), s ? i += s * this.game.time.physicsElapsed : o && (o *= this.game.time.physicsElapsed, i - o > 0 ? i -= o : i + o < 0 ? i += o : i = 0), i > n ? i = n : i < -n && (i = -n), i
            },
            overlap: function(t, e, i, s, o) {
                if (i = i || null, s = s || null, o = o || i, this._total = 0, !Array.isArray(t) && Array.isArray(e))
                    for (n = 0; n < e.length; n++) this.collideHandler(t, e[n], i, s, o, !0);
                else if (Array.isArray(t) && !Array.isArray(e))
                    for (n = 0; n < t.length; n++) this.collideHandler(t[n], e, i, s, o, !0);
                else if (Array.isArray(t) && Array.isArray(e))
                    for (var n = 0; n < t.length; n++)
                        for (var a = 0; a < e.length; a++) this.collideHandler(t[n], e[a], i, s, o, !0);
                else this.collideHandler(t, e, i, s, o, !0);
                return this._total > 0
            },
            collide: function(t, e, i, s, o) {
                if (i = i || null, s = s || null, o = o || i, this._total = 0, !Array.isArray(t) && Array.isArray(e))
                    for (n = 0; n < e.length; n++) this.collideHandler(t, e[n], i, s, o, !1);
                else if (Array.isArray(t) && !Array.isArray(e))
                    for (n = 0; n < t.length; n++) this.collideHandler(t[n], e, i, s, o, !1);
                else if (Array.isArray(t) && Array.isArray(e))
                    for (var n = 0; n < t.length; n++)
                        for (var a = 0; a < e.length; a++) this.collideHandler(t[n], e[a], i, s, o, !1);
                else this.collideHandler(t, e, i, s, o, !1);
                return this._total > 0
            },
            sortLeftRight: function(t, e) {
                return t.body && e.body ? t.body.x - e.body.x : 0
            },
            sortRightLeft: function(t, e) {
                return t.body && e.body ? e.body.x - t.body.x : 0
            },
            sortTopBottom: function(t, e) {
                return t.body && e.body ? t.body.y - e.body.y : 0
            },
            sortBottomTop: function(t, e) {
                return t.body && e.body ? e.body.y - t.body.y : 0
            },
            sort: function(t, e) {
                null !== t.physicsSortDirection ? e = t.physicsSortDirection : void 0 === e && (e = this.sortDirection), e === i.Physics.Arcade.LEFT_RIGHT ? t.hash.sort(this.sortLeftRight) : e === i.Physics.Arcade.RIGHT_LEFT ? t.hash.sort(this.sortRightLeft) : e === i.Physics.Arcade.TOP_BOTTOM ? t.hash.sort(this.sortTopBottom) : e === i.Physics.Arcade.BOTTOM_TOP && t.hash.sort(this.sortBottomTop)
            },
            collideHandler: function(t, e, s, o, n, a) {
                return void 0 === e && t.physicsType === i.GROUP ? (this.sort(t), void this.collideGroupVsSelf(t, s, o, n, a)) : void(t && e && t.exists && e.exists && (this.sortDirection !== i.Physics.Arcade.SORT_NONE && (t.physicsType === i.GROUP && this.sort(t), e.physicsType === i.GROUP && this.sort(e)), t.physicsType === i.SPRITE ? e.physicsType === i.SPRITE ? this.collideSpriteVsSprite(t, e, s, o, n, a) : e.physicsType === i.GROUP ? this.collideSpriteVsGroup(t, e, s, o, n, a) : e.physicsType === i.TILEMAPLAYER && this.collideSpriteVsTilemapLayer(t, e, s, o, n, a) : t.physicsType === i.GROUP ? e.physicsType === i.SPRITE ? this.collideSpriteVsGroup(e, t, s, o, n, a) : e.physicsType === i.GROUP ? this.collideGroupVsGroup(t, e, s, o, n, a) : e.physicsType === i.TILEMAPLAYER && this.collideGroupVsTilemapLayer(t, e, s, o, n, a) : t.physicsType === i.TILEMAPLAYER && (e.physicsType === i.SPRITE ? this.collideSpriteVsTilemapLayer(e, t, s, o, n, a) : e.physicsType === i.GROUP && this.collideGroupVsTilemapLayer(e, t, s, o, n, a))))
            },
            collideSpriteVsSprite: function(t, e, i, s, o, n) {
                return !(!t.body || !e.body || (this.separate(t.body, e.body, s, o, n) && (i && i.call(o, t, e), this._total++), 0))
            },
            collideSpriteVsGroup: function(t, e, s, o, n, a) {
                if (0 !== e.length && t.body)
                    if (this.skipQuadTree || t.body.skipQuadTree)
                        for (var r = {}, h = 0; h < e.hash.length; h++) {
                            var l = e.hash[h];
                            if (l && l.exists && l.body) {
                                if (r = l.body.getBounds(r), this.sortDirection === i.Physics.Arcade.LEFT_RIGHT) {
                                    if (t.body.right < r.x) break;
                                    if (r.right < t.body.x) continue
                                } else if (this.sortDirection === i.Physics.Arcade.RIGHT_LEFT) {
                                    if (t.body.x > r.right) break;
                                    if (r.x > t.body.right) continue
                                } else if (this.sortDirection === i.Physics.Arcade.TOP_BOTTOM) {
                                    if (t.body.bottom < r.y) break;
                                    if (r.bottom < t.body.y) continue
                                } else if (this.sortDirection === i.Physics.Arcade.BOTTOM_TOP) {
                                    if (t.body.y > r.bottom) break;
                                    if (r.y > t.body.bottom) continue
                                }
                                this.collideSpriteVsSprite(t, l, s, o, n, a)
                            }
                        } else {
                            this.quadTree.clear(), this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels), this.quadTree.populate(e);
                            for (var c = this.quadTree.retrieve(t), h = 0; h < c.length; h++) this.separate(t.body, c[h], o, n, a) && (s && s.call(n, t, c[h].sprite), this._total++)
                        }
            },
            collideGroupVsSelf: function(t, e, s, o, n) {
                if (0 !== t.length)
                    for (var a = 0; a < t.hash.length; a++) {
                        var r = {},
                            h = t.hash[a];
                        if (h && h.exists && h.body) {
                            r = h.body.getBounds(r);
                            for (var l = a + 1; l < t.hash.length; l++) {
                                var c = {},
                                    p = t.hash[l];
                                if (p && p.exists && p.body) {
                                    if (c = p.body.getBounds(c), this.sortDirection === i.Physics.Arcade.LEFT_RIGHT) {
                                        if (r.right < c.x) break;
                                        if (c.right < r.x) continue
                                    } else if (this.sortDirection === i.Physics.Arcade.RIGHT_LEFT) {
                                        if (r.x > c.right) continue;
                                        if (c.x > r.right) break
                                    } else if (this.sortDirection === i.Physics.Arcade.TOP_BOTTOM) {
                                        if (r.bottom < c.y) continue;
                                        if (c.bottom < r.y) break
                                    } else if (this.sortDirection === i.Physics.Arcade.BOTTOM_TOP) {
                                        if (r.y > c.bottom) continue;
                                        if (c.y > h.body.bottom) break
                                    }
                                    this.collideSpriteVsSprite(h, p, e, s, o, n)
                                }
                            }
                        }
                    }
            },
            collideGroupVsGroup: function(t, e, s, o, n, a) {
                if (0 !== t.length && 0 !== e.length)
                    for (var r = 0; r < t.children.length; r++) t.children[r].exists && (t.children[r].physicsType === i.GROUP ? this.collideGroupVsGroup(t.children[r], e, s, o, n, a) : this.collideSpriteVsGroup(t.children[r], e, s, o, n, a))
            },
            separate: function(t, e, i, s, o) {
                if (!t.enable || !e.enable || t.checkCollision.none || e.checkCollision.none || !this.intersects(t, e)) return !1;
                if (i && !1 === i.call(s, t.sprite, e.sprite)) return !1;
                if (t.isCircle && e.isCircle) return this.separateCircle(t, e, o);
                if (t.isCircle !== e.isCircle) {
                    var n = t.isCircle ? e : t,
                        a = t.isCircle ? t : e,
                        r = {
                            x: n.x,
                            y: n.y,
                            right: n.right,
                            bottom: n.bottom
                        },
                        h = {
                            x: a.x + a.radius,
                            y: a.y + a.radius
                        };
                    if ((h.y < r.y || h.y > r.bottom) && (h.x < r.x || h.x > r.right)) return this.separateCircle(t, e, o)
                }
                var l = !1,
                    c = !1;
                this.forceX || Math.abs(this.gravity.y + t.gravity.y) < Math.abs(this.gravity.x + t.gravity.x) ? (l = this.separateX(t, e, o), this.intersects(t, e) && (c = this.separateY(t, e, o))) : (c = this.separateY(t, e, o), this.intersects(t, e) && (l = this.separateX(t, e, o)));
                var p = l || c;
                return p && (o ? (t.onOverlap && t.onOverlap.dispatch(t.sprite, e.sprite), e.onOverlap && e.onOverlap.dispatch(e.sprite, t.sprite)) : (t.onCollide && t.onCollide.dispatch(t.sprite, e.sprite), e.onCollide && e.onCollide.dispatch(e.sprite, t.sprite))), p
            },
            intersects: function(t, e) {
                return t !== e && (t.isCircle ? e.isCircle ? i.Math.distance(t.center.x, t.center.y, e.center.x, e.center.y) <= t.radius + e.radius : this.circleBodyIntersects(t, e) : e.isCircle ? this.circleBodyIntersects(e, t) : !(t.right <= e.position.x || t.bottom <= e.position.y || t.position.x >= e.right || t.position.y >= e.bottom))
            },
            circleBodyIntersects: function(t, e) {
                var s = i.Math.clamp(t.center.x, e.left, e.right),
                    o = i.Math.clamp(t.center.y, e.top, e.bottom);
                return (t.center.x - s) * (t.center.x - s) + (t.center.y - o) * (t.center.y - o) <= t.radius * t.radius
            },
            separateCircle: function(t, e, s) {
                this.getOverlapX(t, e), this.getOverlapY(t, e);
                var o = e.center.x - t.center.x,
                    n = e.center.y - t.center.y,
                    a = Math.atan2(n, o),
                    r = 0;
                if (t.isCircle !== e.isCircle) {
                    var h = {
                            x: e.isCircle ? t.position.x : e.position.x,
                            y: e.isCircle ? t.position.y : e.position.y,
                            right: e.isCircle ? t.right : e.right,
                            bottom: e.isCircle ? t.bottom : e.bottom
                        },
                        l = {
                            x: t.isCircle ? t.position.x + t.radius : e.position.x + e.radius,
                            y: t.isCircle ? t.position.y + t.radius : e.position.y + e.radius,
                            radius: t.isCircle ? t.radius : e.radius
                        };
                    l.y < h.y ? l.x < h.x ? r = i.Math.distance(l.x, l.y, h.x, h.y) - l.radius : l.x > h.right && (r = i.Math.distance(l.x, l.y, h.right, h.y) - l.radius) : l.y > h.bottom && (l.x < h.x ? r = i.Math.distance(l.x, l.y, h.x, h.bottom) - l.radius : l.x > h.right && (r = i.Math.distance(l.x, l.y, h.right, h.bottom) - l.radius)), r *= -1
                } else r = t.radius + e.radius - i.Math.distance(t.center.x, t.center.y, e.center.x, e.center.y);
                if (s || 0 === r || t.immovable && e.immovable || t.customSeparateX || e.customSeparateX) return 0 !== r && (t.onOverlap && t.onOverlap.dispatch(t.sprite, e.sprite), e.onOverlap && e.onOverlap.dispatch(e.sprite, t.sprite)), 0 !== r;
                var c = {
                        x: t.velocity.x * Math.cos(a) + t.velocity.y * Math.sin(a),
                        y: t.velocity.x * Math.sin(a) - t.velocity.y * Math.cos(a)
                    },
                    p = {
                        x: e.velocity.x * Math.cos(a) + e.velocity.y * Math.sin(a),
                        y: e.velocity.x * Math.sin(a) - e.velocity.y * Math.cos(a)
                    },
                    u = ((t.mass - e.mass) * c.x + 2 * e.mass * p.x) / (t.mass + e.mass),
                    d = (2 * t.mass * c.x + (e.mass - t.mass) * p.x) / (t.mass + e.mass);
                return t.immovable || (t.velocity.x = (u * Math.cos(a) - c.y * Math.sin(a)) * t.bounce.x, t.velocity.y = (c.y * Math.cos(a) + u * Math.sin(a)) * t.bounce.y), e.immovable || (e.velocity.x = (d * Math.cos(a) - p.y * Math.sin(a)) * e.bounce.x, e.velocity.y = (p.y * Math.cos(a) + d * Math.sin(a)) * e.bounce.y), Math.abs(a) < Math.PI / 2 ? t.velocity.x > 0 && !t.immovable && e.velocity.x > t.velocity.x ? t.velocity.x *= -1 : e.velocity.x < 0 && !e.immovable && t.velocity.x < e.velocity.x ? e.velocity.x *= -1 : t.velocity.y > 0 && !t.immovable && e.velocity.y > t.velocity.y ? t.velocity.y *= -1 : e.velocity.y < 0 && !e.immovable && t.velocity.y < e.velocity.y && (e.velocity.y *= -1) : Math.abs(a) > Math.PI / 2 && (t.velocity.x < 0 && !t.immovable && e.velocity.x < t.velocity.x ? t.velocity.x *= -1 : e.velocity.x > 0 && !e.immovable && t.velocity.x > e.velocity.x ? e.velocity.x *= -1 : t.velocity.y < 0 && !t.immovable && e.velocity.y < t.velocity.y ? t.velocity.y *= -1 : e.velocity.y > 0 && !e.immovable && t.velocity.x > e.velocity.y && (e.velocity.y *= -1)), t.immovable || (t.x += t.velocity.x * this.game.time.physicsElapsed - r * Math.cos(a), t.y += t.velocity.y * this.game.time.physicsElapsed - r * Math.sin(a)), e.immovable || (e.x += e.velocity.x * this.game.time.physicsElapsed + r * Math.cos(a), e.y += e.velocity.y * this.game.time.physicsElapsed + r * Math.sin(a)), t.onCollide && t.onCollide.dispatch(t.sprite, e.sprite), e.onCollide && e.onCollide.dispatch(e.sprite, t.sprite), !0
            },
            getOverlapX: function(t, e, i) {
                var s = 0,
                    o = t.deltaAbsX() + e.deltaAbsX() + this.OVERLAP_BIAS;
                return 0 === t.deltaX() && 0 === e.deltaX() ? (t.embedded = !0, e.embedded = !0) : t.deltaX() > e.deltaX() ? (s = t.right - e.x) > o && !i || !1 === t.checkCollision.right || !1 === e.checkCollision.left ? s = 0 : (t.touching.none = !1, t.touching.right = !0, e.touching.none = !1, e.touching.left = !0) : t.deltaX() < e.deltaX() && (-(s = t.x - e.width - e.x) > o && !i || !1 === t.checkCollision.left || !1 === e.checkCollision.right ? s = 0 : (t.touching.none = !1, t.touching.left = !0, e.touching.none = !1, e.touching.right = !0)), t.overlapX = s, e.overlapX = s, s
            },
            getOverlapY: function(t, e, i) {
                var s = 0,
                    o = t.deltaAbsY() + e.deltaAbsY() + this.OVERLAP_BIAS;
                return 0 === t.deltaY() && 0 === e.deltaY() ? (t.embedded = !0, e.embedded = !0) : t.deltaY() > e.deltaY() ? (s = t.bottom - e.y) > o && !i || !1 === t.checkCollision.down || !1 === e.checkCollision.up ? s = 0 : (t.touching.none = !1, t.touching.down = !0, e.touching.none = !1, e.touching.up = !0) : t.deltaY() < e.deltaY() && (-(s = t.y - e.bottom) > o && !i || !1 === t.checkCollision.up || !1 === e.checkCollision.down ? s = 0 : (t.touching.none = !1, t.touching.up = !0, e.touching.none = !1, e.touching.down = !0)), t.overlapY = s, e.overlapY = s, s
            },
            separateX: function(t, e, i) {
                var s = this.getOverlapX(t, e, i);
                if (i || 0 === s || t.immovable && e.immovable || t.customSeparateX || e.customSeparateX) return 0 !== s || t.embedded && e.embedded;
                var o = t.velocity.x,
                    n = e.velocity.x;
                if (t.immovable || e.immovable) t.immovable ? (e.x += s, e.velocity.x = o - n * e.bounce.x, t.moves && (e.y += (t.y - t.prev.y) * t.friction.y)) : (t.x -= s, t.velocity.x = n - o * t.bounce.x, e.moves && (t.y += (e.y - e.prev.y) * e.friction.y));
                else {
                    s *= .5, t.x -= s, e.x += s;
                    var a = Math.sqrt(n * n * e.mass / t.mass) * (n > 0 ? 1 : -1),
                        r = Math.sqrt(o * o * t.mass / e.mass) * (o > 0 ? 1 : -1),
                        h = .5 * (a + r);
                    a -= h, r -= h, t.velocity.x = h + a * t.bounce.x, e.velocity.x = h + r * e.bounce.x
                }
                return !0
            },
            separateY: function(t, e, i) {
                var s = this.getOverlapY(t, e, i);
                if (i || 0 === s || t.immovable && e.immovable || t.customSeparateY || e.customSeparateY) return 0 !== s || t.embedded && e.embedded;
                var o = t.velocity.y,
                    n = e.velocity.y;
                if (t.immovable || e.immovable) t.immovable ? (e.y += s, e.velocity.y = o - n * e.bounce.y, t.moves && (e.x += (t.x - t.prev.x) * t.friction.x)) : (t.y -= s, t.velocity.y = n - o * t.bounce.y, e.moves && (t.x += (e.x - e.prev.x) * e.friction.x));
                else {
                    s *= .5, t.y -= s, e.y += s;
                    var a = Math.sqrt(n * n * e.mass / t.mass) * (n > 0 ? 1 : -1),
                        r = Math.sqrt(o * o * t.mass / e.mass) * (o > 0 ? 1 : -1),
                        h = .5 * (a + r);
                    a -= h, r -= h, t.velocity.y = h + a * t.bounce.y, e.velocity.y = h + r * e.bounce.y
                }
                return !0
            },
            getObjectsUnderPointer: function(t, e, i, s) {
                if (0 !== e.length && t.exists) return this.getObjectsAtLocation(t.x, t.y, e, i, s, t)
            },
            getObjectsAtLocation: function(t, e, s, o, n, a) {
                this.quadTree.clear(), this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels), this.quadTree.populate(s);
                for (var r = new i.Rectangle(t, e, 1, 1), h = [], l = this.quadTree.retrieve(r), c = 0; c < l.length; c++) l[c].hitTest(t, e) && (o && o.call(n, a, l[c].sprite), h.push(l[c].sprite));
                return h
            },
            moveToObject: function(t, e, i, s) {
                void 0 === i && (i = 60), void 0 === s && (s = 0);
                var o = Math.atan2(e.y - t.y, e.x - t.x);
                return s > 0 && (i = this.distanceBetween(t, e) / (s / 1e3)), t.body.velocity.x = Math.cos(o) * i, t.body.velocity.y = Math.sin(o) * i, o
            },
            moveToPointer: function(t, e, i, s) {
                void 0 === e && (e = 60), i = i || this.game.input.activePointer, void 0 === s && (s = 0);
                var o = this.angleToPointer(t, i);
                return s > 0 && (e = this.distanceToPointer(t, i) / (s / 1e3)), t.body.velocity.x = Math.cos(o) * e, t.body.velocity.y = Math.sin(o) * e, o
            },
            moveToXY: function(t, e, i, s, o) {
                void 0 === s && (s = 60), void 0 === o && (o = 0);
                var n = Math.atan2(i - t.y, e - t.x);
                return o > 0 && (s = this.distanceToXY(t, e, i) / (o / 1e3)), t.body.velocity.x = Math.cos(n) * s, t.body.velocity.y = Math.sin(n) * s, n
            },
            velocityFromAngle: function(t, e, s) {
                return void 0 === e && (e = 60), (s = s || new i.Point).setTo(Math.cos(this.game.math.degToRad(t)) * e, Math.sin(this.game.math.degToRad(t)) * e)
            },
            velocityFromRotation: function(t, e, s) {
                return void 0 === e && (e = 60), (s = s || new i.Point).setTo(Math.cos(t) * e, Math.sin(t) * e)
            },
            accelerationFromRotation: function(t, e, s) {
                return void 0 === e && (e = 60), (s = s || new i.Point).setTo(Math.cos(t) * e, Math.sin(t) * e)
            },
            accelerateToObject: function(t, e, i, s, o) {
                void 0 === i && (i = 60), void 0 === s && (s = 1e3), void 0 === o && (o = 1e3);
                var n = this.angleBetween(t, e);
                return t.body.acceleration.setTo(Math.cos(n) * i, Math.sin(n) * i), t.body.maxVelocity.setTo(s, o), n
            },
            accelerateToPointer: function(t, e, i, s, o) {
                void 0 === i && (i = 60), void 0 === e && (e = this.game.input.activePointer), void 0 === s && (s = 1e3), void 0 === o && (o = 1e3);
                var n = this.angleToPointer(t, e);
                return t.body.acceleration.setTo(Math.cos(n) * i, Math.sin(n) * i), t.body.maxVelocity.setTo(s, o), n
            },
            accelerateToXY: function(t, e, i, s, o, n) {
                void 0 === s && (s = 60), void 0 === o && (o = 1e3), void 0 === n && (n = 1e3);
                var a = this.angleToXY(t, e, i);
                return t.body.acceleration.setTo(Math.cos(a) * s, Math.sin(a) * s), t.body.maxVelocity.setTo(o, n), a
            },
            distanceBetween: function(t, e, i) {
                void 0 === i && (i = !1);
                var s = i ? t.world.x - e.world.x : t.x - e.x,
                    o = i ? t.world.y - e.world.y : t.y - e.y;
                return Math.sqrt(s * s + o * o)
            },
            distanceToXY: function(t, e, i, s) {
                void 0 === s && (s = !1);
                var o = s ? t.world.x - e : t.x - e,
                    n = s ? t.world.y - i : t.y - i;
                return Math.sqrt(o * o + n * n)
            },
            distanceToPointer: function(t, e, i) {
                void 0 === e && (e = this.game.input.activePointer), void 0 === i && (i = !1);
                var s = i ? t.world.x - e.worldX : t.x - e.worldX,
                    o = i ? t.world.y - e.worldY : t.y - e.worldY;
                return Math.sqrt(s * s + o * o)
            },
            angleBetween: function(t, e, i) {
                return void 0 === i && (i = !1), i ? Math.atan2(e.world.y - t.world.y, e.world.x - t.world.x) : Math.atan2(e.y - t.y, e.x - t.x)
            },
            angleBetweenCenters: function(t, e) {
                var i = e.centerX - t.centerX,
                    s = e.centerY - t.centerY;
                return Math.atan2(s, i)
            },
            angleToXY: function(t, e, i, s) {
                return void 0 === s && (s = !1), s ? Math.atan2(i - t.world.y, e - t.world.x) : Math.atan2(i - t.y, e - t.x)
            },
            angleToPointer: function(t, e, i) {
                return void 0 === e && (e = this.game.input.activePointer), void 0 === i && (i = !1), i ? Math.atan2(e.worldY - t.world.y, e.worldX - t.world.x) : Math.atan2(e.worldY - t.y, e.worldX - t.x)
            },
            worldAngleToPointer: function(t, e) {
                return this.angleToPointer(t, e, !0)
            }
        }, i.Physics.Arcade.Body = function(t) {
            this.sprite = t, this.game = t.game, this.type = i.Physics.ARCADE, this.enable = !0, this.isCircle = !1, this.radius = 0, this.offset = new i.Point, this.position = new i.Point(t.x, t.y), this.prev = new i.Point(this.position.x, this.position.y), this.allowRotation = !0, this.rotation = t.angle, this.preRotation = t.angle, this.width = t.width, this.height = t.height, this.sourceWidth = t.width, this.sourceHeight = t.height, t.texture && (this.sourceWidth = t.texture.frame.width, this.sourceHeight = t.texture.frame.height), this.halfWidth = Math.abs(t.width / 2), this.halfHeight = Math.abs(t.height / 2), this.center = new i.Point(t.x + this.halfWidth, t.y + this.halfHeight), this.velocity = new i.Point, this.newVelocity = new i.Point, this.deltaMax = new i.Point, this.acceleration = new i.Point, this.drag = new i.Point, this.allowGravity = !0, this.gravity = new i.Point, this.bounce = new i.Point, this.worldBounce = null, this.onWorldBounds = null, this.onCollide = null, this.onOverlap = null, this.maxVelocity = new i.Point(1e4, 1e4), this.friction = new i.Point(1, 0), this.angularVelocity = 0, this.angularAcceleration = 0, this.angularDrag = 0, this.maxAngular = 1e3, this.mass = 1, this.angle = 0, this.speed = 0, this.facing = i.NONE, this.immovable = !1, this.moves = !0, this.customSeparateX = !1, this.customSeparateY = !1, this.overlapX = 0, this.overlapY = 0, this.overlapR = 0, this.embedded = !1, this.collideWorldBounds = !1, this.checkCollision = {
                none: !1,
                any: !0,
                up: !0,
                down: !0,
                left: !0,
                right: !0
            }, this.touching = {
                none: !0,
                up: !1,
                down: !1,
                left: !1,
                right: !1
            }, this.wasTouching = {
                none: !0,
                up: !1,
                down: !1,
                left: !1,
                right: !1
            }, this.blocked = {
                up: !1,
                down: !1,
                left: !1,
                right: !1
            }, this.tilePadding = new i.Point, this.dirty = !1, this.skipQuadTree = !1, this.syncBounds = !1, this.isMoving = !1, this.stopVelocityOnCollide = !0, this.moveTimer = 0, this.moveDistance = 0, this.moveDuration = 0, this.moveTarget = null, this.moveEnd = null, this.onMoveComplete = new i.Signal, this.movementCallback = null, this.movementCallbackContext = null, this._reset = !0, this._sx = t.scale.x, this._sy = t.scale.y, this._dx = 0, this._dy = 0
        }, i.Physics.Arcade.Body.prototype = {
            updateBounds: function() {
                if (this.syncBounds) {
                    var t = this.sprite.getBounds();
                    t.ceilAll(), t.width === this.width && t.height === this.height || (this.width = t.width, this.height = t.height, this._reset = !0)
                } else {
                    var e = Math.abs(this.sprite.scale.x),
                        i = Math.abs(this.sprite.scale.y);
                    e === this._sx && i === this._sy || (this.width = this.sourceWidth * e, this.height = this.sourceHeight * i, this._sx = e, this._sy = i, this._reset = !0)
                }
                this._reset && (this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight))
            },
            preUpdate: function() {
                this.enable && !this.game.physics.arcade.isPaused && (this.dirty = !0, this.wasTouching.none = this.touching.none, this.wasTouching.up = this.touching.up, this.wasTouching.down = this.touching.down, this.wasTouching.left = this.touching.left, this.wasTouching.right = this.touching.right, this.touching.none = !0, this.touching.up = !1, this.touching.down = !1, this.touching.left = !1, this.touching.right = !1, this.blocked.up = !1, this.blocked.down = !1, this.blocked.left = !1, this.blocked.right = !1, this.embedded = !1, this.updateBounds(), this.position.x = this.sprite.world.x - this.sprite.anchor.x * this.sprite.width + this.sprite.scale.x * this.offset.x, this.position.x -= this.sprite.scale.x < 0 ? this.width : 0, this.position.y = this.sprite.world.y - this.sprite.anchor.y * this.sprite.height + this.sprite.scale.y * this.offset.y, this.position.y -= this.sprite.scale.y < 0 ? this.height : 0, this.rotation = this.sprite.angle, this.preRotation = this.rotation, (this._reset || this.sprite.fresh) && (this.prev.x = this.position.x, this.prev.y = this.position.y), this.moves && (this.game.physics.arcade.updateMotion(this), this.newVelocity.set(this.velocity.x * this.game.time.physicsElapsed, this.velocity.y * this.game.time.physicsElapsed), this.position.x += this.newVelocity.x, this.position.y += this.newVelocity.y, this.position.x === this.prev.x && this.position.y === this.prev.y || (this.angle = Math.atan2(this.velocity.y, this.velocity.x)), this.speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y), this.collideWorldBounds && this.checkWorldBounds() && this.onWorldBounds && this.onWorldBounds.dispatch(this.sprite, this.blocked.up, this.blocked.down, this.blocked.left, this.blocked.right)), this._dx = this.deltaX(), this._dy = this.deltaY(), this._reset = !1)
            },
            updateMovement: function() {
                var t = 0,
                    e = 0 !== this.overlapX || 0 !== this.overlapY;
                if (this.moveDuration > 0 ? (this.moveTimer += this.game.time.elapsedMS, t = this.moveTimer / this.moveDuration) : (this.moveTarget.end.set(this.position.x, this.position.y), t = this.moveTarget.length / this.moveDistance), this.movementCallback) var i = this.movementCallback.call(this.movementCallbackContext, this, this.velocity, t);
                return !(e || t >= 1 || void 0 !== i && !0 !== i) || (this.stopMovement(t >= 1 || this.stopVelocityOnCollide && e), !1)
            },
            stopMovement: function(t) {
                this.isMoving && (this.isMoving = !1, t && this.velocity.set(0), this.onMoveComplete.dispatch(this.sprite, 0 !== this.overlapX || 0 !== this.overlapY))
            },
            postUpdate: function() {
                this.enable && this.dirty && (this.isMoving && this.updateMovement(), this.dirty = !1, this.deltaX() < 0 ? this.facing = i.LEFT : this.deltaX() > 0 && (this.facing = i.RIGHT), this.deltaY() < 0 ? this.facing = i.UP : this.deltaY() > 0 && (this.facing = i.DOWN), this.moves && (this._dx = this.deltaX(), this._dy = this.deltaY(), 0 !== this.deltaMax.x && 0 !== this._dx && (this._dx < 0 && this._dx < -this.deltaMax.x ? this._dx = -this.deltaMax.x : this._dx > 0 && this._dx > this.deltaMax.x && (this._dx = this.deltaMax.x)), 0 !== this.deltaMax.y && 0 !== this._dy && (this._dy < 0 && this._dy < -this.deltaMax.y ? this._dy = -this.deltaMax.y : this._dy > 0 && this._dy > this.deltaMax.y && (this._dy = this.deltaMax.y)), this.sprite.position.x += this._dx, this.sprite.position.y += this._dy, this._reset = !0), this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight), this.allowRotation && (this.sprite.angle += this.deltaZ()), this.prev.x = this.position.x, this.prev.y = this.position.y)
            },
            checkWorldBounds: function() {
                var t = this.position,
                    e = this.game.physics.arcade.bounds,
                    i = this.game.physics.arcade.checkCollision,
                    s = this.worldBounce ? -this.worldBounce.x : -this.bounce.x,
                    o = this.worldBounce ? -this.worldBounce.y : -this.bounce.y;
                if (this.isCircle) {
                    var n = {
                        x: this.center.x - this.radius,
                        y: this.center.y - this.radius,
                        right: this.center.x + this.radius,
                        bottom: this.center.y + this.radius
                    };
                    n.x < e.x && i.left ? (t.x = e.x - this.halfWidth + this.radius, this.velocity.x *= s, this.blocked.left = !0) : n.right > e.right && i.right && (t.x = e.right - this.halfWidth - this.radius, this.velocity.x *= s, this.blocked.right = !0), n.y < e.y && i.up ? (t.y = e.y - this.halfHeight + this.radius, this.velocity.y *= o, this.blocked.up = !0) : n.bottom > e.bottom && i.down && (t.y = e.bottom - this.halfHeight - this.radius, this.velocity.y *= o, this.blocked.down = !0)
                } else t.x < e.x && i.left ? (t.x = e.x, this.velocity.x *= s, this.blocked.left = !0) : this.right > e.right && i.right && (t.x = e.right - this.width, this.velocity.x *= s, this.blocked.right = !0), t.y < e.y && i.up ? (t.y = e.y, this.velocity.y *= o, this.blocked.up = !0) : this.bottom > e.bottom && i.down && (t.y = e.bottom - this.height, this.velocity.y *= o, this.blocked.down = !0);
                return this.blocked.up || this.blocked.down || this.blocked.left || this.blocked.right
            },
            moveFrom: function(t, e, i) {
                if (void 0 === e && (e = this.speed), 0 === e) return !1;
                var s;
                return void 0 === i ? (s = this.angle, i = this.game.math.radToDeg(s)) : s = this.game.math.degToRad(i), this.moveTimer = 0, this.moveDuration = t, 0 === i || 180 === i ? this.velocity.set(Math.cos(s) * e, 0) : 90 === i || 270 === i ? this.velocity.set(0, Math.sin(s) * e) : this.velocity.set(Math.cos(s) * e, Math.sin(s) * e), this.isMoving = !0, !0
            },
            moveTo: function(t, e, s) {
                var o = e / (t / 1e3);
                if (0 === o) return !1;
                var n;
                return void 0 === s ? (n = this.angle, s = this.game.math.radToDeg(n)) : n = this.game.math.degToRad(s), e = Math.abs(e), this.moveDuration = 0, this.moveDistance = e, null === this.moveTarget && (this.moveTarget = new i.Line, this.moveEnd = new i.Point), this.moveTarget.fromAngle(this.x, this.y, n, e), this.moveEnd.set(this.moveTarget.end.x, this.moveTarget.end.y), this.moveTarget.setTo(this.x, this.y, this.x, this.y), 0 === s || 180 === s ? this.velocity.set(Math.cos(n) * o, 0) : 90 === s || 270 === s ? this.velocity.set(0, Math.sin(n) * o) : this.velocity.set(Math.cos(n) * o, Math.sin(n) * o), this.isMoving = !0, !0
            },
            setSize: function(t, e, i, s) {
                void 0 === i && (i = this.offset.x), void 0 === s && (s = this.offset.y), this.sourceWidth = t, this.sourceHeight = e, this.width = this.sourceWidth * this._sx, this.height = this.sourceHeight * this._sy, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.offset.setTo(i, s), this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight), this.isCircle = !1, this.radius = 0
            },
            setCircle: function(t, e, i) {
                void 0 === e && (e = this.offset.x), void 0 === i && (i = this.offset.y), t > 0 ? (this.isCircle = !0, this.radius = t, this.sourceWidth = 2 * t, this.sourceHeight = 2 * t, this.width = this.sourceWidth * this._sx, this.height = this.sourceHeight * this._sy, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.offset.setTo(e, i), this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight)) : this.isCircle = !1
            },
            reset: function(t, e) {
                this.velocity.set(0), this.acceleration.set(0), this.speed = 0, this.angularVelocity = 0, this.angularAcceleration = 0, this.position.x = t - this.sprite.anchor.x * this.sprite.width + this.sprite.scale.x * this.offset.x, this.position.x -= this.sprite.scale.x < 0 ? this.width : 0, this.position.y = e - this.sprite.anchor.y * this.sprite.height + this.sprite.scale.y * this.offset.y, this.position.y -= this.sprite.scale.y < 0 ? this.height : 0, this.prev.x = this.position.x, this.prev.y = this.position.y, this.rotation = this.sprite.angle, this.preRotation = this.rotation, this._sx = this.sprite.scale.x, this._sy = this.sprite.scale.y, this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight)
            },
            getBounds: function(t) {
                return this.isCircle ? (t.x = this.center.x - this.radius, t.y = this.center.y - this.radius, t.right = this.center.x + this.radius, t.bottom = this.center.y + this.radius) : (t.x = this.x, t.y = this.y, t.right = this.right, t.bottom = this.bottom), t
            },
            hitTest: function(t, e) {
                return this.isCircle ? i.Circle.contains(this, t, e) : i.Rectangle.contains(this, t, e)
            },
            onFloor: function() {
                return this.blocked.down
            },
            onCeiling: function() {
                return this.blocked.up
            },
            onWall: function() {
                return this.blocked.left || this.blocked.right
            },
            deltaAbsX: function() {
                return this.deltaX() > 0 ? this.deltaX() : -this.deltaX()
            },
            deltaAbsY: function() {
                return this.deltaY() > 0 ? this.deltaY() : -this.deltaY()
            },
            deltaX: function() {
                return this.position.x - this.prev.x
            },
            deltaY: function() {
                return this.position.y - this.prev.y
            },
            deltaZ: function() {
                return this.rotation - this.preRotation
            },
            destroy: function() {
                this.sprite.parent && this.sprite.parent instanceof i.Group && this.sprite.parent.removeFromHash(this.sprite), this.sprite.body = null, this.sprite = null
            }
        }, Object.defineProperty(i.Physics.Arcade.Body.prototype, "left", {
            get: function() {
                return this.position.x
            }
        }), Object.defineProperty(i.Physics.Arcade.Body.prototype, "right", {
            get: function() {
                return this.position.x + this.width
            }
        }), Object.defineProperty(i.Physics.Arcade.Body.prototype, "top", {
            get: function() {
                return this.position.y
            }
        }), Object.defineProperty(i.Physics.Arcade.Body.prototype, "bottom", {
            get: function() {
                return this.position.y + this.height
            }
        }), Object.defineProperty(i.Physics.Arcade.Body.prototype, "x", {
            get: function() {
                return this.position.x
            },
            set: function(t) {
                this.position.x = t
            }
        }), Object.defineProperty(i.Physics.Arcade.Body.prototype, "y", {
            get: function() {
                return this.position.y
            },
            set: function(t) {
                this.position.y = t
            }
        }), i.Physics.Arcade.Body.render = function(t, e, i, s) {
            void 0 === s && (s = !0), i = i || "rgba(0,255,0,0.4)", t.fillStyle = i, t.strokeStyle = i, e.isCircle ? (t.beginPath(), t.arc(e.center.x - e.game.camera.x, e.center.y - e.game.camera.y, e.radius, 0, 2 * Math.PI), s ? t.fill() : t.stroke()) : s ? t.fillRect(e.position.x - e.game.camera.x, e.position.y - e.game.camera.y, e.width, e.height) : t.strokeRect(e.position.x - e.game.camera.x, e.position.y - e.game.camera.y, e.width, e.height)
        }, i.Physics.Arcade.Body.renderBodyInfo = function(t, e) {
            t.line("x: " + e.x.toFixed(2), "y: " + e.y.toFixed(2), "width: " + e.width, "height: " + e.height), t.line("velocity x: " + e.velocity.x.toFixed(2), "y: " + e.velocity.y.toFixed(2), "deltaX: " + e._dx.toFixed(2), "deltaY: " + e._dy.toFixed(2)), t.line("acceleration x: " + e.acceleration.x.toFixed(2), "y: " + e.acceleration.y.toFixed(2), "speed: " + e.speed.toFixed(2), "angle: " + e.angle.toFixed(2)), t.line("gravity x: " + e.gravity.x, "y: " + e.gravity.y, "bounce x: " + e.bounce.x.toFixed(2), "y: " + e.bounce.y.toFixed(2)), t.line("touching left: " + e.touching.left, "right: " + e.touching.right, "up: " + e.touching.up, "down: " + e.touching.down), t.line("blocked left: " + e.blocked.left, "right: " + e.blocked.right, "up: " + e.blocked.up, "down: " + e.blocked.down)
        }, i.Physics.Arcade.Body.prototype.constructor = i.Physics.Arcade.Body, i.Physics.Arcade.TilemapCollision = function() {}, i.Physics.Arcade.TilemapCollision.prototype = {
            TILE_BIAS: 16,
            collideSpriteVsTilemapLayer: function(t, e, i, s, o, n) {
                if (t.body) {
                    var a = e.getTiles(t.body.position.x - t.body.tilePadding.x, t.body.position.y - t.body.tilePadding.y, t.body.width + t.body.tilePadding.x, t.body.height + t.body.tilePadding.y, !1, !1);
                    if (0 !== a.length)
                        for (var r = 0; r < a.length; r++) s ? s.call(o, t, a[r]) && this.separateTile(r, t.body, a[r], e, n) && (this._total++, i && i.call(o, t, a[r])) : this.separateTile(r, t.body, a[r], e, n) && (this._total++, i && i.call(o, t, a[r]))
                }
            },
            collideGroupVsTilemapLayer: function(t, e, i, s, o, n) {
                if (0 !== t.length)
                    for (var a = 0; a < t.children.length; a++) t.children[a].exists && this.collideSpriteVsTilemapLayer(t.children[a], e, i, s, o, n)
            },
            separateTile: function(t, e, i, s, o) {
                if (!e.enable) return !1;
                var n = s.fixedToCamera ? 0 : s.position.x,
                    a = s.fixedToCamera ? 0 : s.position.y;
                if (!i.intersects(e.position.x - n, e.position.y - a, e.right - n, e.bottom - a)) return !1;
                if (o) return !0;
                if (i.collisionCallback && !i.collisionCallback.call(i.collisionCallbackContext, e.sprite, i)) return !1;
                if (void 0 !== i.layer.callbacks && i.layer.callbacks[i.index] && !i.layer.callbacks[i.index].callback.call(i.layer.callbacks[i.index].callbackContext, e.sprite, i)) return !1;
                if (!(i.faceLeft || i.faceRight || i.faceTop || i.faceBottom)) return !1;
                var r = 0,
                    h = 0,
                    l = 0,
                    c = 1;
                if (e.deltaAbsX() > e.deltaAbsY() ? l = -1 : e.deltaAbsX() < e.deltaAbsY() && (c = -1), 0 !== e.deltaX() && 0 !== e.deltaY() && (i.faceLeft || i.faceRight) && (i.faceTop || i.faceBottom) && (l = Math.min(Math.abs(e.position.x - n - i.right), Math.abs(e.right - n - i.left)), c = Math.min(Math.abs(e.position.y - a - i.bottom), Math.abs(e.bottom - a - i.top))), l < c) {
                    if ((i.faceLeft || i.faceRight) && 0 !== (r = this.tileCheckX(e, i, s)) && !i.intersects(e.position.x - n, e.position.y - a, e.right - n, e.bottom - a)) return !0;
                    (i.faceTop || i.faceBottom) && (h = this.tileCheckY(e, i, s))
                } else {
                    if ((i.faceTop || i.faceBottom) && 0 !== (h = this.tileCheckY(e, i, s)) && !i.intersects(e.position.x - n, e.position.y - a, e.right - n, e.bottom - a)) return !0;
                    (i.faceLeft || i.faceRight) && (r = this.tileCheckX(e, i, s))
                }
                return 0 !== r || 0 !== h
            },
            tileCheckX: function(t, e, i) {
                var s = 0,
                    o = i.fixedToCamera ? 0 : i.position.x;
                return t.deltaX() < 0 && !t.blocked.left && e.collideRight && t.checkCollision.left ? e.faceRight && t.x - o < e.right && (s = t.x - o - e.right) < -this.TILE_BIAS && (s = 0) : t.deltaX() > 0 && !t.blocked.right && e.collideLeft && t.checkCollision.right && e.faceLeft && t.right - o > e.left && (s = t.right - o - e.left) > this.TILE_BIAS && (s = 0), 0 !== s && (t.customSeparateX ? t.overlapX = s : this.processTileSeparationX(t, s)), s
            },
            tileCheckY: function(t, e, i) {
                var s = 0,
                    o = i.fixedToCamera ? 0 : i.position.y;
                return t.deltaY() < 0 && !t.blocked.up && e.collideDown && t.checkCollision.up ? e.faceBottom && t.y - o < e.bottom && (s = t.y - o - e.bottom) < -this.TILE_BIAS && (s = 0) : t.deltaY() > 0 && !t.blocked.down && e.collideUp && t.checkCollision.down && e.faceTop && t.bottom - o > e.top && (s = t.bottom - o - e.top) > this.TILE_BIAS && (s = 0), 0 !== s && (t.customSeparateY ? t.overlapY = s : this.processTileSeparationY(t, s)), s
            },
            processTileSeparationX: function(t, e) {
                e < 0 ? t.blocked.left = !0 : e > 0 && (t.blocked.right = !0), t.position.x -= e, 0 === t.bounce.x ? t.velocity.x = 0 : t.velocity.x = -t.velocity.x * t.bounce.x
            },
            processTileSeparationY: function(t, e) {
                e < 0 ? t.blocked.up = !0 : e > 0 && (t.blocked.down = !0), t.position.y -= e, 0 === t.bounce.y ? t.velocity.y = 0 : t.velocity.y = -t.velocity.y * t.bounce.y
            }
        }, i.Utils.mixinPrototype(i.Physics.Arcade.prototype, i.Physics.Arcade.TilemapCollision.prototype), p2.Body.prototype.parent = null, p2.Spring.prototype.parent = null, i.Physics.P2 = function(t, e) {
            this.game = t, void 0 === e ? e = {
                gravity: [0, 0],
                broadphase: new p2.SAPBroadphase
            } : (e.hasOwnProperty("gravity") || (e.gravity = [0, 0]), e.hasOwnProperty("broadphase") || (e.broadphase = new p2.SAPBroadphase)), this.config = e, this.world = new p2.World(this.config), this.frameRate = 1 / 60, this.useElapsedTime = !1, this.paused = !1, this.materials = [], this.gravity = new i.Physics.P2.InversePointProxy(this, this.world.gravity), this.walls = {
                left: null,
                right: null,
                top: null,
                bottom: null
            }, this.onBodyAdded = new i.Signal, this.onBodyRemoved = new i.Signal, this.onSpringAdded = new i.Signal, this.onSpringRemoved = new i.Signal, this.onConstraintAdded = new i.Signal, this.onConstraintRemoved = new i.Signal, this.onContactMaterialAdded = new i.Signal, this.onContactMaterialRemoved = new i.Signal, this.postBroadphaseCallback = null, this.callbackContext = null, this.onBeginContact = new i.Signal, this.onEndContact = new i.Signal, e.hasOwnProperty("mpx") && e.hasOwnProperty("pxm") && e.hasOwnProperty("mpxi") && e.hasOwnProperty("pxmi") && (this.mpx = e.mpx, this.mpxi = e.mpxi, this.pxm = e.pxm, this.pxmi = e.pxmi), this.world.on("beginContact", this.beginContactHandler, this), this.world.on("endContact", this.endContactHandler, this), this.collisionGroups = [], this.nothingCollisionGroup = new i.Physics.P2.CollisionGroup(1), this.boundsCollisionGroup = new i.Physics.P2.CollisionGroup(2), this.everythingCollisionGroup = new i.Physics.P2.CollisionGroup(2147483648), this.boundsCollidesWith = [], this._toRemove = [], this._collisionGroupID = 2, this._boundsLeft = !0, this._boundsRight = !0, this._boundsTop = !0, this._boundsBottom = !0, this._boundsOwnGroup = !1, this.setBoundsToWorld(!0, !0, !0, !0, !1)
        }, i.Physics.P2.prototype = {
            removeBodyNextStep: function(t) {
                this._toRemove.push(t)
            },
            preUpdate: function() {
                for (var t = this._toRemove.length; t--;) this.removeBody(this._toRemove[t]);
                this._toRemove.length = 0
            },
            enable: function(t, e, s) {
                void 0 === e && (e = !1), void 0 === s && (s = !0);
                var o = 1;
                if (Array.isArray(t))
                    for (o = t.length; o--;) t[o] instanceof i.Group ? this.enable(t[o].children, e, s) : (this.enableBody(t[o], e), s && t[o].hasOwnProperty("children") && t[o].children.length > 0 && this.enable(t[o], e, !0));
                else t instanceof i.Group ? this.enable(t.children, e, s) : (this.enableBody(t, e), s && t.hasOwnProperty("children") && t.children.length > 0 && this.enable(t.children, e, !0))
            },
            enableBody: function(t, e) {
                t.hasOwnProperty("body") && null === t.body && (t.body = new i.Physics.P2.Body(this.game, t, t.x, t.y, 1), t.body.debug = e, void 0 !== t.anchor && t.anchor.set(.5))
            },
            setImpactEvents: function(t) {
                t ? this.world.on("impact", this.impactHandler, this) : this.world.off("impact", this.impactHandler, this)
            },
            setPostBroadphaseCallback: function(t, e) {
                this.postBroadphaseCallback = t, this.callbackContext = e, null !== t ? this.world.on("postBroadphase", this.postBroadphaseHandler, this) : this.world.off("postBroadphase", this.postBroadphaseHandler, this)
            },
            postBroadphaseHandler: function(t) {
                if (this.postBroadphaseCallback && 0 !== t.pairs.length)
                    for (var e = t.pairs.length - 2; e >= 0; e -= 2) t.pairs[e].parent && t.pairs[e + 1].parent && !this.postBroadphaseCallback.call(this.callbackContext, t.pairs[e].parent, t.pairs[e + 1].parent) && t.pairs.splice(e, 2)
            },
            impactHandler: function(t) {
                if (t.bodyA.parent && t.bodyB.parent) {
                    var e = t.bodyA.parent,
                        i = t.bodyB.parent;
                    e._bodyCallbacks[t.bodyB.id] && e._bodyCallbacks[t.bodyB.id].call(e._bodyCallbackContext[t.bodyB.id], e, i, t.shapeA, t.shapeB), i._bodyCallbacks[t.bodyA.id] && i._bodyCallbacks[t.bodyA.id].call(i._bodyCallbackContext[t.bodyA.id], i, e, t.shapeB, t.shapeA), e._groupCallbacks[t.shapeB.collisionGroup] && e._groupCallbacks[t.shapeB.collisionGroup].call(e._groupCallbackContext[t.shapeB.collisionGroup], e, i, t.shapeA, t.shapeB), i._groupCallbacks[t.shapeA.collisionGroup] && i._groupCallbacks[t.shapeA.collisionGroup].call(i._groupCallbackContext[t.shapeA.collisionGroup], i, e, t.shapeB, t.shapeA)
                }
            },
            beginContactHandler: function(t) {
                t.bodyA && t.bodyB && (this.onBeginContact.dispatch(t.bodyA, t.bodyB, t.shapeA, t.shapeB, t.contactEquations), t.bodyA.parent && t.bodyA.parent.onBeginContact.dispatch(t.bodyB.parent, t.bodyB, t.shapeA, t.shapeB, t.contactEquations), t.bodyB.parent && t.bodyB.parent.onBeginContact.dispatch(t.bodyA.parent, t.bodyA, t.shapeB, t.shapeA, t.contactEquations))
            },
            endContactHandler: function(t) {
                t.bodyA && t.bodyB && (this.onEndContact.dispatch(t.bodyA, t.bodyB, t.shapeA, t.shapeB), t.bodyA.parent && t.bodyA.parent.onEndContact.dispatch(t.bodyB.parent, t.bodyB, t.shapeA, t.shapeB), t.bodyB.parent && t.bodyB.parent.onEndContact.dispatch(t.bodyA.parent, t.bodyA, t.shapeB, t.shapeA))
            },
            setBoundsToWorld: function(t, e, i, s, o) {
                this.setBounds(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, t, e, i, s, o)
            },
            setWorldMaterial: function(t, e, i, s, o) {
                void 0 === e && (e = !0), void 0 === i && (i = !0), void 0 === s && (s = !0), void 0 === o && (o = !0), e && this.walls.left && (this.walls.left.shapes[0].material = t), i && this.walls.right && (this.walls.right.shapes[0].material = t), s && this.walls.top && (this.walls.top.shapes[0].material = t), o && this.walls.bottom && (this.walls.bottom.shapes[0].material = t)
            },
            updateBoundsCollisionGroup: function(t) {
                void 0 === t && (t = !0);
                var e = t ? this.boundsCollisionGroup.mask : this.everythingCollisionGroup.mask;
                this.walls.left && (this.walls.left.shapes[0].collisionGroup = e), this.walls.right && (this.walls.right.shapes[0].collisionGroup = e), this.walls.top && (this.walls.top.shapes[0].collisionGroup = e), this.walls.bottom && (this.walls.bottom.shapes[0].collisionGroup = e), this._boundsOwnGroup = t
            },
            setBounds: function(t, e, i, s, o, n, a, r, h) {
                void 0 === o && (o = this._boundsLeft), void 0 === n && (n = this._boundsRight), void 0 === a && (a = this._boundsTop), void 0 === r && (r = this._boundsBottom), void 0 === h && (h = this._boundsOwnGroup), this.setupWall(o, "left", t, e, 1.5707963267948966, h), this.setupWall(n, "right", t + i, e, -1.5707963267948966, h), this.setupWall(a, "top", t, e, -3.141592653589793, h), this.setupWall(r, "bottom", t, e + s, 0, h), this._boundsLeft = o, this._boundsRight = n, this._boundsTop = a, this._boundsBottom = r, this._boundsOwnGroup = h
            },
            setupWall: function(t, e, i, s, o, n) {
                t ? (this.walls[e] ? this.walls[e].position = [this.pxmi(i), this.pxmi(s)] : (this.walls[e] = new p2.Body({
                    mass: 0,
                    position: [this.pxmi(i), this.pxmi(s)],
                    angle: o
                }), this.walls[e].addShape(new p2.Plane), this.world.addBody(this.walls[e])), n && (this.walls[e].shapes[0].collisionGroup = this.boundsCollisionGroup.mask)) : this.walls[e] && (this.world.removeBody(this.walls[e]), this.walls[e] = null)
            },
            pause: function() {
                this.paused = !0
            },
            resume: function() {
                this.paused = !1
            },
            update: function() {
                this.paused || (this.useElapsedTime ? this.world.step(this.game.time.physicsElapsed) : this.world.step(this.frameRate))
            },
            reset: function() {
                this.world.on("beginContact", this.beginContactHandler, this), this.world.on("endContact", this.endContactHandler, this), this.nothingCollisionGroup = new i.Physics.P2.CollisionGroup(1), this.boundsCollisionGroup = new i.Physics.P2.CollisionGroup(2), this.everythingCollisionGroup = new i.Physics.P2.CollisionGroup(2147483648), this._collisionGroupID = 2, this.setBoundsToWorld(!0, !0, !0, !0, !1)
            },
            clear: function() {
                this.world.time = 0, this.world.fixedStepTime = 0, this.world.solver && this.world.solver.equations.length && this.world.solver.removeAllEquations();
                for (var t = this.world.constraints, e = t.length - 1; e >= 0; e--) this.world.removeConstraint(t[e]);
                for (var i = this.world.bodies, e = i.length - 1; e >= 0; e--) this.world.removeBody(i[e]);
                for (var s = this.world.springs, e = s.length - 1; e >= 0; e--) this.world.removeSpring(s[e]);
                for (var o = this.world.contactMaterials, e = o.length - 1; e >= 0; e--) this.world.removeContactMaterial(o[e]);
                this.world.off("beginContact", this.beginContactHandler, this), this.world.off("endContact", this.endContactHandler, this), this.postBroadphaseCallback = null, this.callbackContext = null, this.impactCallback = null, this.collisionGroups = [], this._toRemove = [], this.boundsCollidesWith = [], this.walls = {
                    left: null,
                    right: null,
                    top: null,
                    bottom: null
                }
            },
            destroy: function() {
                this.clear(), this.game = null
            },
            addBody: function(t) {
                return !t.data.world && (this.world.addBody(t.data), this.onBodyAdded.dispatch(t), !0)
            },
            removeBody: function(t) {
                return t.data.world === this.world && (this.world.removeBody(t.data), this.onBodyRemoved.dispatch(t)), t
            },
            addSpring: function(t) {
                return t instanceof i.Physics.P2.Spring || t instanceof i.Physics.P2.RotationalSpring ? this.world.addSpring(t.data) : this.world.addSpring(t), this.onSpringAdded.dispatch(t), t
            },
            removeSpring: function(t) {
                return t instanceof i.Physics.P2.Spring || t instanceof i.Physics.P2.RotationalSpring ? this.world.removeSpring(t.data) : this.world.removeSpring(t), this.onSpringRemoved.dispatch(t), t
            },
            createDistanceConstraint: function(t, e, s, o, n, a) {
                return t = this.getBody(t), e = this.getBody(e), t && e ? this.addConstraint(new i.Physics.P2.DistanceConstraint(this, t, e, s, o, n, a)) : void console.warn("Cannot create Constraint, invalid body objects given")
            },
            createGearConstraint: function(t, e, s, o) {
                return t = this.getBody(t), e = this.getBody(e), t && e ? this.addConstraint(new i.Physics.P2.GearConstraint(this, t, e, s, o)) : void console.warn("Cannot create Constraint, invalid body objects given")
            },
            createRevoluteConstraint: function(t, e, s, o, n, a) {
                return t = this.getBody(t), s = this.getBody(s), t && s ? this.addConstraint(new i.Physics.P2.RevoluteConstraint(this, t, e, s, o, n, a)) : void console.warn("Cannot create Constraint, invalid body objects given")
            },
            createLockConstraint: function(t, e, s, o, n) {
                return t = this.getBody(t), e = this.getBody(e), t && e ? this.addConstraint(new i.Physics.P2.LockConstraint(this, t, e, s, o, n)) : void console.warn("Cannot create Constraint, invalid body objects given")
            },
            createPrismaticConstraint: function(t, e, s, o, n, a, r) {
                return t = this.getBody(t), e = this.getBody(e), t && e ? this.addConstraint(new i.Physics.P2.PrismaticConstraint(this, t, e, s, o, n, a, r)) : void console.warn("Cannot create Constraint, invalid body objects given")
            },
            addConstraint: function(t) {
                return this.world.addConstraint(t), this.onConstraintAdded.dispatch(t), t
            },
            removeConstraint: function(t) {
                return this.world.removeConstraint(t), this.onConstraintRemoved.dispatch(t), t
            },
            addContactMaterial: function(t) {
                return this.world.addContactMaterial(t), this.onContactMaterialAdded.dispatch(t), t
            },
            removeContactMaterial: function(t) {
                return this.world.removeContactMaterial(t), this.onContactMaterialRemoved.dispatch(t), t
            },
            getContactMaterial: function(t, e) {
                return this.world.getContactMaterial(t, e)
            },
            setMaterial: function(t, e) {
                for (var i = e.length; i--;) e[i].setMaterial(t)
            },
            createMaterial: function(t, e) {
                t = t || "";
                var s = new i.Physics.P2.Material(t);
                return this.materials.push(s), void 0 !== e && e.setMaterial(s), s
            },
            createContactMaterial: function(t, e, s) {
                void 0 === t && (t = this.createMaterial()), void 0 === e && (e = this.createMaterial());
                var o = new i.Physics.P2.ContactMaterial(t, e, s);
                return this.addContactMaterial(o)
            },
            getBodies: function() {
                for (var t = [], e = this.world.bodies.length; e--;) t.push(this.world.bodies[e].parent);
                return t
            },
            getBody: function(t) {
                return t instanceof p2.Body ? t : t instanceof i.Physics.P2.Body ? t.data : t.body && t.body.type === i.Physics.P2JS ? t.body.data : null
            },
            getSprings: function() {
                for (var t = [], e = this.world.springs.length; e--;) t.push(this.world.springs[e].parent);
                return t
            },
            getConstraints: function() {
                for (var t = [], e = this.world.constraints.length; e--;) t.push(this.world.constraints[e]);
                return t
            },
            hitTest: function(t, e, s, o) {
                void 0 === e && (e = this.world.bodies), void 0 === s && (s = 5), void 0 === o && (o = !1);
                for (var n = [this.pxmi(t.x), this.pxmi(t.y)], a = [], r = e.length; r--;) e[r] instanceof i.Physics.P2.Body && (!o || e[r].data.type !== p2.Body.STATIC) ? a.push(e[r].data) : e[r] instanceof p2.Body && e[r].parent && (!o || e[r].type !== p2.Body.STATIC) ? a.push(e[r]) : e[r] instanceof i.Sprite && e[r].hasOwnProperty("body") && (!o || e[r].body.data.type !== p2.Body.STATIC) && a.push(e[r].body.data);
                return this.world.hitTest(n, a, s)
            },
            toJSON: function() {
                return this.world.toJSON()
            },
            createCollisionGroup: function(t) {
                var e = Math.pow(2, this._collisionGroupID);
                this.walls.left && (this.walls.left.shapes[0].collisionMask = this.walls.left.shapes[0].collisionMask | e), this.walls.right && (this.walls.right.shapes[0].collisionMask = this.walls.right.shapes[0].collisionMask | e), this.walls.top && (this.walls.top.shapes[0].collisionMask = this.walls.top.shapes[0].collisionMask | e), this.walls.bottom && (this.walls.bottom.shapes[0].collisionMask = this.walls.bottom.shapes[0].collisionMask | e), this._collisionGroupID++;
                var s = new i.Physics.P2.CollisionGroup(e);
                return this.collisionGroups.push(s), t && this.setCollisionGroup(t, s), s
            },
            setCollisionGroup: function(t, e) {
                if (t instanceof i.Group)
                    for (var s = 0; s < t.total; s++) t.children[s].body && t.children[s].body.type === i.Physics.P2JS && t.children[s].body.setCollisionGroup(e);
                else t.body.setCollisionGroup(e)
            },
            createSpring: function(t, e, s, o, n, a, r, h, l) {
                return t = this.getBody(t), e = this.getBody(e), t && e ? this.addSpring(new i.Physics.P2.Spring(this, t, e, s, o, n, a, r, h, l)) : void console.warn("Cannot create Spring, invalid body objects given")
            },
            createRotationalSpring: function(t, e, s, o, n) {
                return t = this.getBody(t), e = this.getBody(e), t && e ? this.addSpring(new i.Physics.P2.RotationalSpring(this, t, e, s, o, n)) : void console.warn("Cannot create Rotational Spring, invalid body objects given")
            },
            createBody: function(t, e, s, o, n, a) {
                void 0 === o && (o = !1);
                var r = new i.Physics.P2.Body(this.game, null, t, e, s);
                return !(a && !r.addPolygon(n, a)) && (o && this.world.addBody(r.data), r)
            },
            createParticle: function(t, e, s, o, n, a) {
                void 0 === o && (o = !1);
                var r = new i.Physics.P2.Body(this.game, null, t, e, s);
                return !(a && !r.addPolygon(n, a)) && (o && this.world.addBody(r.data), r)
            },
            convertCollisionObjects: function(t, e, i) {
                void 0 === i && (i = !0);
                for (var s = [], o = 0, n = t.collision[e].length; o < n; o++) {
                    var a = t.collision[e][o],
                        r = this.createBody(a.x, a.y, 0, i, {}, a.polyline);
                    r && s.push(r)
                }
                return s
            },
            clearTilemapLayerBodies: function(t, e) {
                e = t.getLayer(e);
                for (var i = t.layers[e].bodies.length; i--;) t.layers[e].bodies[i].destroy();
                t.layers[e].bodies.length = 0
            },
            convertTilemap: function(t, e, i, s) {
                e = t.getLayer(e), void 0 === i && (i = !0), void 0 === s && (s = !0), this.clearTilemapLayerBodies(t, e);
                for (var o = 0, n = 0, a = 0, r = 0, h = t.layers[e].height; r < h; r++) {
                    o = 0;
                    for (var l = 0, c = t.layers[e].width; l < c; l++) {
                        var p = t.layers[e].data[r][l];
                        if (p && p.index > -1 && p.collides)
                            if (s) {
                                var u = t.getTileRight(e, l, r);
                                0 === o && (n = p.x * p.width, a = p.y * p.height, o = p.width), u && u.collides ? o += p.width : ((d = this.createBody(n, a, 0, !1)).addRectangle(o, p.height, o / 2, p.height / 2, 0), i && this.addBody(d), t.layers[e].bodies.push(d), o = 0)
                            } else {
                                var d = this.createBody(p.x * p.width, p.y * p.height, 0, !1);
                                d.addRectangle(p.width, p.height, p.width / 2, p.height / 2, 0), i && this.addBody(d), t.layers[e].bodies.push(d)
                            }
                    }
                }
                return t.layers[e].bodies
            },
            mpx: function(t) {
                return t *= 20
            },
            pxm: function(t) {
                return .05 * t
            },
            mpxi: function(t) {
                return t *= -20
            },
            pxmi: function(t) {
                return -.05 * t
            }
        }, Object.defineProperty(i.Physics.P2.prototype, "friction", {
            get: function() {
                return this.world.defaultContactMaterial.friction
            },
            set: function(t) {
                this.world.defaultContactMaterial.friction = t
            }
        }), Object.defineProperty(i.Physics.P2.prototype, "restitution", {
            get: function() {
                return this.world.defaultContactMaterial.restitution
            },
            set: function(t) {
                this.world.defaultContactMaterial.restitution = t
            }
        }), Object.defineProperty(i.Physics.P2.prototype, "contactMaterial", {
            get: function() {
                return this.world.defaultContactMaterial
            },
            set: function(t) {
                this.world.defaultContactMaterial = t
            }
        }), Object.defineProperty(i.Physics.P2.prototype, "applySpringForces", {
            get: function() {
                return this.world.applySpringForces
            },
            set: function(t) {
                this.world.applySpringForces = t
            }
        }), Object.defineProperty(i.Physics.P2.prototype, "applyDamping", {
            get: function() {
                return this.world.applyDamping
            },
            set: function(t) {
                this.world.applyDamping = t
            }
        }), Object.defineProperty(i.Physics.P2.prototype, "applyGravity", {
            get: function() {
                return this.world.applyGravity
            },
            set: function(t) {
                this.world.applyGravity = t
            }
        }), Object.defineProperty(i.Physics.P2.prototype, "solveConstraints", {
            get: function() {
                return this.world.solveConstraints
            },
            set: function(t) {
                this.world.solveConstraints = t
            }
        }), Object.defineProperty(i.Physics.P2.prototype, "time", {
            get: function() {
                return this.world.time
            }
        }), Object.defineProperty(i.Physics.P2.prototype, "emitImpactEvent", {
            get: function() {
                return this.world.emitImpactEvent
            },
            set: function(t) {
                this.world.emitImpactEvent = t
            }
        }), Object.defineProperty(i.Physics.P2.prototype, "sleepMode", {
            get: function() {
                return this.world.sleepMode
            },
            set: function(t) {
                this.world.sleepMode = t
            }
        }), Object.defineProperty(i.Physics.P2.prototype, "total", {
            get: function() {
                return this.world.bodies.length
            }
        }), i.Physics.P2.FixtureList = function(t) {
            Array.isArray(t) || (t = [t]), this.rawList = t, this.init(), this.parse(this.rawList)
        }, i.Physics.P2.FixtureList.prototype = {
            init: function() {
                this.namedFixtures = {}, this.groupedFixtures = [], this.allFixtures = []
            },
            setCategory: function(t, e) {
                this.getFixtures(e).forEach(function(e) {
                    e.collisionGroup = t
                })
            },
            setMask: function(t, e) {
                this.getFixtures(e).forEach(function(e) {
                    e.collisionMask = t
                })
            },
            setSensor: function(t, e) {
                this.getFixtures(e).forEach(function(e) {
                    e.sensor = t
                })
            },
            setMaterial: function(t, e) {
                this.getFixtures(e).forEach(function(e) {
                    e.material = t
                })
            },
            getFixtures: function(t) {
                var e = [];
                if (t) {
                    t instanceof Array || (t = [t]);
                    var i = this;
                    return t.forEach(function(t) {
                        i.namedFixtures[t] && e.push(i.namedFixtures[t])
                    }), this.flatten(e)
                }
                return this.allFixtures
            },
            getFixtureByKey: function(t) {
                return this.namedFixtures[t]
            },
            getGroup: function(t) {
                return this.groupedFixtures[t]
            },
            parse: function() {
                var t, e, i, s;
                i = this.rawList, s = [];
                for (t in i) e = i[t], isNaN(t - 0) ? this.namedFixtures[t] = this.flatten(e) : (this.groupedFixtures[t] = this.groupedFixtures[t] || [], this.groupedFixtures[t] = this.groupedFixtures[t].concat(e)), s.push(this.allFixtures = this.flatten(this.groupedFixtures))
            },
            flatten: function(t) {
                var e, i;
                return e = [], i = arguments.callee, t.forEach(function(t) {
                    return Array.prototype.push.apply(e, Array.isArray(t) ? i(t) : [t])
                }), e
            }
        }, i.Physics.P2.PointProxy = function(t, e) {
            this.world = t, this.destination = e
        }, i.Physics.P2.PointProxy.prototype.constructor = i.Physics.P2.PointProxy, Object.defineProperty(i.Physics.P2.PointProxy.prototype, "x", {
            get: function() {
                return this.world.mpx(this.destination[0])
            },
            set: function(t) {
                this.destination[0] = this.world.pxm(t)
            }
        }), Object.defineProperty(i.Physics.P2.PointProxy.prototype, "y", {
            get: function() {
                return this.world.mpx(this.destination[1])
            },
            set: function(t) {
                this.destination[1] = this.world.pxm(t)
            }
        }), Object.defineProperty(i.Physics.P2.PointProxy.prototype, "mx", {
            get: function() {
                return this.destination[0]
            },
            set: function(t) {
                this.destination[0] = t
            }
        }), Object.defineProperty(i.Physics.P2.PointProxy.prototype, "my", {
            get: function() {
                return this.destination[1]
            },
            set: function(t) {
                this.destination[1] = t
            }
        }), i.Physics.P2.InversePointProxy = function(t, e) {
            this.world = t, this.destination = e
        }, i.Physics.P2.InversePointProxy.prototype.constructor = i.Physics.P2.InversePointProxy, Object.defineProperty(i.Physics.P2.InversePointProxy.prototype, "x", {
            get: function() {
                return this.world.mpxi(this.destination[0])
            },
            set: function(t) {
                this.destination[0] = this.world.pxmi(t)
            }
        }), Object.defineProperty(i.Physics.P2.InversePointProxy.prototype, "y", {
            get: function() {
                return this.world.mpxi(this.destination[1])
            },
            set: function(t) {
                this.destination[1] = this.world.pxmi(t)
            }
        }), Object.defineProperty(i.Physics.P2.InversePointProxy.prototype, "mx", {
            get: function() {
                return this.destination[0]
            },
            set: function(t) {
                this.destination[0] = -t
            }
        }), Object.defineProperty(i.Physics.P2.InversePointProxy.prototype, "my", {
            get: function() {
                return this.destination[1]
            },
            set: function(t) {
                this.destination[1] = -t
            }
        }), i.Physics.P2.Body = function(t, e, s, o, n) {
            e = e || null, s = s || 0, o = o || 0, void 0 === n && (n = 1), this.game = t, this.world = t.physics.p2, this.sprite = e, this.type = i.Physics.P2JS, this.offset = new i.Point, this.data = new p2.Body({
                position: [this.world.pxmi(s), this.world.pxmi(o)],
                mass: n
            }), this.data.parent = this, this.velocity = new i.Physics.P2.InversePointProxy(this.world, this.data.velocity), this.force = new i.Physics.P2.InversePointProxy(this.world, this.data.force), this.gravity = new i.Point, this.onBeginContact = new i.Signal, this.onEndContact = new i.Signal, this.collidesWith = [], this.removeNextStep = !1, this.debugBody = null, this.dirty = !1, this._collideWorldBounds = !0, this._bodyCallbacks = {}, this._bodyCallbackContext = {}, this._groupCallbacks = {}, this._groupCallbackContext = {}, this._reset = !1, e && (this.setRectangleFromSprite(e), e.exists && this.game.physics.p2.addBody(this))
        }, i.Physics.P2.Body.prototype = {
            createBodyCallback: function(t, e, i) {
                var s = -1;
                t.id ? s = t.id : t.body && (s = t.body.id), s > -1 && (null === e ? (delete this._bodyCallbacks[s], delete this._bodyCallbackContext[s]) : (this._bodyCallbacks[s] = e, this._bodyCallbackContext[s] = i))
            },
            createGroupCallback: function(t, e, i) {
                null === e ? (delete this._groupCallbacks[t.mask], delete this._groupCallbackContext[t.mask]) : (this._groupCallbacks[t.mask] = e, this._groupCallbackContext[t.mask] = i)
            },
            getCollisionMask: function() {
                var t = 0;
                this._collideWorldBounds && (t = this.game.physics.p2.boundsCollisionGroup.mask);
                for (var e = 0; e < this.collidesWith.length; e++) t |= this.collidesWith[e].mask;
                return t
            },
            updateCollisionMask: function(t) {
                var e = this.getCollisionMask();
                if (void 0 === t)
                    for (var i = this.data.shapes.length - 1; i >= 0; i--) this.data.shapes[i].collisionMask = e;
                else t.collisionMask = e
            },
            setCollisionGroup: function(t, e) {
                var i = this.getCollisionMask();
                if (void 0 === e)
                    for (var s = this.data.shapes.length - 1; s >= 0; s--) this.data.shapes[s].collisionGroup = t.mask, this.data.shapes[s].collisionMask = i;
                else e.collisionGroup = t.mask, e.collisionMask = i
            },
            clearCollision: function(t, e, i) {
                if (void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === i)
                    for (var s = this.data.shapes.length - 1; s >= 0; s--) t && (this.data.shapes[s].collisionGroup = null), e && (this.data.shapes[s].collisionMask = null);
                else t && (i.collisionGroup = null), e && (i.collisionMask = null);
                t && (this.collidesWith.length = 0)
            },
            removeCollisionGroup: function(t, e, i) {
                void 0 === e && (e = !0);
                var s;
                if (Array.isArray(t))
                    for (n = 0; n < t.length; n++)(s = this.collidesWith.indexOf(t[n])) > -1 && (this.collidesWith.splice(s, 1), e && (delete this._groupCallbacks[t.mask], delete this._groupCallbackContext[t.mask]));
                else(s = this.collidesWith.indexOf(t)) > -1 && (this.collidesWith.splice(s, 1), e && (delete this._groupCallbacks[t.mask], delete this._groupCallbackContext[t.mask]));
                var o = this.getCollisionMask();
                if (void 0 === i)
                    for (var n = this.data.shapes.length - 1; n >= 0; n--) this.data.shapes[n].collisionMask = o;
                else i.collisionMask = o
            },
            collides: function(t, e, i, s) {
                if (Array.isArray(t))
                    for (n = 0; n < t.length; n++) - 1 === this.collidesWith.indexOf(t[n]) && (this.collidesWith.push(t[n]), e && this.createGroupCallback(t[n], e, i));
                else -1 === this.collidesWith.indexOf(t) && (this.collidesWith.push(t), e && this.createGroupCallback(t, e, i));
                var o = this.getCollisionMask();
                if (void 0 === s)
                    for (var n = this.data.shapes.length - 1; n >= 0; n--) this.data.shapes[n].collisionMask = o;
                else s.collisionMask = o
            },
            adjustCenterOfMass: function() {
                this.data.adjustCenterOfMass(), this.shapeChanged()
            },
            getVelocityAtPoint: function(t, e) {
                return this.data.getVelocityAtPoint(t, e)
            },
            applyDamping: function(t) {
                this.data.applyDamping(t)
            },
            applyImpulse: function(t, e, i) {
                this.data.applyImpulse(t, [this.world.pxmi(e), this.world.pxmi(i)])
            },
            applyImpulseLocal: function(t, e, i) {
                this.data.applyImpulseLocal(t, [this.world.pxmi(e), this.world.pxmi(i)])
            },
            applyForce: function(t, e, i) {
                this.data.applyForce(t, [this.world.pxmi(e), this.world.pxmi(i)])
            },
            setZeroForce: function() {
                this.data.setZeroForce()
            },
            setZeroRotation: function() {
                this.data.angularVelocity = 0
            },
            setZeroVelocity: function() {
                this.data.velocity[0] = 0, this.data.velocity[1] = 0
            },
            setZeroDamping: function() {
                this.data.damping = 0, this.data.angularDamping = 0
            },
            toLocalFrame: function(t, e) {
                return this.data.toLocalFrame(t, e)
            },
            toWorldFrame: function(t, e) {
                return this.data.toWorldFrame(t, e)
            },
            rotateLeft: function(t) {
                this.data.angularVelocity = this.world.pxm(-t)
            },
            rotateRight: function(t) {
                this.data.angularVelocity = this.world.pxm(t)
            },
            moveForward: function(t) {
                var e = this.world.pxmi(-t),
                    i = this.data.angle + Math.PI / 2;
                this.data.velocity[0] = e * Math.cos(i), this.data.velocity[1] = e * Math.sin(i)
            },
            moveBackward: function(t) {
                var e = this.world.pxmi(-t),
                    i = this.data.angle + Math.PI / 2;
                this.data.velocity[0] = -e * Math.cos(i), this.data.velocity[1] = -e * Math.sin(i)
            },
            thrust: function(t) {
                var e = this.world.pxmi(-t),
                    i = this.data.angle + Math.PI / 2;
                this.data.force[0] += e * Math.cos(i), this.data.force[1] += e * Math.sin(i)
            },
            thrustLeft: function(t) {
                var e = this.world.pxmi(-t),
                    i = this.data.angle;
                this.data.force[0] += e * Math.cos(i), this.data.force[1] += e * Math.sin(i)
            },
            thrustRight: function(t) {
                var e = this.world.pxmi(-t),
                    i = this.data.angle;
                this.data.force[0] -= e * Math.cos(i), this.data.force[1] -= e * Math.sin(i)
            },
            reverse: function(t) {
                var e = this.world.pxmi(-t),
                    i = this.data.angle + Math.PI / 2;
                this.data.force[0] -= e * Math.cos(i), this.data.force[1] -= e * Math.sin(i)
            },
            moveLeft: function(t) {
                this.data.velocity[0] = this.world.pxmi(-t)
            },
            moveRight: function(t) {
                this.data.velocity[0] = this.world.pxmi(t)
            },
            moveUp: function(t) {
                this.data.velocity[1] = this.world.pxmi(-t)
            },
            moveDown: function(t) {
                this.data.velocity[1] = this.world.pxmi(t)
            },
            preUpdate: function() {
                this.dirty = !0, this.removeNextStep && (this.removeFromWorld(), this.removeNextStep = !1)
            },
            postUpdate: function() {
                this.sprite.x = this.world.mpxi(this.data.position[0]) + this.offset.x, this.sprite.y = this.world.mpxi(this.data.position[1]) + this.offset.y, this.fixedRotation || (this.sprite.rotation = this.data.angle), this.debugBody && this.debugBody.updateSpriteTransform(), this.dirty = !1
            },
            reset: function(t, e, i, s) {
                void 0 === i && (i = !1), void 0 === s && (s = !1), this.setZeroForce(), this.setZeroVelocity(), this.setZeroRotation(), i && this.setZeroDamping(), s && (this.mass = 1), this.x = t, this.y = e
            },
            addToWorld: function() {
                if (this.game.physics.p2._toRemove)
                    for (var t = 0; t < this.game.physics.p2._toRemove.length; t++) this.game.physics.p2._toRemove[t] === this && this.game.physics.p2._toRemove.splice(t, 1);
                this.data.world !== this.game.physics.p2.world && this.game.physics.p2.addBody(this)
            },
            removeFromWorld: function() {
                this.data.world === this.game.physics.p2.world && this.game.physics.p2.removeBodyNextStep(this)
            },
            destroy: function() {
                this.removeFromWorld(), this.clearShapes(), this._bodyCallbacks = {}, this._bodyCallbackContext = {}, this._groupCallbacks = {}, this._groupCallbackContext = {}, this.debugBody && this.debugBody.destroy(!0, !0), this.debugBody = null, this.sprite && (this.sprite.body = null, this.sprite = null)
            },
            clearShapes: function() {
                for (var t = this.data.shapes.length; t--;) this.data.removeShape(this.data.shapes[t]);
                this.shapeChanged()
            },
            addShape: function(t, e, i, s) {
                return void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = 0), this.data.addShape(t, [this.world.pxmi(e), this.world.pxmi(i)], s), this.shapeChanged(), t
            },
            addCircle: function(t, e, i, s) {
                var o = new p2.Circle({
                    radius: this.world.pxm(t)
                });
                return this.addShape(o, e, i, s)
            },
            addRectangle: function(t, e, i, s, o) {
                var n = new p2.Box({
                    width: this.world.pxm(t),
                    height: this.world.pxm(e)
                });
                return this.addShape(n, i, s, o)
            },
            addPlane: function(t, e, i) {
                var s = new p2.Plane;
                return this.addShape(s, t, e, i)
            },
            addParticle: function(t, e, i) {
                var s = new p2.Particle;
                return this.addShape(s, t, e, i)
            },
            addLine: function(t, e, i, s) {
                var o = new p2.Line({
                    length: this.world.pxm(t)
                });
                return this.addShape(o, e, i, s)
            },
            addCapsule: function(t, e, i, s, o) {
                var n = new p2.Capsule({
                    length: this.world.pxm(t),
                    radius: this.world.pxm(e)
                });
                return this.addShape(n, i, s, o)
            },
            addPolygon: function(t, e) {
                t = t || {}, Array.isArray(e) || (e = Array.prototype.slice.call(arguments, 1));
                var i = [];
                if (1 === e.length && Array.isArray(e[0])) i = e[0].slice(0);
                else if (Array.isArray(e[0])) i = e.slice();
                else if ("number" == typeof e[0])
                    for (var s = 0, o = e.length; s < o; s += 2) i.push([e[s], e[s + 1]]);
                var n = i.length - 1;
                i[n][0] === i[0][0] && i[n][1] === i[0][1] && i.pop();
                for (var a = 0; a < i.length; a++) i[a][0] = this.world.pxmi(i[a][0]), i[a][1] = this.world.pxmi(i[a][1]);
                var r = this.data.fromPolygon(i, t);
                return this.shapeChanged(), r
            },
            removeShape: function(t) {
                var e = this.data.removeShape(t);
                return this.shapeChanged(), e
            },
            setCircle: function(t, e, i, s) {
                return this.clearShapes(), this.addCircle(t, e, i, s)
            },
            setRectangle: function(t, e, i, s, o) {
                return void 0 === t && (t = 16), void 0 === e && (e = 16), this.clearShapes(), this.addRectangle(t, e, i, s, o)
            },
            setRectangleFromSprite: function(t) {
                return void 0 === t && (t = this.sprite), this.clearShapes(), this.addRectangle(t.width, t.height, 0, 0, t.rotation)
            },
            setMaterial: function(t, e) {
                if (void 0 === e)
                    for (var i = this.data.shapes.length - 1; i >= 0; i--) this.data.shapes[i].material = t;
                else e.material = t
            },
            shapeChanged: function() {
                this.debugBody && this.debugBody.draw()
            },
            addPhaserPolygon: function(t, e) {
                for (var i = this.game.cache.getPhysicsData(t, e), s = [], o = 0; o < i.length; o++) {
                    var n = i[o],
                        a = this.addFixture(n);
                    s[n.filter.group] = s[n.filter.group] || [], s[n.filter.group] = s[n.filter.group].concat(a), n.fixtureKey && (s[n.fixtureKey] = a)
                }
                return this.data.aabbNeedsUpdate = !0, this.shapeChanged(), s
            },
            addFixture: function(t) {
                var e = [];
                if (t.circle) {
                    (l = new p2.Circle({
                        radius: this.world.pxm(t.circle.radius)
                    })).collisionGroup = t.filter.categoryBits, l.collisionMask = t.filter.maskBits, l.sensor = t.isSensor;
                    var i = p2.vec2.create();
                    i[0] = this.world.pxmi(t.circle.position[0] - this.sprite.width / 2), i[1] = this.world.pxmi(t.circle.position[1] - this.sprite.height / 2), this.data.addShape(l, i), e.push(l)
                } else
                    for (var s = t.polygons, o = p2.vec2.create(), n = 0; n < s.length; n++) {
                        for (var a = s[n], r = [], h = 0; h < a.length; h += 2) r.push([this.world.pxmi(a[h]), this.world.pxmi(a[h + 1])]);
                        for (var l = new p2.Convex({
                                vertices: r
                            }), c = 0; c !== l.vertices.length; c++) {
                            var p = l.vertices[c];
                            p2.vec2.sub(p, p, l.centerOfMass)
                        }
                        p2.vec2.scale(o, l.centerOfMass, 1), o[0] -= this.world.pxmi(this.sprite.width / 2), o[1] -= this.world.pxmi(this.sprite.height / 2), l.updateTriangles(), l.updateCenterOfMass(), l.updateBoundingRadius(), l.collisionGroup = t.filter.categoryBits, l.collisionMask = t.filter.maskBits, l.sensor = t.isSensor, this.data.addShape(l, o), e.push(l)
                    }
                return e
            },
            loadPolygon: function(t, e) {
                if (null === t) i = e;
                else var i = this.game.cache.getPhysicsData(t, e);
                for (var s = p2.vec2.create(), o = 0; o < i.length; o++) {
                    for (var n = [], a = 0; a < i[o].shape.length; a += 2) n.push([this.world.pxmi(i[o].shape[a]), this.world.pxmi(i[o].shape[a + 1])]);
                    for (var r = new p2.Convex({
                            vertices: n
                        }), h = 0; h !== r.vertices.length; h++) {
                        var l = r.vertices[h];
                        p2.vec2.sub(l, l, r.centerOfMass)
                    }
                    p2.vec2.scale(s, r.centerOfMass, 1), s[0] -= this.world.pxmi(this.sprite.width / 2), s[1] -= this.world.pxmi(this.sprite.height / 2), r.updateTriangles(), r.updateCenterOfMass(), r.updateBoundingRadius(), this.data.addShape(r, s)
                }
                return this.data.aabbNeedsUpdate = !0, this.shapeChanged(), !0
            }
        }, i.Physics.P2.Body.prototype.constructor = i.Physics.P2.Body, i.Physics.P2.Body.DYNAMIC = 1, i.Physics.P2.Body.STATIC = 2, i.Physics.P2.Body.KINEMATIC = 4, Object.defineProperty(i.Physics.P2.Body.prototype, "static", {
            get: function() {
                return this.data.type === i.Physics.P2.Body.STATIC
            },
            set: function(t) {
                t && this.data.type !== i.Physics.P2.Body.STATIC ? (this.data.type = i.Physics.P2.Body.STATIC, this.mass = 0) : t || this.data.type !== i.Physics.P2.Body.STATIC || (this.data.type = i.Physics.P2.Body.DYNAMIC, this.mass = 1)
            }
        }), Object.defineProperty(i.Physics.P2.Body.prototype, "dynamic", {
            get: function() {
                return this.data.type === i.Physics.P2.Body.DYNAMIC
            },
            set: function(t) {
                t && this.data.type !== i.Physics.P2.Body.DYNAMIC ? (this.data.type = i.Physics.P2.Body.DYNAMIC, this.mass = 1) : t || this.data.type !== i.Physics.P2.Body.DYNAMIC || (this.data.type = i.Physics.P2.Body.STATIC, this.mass = 0)
            }
        }), Object.defineProperty(i.Physics.P2.Body.prototype, "kinematic", {
            get: function() {
                return this.data.type === i.Physics.P2.Body.KINEMATIC
            },
            set: function(t) {
                t && this.data.type !== i.Physics.P2.Body.KINEMATIC ? (this.data.type = i.Physics.P2.Body.KINEMATIC, this.mass = 4) : t || this.data.type !== i.Physics.P2.Body.KINEMATIC || (this.data.type = i.Physics.P2.Body.STATIC, this.mass = 0)
            }
        }), Object.defineProperty(i.Physics.P2.Body.prototype, "allowSleep", {
            get: function() {
                return this.data.allowSleep
            },
            set: function(t) {
                t !== this.data.allowSleep && (this.data.allowSleep = t)
            }
        }), Object.defineProperty(i.Physics.P2.Body.prototype, "angle", {
            get: function() {
                return i.Math.wrapAngle(i.Math.radToDeg(this.data.angle))
            },
            set: function(t) {
                this.data.angle = i.Math.degToRad(i.Math.wrapAngle(t))
            }
        }), Object.defineProperty(i.Physics.P2.Body.prototype, "angularDamping", {
            get: function() {
                return this.data.angularDamping
            },
            set: function(t) {
                this.data.angularDamping = t
            }
        }), Object.defineProperty(i.Physics.P2.Body.prototype, "angularForce", {
            get: function() {
                return this.data.angularForce
            },
            set: function(t) {
                this.data.angularForce = t
            }
        }), Object.defineProperty(i.Physics.P2.Body.prototype, "angularVelocity", {
            get: function() {
                return this.data.angularVelocity
            },
            set: function(t) {
                this.data.angularVelocity = t
            }
        }), Object.defineProperty(i.Physics.P2.Body.prototype, "damping", {
            get: function() {
                return this.data.damping
            },
            set: function(t) {
                this.data.damping = t
            }
        }), Object.defineProperty(i.Physics.P2.Body.prototype, "fixedRotation", {
            get: function() {
                return this.data.fixedRotation
            },
            set: function(t) {
                t !== this.data.fixedRotation && (this.data.fixedRotation = t)
            }
        }), Object.defineProperty(i.Physics.P2.Body.prototype, "inertia", {
            get: function() {
                return this.data.inertia
            },
            set: function(t) {
                this.data.inertia = t
            }
        }), Object.defineProperty(i.Physics.P2.Body.prototype, "mass", {
            get: function() {
                return this.data.mass
            },
            set: function(t) {
                t !== this.data.mass && (this.data.mass = t, this.data.updateMassProperties())
            }
        }), Object.defineProperty(i.Physics.P2.Body.prototype, "motionState", {
            get: function() {
                return this.data.type
            },
            set: function(t) {
                t !== this.data.type && (this.data.type = t)
            }
        }), Object.defineProperty(i.Physics.P2.Body.prototype, "rotation", {
            get: function() {
                return this.data.angle
            },
            set: function(t) {
                this.data.angle = t
            }
        }), Object.defineProperty(i.Physics.P2.Body.prototype, "sleepSpeedLimit", {
            get: function() {
                return this.data.sleepSpeedLimit
            },
            set: function(t) {
                this.data.sleepSpeedLimit = t
            }
        }), Object.defineProperty(i.Physics.P2.Body.prototype, "x", {
            get: function() {
                return this.world.mpxi(this.data.position[0])
            },
            set: function(t) {
                this.data.position[0] = this.world.pxmi(t)
            }
        }), Object.defineProperty(i.Physics.P2.Body.prototype, "y", {
            get: function() {
                return this.world.mpxi(this.data.position[1])
            },
            set: function(t) {
                this.data.position[1] = this.world.pxmi(t)
            }
        }), Object.defineProperty(i.Physics.P2.Body.prototype, "id", {
            get: function() {
                return this.data.id
            }
        }), Object.defineProperty(i.Physics.P2.Body.prototype, "debug", {
            get: function() {
                return null !== this.debugBody
            },
            set: function(t) {
                t && !this.debugBody ? this.debugBody = new i.Physics.P2.BodyDebug(this.game, this.data) : !t && this.debugBody && (this.debugBody.destroy(), this.debugBody = null)
            }
        }), Object.defineProperty(i.Physics.P2.Body.prototype, "collideWorldBounds", {
            get: function() {
                return this._collideWorldBounds
            },
            set: function(t) {
                t && !this._collideWorldBounds ? (this._collideWorldBounds = !0, this.updateCollisionMask()) : !t && this._collideWorldBounds && (this._collideWorldBounds = !1, this.updateCollisionMask())
            }
        }), i.Physics.P2.BodyDebug = function(t, e, s) {
            i.Group.call(this, t);
            var o = {
                pixelsPerLengthUnit: t.physics.p2.mpx(1),
                debugPolygons: !1,
                lineWidth: 1,
                alpha: .5
            };
            this.settings = i.Utils.extend(o, s), this.ppu = this.settings.pixelsPerLengthUnit, this.ppu = -1 * this.ppu, this.body = e, this.canvas = new i.Graphics(t), this.canvas.alpha = this.settings.alpha, this.add(this.canvas), this.draw(), this.updateSpriteTransform()
        }, i.Physics.P2.BodyDebug.prototype = Object.create(i.Group.prototype), i.Physics.P2.BodyDebug.prototype.constructor = i.Physics.P2.BodyDebug, i.Utils.extend(i.Physics.P2.BodyDebug.prototype, {
            updateSpriteTransform: function() {
                this.position.x = this.body.position[0] * this.ppu, this.position.y = this.body.position[1] * this.ppu, this.rotation = this.body.angle
            },
            draw: function() {
                var t, e, i, s, o, n, a, r, h, l, c, p, u, d, m;
                if (r = this.body, (l = this.canvas).clear(), i = parseInt(this.randomPastelHex(), 16), n = 16711680, a = this.lineWidth, r instanceof p2.Body && r.shapes.length) {
                    var y = r.shapes.length;
                    for (s = 0; s !== y;) {
                        if (e = r.shapes[s], h = e.position || 0, t = e.angle || 0, e instanceof p2.Circle) this.drawCircle(l, h[0] * this.ppu, h[1] * this.ppu, t, e.radius * this.ppu, i, a);
                        else if (e instanceof p2.Capsule) this.drawCapsule(l, h[0] * this.ppu, h[1] * this.ppu, t, e.length * this.ppu, e.radius * this.ppu, n, i, a);
                        else if (e instanceof p2.Plane) this.drawPlane(l, h[0] * this.ppu, -h[1] * this.ppu, i, n, 5 * a, 10 * a, 10 * a, 100 * this.ppu, t);
                        else if (e instanceof p2.Line) this.drawLine(l, e.length * this.ppu, n, a);
                        else if (e instanceof p2.Box) this.drawRectangle(l, h[0] * this.ppu, h[1] * this.ppu, t, e.width * this.ppu, e.height * this.ppu, n, i, a);
                        else if (e instanceof p2.Convex) {
                            for (p = [], u = p2.vec2.create(), o = d = 0, m = e.vertices.length; 0 <= m ? d < m : d > m; o = 0 <= m ? ++d : --d) c = e.vertices[o], p2.vec2.rotate(u, c, t), p.push([(u[0] + h[0]) * this.ppu, -(u[1] + h[1]) * this.ppu]);
                            this.drawConvex(l, p, e.triangles, n, i, a, this.settings.debugPolygons, [h[0] * this.ppu, -h[1] * this.ppu])
                        }
                        s++
                    }
                }
            },
            drawRectangle: function(t, e, i, s, o, n, a, r, h) {
                void 0 === h && (h = 1), void 0 === a && (a = 0), t.lineStyle(h, a, 1), t.beginFill(r), t.drawRect(e - o / 2, i - n / 2, o, n)
            },
            drawCircle: function(t, e, i, s, o, n, a) {
                void 0 === a && (a = 1), void 0 === n && (n = 16777215), t.lineStyle(a, 0, 1), t.beginFill(n, 1), t.drawCircle(e, i, 2 * -o), t.endFill(), t.moveTo(e, i), t.lineTo(e + o * Math.cos(-s), i + o * Math.sin(-s))
            },
            drawLine: function(t, e, i, s) {
                void 0 === s && (s = 1), void 0 === i && (i = 0), t.lineStyle(5 * s, i, 1), t.moveTo(-e / 2, 0), t.lineTo(e / 2, 0)
            },
            drawConvex: function(t, e, i, s, o, n, a, r) {
                var h, l, c, p, u, d, m, y, f, g, _;
                if (void 0 === n && (n = 1), void 0 === s && (s = 0), a) {
                    for (h = [16711680, 65280, 255], l = 0; l !== e.length + 1;) p = e[l % e.length], u = e[(l + 1) % e.length], m = p[0], g = p[1], y = u[0], _ = u[1], t.lineStyle(n, h[l % h.length], 1), t.moveTo(m, -g), t.lineTo(y, -_), t.drawCircle(m, -g, 2 * n), l++;
                    return t.lineStyle(n, 0, 1), t.drawCircle(r[0], r[1], 2 * n)
                }
                for (t.lineStyle(n, s, 1), t.beginFill(o), l = 0; l !== e.length;) c = e[l], d = c[0], f = c[1], 0 === l ? t.moveTo(d, -f) : t.lineTo(d, -f), l++;
                if (t.endFill(), e.length > 2) return t.moveTo(e[e.length - 1][0], -e[e.length - 1][1]), t.lineTo(e[0][0], -e[0][1])
            },
            drawPath: function(t, e, i, s, o) {
                var n, a, r, h, l, c, p, u, d, m, y, f;
                for (void 0 === o && (o = 1), void 0 === i && (i = 0), t.lineStyle(o, i, 1), "number" == typeof s && t.beginFill(s), a = null, r = null, n = 0; n < e.length;) m = e[n], y = m[0], f = m[1], y === a && f === r || (0 === n ? t.moveTo(y, f) : (h = a, l = r, c = y, p = f, u = e[(n + 1) % e.length][0], d = e[(n + 1) % e.length][1], 0 !== (c - h) * (d - l) - (u - h) * (p - l) && t.lineTo(y, f)), a = y, r = f), n++;
                "number" == typeof s && t.endFill(), e.length > 2 && "number" == typeof s && (t.moveTo(e[e.length - 1][0], e[e.length - 1][1]), t.lineTo(e[0][0], e[0][1]))
            },
            drawPlane: function(t, e, i, s, o, n, a, r, h, l) {
                var c, p;
                void 0 === n && (n = 1), void 0 === s && (s = 16777215), t.lineStyle(n, o, 11), t.beginFill(s), t.moveTo(e, -i), c = e + Math.cos(l) * this.game.width, p = i + Math.sin(l) * this.game.height, t.lineTo(c, -p), t.moveTo(e, -i), c = e + Math.cos(l) * -this.game.width, p = i + Math.sin(l) * -this.game.height, t.lineTo(c, -p)
            },
            drawCapsule: function(t, e, i, s, o, n, a, r, h) {
                void 0 === h && (h = 1), void 0 === a && (a = 0), t.lineStyle(h, a, 1);
                var l = Math.cos(s),
                    c = Math.sin(s);
                t.beginFill(r, 1), t.drawCircle(-o / 2 * l + e, -o / 2 * c + i, 2 * -n), t.drawCircle(o / 2 * l + e, o / 2 * c + i, 2 * -n), t.endFill(), t.lineStyle(h, a, 0), t.beginFill(r, 1), t.moveTo(-o / 2 * l + n * c + e, -o / 2 * c + n * l + i), t.lineTo(o / 2 * l + n * c + e, o / 2 * c + n * l + i), t.lineTo(o / 2 * l - n * c + e, o / 2 * c - n * l + i), t.lineTo(-o / 2 * l - n * c + e, -o / 2 * c - n * l + i), t.endFill(), t.lineStyle(h, a, 1), t.moveTo(-o / 2 * l + n * c + e, -o / 2 * c + n * l + i), t.lineTo(o / 2 * l + n * c + e, o / 2 * c + n * l + i), t.moveTo(-o / 2 * l - n * c + e, -o / 2 * c - n * l + i), t.lineTo(o / 2 * l - n * c + e, o / 2 * c - n * l + i)
            },
            randomPastelHex: function() {
                var t, e, i, s;
                return i = [255, 255, 255], s = Math.floor(256 * Math.random()), e = Math.floor(256 * Math.random()), t = Math.floor(256 * Math.random()), s = Math.floor((s + 3 * i[0]) / 4), e = Math.floor((e + 3 * i[1]) / 4), t = Math.floor((t + 3 * i[2]) / 4), this.rgbToHex(s, e, t)
            },
            rgbToHex: function(t, e, i) {
                return this.componentToHex(t) + this.componentToHex(e) + this.componentToHex(i)
            },
            componentToHex: function(t) {
                var e;
                return 2 === (e = t.toString(16)).length ? e : e + "0"
            }
        }), i.Physics.P2.Spring = function(t, e, i, s, o, n, a, r, h, l) {
            this.game = t.game, this.world = t, void 0 === s && (s = 1), void 0 === o && (o = 100), void 0 === n && (n = 1);
            var c = {
                restLength: s = t.pxm(s),
                stiffness: o,
                damping: n
            };
            void 0 !== a && null !== a && (c.worldAnchorA = [t.pxm(a[0]), t.pxm(a[1])]), void 0 !== r && null !== r && (c.worldAnchorB = [t.pxm(r[0]), t.pxm(r[1])]), void 0 !== h && null !== h && (c.localAnchorA = [t.pxm(h[0]), t.pxm(h[1])]), void 0 !== l && null !== l && (c.localAnchorB = [t.pxm(l[0]), t.pxm(l[1])]), this.data = new p2.LinearSpring(e, i, c), this.data.parent = this
        }, i.Physics.P2.Spring.prototype.constructor = i.Physics.P2.Spring, i.Physics.P2.RotationalSpring = function(t, e, i, s, o, n) {
            this.game = t.game, this.world = t, void 0 === s && (s = null), void 0 === o && (o = 100), void 0 === n && (n = 1), s && (s = t.pxm(s));
            var a = {
                restAngle: s,
                stiffness: o,
                damping: n
            };
            this.data = new p2.RotationalSpring(e, i, a), this.data.parent = this
        }, i.Physics.P2.Spring.prototype.constructor = i.Physics.P2.Spring, i.Physics.P2.Material = function(t) {
            this.name = t, p2.Material.call(this)
        }, i.Physics.P2.Material.prototype = Object.create(p2.Material.prototype), i.Physics.P2.Material.prototype.constructor = i.Physics.P2.Material, i.Physics.P2.ContactMaterial = function(t, e, i) {
            p2.ContactMaterial.call(this, t, e, i)
        }, i.Physics.P2.ContactMaterial.prototype = Object.create(p2.ContactMaterial.prototype), i.Physics.P2.ContactMaterial.prototype.constructor = i.Physics.P2.ContactMaterial, i.Physics.P2.CollisionGroup = function(t) {
            this.mask = t
        }, i.Physics.P2.DistanceConstraint = function(t, e, i, s, o, n, a) {
            void 0 === s && (s = 100), void 0 === o && (o = [0, 0]), void 0 === n && (n = [0, 0]), void 0 === a && (a = Number.MAX_VALUE), this.game = t.game, this.world = t;
            var r = {
                distance: s = t.pxm(s),
                localAnchorA: o = [t.pxmi(o[0]), t.pxmi(o[1])],
                localAnchorB: n = [t.pxmi(n[0]), t.pxmi(n[1])],
                maxForce: a
            };
            p2.DistanceConstraint.call(this, e, i, r)
        }, i.Physics.P2.DistanceConstraint.prototype = Object.create(p2.DistanceConstraint.prototype), i.Physics.P2.DistanceConstraint.prototype.constructor = i.Physics.P2.DistanceConstraint, i.Physics.P2.GearConstraint = function(t, e, i, s, o) {
            void 0 === s && (s = 0), void 0 === o && (o = 1), this.game = t.game, this.world = t;
            var n = {
                angle: s,
                ratio: o
            };
            p2.GearConstraint.call(this, e, i, n)
        }, i.Physics.P2.GearConstraint.prototype = Object.create(p2.GearConstraint.prototype), i.Physics.P2.GearConstraint.prototype.constructor = i.Physics.P2.GearConstraint, i.Physics.P2.LockConstraint = function(t, e, i, s, o, n) {
            void 0 === s && (s = [0, 0]), void 0 === o && (o = 0), void 0 === n && (n = Number.MAX_VALUE), this.game = t.game, this.world = t;
            var a = {
                localOffsetB: s = [t.pxm(s[0]), t.pxm(s[1])],
                localAngleB: o,
                maxForce: n
            };
            p2.LockConstraint.call(this, e, i, a)
        }, i.Physics.P2.LockConstraint.prototype = Object.create(p2.LockConstraint.prototype), i.Physics.P2.LockConstraint.prototype.constructor = i.Physics.P2.LockConstraint, i.Physics.P2.PrismaticConstraint = function(t, e, i, s, o, n, a, r) {
            void 0 === s && (s = !0), void 0 === o && (o = [0, 0]), void 0 === n && (n = [0, 0]), void 0 === a && (a = [0, 0]), void 0 === r && (r = Number.MAX_VALUE), this.game = t.game, this.world = t;
            var h = {
                localAnchorA: o = [t.pxmi(o[0]), t.pxmi(o[1])],
                localAnchorB: n = [t.pxmi(n[0]), t.pxmi(n[1])],
                localAxisA: a,
                maxForce: r,
                disableRotationalLock: !s
            };
            p2.PrismaticConstraint.call(this, e, i, h)
        }, i.Physics.P2.PrismaticConstraint.prototype = Object.create(p2.PrismaticConstraint.prototype), i.Physics.P2.PrismaticConstraint.prototype.constructor = i.Physics.P2.PrismaticConstraint, i.Physics.P2.RevoluteConstraint = function(t, e, i, s, o, n, a) {
            void 0 === n && (n = Number.MAX_VALUE), void 0 === a && (a = null), this.game = t.game, this.world = t, i = [t.pxmi(i[0]), t.pxmi(i[1])], o = [t.pxmi(o[0]), t.pxmi(o[1])], a && (a = [t.pxmi(a[0]), t.pxmi(a[1])]);
            var r = {
                worldPivot: a,
                localPivotA: i,
                localPivotB: o,
                maxForce: n
            };
            p2.RevoluteConstraint.call(this, e, s, r)
        }, i.Physics.P2.RevoluteConstraint.prototype = Object.create(p2.RevoluteConstraint.prototype), i.Physics.P2.RevoluteConstraint.prototype.constructor = i.Physics.P2.RevoluteConstraint, i.ImageCollection = function(t, e, i, s, o, n, a) {
            (void 0 === i || i <= 0) && (i = 32), (void 0 === s || s <= 0) && (s = 32), void 0 === o && (o = 0), void 0 === n && (n = 0), this.name = t, this.firstgid = 0 | e, this.imageWidth = 0 | i, this.imageHeight = 0 | s, this.imageMargin = 0 | o, this.imageSpacing = 0 | n, this.properties = a || {}, this.images = [], this.total = 0
        }, i.ImageCollection.prototype = {
            containsImageIndex: function(t) {
                return t >= this.firstgid && t < this.firstgid + this.total
            },
            addImage: function(t, e) {
                this.images.push({
                    gid: t,
                    image: e
                }), this.total++
            }
        }, i.ImageCollection.prototype.constructor = i.ImageCollection, i.Tile = function(t, e, i, s, o, n) {
            this.layer = t, this.index = e, this.x = i, this.y = s, this.rotation = 0, this.flipped = !1, this.worldX = i * o, this.worldY = s * n, this.width = o, this.height = n, this.centerX = Math.abs(o / 2), this.centerY = Math.abs(n / 2), this.alpha = 1, this.properties = {}, this.scanned = !1, this.faceTop = !1, this.faceBottom = !1, this.faceLeft = !1, this.faceRight = !1, this.collideLeft = !1, this.collideRight = !1, this.collideUp = !1, this.collideDown = !1, this.collisionCallback = null, this.collisionCallbackContext = this
        }, i.Tile.prototype = {
            containsPoint: function(t, e) {
                return !(t < this.worldX || e < this.worldY || t > this.right || e > this.bottom)
            },
            intersects: function(t, e, i, s) {
                return !(i <= this.worldX || s <= this.worldY || t >= this.worldX + this.width || e >= this.worldY + this.height)
            },
            setCollisionCallback: function(t, e) {
                this.collisionCallback = t, this.collisionCallbackContext = e
            },
            destroy: function() {
                this.collisionCallback = null, this.collisionCallbackContext = null, this.properties = null
            },
            setCollision: function(t, e, i, s) {
                this.collideLeft = t, this.collideRight = e, this.collideUp = i, this.collideDown = s, this.faceLeft = t, this.faceRight = e, this.faceTop = i, this.faceBottom = s
            },
            resetCollision: function() {
                this.collideLeft = !1, this.collideRight = !1, this.collideUp = !1, this.collideDown = !1, this.faceTop = !1, this.faceBottom = !1, this.faceLeft = !1, this.faceRight = !1
            },
            isInteresting: function(t, e) {
                return t && e ? this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.faceTop || this.faceBottom || this.faceLeft || this.faceRight || this.collisionCallback : t ? this.collideLeft || this.collideRight || this.collideUp || this.collideDown : !!e && (this.faceTop || this.faceBottom || this.faceLeft || this.faceRight)
            },
            copy: function(t) {
                this.index = t.index, this.alpha = t.alpha, this.properties = t.properties, this.collideUp = t.collideUp, this.collideDown = t.collideDown, this.collideLeft = t.collideLeft, this.collideRight = t.collideRight, this.collisionCallback = t.collisionCallback, this.collisionCallbackContext = t.collisionCallbackContext
            }
        }, i.Tile.prototype.constructor = i.Tile, Object.defineProperty(i.Tile.prototype, "collides", {
            get: function() {
                return this.collideLeft || this.collideRight || this.collideUp || this.collideDown
            }
        }), Object.defineProperty(i.Tile.prototype, "canCollide", {
            get: function() {
                return this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.collisionCallback
            }
        }), Object.defineProperty(i.Tile.prototype, "left", {
            get: function() {
                return this.worldX
            }
        }), Object.defineProperty(i.Tile.prototype, "right", {
            get: function() {
                return this.worldX + this.width
            }
        }), Object.defineProperty(i.Tile.prototype, "top", {
            get: function() {
                return this.worldY
            }
        }), Object.defineProperty(i.Tile.prototype, "bottom", {
            get: function() {
                return this.worldY + this.height
            }
        }), i.Tilemap = function(t, e, s, o, n, a) {
            this.game = t, this.key = e;
            var r = i.TilemapParser.parse(this.game, e, s, o, n, a);
            null !== r && (this.width = r.width, this.height = r.height, this.tileWidth = r.tileWidth, this.tileHeight = r.tileHeight, this.orientation = r.orientation, this.format = r.format, this.version = r.version, this.properties = r.properties, this.widthInPixels = r.widthInPixels, this.heightInPixels = r.heightInPixels, this.layers = r.layers, this.tilesets = r.tilesets, this.imagecollections = r.imagecollections, this.tiles = r.tiles, this.objects = r.objects, this.collideIndexes = [], this.collision = r.collision, this.images = r.images, this.enableDebug = !1, this.currentLayer = 0, this.debugMap = [], this._results = [], this._tempA = 0, this._tempB = 0)
        }, i.Tilemap.CSV = 0, i.Tilemap.TILED_JSON = 1, i.Tilemap.NORTH = 0, i.Tilemap.EAST = 1, i.Tilemap.SOUTH = 2, i.Tilemap.WEST = 3, i.Tilemap.prototype = {
            create: function(t, e, i, s, o, n) {
                return void 0 === n && (n = this.game.world), this.width = e, this.height = i, this.setTileSize(s, o), this.layers.length = 0, this.createBlankLayer(t, e, i, s, o, n)
            },
            setTileSize: function(t, e) {
                this.tileWidth = t, this.tileHeight = e, this.widthInPixels = this.width * t, this.heightInPixels = this.height * e
            },
            addTilesetImage: function(t, e, s, o, n, a, r) {
                if (void 0 === t) return null;
                void 0 === s && (s = this.tileWidth), void 0 === o && (o = this.tileHeight), void 0 === n && (n = 0), void 0 === a && (a = 0), void 0 === r && (r = 0), 0 === s && (s = 32), 0 === o && (o = 32);
                var h = null;
                if (void 0 !== e && null !== e || (e = t), e instanceof i.BitmapData) h = e.canvas;
                else {
                    if (!this.game.cache.checkImageKey(e)) return console.warn('Phaser.Tilemap.addTilesetImage: Invalid image key given: "' + e + '"'), null;
                    h = this.game.cache.getImage(e)
                }
                var l = this.getTilesetIndex(t);
                if (null === l && this.format === i.Tilemap.TILED_JSON) return console.warn('Phaser.Tilemap.addTilesetImage: No data found in the JSON matching the tileset name: "' + t + '"'), null;
                if (this.tilesets[l]) return this.tilesets[l].setImage(h), this.tilesets[l];
                var c = new i.Tileset(t, r, s, o, n, a, {});
                c.setImage(h), this.tilesets.push(c);
                for (var p = this.tilesets.length - 1, u = n, d = n, m = 0, y = 0, f = 0, g = r; g < r + c.total && (this.tiles[g] = [u, d, p], u += s + a, ++m !== c.total) && (++y !== c.columns || (u = n, d += o + a, y = 0, ++f !== c.rows)); g++);
                return c
            },
            createFromObjects: function(t, e, s, o, n, a, r, h, l) {
                if (void 0 === n && (n = !0), void 0 === a && (a = !1), void 0 === r && (r = this.game.world), void 0 === h && (h = i.Sprite), void 0 === l && (l = !0), this.objects[t])
                    for (var c = 0; c < this.objects[t].length; c++) {
                        var p = !1,
                            u = this.objects[t][c];
                        if (void 0 !== u.gid && "number" == typeof e && u.gid === e ? p = !0 : void 0 !== u.id && "number" == typeof e && u.id === e ? p = !0 : void 0 !== u.name && "string" == typeof e && u.name === e && (p = !0), p) {
                            var d = new h(this.game, parseFloat(u.x, 10), parseFloat(u.y, 10), s, o);
                            d.name = u.name, d.visible = u.visible, d.autoCull = a, d.exists = n, u.width && (d.width = u.width), u.height && (d.height = u.height), u.rotation && (d.angle = u.rotation), l && (d.y -= d.height), r.add(d);
                            for (var m in u.properties) r.set(d, m, u.properties[m], !1, !1, 0, !0)
                        }
                    } else console.warn("Tilemap.createFromObjects: Invalid objectgroup name given: " + t)
            },
            createFromTiles: function(t, e, s, o, n, a) {
                "number" == typeof t && (t = [t]), void 0 === e || null === e ? e = [] : "number" == typeof e && (e = [e]), o = this.getLayer(o), void 0 === n && (n = this.game.world), void 0 === a && (a = {}), void 0 === a.customClass && (a.customClass = i.Sprite), void 0 === a.adjustY && (a.adjustY = !0);
                var r = this.layers[o].width,
                    h = this.layers[o].height;
                if (this.copy(0, 0, r, h, o), this._results.length < 2) return 0;
                for (var l, c = 0, p = 1, u = this._results.length; p < u; p++)
                    if (-1 !== t.indexOf(this._results[p].index)) {
                        l = new a.customClass(this.game, this._results[p].worldX, this._results[p].worldY, s);
                        for (var d in a) l[d] = a[d];
                        n.add(l), c++
                    }
                if (1 === e.length)
                    for (p = 0; p < t.length; p++) this.replace(t[p], e[0], 0, 0, r, h, o);
                else if (e.length > 1)
                    for (p = 0; p < t.length; p++) this.replace(t[p], e[p], 0, 0, r, h, o);
                return c
            },
            createLayer: function(t, e, s, o) {
                void 0 === e && (e = this.game.width), void 0 === s && (s = this.game.height), void 0 === o && (o = this.game.world);
                var n = t; {
                    if ("string" == typeof t && (n = this.getLayerIndex(t)), !(null === n || n > this.layers.length)) {
                        void 0 === e || e <= 0 ? e = Math.min(this.game.width, this.layers[n].widthInPixels) : e > this.game.width && (e = this.game.width), void 0 === s || s <= 0 ? s = Math.min(this.game.height, this.layers[n].heightInPixels) : s > this.game.height && (s = this.game.height), this.enableDebug && (console.group("Tilemap.createLayer"), console.log("Name:", this.layers[n].name), console.log("Size:", e, "x", s), console.log("Tileset:", this.tilesets[0].name, "index:", n));
                        var a = o.add(new i.TilemapLayer(this.game, this, n, e, s));
                        return this.enableDebug && console.groupEnd(), a
                    }
                    console.warn("Tilemap.createLayer: Invalid layer ID given: " + n)
                }
            },
            createBlankLayer: function(t, e, s, o, n, a) {
                if (void 0 === a && (a = this.game.world), null === this.getLayerIndex(t)) {
                    for (var r, h = {
                            name: t,
                            x: 0,
                            y: 0,
                            width: e,
                            height: s,
                            widthInPixels: e * o,
                            heightInPixels: s * n,
                            alpha: 1,
                            visible: !0,
                            properties: {},
                            indexes: [],
                            callbacks: [],
                            bodies: [],
                            data: null
                        }, l = [], c = 0; c < s; c++) {
                        r = [];
                        for (var p = 0; p < e; p++) r.push(new i.Tile(h, -1, p, c, o, n));
                        l.push(r)
                    }
                    h.data = l, this.layers.push(h), this.currentLayer = this.layers.length - 1;
                    var u = h.widthInPixels,
                        d = h.heightInPixels;
                    return u > this.game.width && (u = this.game.width), d > this.game.height && (d = this.game.height), (l = new i.TilemapLayer(this.game, this, this.layers.length - 1, u, d)).name = t, a.add(l)
                }
                console.warn("Tilemap.createBlankLayer: Layer with matching name already exists: " + t)
            },
            getIndex: function(t, e) {
                for (var i = 0; i < t.length; i++)
                    if (t[i].name === e) return i;
                return null
            },
            getLayerIndex: function(t) {
                return this.getIndex(this.layers, t)
            },
            getTilesetIndex: function(t) {
                return this.getIndex(this.tilesets, t)
            },
            getImageIndex: function(t) {
                return this.getIndex(this.images, t)
            },
            setTileIndexCallback: function(t, e, i, s) {
                if (s = this.getLayer(s), "number" == typeof t) this.layers[s].callbacks[t] = {
                    callback: e,
                    callbackContext: i
                };
                else
                    for (var o = 0, n = t.length; o < n; o++) this.layers[s].callbacks[t[o]] = {
                        callback: e,
                        callbackContext: i
                    }
            },
            setTileLocationCallback: function(t, e, i, s, o, n, a) {
                if (a = this.getLayer(a), this.copy(t, e, i, s, a), !(this._results.length < 2))
                    for (var r = 1; r < this._results.length; r++) this._results[r].setCollisionCallback(o, n)
            },
            setCollision: function(t, e, i, s) {
                if (void 0 === e && (e = !0), void 0 === s && (s = !0), i = this.getLayer(i), "number" == typeof t) return this.setCollisionByIndex(t, e, i, !0);
                if (Array.isArray(t)) {
                    for (var o = 0; o < t.length; o++) this.setCollisionByIndex(t[o], e, i, !1);
                    s && this.calculateFaces(i)
                }
            },
            setCollisionBetween: function(t, e, i, s, o) {
                if (void 0 === i && (i = !0), void 0 === o && (o = !0), s = this.getLayer(s), !(t > e)) {
                    for (var n = t; n <= e; n++) this.setCollisionByIndex(n, i, s, !1);
                    o && this.calculateFaces(s)
                }
            },
            setCollisionByExclusion: function(t, e, i, s) {
                void 0 === e && (e = !0), void 0 === s && (s = !0), i = this.getLayer(i);
                for (var o = 0, n = this.tiles.length; o < n; o++) - 1 === t.indexOf(o) && this.setCollisionByIndex(o, e, i, !1);
                s && this.calculateFaces(i)
            },
            setCollisionByIndex: function(t, e, i, s) {
                if (void 0 === e && (e = !0), void 0 === i && (i = this.currentLayer), void 0 === s && (s = !0), e) this.collideIndexes.push(t);
                else {
                    var o = this.collideIndexes.indexOf(t);
                    o > -1 && this.collideIndexes.splice(o, 1)
                }
                for (var n = 0; n < this.layers[i].height; n++)
                    for (var a = 0; a < this.layers[i].width; a++) {
                        var r = this.layers[i].data[n][a];
                        r && r.index === t && (e ? r.setCollision(!0, !0, !0, !0) : r.resetCollision(), r.faceTop = e, r.faceBottom = e, r.faceLeft = e, r.faceRight = e)
                    }
                return s && this.calculateFaces(i), i
            },
            getLayer: function(t) {
                return void 0 === t ? t = this.currentLayer : "string" == typeof t ? t = this.getLayerIndex(t) : t instanceof i.TilemapLayer && (t = t.index), t
            },
            setPreventRecalculate: function(t) {
                if (!0 === t && !0 !== this.preventingRecalculate && (this.preventingRecalculate = !0, this.needToRecalculate = {}), !1 === t && !0 === this.preventingRecalculate) {
                    this.preventingRecalculate = !1;
                    for (var e in this.needToRecalculate) this.calculateFaces(e);
                    this.needToRecalculate = !1
                }
            },
            calculateFaces: function(t) {
                if (this.preventingRecalculate) this.needToRecalculate[t] = !0;
                else
                    for (var e = null, i = null, s = null, o = null, n = 0, a = this.layers[t].height; n < a; n++)
                        for (var r = 0, h = this.layers[t].width; r < h; r++) {
                            var l = this.layers[t].data[n][r];
                            l && (e = this.getTileAbove(t, r, n), i = this.getTileBelow(t, r, n), s = this.getTileLeft(t, r, n), o = this.getTileRight(t, r, n), l.collides && (l.faceTop = !0, l.faceBottom = !0, l.faceLeft = !0, l.faceRight = !0), e && e.collides && (l.faceTop = !1), i && i.collides && (l.faceBottom = !1), s && s.collides && (l.faceLeft = !1), o && o.collides && (l.faceRight = !1))
                        }
            },
            getTileAbove: function(t, e, i) {
                return i > 0 ? this.layers[t].data[i - 1][e] : null
            },
            getTileBelow: function(t, e, i) {
                return i < this.layers[t].height - 1 ? this.layers[t].data[i + 1][e] : null
            },
            getTileLeft: function(t, e, i) {
                return e > 0 ? this.layers[t].data[i][e - 1] : null
            },
            getTileRight: function(t, e, i) {
                return e < this.layers[t].width - 1 ? this.layers[t].data[i][e + 1] : null
            },
            setLayer: function(t) {
                t = this.getLayer(t), this.layers[t] && (this.currentLayer = t)
            },
            hasTile: function(t, e, i) {
                return i = this.getLayer(i), void 0 !== this.layers[i].data[e] && void 0 !== this.layers[i].data[e][t] && this.layers[i].data[e][t].index > -1
            },
            removeTile: function(t, e, s) {
                if (s = this.getLayer(s), t >= 0 && t < this.layers[s].width && e >= 0 && e < this.layers[s].height && this.hasTile(t, e, s)) {
                    var o = this.layers[s].data[e][t];
                    return this.layers[s].data[e][t] = new i.Tile(this.layers[s], -1, t, e, this.tileWidth, this.tileHeight), this.layers[s].dirty = !0, this.calculateFaces(s), o
                }
            },
            removeTileWorldXY: function(t, e, i, s, o) {
                return o = this.getLayer(o), t = this.game.math.snapToFloor(t, i) / i, e = this.game.math.snapToFloor(e, s) / s, this.removeTile(t, e, o)
            },
            putTile: function(t, e, s, o) {
                if (null === t) return this.removeTile(e, s, o);
                if (o = this.getLayer(o), e >= 0 && e < this.layers[o].width && s >= 0 && s < this.layers[o].height) {
                    var n;
                    return t instanceof i.Tile ? (n = t.index, this.hasTile(e, s, o) ? this.layers[o].data[s][e].copy(t) : this.layers[o].data[s][e] = new i.Tile(o, n, e, s, t.width, t.height)) : (n = t, this.hasTile(e, s, o) ? this.layers[o].data[s][e].index = n : this.layers[o].data[s][e] = new i.Tile(this.layers[o], n, e, s, this.tileWidth, this.tileHeight)), this.collideIndexes.indexOf(n) > -1 ? this.layers[o].data[s][e].setCollision(!0, !0, !0, !0) : this.layers[o].data[s][e].resetCollision(), this.layers[o].dirty = !0, this.calculateFaces(o), this.layers[o].data[s][e]
                }
                return null
            },
            putTileWorldXY: function(t, e, i, s, o, n) {
                return n = this.getLayer(n), e = this.game.math.snapToFloor(e, s) / s, i = this.game.math.snapToFloor(i, o) / o, this.putTile(t, e, i, n)
            },
            searchTileIndex: function(t, e, i, s) {
                void 0 === e && (e = 0), void 0 === i && (i = !1), s = this.getLayer(s);
                var o = 0;
                if (i) {
                    for (n = this.layers[s].height - 1; n >= 0; n--)
                        for (a = this.layers[s].width - 1; a >= 0; a--)
                            if (this.layers[s].data[n][a].index === t) {
                                if (o === e) return this.layers[s].data[n][a];
                                o++
                            }
                } else
                    for (var n = 0; n < this.layers[s].height; n++)
                        for (var a = 0; a < this.layers[s].width; a++)
                            if (this.layers[s].data[n][a].index === t) {
                                if (o === e) return this.layers[s].data[n][a];
                                o++
                            } return null
            },
            getTile: function(t, e, i, s) {
                return void 0 === s && (s = !1), i = this.getLayer(i), t >= 0 && t < this.layers[i].width && e >= 0 && e < this.layers[i].height ? -1 === this.layers[i].data[e][t].index ? s ? this.layers[i].data[e][t] : null : this.layers[i].data[e][t] : null
            },
            getTileWorldXY: function(t, e, i, s, o, n) {
                return void 0 === i && (i = this.tileWidth), void 0 === s && (s = this.tileHeight), o = this.getLayer(o), t = this.game.math.snapToFloor(t, i) / i, e = this.game.math.snapToFloor(e, s) / s, this.getTile(t, e, o, n)
            },
            copy: function(t, e, i, s, o) {
                if (o = this.getLayer(o), this.layers[o]) {
                    void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.layers[o].width), void 0 === s && (s = this.layers[o].height), t < 0 && (t = 0), e < 0 && (e = 0), i > this.layers[o].width && (i = this.layers[o].width), s > this.layers[o].height && (s = this.layers[o].height), this._results.length = 0, this._results.push({
                        x: t,
                        y: e,
                        width: i,
                        height: s,
                        layer: o
                    });
                    for (var n = e; n < e + s; n++)
                        for (var a = t; a < t + i; a++) this._results.push(this.layers[o].data[n][a]);
                    return this._results
                }
                this._results.length = 0
            },
            paste: function(t, e, i, s) {
                if (void 0 === t && (t = 0), void 0 === e && (e = 0), s = this.getLayer(s), i && !(i.length < 2)) {
                    for (var o = t - i[1].x, n = e - i[1].y, a = 1; a < i.length; a++) this.layers[s].data[n + i[a].y][o + i[a].x].copy(i[a]);
                    this.layers[s].dirty = !0, this.calculateFaces(s)
                }
            },
            swap: function(t, e, i, s, o, n, a) {
                a = this.getLayer(a), this.copy(i, s, o, n, a), this._results.length < 2 || (this._tempA = t, this._tempB = e, this._results.forEach(this.swapHandler, this), this.paste(i, s, this._results, a))
            },
            swapHandler: function(t) {
                t.index === this._tempA ? t.index = this._tempB : t.index === this._tempB && (t.index = this._tempA)
            },
            forEach: function(t, e, i, s, o, n, a) {
                a = this.getLayer(a), this.copy(i, s, o, n, a), this._results.length < 2 || (this._results.forEach(t, e), this.paste(i, s, this._results, a))
            },
            replace: function(t, e, i, s, o, n, a) {
                if (a = this.getLayer(a), this.copy(i, s, o, n, a), !(this._results.length < 2)) {
                    for (var r = 1; r < this._results.length; r++) this._results[r].index === t && (this._results[r].index = e);
                    this.paste(i, s, this._results, a)
                }
            },
            random: function(t, e, i, s, o) {
                if (o = this.getLayer(o), this.copy(t, e, i, s, o), !(this._results.length < 2)) {
                    for (var n = [], a = 1; a < this._results.length; a++)
                        if (this._results[a].index) {
                            var r = this._results[a].index; - 1 === n.indexOf(r) && n.push(r)
                        }
                    for (var h = 1; h < this._results.length; h++) this._results[h].index = this.game.rnd.pick(n);
                    this.paste(t, e, this._results, o)
                }
            },
            shuffle: function(t, e, s, o, n) {
                if (n = this.getLayer(n), this.copy(t, e, s, o, n), !(this._results.length < 2)) {
                    for (var a = [], r = 1; r < this._results.length; r++) this._results[r].index && a.push(this._results[r].index);
                    i.ArrayUtils.shuffle(a);
                    for (var h = 1; h < this._results.length; h++) this._results[h].index = a[h - 1];
                    this.paste(t, e, this._results, n)
                }
            },
            fill: function(t, e, i, s, o, n) {
                if (n = this.getLayer(n), this.copy(e, i, s, o, n), !(this._results.length < 2)) {
                    for (var a = 1; a < this._results.length; a++) this._results[a].index = t;
                    this.paste(e, i, this._results, n)
                }
            },
            removeAllLayers: function() {
                this.layers.length = 0, this.currentLayer = 0
            },
            dump: function() {
                for (var t = "", e = [""], i = 0; i < this.layers[this.currentLayer].height; i++) {
                    for (var s = 0; s < this.layers[this.currentLayer].width; s++) t += "%c  ", this.layers[this.currentLayer].data[i][s] > 1 ? this.debugMap[this.layers[this.currentLayer].data[i][s]] ? e.push("background: " + this.debugMap[this.layers[this.currentLayer].data[i][s]]) : e.push("background: #ffffff") : e.push("background: rgb(0, 0, 0)");
                    t += "\n"
                }
                e[0] = t, console.log.apply(console, e)
            },
            destroy: function() {
                this.removeAllLayers(), this.data = [], this.game = null
            }
        }, i.Tilemap.prototype.constructor = i.Tilemap, Object.defineProperty(i.Tilemap.prototype, "layer", {
            get: function() {
                return this.layers[this.currentLayer]
            },
            set: function(t) {
                t !== this.currentLayer && this.setLayer(t)
            }
        }), i.TilemapLayer = function(t, e, s, o, n) {
            o |= 0, n |= 0, i.Sprite.call(this, t, 0, 0), this.map = e, this.index = s, this.layer = e.layers[s], this.canvas = PIXI.CanvasPool.create(this, o, n), this.context = this.canvas.getContext("2d"), this.setTexture(new PIXI.Texture(new PIXI.BaseTexture(this.canvas))), this.type = i.TILEMAPLAYER, this.physicsType = i.TILEMAPLAYER, this.renderSettings = {
                enableScrollDelta: !1,
                overdrawRatio: .2,
                copyCanvas: null
            }, this.debug = !1, this.exists = !0, this.debugSettings = {
                missingImageFill: "rgb(255,255,255)",
                debuggedTileOverfill: "rgba(0,255,0,0.4)",
                forceFullRedraw: !0,
                debugAlpha: .5,
                facingEdgeStroke: "rgba(0,255,0,1)",
                collidingTileOverfill: "rgba(0,255,0,0.2)"
            }, this.scrollFactorX = 1, this.scrollFactorY = 1, this.dirty = !0, this.rayStepRate = 4, this._wrap = !1, this._mc = {
                scrollX: 0,
                scrollY: 0,
                renderWidth: 0,
                renderHeight: 0,
                tileWidth: e.tileWidth,
                tileHeight: e.tileHeight,
                cw: e.tileWidth,
                ch: e.tileHeight,
                tilesets: []
            }, this._scrollX = 0, this._scrollY = 0, this._results = [], t.device.canvasBitBltShift || (this.renderSettings.copyCanvas = i.TilemapLayer.ensureSharedCopyCanvas()), this.fixedToCamera = !0
        }, i.TilemapLayer.prototype = Object.create(i.Sprite.prototype), i.TilemapLayer.prototype.constructor = i.TilemapLayer, i.TilemapLayer.prototype.preUpdateCore = i.Component.Core.preUpdate, i.TilemapLayer.sharedCopyCanvas = null, i.TilemapLayer.ensureSharedCopyCanvas = function() {
            return this.sharedCopyCanvas || (this.sharedCopyCanvas = PIXI.CanvasPool.create(this, 2, 2)), this.sharedCopyCanvas
        }, i.TilemapLayer.prototype.preUpdate = function() {
            return this.preUpdateCore()
        }, i.TilemapLayer.prototype.postUpdate = function() {
            this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y), this._scrollX = this.game.camera.view.x * this.scrollFactorX / this.scale.x, this._scrollY = this.game.camera.view.y * this.scrollFactorY / this.scale.y
        }, i.TilemapLayer.prototype._renderCanvas = function(t) {
            this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y), this._scrollX = this.game.camera.view.x * this.scrollFactorX / this.scale.x, this._scrollY = this.game.camera.view.y * this.scrollFactorY / this.scale.y, this.render(), PIXI.Sprite.prototype._renderCanvas.call(this, t)
        }, i.TilemapLayer.prototype._renderWebGL = function(t) {
            this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y), this._scrollX = this.game.camera.view.x * this.scrollFactorX / this.scale.x, this._scrollY = this.game.camera.view.y * this.scrollFactorY / this.scale.y, this.render(), PIXI.Sprite.prototype._renderWebGL.call(this, t)
        }, i.TilemapLayer.prototype.destroy = function() {
            PIXI.CanvasPool.remove(this), i.Component.Destroy.prototype.destroy.call(this)
        }, i.TilemapLayer.prototype.resize = function(t, e) {
            this.canvas.width = t, this.canvas.height = e, this.texture.frame.resize(t, e), this.texture.width = t, this.texture.height = e, this.texture.crop.width = t, this.texture.crop.height = e, this.texture.baseTexture.width = t, this.texture.baseTexture.height = e, this.texture.baseTexture.dirty(), this.texture.requiresUpdate = !0, this.texture._updateUvs(), this.dirty = !0
        }, i.TilemapLayer.prototype.resizeWorld = function() {
            this.game.world.setBounds(0, 0, this.layer.widthInPixels * this.scale.x, this.layer.heightInPixels * this.scale.y)
        }, i.TilemapLayer.prototype._fixX = function(t) {
            return 1 === this.scrollFactorX || 0 === this.scrollFactorX && 0 === this.position.x ? t : 0 === this.scrollFactorX && 0 !== this.position.x ? t - this.position.x : this._scrollX + (t - this._scrollX / this.scrollFactorX)
        }, i.TilemapLayer.prototype._unfixX = function(t) {
            return 1 === this.scrollFactorX ? t : this._scrollX / this.scrollFactorX + (t - this._scrollX)
        }, i.TilemapLayer.prototype._fixY = function(t) {
            return 1 === this.scrollFactorY || 0 === this.scrollFactorY && 0 === this.position.y ? t : 0 === this.scrollFactorY && 0 !== this.position.y ? t - this.position.y : this._scrollY + (t - this._scrollY / this.scrollFactorY)
        }, i.TilemapLayer.prototype._unfixY = function(t) {
            return 1 === this.scrollFactorY ? t : this._scrollY / this.scrollFactorY + (t - this._scrollY)
        }, i.TilemapLayer.prototype.getTileX = function(t) {
            return Math.floor(this._fixX(t) / this._mc.tileWidth)
        }, i.TilemapLayer.prototype.getTileY = function(t) {
            return Math.floor(this._fixY(t) / this._mc.tileHeight)
        }, i.TilemapLayer.prototype.getTileXY = function(t, e, i) {
            return i.x = this.getTileX(t), i.y = this.getTileY(e), i
        }, i.TilemapLayer.prototype.getRayCastTiles = function(t, e, i, s) {
            e || (e = this.rayStepRate), void 0 === i && (i = !1), void 0 === s && (s = !1);
            var o = this.getTiles(t.x, t.y, t.width, t.height, i, s);
            if (0 === o.length) return [];
            for (var n = t.coordinatesOnLine(e), a = [], r = 0; r < o.length; r++)
                for (var h = 0; h < n.length; h++) {
                    var l = o[r],
                        c = n[h];
                    if (l.containsPoint(c[0], c[1])) {
                        a.push(l);
                        break
                    }
                }
            return a
        }, i.TilemapLayer.prototype.getTiles = function(t, e, i, s, o, n) {
            void 0 === o && (o = !1), void 0 === n && (n = !1);
            var a = !(o || n);
            t = this._fixX(t), e = this._fixY(e);
            for (var r = Math.floor(t / (this._mc.cw * this.scale.x)), h = Math.floor(e / (this._mc.ch * this.scale.y)), l = Math.ceil((t + i) / (this._mc.cw * this.scale.x)) - r, c = Math.ceil((e + s) / (this._mc.ch * this.scale.y)) - h; this._results.length;) this._results.pop();
            for (var p = h; p < h + c; p++)
                for (var u = r; u < r + l; u++) {
                    var d = this.layer.data[p];
                    d && d[u] && (a || d[u].isInteresting(o, n)) && this._results.push(d[u])
                }
            return this._results.slice()
        }, i.TilemapLayer.prototype.resolveTileset = function(t) {
            var e = this._mc.tilesets;
            if (t < 2e3)
                for (; e.length < t;) e.push(void 0);
            var i = this.map.tiles[t] && this.map.tiles[t][2];
            if (null !== i) {
                var s = this.map.tilesets[i];
                if (s && s.containsTileIndex(t)) return e[t] = s
            }
            return e[t] = null
        }, i.TilemapLayer.prototype.resetTilesetCache = function() {
            for (var t = this._mc.tilesets; t.length;) t.pop()
        }, i.TilemapLayer.prototype.setScale = function(t, e) {
            t = t || 1, e = e || t;
            for (var i = 0; i < this.layer.data.length; i++)
                for (var s = this.layer.data[i], o = 0; o < s.length; o++) {
                    var n = s[o];
                    n.width = this.map.tileWidth * t, n.height = this.map.tileHeight * e, n.worldX = n.x * n.width, n.worldY = n.y * n.height
                }
            this.scale.setTo(t, e)
        }, i.TilemapLayer.prototype.shiftCanvas = function(t, e, i) {
            var s = t.canvas,
                o = s.width - Math.abs(e),
                n = s.height - Math.abs(i),
                a = 0,
                r = 0,
                h = e,
                l = i;
            e < 0 && (a = -e, h = 0), i < 0 && (r = -i, l = 0);
            var c = this.renderSettings.copyCanvas;
            if (c) {
                (c.width < o || c.height < n) && (c.width = o, c.height = n);
                var p = c.getContext("2d");
                p.clearRect(0, 0, o, n), p.drawImage(s, a, r, o, n, 0, 0, o, n), t.clearRect(h, l, o, n), t.drawImage(c, 0, 0, o, n, h, l, o, n)
            } else t.save(), t.globalCompositeOperation = "copy", t.drawImage(s, a, r, o, n, h, l, o, n), t.restore()
        }, i.TilemapLayer.prototype.renderRegion = function(t, e, i, s, o, n) {
            var a = this.context,
                r = this.layer.width,
                h = this.layer.height,
                l = this._mc.tileWidth,
                c = this._mc.tileHeight,
                p = this._mc.tilesets,
                u = NaN;
            this._wrap || (i <= o && (i = Math.max(0, i), o = Math.min(r - 1, o)), s <= n && (s = Math.max(0, s), n = Math.min(h - 1, n)));
            var d, m, y, f, g, _, v = i * l - t,
                b = (i + (1 << 20) * r) % r;
            for (f = (s + (1 << 20) * h) % h, _ = n - s, m = s * c - e; _ >= 0; f++, _--, m += c) {
                f >= h && (f -= h);
                var x = this.layer.data[f];
                for (y = b, g = o - i, d = v; g >= 0; y++, g--, d += l) {
                    y >= r && (y -= r);
                    var C = x[y];
                    if (C && !(C.index < 0)) {
                        var S = C.index,
                            w = p[S];
                        void 0 === w && (w = this.resolveTileset(S)), C.alpha === u || this.debug || (a.globalAlpha = C.alpha, u = C.alpha), w ? C.rotation || C.flipped ? (a.save(), a.translate(d + C.centerX, m + C.centerY), a.rotate(C.rotation), C.flipped && a.scale(-1, 1), w.draw(a, -C.centerX, -C.centerY, S), a.restore()) : w.draw(a, d, m, S) : this.debugSettings.missingImageFill && (a.fillStyle = this.debugSettings.missingImageFill, a.fillRect(d, m, l, c)), C.debug && this.debugSettings.debuggedTileOverfill && (a.fillStyle = this.debugSettings.debuggedTileOverfill, a.fillRect(d, m, l, c))
                    }
                }
            }
        }, i.TilemapLayer.prototype.renderDeltaScroll = function(t, e) {
            var i = this._mc.scrollX,
                s = this._mc.scrollY,
                o = this.canvas.width,
                n = this.canvas.height,
                a = this._mc.tileWidth,
                r = this._mc.tileHeight,
                h = 0,
                l = -a,
                c = 0,
                p = -r;
            if (t < 0 ? (h = o + t, l = o - 1) : t > 0 && (l = t), e < 0 ? (c = n + e, p = n - 1) : e > 0 && (p = e), this.shiftCanvas(this.context, t, e), h = Math.floor((h + i) / a), l = Math.floor((l + i) / a), c = Math.floor((c + s) / r), p = Math.floor((p + s) / r), h <= l) {
                this.context.clearRect(h * a - i, 0, (l - h + 1) * a, n);
                var u = Math.floor((0 + s) / r),
                    d = Math.floor((n - 1 + s) / r);
                this.renderRegion(i, s, h, u, l, d)
            }
            if (c <= p) {
                this.context.clearRect(0, c * r - s, o, (p - c + 1) * r);
                var m = Math.floor((0 + i) / a),
                    y = Math.floor((o - 1 + i) / a);
                this.renderRegion(i, s, m, c, y, p)
            }
        }, i.TilemapLayer.prototype.renderFull = function() {
            var t = this._mc.scrollX,
                e = this._mc.scrollY,
                i = this.canvas.width,
                s = this.canvas.height,
                o = this._mc.tileWidth,
                n = this._mc.tileHeight,
                a = Math.floor(t / o),
                r = Math.floor((i - 1 + t) / o),
                h = Math.floor(e / n),
                l = Math.floor((s - 1 + e) / n);
            this.context.clearRect(0, 0, i, s), this.renderRegion(t, e, a, h, r, l)
        }, i.TilemapLayer.prototype.render = function() {
            var t = !1;
            if (this.visible) {
                (this.dirty || this.layer.dirty) && (this.layer.dirty = !1, t = !0);
                var e = this.canvas.width,
                    i = this.canvas.height,
                    s = 0 | this._scrollX,
                    o = 0 | this._scrollY,
                    n = this._mc,
                    a = n.scrollX - s,
                    r = n.scrollY - o;
                if (t || 0 !== a || 0 !== r || n.renderWidth !== e || n.renderHeight !== i) return this.context.save(), n.scrollX = s, n.scrollY = o, n.renderWidth === e && n.renderHeight === i || (n.renderWidth = e, n.renderHeight = i), this.debug && (this.context.globalAlpha = this.debugSettings.debugAlpha, this.debugSettings.forceFullRedraw && (t = !0)), !t && this.renderSettings.enableScrollDelta && Math.abs(a) + Math.abs(r) < Math.min(e, i) ? this.renderDeltaScroll(a, r) : this.renderFull(), this.debug && (this.context.globalAlpha = 1, this.renderDebug()), this.texture.baseTexture.dirty(), this.dirty = !1, this.context.restore(), !0
            }
        }, i.TilemapLayer.prototype.renderDebug = function() {
            var t, e, i, s, o, n, a = this._mc.scrollX,
                r = this._mc.scrollY,
                h = this.context,
                l = this.canvas.width,
                c = this.canvas.height,
                p = this.layer.width,
                u = this.layer.height,
                d = this._mc.tileWidth,
                m = this._mc.tileHeight,
                y = Math.floor(a / d),
                f = Math.floor((l - 1 + a) / d),
                g = Math.floor(r / m),
                _ = Math.floor((c - 1 + r) / m),
                v = y * d - a,
                b = g * m - r,
                x = (y + (1 << 20) * p) % p,
                C = (g + (1 << 20) * u) % u;
            for (h.strokeStyle = this.debugSettings.facingEdgeStroke, s = C, n = _ - g, e = b; n >= 0; s++, n--, e += m) {
                s >= u && (s -= u);
                var S = this.layer.data[s];
                for (i = x, o = f - y, t = v; o >= 0; i++, o--, t += d) {
                    i >= p && (i -= p);
                    var w = S[i];
                    !w || w.index < 0 || !w.collides || (this.debugSettings.collidingTileOverfill && (h.fillStyle = this.debugSettings.collidingTileOverfill, h.fillRect(t, e, this._mc.cw, this._mc.ch)), this.debugSettings.facingEdgeStroke && (h.beginPath(), w.faceTop && (h.moveTo(t, e), h.lineTo(t + this._mc.cw, e)), w.faceBottom && (h.moveTo(t, e + this._mc.ch), h.lineTo(t + this._mc.cw, e + this._mc.ch)), w.faceLeft && (h.moveTo(t, e), h.lineTo(t, e + this._mc.ch)), w.faceRight && (h.moveTo(t + this._mc.cw, e), h.lineTo(t + this._mc.cw, e + this._mc.ch)), h.closePath(), h.stroke()))
                }
            }
        }, Object.defineProperty(i.TilemapLayer.prototype, "wrap", {
            get: function() {
                return this._wrap
            },
            set: function(t) {
                this._wrap = t, this.dirty = !0
            }
        }), Object.defineProperty(i.TilemapLayer.prototype, "scrollX", {
            get: function() {
                return this._scrollX
            },
            set: function(t) {
                this._scrollX = t
            }
        }), Object.defineProperty(i.TilemapLayer.prototype, "scrollY", {
            get: function() {
                return this._scrollY
            },
            set: function(t) {
                this._scrollY = t
            }
        }), Object.defineProperty(i.TilemapLayer.prototype, "collisionWidth", {
            get: function() {
                return this._mc.cw
            },
            set: function(t) {
                this._mc.cw = 0 | t, this.dirty = !0
            }
        }), Object.defineProperty(i.TilemapLayer.prototype, "collisionHeight", {
            get: function() {
                return this._mc.ch
            },
            set: function(t) {
                this._mc.ch = 0 | t, this.dirty = !0
            }
        }), i.TilemapParser = {
            INSERT_NULL: !1,
            parse: function(t, e, s, o, n, a) {
                if (void 0 === s && (s = 32), void 0 === o && (o = 32), void 0 === n && (n = 10), void 0 === a && (a = 10), void 0 === e) return this.getEmptyData();
                if (null === e) return this.getEmptyData(s, o, n, a);
                var r = t.cache.getTilemapData(e);
                if (r) {
                    if (r.format === i.Tilemap.CSV) return this.parseCSV(e, r.data, s, o);
                    if (!r.format || r.format === i.Tilemap.TILED_JSON) return this.parseTiledJSON(r.data)
                } else console.warn("Phaser.TilemapParser.parse - No map data found for key " + e)
            },
            parseCSV: function(t, e, s, o) {
                for (var n = this.getEmptyData(), a = [], r = (e = e.trim()).split("\n"), h = r.length, l = 0, c = 0; c < r.length; c++) {
                    a[c] = [];
                    for (var p = r[c].split(","), u = 0; u < p.length; u++) a[c][u] = new i.Tile(n.layers[0], parseInt(p[u], 10), u, c, s, o);
                    0 === l && (l = p.length)
                }
                return n.format = i.Tilemap.CSV, n.name = t, n.width = l, n.height = h, n.tileWidth = s, n.tileHeight = o, n.widthInPixels = l * s, n.heightInPixels = h * o, n.layers[0].width = l, n.layers[0].height = h, n.layers[0].widthInPixels = n.widthInPixels, n.layers[0].heightInPixels = n.heightInPixels, n.layers[0].data = a, n
            },
            getEmptyData: function(t, e, i, s) {
                return {
                    width: void 0 !== i && null !== i ? i : 0,
                    height: void 0 !== s && null !== s ? s : 0,
                    tileWidth: void 0 !== t && null !== t ? t : 0,
                    tileHeight: void 0 !== e && null !== e ? e : 0,
                    orientation: "orthogonal",
                    version: "1",
                    properties: {},
                    widthInPixels: 0,
                    heightInPixels: 0,
                    layers: [{
                        name: "layer",
                        x: 0,
                        y: 0,
                        width: 0,
                        height: 0,
                        widthInPixels: 0,
                        heightInPixels: 0,
                        alpha: 1,
                        visible: !0,
                        properties: {},
                        indexes: [],
                        callbacks: [],
                        bodies: [],
                        data: []
                    }],
                    images: [],
                    objects: {},
                    collision: {},
                    tilesets: [],
                    tiles: []
                }
            },
            parseTiledJSON: function(t) {
                function e(t, e) {
                    var i = {};
                    for (var s in e) {
                        var o = e[s];
                        void 0 !== t[o] && (i[o] = t[o])
                    }
                    return i
                }
                if ("orthogonal" !== t.orientation) return console.warn("TilemapParser.parseTiledJSON - Only orthogonal map types are supported in this version of Phaser"), null;
                for (var s = {
                        width: t.width,
                        height: t.height,
                        tileWidth: t.tilewidth,
                        tileHeight: t.tileheight,
                        orientation: t.orientation,
                        format: i.Tilemap.TILED_JSON,
                        version: t.version,
                        properties: t.properties,
                        widthInPixels: t.width * t.tilewidth,
                        heightInPixels: t.height * t.tileheight
                    }, o = [], n = 0; n < t.layers.length; n++)
                    if ("tilelayer" === t.layers[n].type) {
                        var a = t.layers[n];
                        if (!a.compression && a.encoding && "base64" === a.encoding) {
                            for (var r = window.atob(a.data), h = r.length, l = new Array(h), c = 0; c < h; c += 4) l[c / 4] = (r.charCodeAt(c) | r.charCodeAt(c + 1) << 8 | r.charCodeAt(c + 2) << 16 | r.charCodeAt(c + 3) << 24) >>> 0;
                            a.data = l, delete a.encoding
                        } else if (a.compression) {
                            console.warn("TilemapParser.parseTiledJSON - Layer compression is unsupported, skipping layer '" + a.name + "'");
                            continue
                        }
                        N = {
                            name: a.name,
                            x: a.x,
                            y: a.y,
                            width: a.width,
                            height: a.height,
                            widthInPixels: a.width * t.tilewidth,
                            heightInPixels: a.height * t.tileheight,
                            alpha: a.opacity,
                            visible: a.visible,
                            properties: {},
                            indexes: [],
                            callbacks: [],
                            bodies: []
                        };
                        a.properties && (N.properties = a.properties);
                        for (var p, u, d, m = 0, y = [], f = [], g = 0, h = a.data.length; g < h; g++) {
                            if (p = 0, u = !1, B = a.data[g], d = 0, B > 536870912) switch (B > 2147483648 && (B -= 2147483648, d += 4), B > 1073741824 && (B -= 1073741824, d += 2), B > 536870912 && (B -= 536870912, d += 1), d) {
                                case 5:
                                    p = Math.PI / 2;
                                    break;
                                case 6:
                                    p = Math.PI;
                                    break;
                                case 3:
                                    p = 3 * Math.PI / 2;
                                    break;
                                case 4:
                                    p = 0, u = !0;
                                    break;
                                case 7:
                                    p = Math.PI / 2, u = !0;
                                    break;
                                case 2:
                                    p = Math.PI, u = !0;
                                    break;
                                case 1:
                                    p = 3 * Math.PI / 2, u = !0
                            }
                            B > 0 ? ((V = new i.Tile(N, B, m, f.length, t.tilewidth, t.tileheight)).rotation = p, V.flipped = u, 0 !== d && (V.flippedVal = d), y.push(V)) : i.TilemapParser.INSERT_NULL ? y.push(null) : y.push(new i.Tile(N, -1, m, f.length, t.tilewidth, t.tileheight)), ++m === a.width && (f.push(y), m = 0, y = [])
                        }
                        N.data = f, o.push(N)
                    }
                s.layers = o;
                for (var _ = [], n = 0; n < t.layers.length; n++)
                    if ("imagelayer" === t.layers[n].type) {
                        var v = t.layers[n],
                            b = {
                                name: v.name,
                                image: v.image,
                                x: v.x,
                                y: v.y,
                                alpha: v.opacity,
                                visible: v.visible,
                                properties: {}
                            };
                        v.properties && (b.properties = v.properties), _.push(b)
                    }
                s.images = _;
                for (var x = [], C = [], S = null, n = 0; n < t.tilesets.length; n++) {
                    if ((G = t.tilesets[n]).image) {
                        var w = new i.Tileset(G.name, G.firstgid, G.tilewidth, G.tileheight, G.margin, G.spacing, G.properties);
                        G.tileproperties && (w.tileProperties = G.tileproperties), w.updateTileData(G.imagewidth, G.imageheight), x.push(w)
                    } else {
                        var A = new i.ImageCollection(G.name, G.firstgid, G.tilewidth, G.tileheight, G.margin, G.spacing, G.properties);
                        for (var T in G.tiles) {
                            var b = G.tiles[T].image,
                                B = G.firstgid + parseInt(T, 10);
                            A.addImage(B, b)
                        }
                        C.push(A)
                    }
                    S && (S.lastgid = G.firstgid - 1), S = G
                }
                s.tilesets = x, s.imagecollections = C;
                for (var P = {}, D = {}, n = 0; n < t.layers.length; n++)
                    if ("objectgroup" === t.layers[n].type) {
                        var I = t.layers[n];
                        P[I.name] = [], D[I.name] = [];
                        for (var E = 0, h = I.objects.length; E < h; E++)
                            if (I.objects[E].gid) {
                                M = {
                                    gid: I.objects[E].gid,
                                    name: I.objects[E].name,
                                    type: I.objects[E].hasOwnProperty("type") ? I.objects[E].type : "",
                                    x: I.objects[E].x,
                                    y: I.objects[E].y,
                                    visible: I.objects[E].visible,
                                    properties: I.objects[E].properties
                                };
                                I.objects[E].rotation && (M.rotation = I.objects[E].rotation), P[I.name].push(M)
                            } else if (I.objects[E].polyline) {
                            M = {
                                name: I.objects[E].name,
                                type: I.objects[E].type,
                                x: I.objects[E].x,
                                y: I.objects[E].y,
                                width: I.objects[E].width,
                                height: I.objects[E].height,
                                visible: I.objects[E].visible,
                                properties: I.objects[E].properties
                            };
                            I.objects[E].rotation && (M.rotation = I.objects[E].rotation), M.polyline = [];
                            for (L = 0; L < I.objects[E].polyline.length; L++) M.polyline.push([I.objects[E].polyline[L].x, I.objects[E].polyline[L].y]);
                            D[I.name].push(M), P[I.name].push(M)
                        } else if (I.objects[E].polygon) {
                            (M = e(I.objects[E], ["name", "type", "x", "y", "visible", "rotation", "properties"])).polygon = [];
                            for (var L = 0; L < I.objects[E].polygon.length; L++) M.polygon.push([I.objects[E].polygon[L].x, I.objects[E].polygon[L].y]);
                            P[I.name].push(M)
                        } else if (I.objects[E].ellipse) {
                            var M = e(I.objects[E], ["name", "type", "ellipse", "x", "y", "width", "height", "visible", "rotation", "properties"]);
                            P[I.name].push(M)
                        } else(M = e(I.objects[E], ["name", "type", "x", "y", "width", "height", "visible", "rotation", "properties"])).rectangle = !0, P[I.name].push(M)
                    }
                s.objects = P, s.collision = D, s.tiles = [];
                for (n = 0; n < s.tilesets.length; n++)
                    for (var G = s.tilesets[n], m = G.tileMargin, O = G.tileMargin, R = 0, k = 0, F = 0, g = G.firstgid; g < G.firstgid + G.total && (s.tiles[g] = [m, O, n], m += G.tileWidth + G.tileSpacing, ++R !== G.total) && (++k !== G.columns || (m = G.tileMargin, O += G.tileHeight + G.tileSpacing, k = 0, ++F !== G.rows)); g++);
                for (var N, V, U, n = 0; n < s.layers.length; n++) {
                    N = s.layers[n], G = null;
                    for (c = 0; c < N.data.length; c++) {
                        y = N.data[c];
                        for (var W = 0; W < y.length; W++) null === (V = y[W]) || V.index < 0 || (U = s.tiles[V.index][2], (G = s.tilesets[U]).tileProperties && G.tileProperties[V.index - G.firstgid] && (V.properties = i.Utils.mixin(G.tileProperties[V.index - G.firstgid], V.properties)))
                    }
                }
                return s
            }
        }, i.Tileset = function(t, e, i, s, o, n, a) {
            (void 0 === i || i <= 0) && (i = 32), (void 0 === s || s <= 0) && (s = 32), void 0 === o && (o = 0), void 0 === n && (n = 0), this.name = t, this.firstgid = 0 | e, this.tileWidth = 0 | i, this.tileHeight = 0 | s, this.tileMargin = 0 | o, this.tileSpacing = 0 | n, this.properties = a || {}, this.image = null, this.rows = 0, this.columns = 0, this.total = 0, this.drawCoords = []
        }, i.Tileset.prototype = {
            draw: function(t, e, i, s) {
                var o = s - this.firstgid << 1;
                o >= 0 && o + 1 < this.drawCoords.length && t.drawImage(this.image, this.drawCoords[o], this.drawCoords[o + 1], this.tileWidth, this.tileHeight, e, i, this.tileWidth, this.tileHeight)
            },
            containsTileIndex: function(t) {
                return t >= this.firstgid && t < this.firstgid + this.total
            },
            setImage: function(t) {
                this.image = t, this.updateTileData(t.width, t.height)
            },
            setSpacing: function(t, e) {
                this.tileMargin = 0 | t, this.tileSpacing = 0 | e, this.image && this.updateTileData(this.image.width, this.image.height)
            },
            updateTileData: function(t, e) {
                var i = (e - 2 * this.tileMargin + this.tileSpacing) / (this.tileHeight + this.tileSpacing),
                    s = (t - 2 * this.tileMargin + this.tileSpacing) / (this.tileWidth + this.tileSpacing);
                i % 1 == 0 && s % 1 == 0 || console.warn("Phaser.Tileset - " + this.name + " image tile area is not an even multiple of tile size"), i = Math.floor(i), s = Math.floor(s), (this.rows && this.rows !== i || this.columns && this.columns !== s) && console.warn("Phaser.Tileset - actual and expected number of tile rows and columns differ"), this.rows = i, this.columns = s, this.total = i * s, this.drawCoords.length = 0;
                for (var o = this.tileMargin, n = this.tileMargin, a = 0; a < this.rows; a++) {
                    for (var r = 0; r < this.columns; r++) this.drawCoords.push(o), this.drawCoords.push(n), o += this.tileWidth + this.tileSpacing;
                    o = this.tileMargin, n += this.tileHeight + this.tileSpacing
                }
            }
        }, i.Tileset.prototype.constructor = i.Tileset, i.Particle = function(t, e, s, o, n) {
            i.Sprite.call(this, t, e, s, o, n), this.autoScale = !1, this.scaleData = null, this._s = 0, this.autoAlpha = !1, this.alphaData = null, this._a = 0
        }, i.Particle.prototype = Object.create(i.Sprite.prototype), i.Particle.prototype.constructor = i.Particle, i.Particle.prototype.update = function() {
            this.autoScale && (--this._s ? this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y) : this.autoScale = !1), this.autoAlpha && (--this._a ? this.alpha = this.alphaData[this._a].v : this.autoAlpha = !1)
        }, i.Particle.prototype.onEmit = function() {}, i.Particle.prototype.setAlphaData = function(t) {
            this.alphaData = t, this._a = t.length - 1, this.alpha = this.alphaData[this._a].v, this.autoAlpha = !0
        }, i.Particle.prototype.setScaleData = function(t) {
            this.scaleData = t, this._s = t.length - 1, this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y), this.autoScale = !0
        }, i.Particle.prototype.reset = function(t, e, s) {
            return i.Component.Reset.prototype.reset.call(this, t, e, s), this.alpha = 1, this.scale.set(1), this.autoScale = !1, this.autoAlpha = !1, this
        }, i.Particles = function(t) {
            this.game = t, this.emitters = {}, this.ID = 0
        }, i.Particles.prototype = {
            add: function(t) {
                return this.emitters[t.name] = t, t
            },
            remove: function(t) {
                delete this.emitters[t.name]
            },
            update: function() {
                for (var t in this.emitters) this.emitters[t].exists && this.emitters[t].update()
            }
        }, i.Particles.prototype.constructor = i.Particles, i.Particles.Arcade = {}, i.Particles.Arcade.Emitter = function(t, e, s, o) {
            this.maxParticles = o || 50, i.Group.call(this, t), this.name = "emitter" + this.game.particles.ID++, this.type = i.EMITTER, this.physicsType = i.GROUP, this.area = new i.Rectangle(e, s, 1, 1), this.minParticleSpeed = new i.Point(-100, -100), this.maxParticleSpeed = new i.Point(100, 100), this.minParticleScale = 1, this.maxParticleScale = 1, this.scaleData = null, this.minRotation = -360, this.maxRotation = 360, this.minParticleAlpha = 1, this.maxParticleAlpha = 1, this.alphaData = null, this.gravity = 100, this.particleClass = i.Particle, this.particleDrag = new i.Point, this.angularDrag = 0, this.frequency = 100, this.lifespan = 2e3, this.bounce = new i.Point, this.on = !1, this.particleAnchor = new i.Point(.5, .5), this.blendMode = i.blendModes.NORMAL, this.emitX = e, this.emitY = s, this.autoScale = !1, this.autoAlpha = !1, this.particleBringToTop = !1, this.particleSendToBack = !1, this._minParticleScale = new i.Point(1, 1), this._maxParticleScale = new i.Point(1, 1), this._quantity = 0, this._timer = 0, this._counter = 0, this._flowQuantity = 0, this._flowTotal = 0, this._explode = !0, this._frames = null
        }, i.Particles.Arcade.Emitter.prototype = Object.create(i.Group.prototype), i.Particles.Arcade.Emitter.prototype.constructor = i.Particles.Arcade.Emitter, i.Particles.Arcade.Emitter.prototype.update = function() {
            if (this.on && this.game.time.time >= this._timer)
                if (this._timer = this.game.time.time + this.frequency * this.game.time.slowMotion, 0 !== this._flowTotal)
                    if (this._flowQuantity > 0) {
                        for (t = 0; t < this._flowQuantity; t++)
                            if (this.emitParticle() && (this._counter++, -1 !== this._flowTotal && this._counter >= this._flowTotal)) {
                                this.on = !1;
                                break
                            }
                    } else this.emitParticle() && (this._counter++, -1 !== this._flowTotal && this._counter >= this._flowTotal && (this.on = !1));
            else this.emitParticle() && (this._counter++, this._quantity > 0 && this._counter >= this._quantity && (this.on = !1));
            for (var t = this.children.length; t--;) this.children[t].exists && this.children[t].update()
        }, i.Particles.Arcade.Emitter.prototype.makeParticles = function(t, e, i, s, o) {
            void 0 === e && (e = 0), void 0 === i && (i = this.maxParticles), void 0 === s && (s = !1), void 0 === o && (o = !1);
            var n, a = 0,
                r = t,
                h = e;
            for (this._frames = e, i > this.maxParticles && (this.maxParticles = i); a < i;) Array.isArray(t) && (r = this.game.rnd.pick(t)), Array.isArray(e) && (h = this.game.rnd.pick(e)), n = new this.particleClass(this.game, 0, 0, r, h), this.game.physics.arcade.enable(n, !1), s ? (n.body.checkCollision.any = !0, n.body.checkCollision.none = !1) : n.body.checkCollision.none = !0, n.body.collideWorldBounds = o, n.body.skipQuadTree = !0, n.exists = !1, n.visible = !1, n.anchor.copyFrom(this.particleAnchor), this.add(n), a++;
            return this
        }, i.Particles.Arcade.Emitter.prototype.kill = function() {
            return this.on = !1, this.alive = !1, this.exists = !1, this
        }, i.Particles.Arcade.Emitter.prototype.revive = function() {
            return this.alive = !0, this.exists = !0, this
        }, i.Particles.Arcade.Emitter.prototype.explode = function(t, e) {
            return this._flowTotal = 0, this.start(!0, t, 0, e, !1), this
        }, i.Particles.Arcade.Emitter.prototype.flow = function(t, e, i, s, o) {
            return void 0 !== i && 0 !== i || (i = 1), void 0 === s && (s = -1), void 0 === o && (o = !0), i > this.maxParticles && (i = this.maxParticles), this._counter = 0, this._flowQuantity = i, this._flowTotal = s, o ? (this.start(!0, t, e, i), this._counter += i, this.on = !0, this._timer = this.game.time.time + e * this.game.time.slowMotion) : this.start(!1, t, e, i), this
        }, i.Particles.Arcade.Emitter.prototype.start = function(t, e, i, s, o) {
            if (void 0 === t && (t = !0), void 0 === e && (e = 0), void 0 !== i && null !== i || (i = 250), void 0 === s && (s = 0), void 0 === o && (o = !1), s > this.maxParticles && (s = this.maxParticles), this.revive(), this.visible = !0, this.lifespan = e, this.frequency = i, t || o)
                for (var n = 0; n < s; n++) this.emitParticle();
            else this.on = !0, this._quantity = s, this._counter = 0, this._timer = this.game.time.time + i * this.game.time.slowMotion;
            return this
        }, i.Particles.Arcade.Emitter.prototype.emitParticle = function(t, e, i, s) {
            void 0 === t && (t = null), void 0 === e && (e = null);
            var o = this.getFirstExists(!1);
            if (null === o) return !1;
            var n = this.game.rnd;
            void 0 !== i && void 0 !== s ? o.loadTexture(i, s) : void 0 !== i && o.loadTexture(i);
            var a = this.emitX,
                r = this.emitY;
            null !== t ? a = t : this.width > 1 && (a = n.between(this.left, this.right)), null !== e ? r = e : this.height > 1 && (r = n.between(this.top, this.bottom)), o.reset(a, r), o.angle = 0, o.lifespan = this.lifespan, this.particleBringToTop ? this.bringToTop(o) : this.particleSendToBack && this.sendToBack(o), this.autoScale ? o.setScaleData(this.scaleData) : 1 !== this.minParticleScale || 1 !== this.maxParticleScale ? o.scale.set(n.realInRange(this.minParticleScale, this.maxParticleScale)) : this._minParticleScale.x === this._maxParticleScale.x && this._minParticleScale.y === this._maxParticleScale.y || o.scale.set(n.realInRange(this._minParticleScale.x, this._maxParticleScale.x), n.realInRange(this._minParticleScale.y, this._maxParticleScale.y)), void 0 === s && (Array.isArray(this._frames) ? o.frame = this.game.rnd.pick(this._frames) : o.frame = this._frames), this.autoAlpha ? o.setAlphaData(this.alphaData) : o.alpha = n.realInRange(this.minParticleAlpha, this.maxParticleAlpha), o.blendMode = this.blendMode;
            var h = o.body;
            return h.updateBounds(), h.bounce.copyFrom(this.bounce), h.drag.copyFrom(this.particleDrag), h.velocity.x = n.between(this.minParticleSpeed.x, this.maxParticleSpeed.x), h.velocity.y = n.between(this.minParticleSpeed.y, this.maxParticleSpeed.y), h.angularVelocity = n.between(this.minRotation, this.maxRotation), h.gravity.y = this.gravity, h.angularDrag = this.angularDrag, o.onEmit(), !0
        }, i.Particles.Arcade.Emitter.prototype.destroy = function() {
            this.game.particles.remove(this), i.Group.prototype.destroy.call(this, !0, !1)
        }, i.Particles.Arcade.Emitter.prototype.setSize = function(t, e) {
            return this.area.width = t, this.area.height = e, this
        }, i.Particles.Arcade.Emitter.prototype.setXSpeed = function(t, e) {
            return t = t || 0, e = e || 0, this.minParticleSpeed.x = t, this.maxParticleSpeed.x = e, this
        }, i.Particles.Arcade.Emitter.prototype.setYSpeed = function(t, e) {
            return t = t || 0, e = e || 0, this.minParticleSpeed.y = t, this.maxParticleSpeed.y = e, this
        }, i.Particles.Arcade.Emitter.prototype.setRotation = function(t, e) {
            return t = t || 0, e = e || 0, this.minRotation = t, this.maxRotation = e, this
        }, i.Particles.Arcade.Emitter.prototype.setAlpha = function(t, e, s, o, n) {
            if (void 0 === t && (t = 1), void 0 === e && (e = 1), void 0 === s && (s = 0), void 0 === o && (o = i.Easing.Linear.None), void 0 === n && (n = !1), this.minParticleAlpha = t, this.maxParticleAlpha = e, this.autoAlpha = !1, s > 0 && t !== e) {
                var a = {
                        v: t
                    },
                    r = this.game.make.tween(a).to({
                        v: e
                    }, s, o);
                r.yoyo(n), this.alphaData = r.generateData(60), this.alphaData.reverse(), this.autoAlpha = !0
            }
            return this
        }, i.Particles.Arcade.Emitter.prototype.setScale = function(t, e, s, o, n, a, r) {
            if (void 0 === t && (t = 1), void 0 === e && (e = 1), void 0 === s && (s = 1), void 0 === o && (o = 1), void 0 === n && (n = 0), void 0 === a && (a = i.Easing.Linear.None), void 0 === r && (r = !1), this.minParticleScale = 1, this.maxParticleScale = 1, this._minParticleScale.set(t, s), this._maxParticleScale.set(e, o), this.autoScale = !1, n > 0 && (t !== e || s !== o)) {
                var h = {
                        x: t,
                        y: s
                    },
                    l = this.game.make.tween(h).to({
                        x: e,
                        y: o
                    }, n, a);
                l.yoyo(r), this.scaleData = l.generateData(60), this.scaleData.reverse(), this.autoScale = !0
            }
            return this
        }, i.Particles.Arcade.Emitter.prototype.at = function(t) {
            return t.center ? (this.emitX = t.center.x, this.emitY = t.center.y) : (this.emitX = t.world.x + t.anchor.x * t.width, this.emitY = t.world.y + t.anchor.y * t.height), this
        }, Object.defineProperty(i.Particles.Arcade.Emitter.prototype, "width", {
            get: function() {
                return this.area.width
            },
            set: function(t) {
                this.area.width = t
            }
        }), Object.defineProperty(i.Particles.Arcade.Emitter.prototype, "height", {
            get: function() {
                return this.area.height
            },
            set: function(t) {
                this.area.height = t
            }
        }), Object.defineProperty(i.Particles.Arcade.Emitter.prototype, "x", {
            get: function() {
                return this.emitX
            },
            set: function(t) {
                this.emitX = t
            }
        }), Object.defineProperty(i.Particles.Arcade.Emitter.prototype, "y", {
            get: function() {
                return this.emitY
            },
            set: function(t) {
                this.emitY = t
            }
        }), Object.defineProperty(i.Particles.Arcade.Emitter.prototype, "left", {
            get: function() {
                return Math.floor(this.x - this.area.width / 2)
            }
        }), Object.defineProperty(i.Particles.Arcade.Emitter.prototype, "right", {
            get: function() {
                return Math.floor(this.x + this.area.width / 2)
            }
        }), Object.defineProperty(i.Particles.Arcade.Emitter.prototype, "top", {
            get: function() {
                return Math.floor(this.y - this.area.height / 2)
            }
        }), Object.defineProperty(i.Particles.Arcade.Emitter.prototype, "bottom", {
            get: function() {
                return Math.floor(this.y + this.area.height / 2)
            }
        }), i.Weapon = function(t, e) {
            i.Plugin.call(this, t, e), this.bullets = null, this.autoExpandBulletsGroup = !1, this.autofire = !1, this.shots = 0, this.fireLimit = 0, this.fireRate = 100, this.fireRateVariance = 0, this.fireFrom = new i.Rectangle(0, 0, 1, 1), this.fireAngle = i.ANGLE_UP, this.bulletInheritSpriteSpeed = !1, this.bulletAnimation = "", this.bulletFrameRandom = !1, this.bulletFrameCycle = !1, this.bulletWorldWrap = !1, this.bulletWorldWrapPadding = 0, this.bulletAngleOffset = 0, this.bulletAngleVariance = 0, this.bulletSpeed = 200, this.bulletSpeedVariance = 0, this.bulletLifespan = 0, this.bulletKillDistance = 0, this.bulletGravity = new i.Point(0, 0), this.bulletRotateToVelocity = !1, this.bulletKey = "", this.bulletFrame = "", this._bulletClass = i.Bullet, this._bulletCollideWorldBounds = !1, this._bulletKillType = i.Weapon.KILL_WORLD_BOUNDS, this._data = {
                customBody: !1,
                width: 0,
                height: 0,
                offsetX: 0,
                offsetY: 0
            }, this.bounds = new i.Rectangle, this.bulletBounds = t.world.bounds, this.bulletFrames = [], this.bulletFrameIndex = 0, this.anims = {}, this.onFire = new i.Signal, this.onKill = new i.Signal, this.onFireLimit = new i.Signal, this.trackedSprite = null, this.trackedPointer = null, this.trackRotation = !1, this.trackOffset = new i.Point, this._nextFire = 0, this._rotatedPoint = new i.Point
        }, i.Weapon.prototype = Object.create(i.Plugin.prototype), i.Weapon.prototype.constructor = i.Weapon, i.Weapon.KILL_NEVER = 0, i.Weapon.KILL_LIFESPAN = 1, i.Weapon.KILL_DISTANCE = 2, i.Weapon.KILL_WEAPON_BOUNDS = 3, i.Weapon.KILL_CAMERA_BOUNDS = 4, i.Weapon.KILL_WORLD_BOUNDS = 5, i.Weapon.KILL_STATIC_BOUNDS = 6, i.Weapon.prototype.createBullets = function(t, e, s, o) {
            return void 0 === t && (t = 1), void 0 === o && (o = this.game.world), this.bullets || (this.bullets = this.game.add.physicsGroup(i.Physics.ARCADE, o), this.bullets.classType = this._bulletClass), 0 !== t && (-1 === t && (this.autoExpandBulletsGroup = !0, t = 1), this.bullets.createMultiple(t, e, s), this.bullets.setAll("data.bulletManager", this), this.bulletKey = e, this.bulletFrame = s), this
        }, i.Weapon.prototype.forEach = function(t, e) {
            return this.bullets.forEachExists(t, e, arguments), this
        }, i.Weapon.prototype.pauseAll = function() {
            return this.bullets.setAll("body.enable", !1), this
        }, i.Weapon.prototype.resumeAll = function() {
            return this.bullets.setAll("body.enable", !0), this
        }, i.Weapon.prototype.killAll = function() {
            return this.bullets.callAllExists("kill", !0), this.bullets.setAll("body.enable", !0), this
        }, i.Weapon.prototype.resetShots = function(t) {
            return this.shots = 0, void 0 !== t && (this.fireLimit = t), this
        }, i.Weapon.prototype.destroy = function() {
            this.parent.remove(this, !1), this.bullets.destroy(), this.game = null, this.parent = null, this.active = !1, this.visible = !1
        }, i.Weapon.prototype.update = function() {
            this._bulletKillType === i.Weapon.KILL_WEAPON_BOUNDS && (this.trackedSprite ? (this.trackedSprite.updateTransform(), this.bounds.centerOn(this.trackedSprite.worldPosition.x, this.trackedSprite.worldPosition.y)) : this.trackedPointer && this.bounds.centerOn(this.trackedPointer.worldX, this.trackedPointer.worldY)), this.autofire && this.fire()
        }, i.Weapon.prototype.trackSprite = function(t, e, i, s) {
            return void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = !1), this.trackedPointer = null, this.trackedSprite = t, this.trackRotation = s, this.trackOffset.set(e, i), this
        }, i.Weapon.prototype.trackPointer = function(t, e, i) {
            return void 0 === t && (t = this.game.input.activePointer), void 0 === e && (e = 0), void 0 === i && (i = 0), this.trackedPointer = t, this.trackedSprite = null, this.trackRotation = !1, this.trackOffset.set(e, i), this
        }, i.Weapon.prototype.fire = function(t, e, s) {
            if (this.game.time.now < this._nextFire || this.fireLimit > 0 && this.shots === this.fireLimit) return !1;
            var o = this.bulletSpeed;
            0 !== this.bulletSpeedVariance && (o += i.Math.between(-this.bulletSpeedVariance, this.bulletSpeedVariance)), t ? this.fireFrom.width > 1 ? this.fireFrom.centerOn(t.x, t.y) : (this.fireFrom.x = t.x, this.fireFrom.y = t.y) : this.trackedSprite ? (this.trackRotation ? (this._rotatedPoint.set(this.trackedSprite.world.x + this.trackOffset.x, this.trackedSprite.world.y + this.trackOffset.y), this._rotatedPoint.rotate(this.trackedSprite.world.x, this.trackedSprite.world.y, this.trackedSprite.rotation), this.fireFrom.width > 1 ? this.fireFrom.centerOn(this._rotatedPoint.x, this._rotatedPoint.y) : (this.fireFrom.x = this._rotatedPoint.x, this.fireFrom.y = this._rotatedPoint.y)) : this.fireFrom.width > 1 ? this.fireFrom.centerOn(this.trackedSprite.world.x + this.trackOffset.x, this.trackedSprite.world.y + this.trackOffset.y) : (this.fireFrom.x = this.trackedSprite.world.x + this.trackOffset.x, this.fireFrom.y = this.trackedSprite.world.y + this.trackOffset.y), this.bulletInheritSpriteSpeed && (o += this.trackedSprite.body.speed)) : this.trackedPointer && (this.fireFrom.width > 1 ? this.fireFrom.centerOn(this.trackedPointer.world.x + this.trackOffset.x, this.trackedPointer.world.y + this.trackOffset.y) : (this.fireFrom.x = this.trackedPointer.world.x + this.trackOffset.x, this.fireFrom.y = this.trackedPointer.world.y + this.trackOffset.y));
            var n = this.fireFrom.width > 1 ? this.fireFrom.randomX : this.fireFrom.x,
                a = this.fireFrom.height > 1 ? this.fireFrom.randomY : this.fireFrom.y,
                r = this.trackRotation ? this.trackedSprite.angle : this.fireAngle;
            void 0 !== e && void 0 !== s && (r = this.game.math.radToDeg(Math.atan2(s - a, e - n))), 0 !== this.bulletAngleVariance && (r += i.Math.between(-this.bulletAngleVariance, this.bulletAngleVariance));
            var h = 0,
                l = 0;
            0 === r || 180 === r ? h = Math.cos(this.game.math.degToRad(r)) * o : 90 === r || 270 === r ? l = Math.sin(this.game.math.degToRad(r)) * o : (h = Math.cos(this.game.math.degToRad(r)) * o, l = Math.sin(this.game.math.degToRad(r)) * o);
            var c = null;
            if (this.autoExpandBulletsGroup ? (c = this.bullets.getFirstExists(!1, !0, n, a, this.bulletKey, this.bulletFrame), c.data.bulletManager = this) : c = this.bullets.getFirstExists(!1), c) {
                if (c.reset(n, a), c.data.fromX = n, c.data.fromY = a, c.data.killType = this.bulletKillType, c.data.killDistance = this.bulletKillDistance, c.data.rotateToVelocity = this.bulletRotateToVelocity, this.bulletKillType === i.Weapon.KILL_LIFESPAN && (c.lifespan = this.bulletLifespan), c.angle = r + this.bulletAngleOffset, "" !== this.bulletAnimation) {
                    if (null === c.animations.getAnimation(this.bulletAnimation)) {
                        var p = this.anims[this.bulletAnimation];
                        c.animations.add(p.name, p.frames, p.frameRate, p.loop, p.useNumericIndex)
                    }
                    c.animations.play(this.bulletAnimation)
                } else this.bulletFrameCycle ? (c.frame = this.bulletFrames[this.bulletFrameIndex], ++this.bulletFrameIndex >= this.bulletFrames.length && (this.bulletFrameIndex = 0)) : this.bulletFrameRandom && (c.frame = this.bulletFrames[Math.floor(Math.random() * this.bulletFrames.length)]);
                if (c.data.bodyDirty && (this._data.customBody && c.body.setSize(this._data.width, this._data.height, this._data.offsetX, this._data.offsetY), c.body.collideWorldBounds = this.bulletCollideWorldBounds, c.data.bodyDirty = !1), c.body.velocity.set(h, l), c.body.gravity.set(this.bulletGravity.x, this.bulletGravity.y), 0 !== this.bulletSpeedVariance) {
                    var u = this.fireRate;
                    (u += i.Math.between(-this.fireRateVariance, this.fireRateVariance)) < 0 && (u = 0), this._nextFire = this.game.time.now + u
                } else this._nextFire = this.game.time.now + this.fireRate;
                this.shots++, this.onFire.dispatch(c, this, o), this.fireLimit > 0 && this.shots === this.fireLimit && this.onFireLimit.dispatch(this, this.fireLimit)
            }
            return c
        }, i.Weapon.prototype.fireAtPointer = function(t) {
            return void 0 === t && (t = this.game.input.activePointer), this.fire(null, t.worldX, t.worldY)
        }, i.Weapon.prototype.fireAtSprite = function(t) {
            return this.fire(null, t.world.x, t.world.y)
        }, i.Weapon.prototype.fireAtXY = function(t, e) {
            return this.fire(null, t, e)
        }, i.Weapon.prototype.setBulletBodyOffset = function(t, e, i, s) {
            return void 0 === i && (i = 0), void 0 === s && (s = 0), this._data.customBody = !0, this._data.width = t, this._data.height = e, this._data.offsetX = i, this._data.offsetY = s, this.bullets.callAll("body.setSize", "body", t, e, i, s), this.bullets.setAll("data.bodyDirty", !1), this
        }, i.Weapon.prototype.setBulletFrames = function(t, e, s, o) {
            return void 0 === s && (s = !0), void 0 === o && (o = !1), this.bulletFrames = i.ArrayUtils.numberArray(t, e), this.bulletFrameIndex = 0, this.bulletFrameCycle = s, this.bulletFrameRandom = o, this
        }, i.Weapon.prototype.addBulletAnimation = function(t, e, i, s, o) {
            return this.anims[t] = {
                name: t,
                frames: e,
                frameRate: i,
                loop: s,
                useNumericIndex: o
            }, this.bullets.callAll("animations.add", "animations", t, e, i, s, o), this.bulletAnimation = t, this
        }, i.Weapon.prototype.debug = function(t, e, i) {
            void 0 === t && (t = 16), void 0 === e && (e = 32), void 0 === i && (i = !1), this.game.debug.text("Weapon Plugin", t, e), this.game.debug.text("Bullets Alive: " + this.bullets.total + " - Total: " + this.bullets.length, t, e + 24), i && this.bullets.forEachExists(this.game.debug.body, this.game.debug, "rgba(255, 0, 255, 0.8)")
        }, Object.defineProperty(i.Weapon.prototype, "bulletClass", {
            get: function() {
                return this._bulletClass
            },
            set: function(t) {
                this._bulletClass = t, this.bullets.classType = this._bulletClass
            }
        }), Object.defineProperty(i.Weapon.prototype, "bulletKillType", {
            get: function() {
                return this._bulletKillType
            },
            set: function(t) {
                switch (t) {
                    case i.Weapon.KILL_STATIC_BOUNDS:
                    case i.Weapon.KILL_WEAPON_BOUNDS:
                        this.bulletBounds = this.bounds;
                        break;
                    case i.Weapon.KILL_CAMERA_BOUNDS:
                        this.bulletBounds = this.game.camera.view;
                        break;
                    case i.Weapon.KILL_WORLD_BOUNDS:
                        this.bulletBounds = this.game.world.bounds
                }
                this._bulletKillType = t
            }
        }), Object.defineProperty(i.Weapon.prototype, "bulletCollideWorldBounds", {
            get: function() {
                return this._bulletCollideWorldBounds
            },
            set: function(t) {
                this._bulletCollideWorldBounds = t, this.bullets.setAll("body.collideWorldBounds", t), this.bullets.setAll("data.bodyDirty", !1)
            }
        }), Object.defineProperty(i.Weapon.prototype, "x", {
            get: function() {
                return this.fireFrom.x
            },
            set: function(t) {
                this.fireFrom.x = t
            }
        }), Object.defineProperty(i.Weapon.prototype, "y", {
            get: function() {
                return this.fireFrom.y
            },
            set: function(t) {
                this.fireFrom.y = t
            }
        }), i.Bullet = function(t, e, s, o, n) {
            i.Sprite.call(this, t, e, s, o, n), this.anchor.set(.5), this.data = {
                bulletManager: null,
                fromX: 0,
                fromY: 0,
                bodyDirty: !0,
                rotateToVelocity: !1,
                killType: 0,
                killDistance: 0
            }
        }, i.Bullet.prototype = Object.create(i.Sprite.prototype), i.Bullet.prototype.constructor = i.Bullet, i.Bullet.prototype.kill = function() {
            return this.alive = !1, this.exists = !1, this.visible = !1, this.data.bulletManager.onKill.dispatch(this), this
        }, i.Bullet.prototype.update = function() {
            this.exists && (this.data.killType > i.Weapon.KILL_LIFESPAN && (this.data.killType === i.Weapon.KILL_DISTANCE ? this.game.physics.arcade.distanceToXY(this, this.data.fromX, this.data.fromY, !0) > this.data.killDistance && this.kill() : this.data.bulletManager.bulletBounds.intersects(this) || this.kill()), this.data.rotateToVelocity && (this.rotation = Math.atan2(this.body.velocity.y, this.body.velocity.x)), this.data.bulletManager.bulletWorldWrap && this.game.world.wrap(this, this.data.bulletManager.bulletWorldWrapPadding))
        }, i.Video = function(t, e, s) {
            if (void 0 === e && (e = null), void 0 === s && (s = null), this.game = t, this.key = e, this.width = 0, this.height = 0, this.type = i.VIDEO, this.disableTextureUpload = !1, this.touchLocked = !1, this.onPlay = new i.Signal, this.onChangeSource = new i.Signal, this.onComplete = new i.Signal, this.onAccess = new i.Signal, this.onError = new i.Signal, this.onTimeout = new i.Signal, this.timeout = 15e3, this._timeOutID = null, this.video = null, this.videoStream = null, this.isStreaming = !1, this.retryLimit = 20, this.retry = 0, this.retryInterval = 500, this._retryID = null, this._codeMuted = !1, this._muted = !1, this._codePaused = !1, this._paused = !1, this._pending = !1, this._autoplay = !1, this._endCallback = null, this._playCallback = null, e && this.game.cache.checkVideoKey(e)) {
                var o = this.game.cache.getVideo(e);
                o.isBlob ? this.createVideoFromBlob(o.data) : this.video = o.data, this.width = this.video.videoWidth, this.height = this.video.videoHeight
            } else s && this.createVideoFromURL(s, !1);
            this.video && !s ? (this.baseTexture = new PIXI.BaseTexture(this.video), this.baseTexture.forceLoaded(this.width, this.height)) : (this.baseTexture = new PIXI.BaseTexture(i.Cache.DEFAULT.baseTexture.source), this.baseTexture.forceLoaded(this.width, this.height)), this.texture = new PIXI.Texture(this.baseTexture), this.textureFrame = new i.Frame(0, 0, 0, this.width, this.height, "video"), this.texture.setFrame(this.textureFrame), this.texture.valid = !1, null !== e && this.video && (this.texture.valid = this.video.canplay), this.snapshot = null, i.BitmapData && (this.snapshot = new i.BitmapData(this.game, "", this.width, this.height)), !this.game.device.cocoonJS && (this.game.device.iOS || this.game.device.android) || window.PhaserGlobal && window.PhaserGlobal.fakeiOSTouchLock ? this.setTouchLock() : o && (o.locked = !1)
        }, i.Video.prototype = {
            connectToMediaStream: function(t, e) {
                return t && e && (this.video = t, this.videoStream = e, this.isStreaming = !0, this.baseTexture.source = this.video, this.updateTexture(null, this.video.videoWidth, this.video.videoHeight), this.onAccess.dispatch(this)), this
            },
            startMediaStream: function(t, e, i) {
                if (void 0 === t && (t = !1), void 0 === e && (e = null), void 0 === i && (i = null), !this.game.device.getUserMedia) return this.onError.dispatch(this, "No getUserMedia"), !1;
                null !== this.videoStream && (this.videoStream.active ? this.videoStream.active = !1 : this.videoStream.stop()), this.removeVideoElement(), this.video = document.createElement("video"), this.video.setAttribute("autoplay", "autoplay"), null !== e && (this.video.width = e), null !== i && (this.video.height = i), this._timeOutID = window.setTimeout(this.getUserMediaTimeout.bind(this), this.timeout);
                try {
                    navigator.getUserMedia({
                        audio: t,
                        video: !0
                    }, this.getUserMediaSuccess.bind(this), this.getUserMediaError.bind(this))
                } catch (t) {
                    this.getUserMediaError(t)
                }
                return this
            },
            getUserMediaTimeout: function() {
                clearTimeout(this._timeOutID), this.onTimeout.dispatch(this)
            },
            getUserMediaError: function(t) {
                clearTimeout(this._timeOutID), this.onError.dispatch(this, t)
            },
            getUserMediaSuccess: function(t) {
                clearTimeout(this._timeOutID), this.videoStream = t, void 0 !== this.video.mozSrcObject ? this.video.mozSrcObject = t : this.video.src = window.URL && window.URL.createObjectURL(t) || t;
                var e = this;
                this.video.onloadeddata = function() {
                    function t() {
                        if (i > 0)
                            if (e.video.videoWidth > 0) {
                                var s = e.video.videoWidth,
                                    o = e.video.videoHeight;
                                isNaN(e.video.videoHeight) && (o = s / (4 / 3)), e.video.play(), e.isStreaming = !0, e.baseTexture.source = e.video, e.updateTexture(null, s, o), e.onAccess.dispatch(e)
                            } else window.setTimeout(t, 500);
                        else console.warn("Unable to connect to video stream. Webcam error?");
                        i--
                    }
                    var i = 10;
                    t()
                }
            },
            createVideoFromBlob: function(t) {
                var e = this;
                return this.video = document.createElement("video"), this.video.controls = !1, this.video.setAttribute("autoplay", "autoplay"), this.video.addEventListener("loadeddata", function(t) {
                    e.updateTexture(t)
                }, !0), this.video.src = window.URL.createObjectURL(t), this.video.canplay = !0, this
            },
            createVideoFromURL: function(t, e) {
                return void 0 === e && (e = !1), this.texture && (this.texture.valid = !1), this.video = document.createElement("video"), this.video.controls = !1, e && this.video.setAttribute("autoplay", "autoplay"), this.video.src = t, this.video.canplay = !0, this.video.load(), this.retry = this.retryLimit, this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval), this.key = t, this
            },
            updateTexture: function(t, e, i) {
                var s = !1;
                void 0 !== e && null !== e || (e = this.video.videoWidth, s = !0), void 0 !== i && null !== i || (i = this.video.videoHeight), this.width = e, this.height = i, this.baseTexture.source !== this.video && (this.baseTexture.source = this.video), this.baseTexture.forceLoaded(e, i), this.texture.frame.resize(e, i), this.texture.width = e, this.texture.height = i, this.texture.valid = !0, this.snapshot && this.snapshot.resize(e, i), s && null !== this.key && (this.onChangeSource.dispatch(this, e, i), this._autoplay && (this.video.play(), this.onPlay.dispatch(this, this.loop, this.playbackRate)))
            },
            complete: function() {
                this.onComplete.dispatch(this)
            },
            play: function(t, e) {
                return void 0 === t && (t = !1), void 0 === e && (e = 1), this.game.sound.onMute && (this.game.sound.onMute.add(this.setMute, this), this.game.sound.onUnMute.add(this.unsetMute, this), this.game.sound.mute && this.setMute()), this.game.onPause.add(this.setPause, this), this.game.onResume.add(this.setResume, this), this._endCallback = this.complete.bind(this), this.video.addEventListener("ended", this._endCallback, !0), this.video.addEventListener("webkitendfullscreen", this._endCallback, !0), this.video.loop = t ? "loop" : "", this.video.playbackRate = e, this.touchLocked ? this._pending = !0 : (this._pending = !1, null !== this.key && (4 !== this.video.readyState ? (this.retry = this.retryLimit, this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval)) : (this._playCallback = this.playHandler.bind(this), this.video.addEventListener("playing", this._playCallback, !0))), this.video.play(), this.onPlay.dispatch(this, t, e)), this
            },
            playHandler: function() {
                this.video.removeEventListener("playing", this._playCallback, !0), this.updateTexture()
            },
            stop: function() {
                return this.game.sound.onMute && (this.game.sound.onMute.remove(this.setMute, this), this.game.sound.onUnMute.remove(this.unsetMute, this)), this.game.onPause.remove(this.setPause, this), this.game.onResume.remove(this.setResume, this), this.isStreaming ? (this.video.mozSrcObject ? (this.video.mozSrcObject.stop(), this.video.src = null) : (this.video.src = "", this.videoStream.active ? this.videoStream.active = !1 : this.videoStream.getTracks ? this.videoStream.getTracks().forEach(function(t) {
                    t.stop()
                }) : this.videoStream.stop()), this.videoStream = null, this.isStreaming = !1) : (this.video.removeEventListener("ended", this._endCallback, !0), this.video.removeEventListener("webkitendfullscreen", this._endCallback, !0), this.video.removeEventListener("playing", this._playCallback, !0), this.touchLocked ? this._pending = !1 : this.video.pause()), this
            },
            add: function(t) {
                if (Array.isArray(t))
                    for (var e = 0; e < t.length; e++) t[e].loadTexture && t[e].loadTexture(this);
                else t.loadTexture(this);
                return this
            },
            addToWorld: function(t, e, i, s, o, n) {
                o = o || 1, n = n || 1;
                var a = this.game.add.image(t, e, this);
                return a.anchor.set(i, s), a.scale.set(o, n), a
            },
            render: function() {
                !this.disableTextureUpload && this.playing && this.baseTexture.dirty()
            },
            setMute: function() {
                this._muted || (this._muted = !0, this.video.muted = !0)
            },
            unsetMute: function() {
                this._muted && !this._codeMuted && (this._muted = !1, this.video.muted = !1)
            },
            setPause: function() {
                this._paused || this.touchLocked || (this._paused = !0, this.video.pause())
            },
            setResume: function() {
                !this._paused || this._codePaused || this.touchLocked || (this._paused = !1, this.video.ended || this.video.play())
            },
            changeSource: function(t, e) {
                return void 0 === e && (e = !0), this.texture.valid = !1, this.video.pause(), this.retry = this.retryLimit, this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval), this.video.src = t, this.video.load(), this._autoplay = e, e || (this.paused = !0), this
            },
            checkVideoProgress: function() {
                4 === this.video.readyState ? this.updateTexture() : --this.retry > 0 ? this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval) : console.warn("Phaser.Video: Unable to start downloading video in time", this.isStreaming)
            },
            setTouchLock: function() {
                this.game.input.touch.addTouchLockCallback(this.unlock, this), this.touchLocked = !0
            },
            unlock: function() {
                if (this.touchLocked = !1, this.video.play(), this.onPlay.dispatch(this, this.loop, this.playbackRate), this.key) {
                    var t = this.game.cache.getVideo(this.key);
                    t && !t.isBlob && (t.locked = !1)
                }
                return !0
            },
            grab: function(t, e, i) {
                return void 0 === t && (t = !1), void 0 === e && (e = 1), void 0 === i && (i = null), null === this.snapshot ? void console.warn("Video.grab cannot run because Phaser.BitmapData is unavailable") : (t && this.snapshot.cls(), this.snapshot.copy(this.video, 0, 0, this.width, this.height, 0, 0, this.width, this.height, 0, 0, 0, 1, 1, e, i), this.snapshot)
            },
            removeVideoElement: function() {
                if (this.video) {
                    for (this.video.parentNode && this.video.parentNode.removeChild(this.video); this.video.hasChildNodes();) this.video.removeChild(this.video.firstChild);
                    this.video.removeAttribute("autoplay"), this.video.removeAttribute("src"), this.video = null
                }
            },
            destroy: function() {
                this.stop(), this.removeVideoElement(), this.touchLocked && this.game.input.touch.removeTouchLockCallback(this.unlock, this), this._retryID && window.clearTimeout(this._retryID)
            }
        }, Object.defineProperty(i.Video.prototype, "currentTime", {
            get: function() {
                return this.video ? this.video.currentTime : 0
            },
            set: function(t) {
                this.video.currentTime = t
            }
        }), Object.defineProperty(i.Video.prototype, "duration", {
            get: function() {
                return this.video ? this.video.duration : 0
            }
        }), Object.defineProperty(i.Video.prototype, "progress", {
            get: function() {
                return this.video ? this.video.currentTime / this.video.duration : 0
            }
        }), Object.defineProperty(i.Video.prototype, "mute", {
            get: function() {
                return this._muted
            },
            set: function(t) {
                if (t = t || null) {
                    if (this._muted) return;
                    this._codeMuted = !0, this.setMute()
                } else {
                    if (!this._muted) return;
                    this._codeMuted = !1, this.unsetMute()
                }
            }
        }), Object.defineProperty(i.Video.prototype, "paused", {
            get: function() {
                return this._paused
            },
            set: function(t) {
                if (t = t || null, !this.touchLocked)
                    if (t) {
                        if (this._paused) return;
                        this._codePaused = !0, this.setPause()
                    } else {
                        if (!this._paused) return;
                        this._codePaused = !1, this.setResume()
                    }
            }
        }), Object.defineProperty(i.Video.prototype, "volume", {
            get: function() {
                return this.video ? this.video.volume : 1
            },
            set: function(t) {
                t < 0 ? t = 0 : t > 1 && (t = 1), this.video && (this.video.volume = t)
            }
        }), Object.defineProperty(i.Video.prototype, "playbackRate", {
            get: function() {
                return this.video ? this.video.playbackRate : 1
            },
            set: function(t) {
                this.video && (this.video.playbackRate = t)
            }
        }), Object.defineProperty(i.Video.prototype, "loop", {
            get: function() {
                return !!this.video && this.video.loop
            },
            set: function(t) {
                t && this.video ? this.video.loop = "loop" : this.video && (this.video.loop = "")
            }
        }), Object.defineProperty(i.Video.prototype, "playing", {
            get: function() {
                return !(this.video.paused && this.video.ended)
            }
        }), i.Video.prototype.constructor = i.Video, void 0 === PIXI.blendModes && (PIXI.blendModes = i.blendModes), void 0 === PIXI.scaleModes && (PIXI.scaleModes = i.scaleModes), void 0 === PIXI.Texture.emptyTexture && (PIXI.Texture.emptyTexture = new PIXI.Texture(new PIXI.BaseTexture)), void 0 === PIXI.DisplayObject._tempMatrix && (PIXI.DisplayObject._tempMatrix = new PIXI.Matrix), void 0 === PIXI.RenderTexture.tempMatrix && (PIXI.RenderTexture.tempMatrix = new PIXI.Matrix), PIXI.Graphics && void 0 === PIXI.Graphics.POLY && (PIXI.Graphics.POLY = i.POLYGON, PIXI.Graphics.RECT = i.RECTANGLE, PIXI.Graphics.CIRC = i.CIRCLE, PIXI.Graphics.ELIP = i.ELLIPSE, PIXI.Graphics.RREC = i.ROUNDEDRECTANGLE), PIXI.TextureSilentFail = !0, "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = i), exports.Phaser = i) : "undefined" != typeof define && define.amd ? define("Phaser", e.Phaser = i) : e.Phaser = i, i
    }.call(this),
    function() {
        function t(t, e, i) {
            return t.call.apply(t.bind, arguments)
        }

        function e(t, e, i) {
            if (!t) throw Error();
            if (2 < arguments.length) {
                var s = Array.prototype.slice.call(arguments, 2);
                return function() {
                    var i = Array.prototype.slice.call(arguments);
                    return Array.prototype.unshift.apply(i, s), t.apply(e, i)
                }
            }
            return function() {
                return t.apply(e, arguments)
            }
        }

        function i(s, o, n) {
            return (i = Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? t : e).apply(null, arguments)
        }

        function s(t, e) {
            this.a = t, this.o = e || t, this.c = this.o.document
        }

        function o(t, e, i, s) {
            if (e = t.c.createElement(e), i)
                for (var o in i) i.hasOwnProperty(o) && ("style" == o ? e.style.cssText = i[o] : e.setAttribute(o, i[o]));
            return s && e.appendChild(t.c.createTextNode(s)), e
        }

        function n(t, e, i) {
            (t = t.c.getElementsByTagName(e)[0]) || (t = document.documentElement), t.insertBefore(i, t.lastChild)
        }

        function a(t) {
            t.parentNode && t.parentNode.removeChild(t)
        }

        function r(t, e, i) {
            e = e || [], i = i || [];
            for (var s = t.className.split(/\s+/), o = 0; o < e.length; o += 1) {
                for (var n = !1, a = 0; a < s.length; a += 1)
                    if (e[o] === s[a]) {
                        n = !0;
                        break
                    }
                n || s.push(e[o])
            }
            for (e = [], o = 0; o < s.length; o += 1) {
                for (n = !1, a = 0; a < i.length; a += 1)
                    if (s[o] === i[a]) {
                        n = !0;
                        break
                    }
                n || e.push(s[o])
            }
            t.className = e.join(" ").replace(/\s+/g, " ").replace(/^\s+|\s+$/, "")
        }

        function h(t, e) {
            for (var i = t.className.split(/\s+/), s = 0, o = i.length; s < o; s++)
                if (i[s] == e) return !0;
            return !1
        }

        function l(t) {
            return t.o.location.hostname || t.a.location.hostname
        }

        function c(t, e, i) {
            function s() {
                l && a && r && (l(h), l = null)
            }
            e = o(t, "link", {
                rel: "stylesheet",
                href: e,
                media: "all"
            });
            var a = !1,
                r = !0,
                h = null,
                l = i || null;
            et ? (e.onload = function() {
                a = !0, s()
            }, e.onerror = function() {
                a = !0, h = Error("Stylesheet failed to load"), s()
            }) : setTimeout(function() {
                a = !0, s()
            }, 0), n(t, "head", e)
        }

        function p(t, e, i, s) {
            var n = t.c.getElementsByTagName("head")[0];
            if (n) {
                var a = o(t, "script", {
                        src: e
                    }),
                    r = !1;
                return a.onload = a.onreadystatechange = function() {
                    r || this.readyState && "loaded" != this.readyState && "complete" != this.readyState || (r = !0, i && i(null), a.onload = a.onreadystatechange = null, "HEAD" == a.parentNode.tagName && n.removeChild(a))
                }, n.appendChild(a), setTimeout(function() {
                    r || (r = !0, i && i(Error("Script load timeout")))
                }, s || 5e3), a
            }
            return null
        }

        function u() {
            this.a = 0, this.c = null
        }

        function d(t) {
            return t.a++,
                function() {
                    t.a--, y(t)
                }
        }

        function m(t, e) {
            t.c = e, y(t)
        }

        function y(t) {
            0 == t.a && t.c && (t.c(), t.c = null)
        }

        function f(t) {
            this.a = t || "-"
        }

        function g(t, e) {
            this.c = t, this.f = 4, this.a = "n";
            var i = (e || "n4").match(/^([nio])([1-9])$/i);
            i && (this.a = i[1], this.f = parseInt(i[2], 10))
        }

        function _(t) {
            return x(t) + " " + t.f + "00 300px " + v(t.c)
        }

        function v(t) {
            var e = [];
            t = t.split(/,\s*/);
            for (var i = 0; i < t.length; i++) {
                var s = t[i].replace(/['"]/g, ""); - 1 != s.indexOf(" ") || /^\d/.test(s) ? e.push("'" + s + "'") : e.push(s)
            }
            return e.join(",")
        }

        function b(t) {
            return t.a + t.f
        }

        function x(t) {
            var e = "normal";
            return "o" === t.a ? e = "oblique" : "i" === t.a && (e = "italic"), e
        }

        function C(t) {
            var e = 4,
                i = "n",
                s = null;
            return t && ((s = t.match(/(normal|oblique|italic)/i)) && s[1] && (i = s[1].substr(0, 1).toLowerCase()), (s = t.match(/([1-9]00|normal|bold)/i)) && s[1] && (/bold/i.test(s[1]) ? e = 7 : /[1-9]00/.test(s[1]) && (e = parseInt(s[1].substr(0, 1), 10)))), i + e
        }

        function S(t, e) {
            this.c = t, this.f = t.o.document.documentElement, this.h = e, this.a = new f("-"), this.j = !1 !== e.events, this.g = !1 !== e.classes
        }

        function w(t) {
            t.g && r(t.f, [t.a.c("wf", "loading")]), T(t, "loading")
        }

        function A(t) {
            if (t.g) {
                var e = h(t.f, t.a.c("wf", "active")),
                    i = [],
                    s = [t.a.c("wf", "loading")];
                e || i.push(t.a.c("wf", "inactive")), r(t.f, i, s)
            }
            T(t, "inactive")
        }

        function T(t, e, i) {
            t.j && t.h[e] && (i ? t.h[e](i.c, b(i)) : t.h[e]())
        }

        function B() {
            this.c = {}
        }

        function P(t, e, i) {
            var s, o = [];
            for (s in e)
                if (e.hasOwnProperty(s)) {
                    var n = t.c[s];
                    n && o.push(n(e[s], i))
                }
            return o
        }

        function D(t, e) {
            this.c = t, this.f = e, this.a = o(this.c, "span", {
                "aria-hidden": "true"
            }, this.f)
        }

        function I(t) {
            n(t.c, "body", t.a)
        }

        function E(t) {
            return "display:block;position:absolute;top:-9999px;left:-9999px;font-size:300px;width:auto;height:auto;line-height:normal;margin:0;padding:0;font-variant:normal;white-space:nowrap;font-family:" + v(t.c) + ";font-style:" + x(t) + ";font-weight:" + t.f + "00;"
        }

        function L(t, e, i, s, o, n) {
            this.g = t, this.j = e, this.a = s, this.c = i, this.f = o || 3e3, this.h = n || void 0
        }

        function M(t, e, i, s, o, n, a) {
            this.v = t, this.B = e, this.c = i, this.a = s, this.s = a || "BESbswy", this.f = {}, this.w = o || 3e3, this.u = n || null, this.m = this.j = this.h = this.g = null, this.g = new D(this.c, this.s), this.h = new D(this.c, this.s), this.j = new D(this.c, this.s), this.m = new D(this.c, this.s), t = E(t = new g(this.a.c + ",serif", b(this.a))), this.g.a.style.cssText = t, t = E(t = new g(this.a.c + ",sans-serif", b(this.a))), this.h.a.style.cssText = t, t = E(t = new g("serif", b(this.a))), this.j.a.style.cssText = t, t = E(t = new g("sans-serif", b(this.a))), this.m.a.style.cssText = t, I(this.g), I(this.h), I(this.j), I(this.m)
        }

        function G() {
            if (null === st) {
                var t = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent);
                st = !!t && (536 > parseInt(t[1], 10) || 536 === parseInt(t[1], 10) && 11 >= parseInt(t[2], 10))
            }
            return st
        }

        function O(t, e, i) {
            for (var s in it)
                if (it.hasOwnProperty(s) && e === t.f[it[s]] && i === t.f[it[s]]) return !0;
            return !1
        }

        function R(t) {
            var e, i = t.g.a.offsetWidth,
                s = t.h.a.offsetWidth;
            (e = i === t.f.serif && s === t.f["sans-serif"]) || (e = G() && O(t, i, s)), e ? tt() - t.A >= t.w ? G() && O(t, i, s) && (null === t.u || t.u.hasOwnProperty(t.a.c)) ? F(t, t.v) : F(t, t.B) : k(t) : F(t, t.v)
        }

        function k(t) {
            setTimeout(i(function() {
                R(this)
            }, t), 50)
        }

        function F(t, e) {
            setTimeout(i(function() {
                a(this.g.a), a(this.h.a), a(this.j.a), a(this.m.a), e(this.a)
            }, t), 0)
        }

        function N(t, e, i) {
            this.c = t, this.a = e, this.f = 0, this.m = this.j = !1, this.s = i
        }

        function V(t) {
            0 == --t.f && t.j && (t.m ? ((t = t.a).g && r(t.f, [t.a.c("wf", "active")], [t.a.c("wf", "loading"), t.a.c("wf", "inactive")]), T(t, "active")) : A(t.a))
        }

        function U(t) {
            this.j = t, this.a = new B, this.h = 0, this.f = this.g = !0
        }

        function W(t, e, s, o, n) {
            var a = 0 == --t.h;
            (t.f || t.g) && setTimeout(function() {
                var t = n || null,
                    h = o || null || {};
                if (0 === s.length && a) A(e.a);
                else {
                    e.f += s.length, a && (e.j = a);
                    var l, c = [];
                    for (l = 0; l < s.length; l++) {
                        var p = s[l],
                            u = h[p.c],
                            d = e.a,
                            m = p;
                        if (d.g && r(d.f, [d.a.c("wf", m.c, b(m).toString(), "loading")]), T(d, "fontloading", m), d = null, null === ot)
                            if (window.FontFace) {
                                var m = /Gecko.*Firefox\/(\d+)/.exec(window.navigator.userAgent),
                                    y = /OS X.*Version\/10\..*Safari/.exec(window.navigator.userAgent) && /Apple/.exec(window.navigator.vendor);
                                ot = m ? 42 < parseInt(m[1], 10) : !y
                            } else ot = !1;
                        d = ot ? new L(i(e.g, e), i(e.h, e), e.c, p, e.s, u) : new M(i(e.g, e), i(e.h, e), e.c, p, e.s, t, u), c.push(d)
                    }
                    for (l = 0; l < c.length; l++) c[l].start()
                }
            }, 0)
        }

        function j(t, e, i) {
            var s = [],
                o = i.timeout;
            w(e);
            var s = P(t.a, i, t.c),
                n = new N(t.c, e, o);
            for (t.h = s.length, e = 0, i = s.length; e < i; e++) s[e].load(function(e, i, s) {
                W(t, n, e, i, s)
            })
        }

        function X(t, e) {
            this.c = t, this.a = e
        }

        function K(t, e) {
            this.c = t, this.a = e
        }

        function H(t, e) {
            this.c = t || nt, this.a = [], this.f = [], this.g = e || ""
        }

        function q(t, e) {
            for (var i = e.length, s = 0; s < i; s++) {
                var o = e[s].split(":");
                3 == o.length && t.f.push(o.pop());
                var n = "";
                2 == o.length && "" != o[1] && (n = ":"), t.a.push(o.join(n))
            }
        }

        function J(t) {
            if (0 == t.a.length) throw Error("No fonts to load!");
            if (-1 != t.c.indexOf("kit=")) return t.c;
            for (var e = t.a.length, i = [], s = 0; s < e; s++) i.push(t.a[s].replace(/ /g, "+"));
            return e = t.c + "?family=" + i.join("%7C"), 0 < t.f.length && (e += "&subset=" + t.f.join(",")), 0 < t.g.length && (e += "&text=" + encodeURIComponent(t.g)), e
        }

        function z(t) {
            this.f = t, this.a = [], this.c = {}
        }

        function Y(t) {
            for (var e = t.f.length, i = 0; i < e; i++) {
                var s = t.f[i].split(":"),
                    o = s[0].replace(/\+/g, " "),
                    n = ["n4"];
                if (2 <= s.length) {
                    var a;
                    if (a = [], r = s[1])
                        for (var r = r.split(","), h = r.length, l = 0; l < h; l++) {
                            var c;
                            if ((c = r[l]).match(/^[\w-]+$/))
                                if (null == (u = lt.exec(c.toLowerCase()))) c = "";
                                else {
                                    if (c = u[2], c = null == c || "" == c ? "n" : ht[c], null == (u = u[1]) || "" == u) u = "4";
                                    else var p = rt[u],
                                        u = p || (isNaN(u) ? "4" : u.substr(0, 1));
                                    c = [c, u].join("")
                                }
                            else c = "";
                            c && a.push(c)
                        }
                    0 < a.length && (n = a), 3 == s.length && (s = s[2], a = [], 0 < (s = s ? s.split(",") : a).length && (s = at[s[0]]) && (t.c[o] = s))
                }
                for (t.c[o] || (s = at[o]) && (t.c[o] = s), s = 0; s < n.length; s += 1) t.a.push(new g(o, n[s]))
            }
        }

        function Z(t, e) {
            this.c = t, this.a = e
        }

        function Q(t, e) {
            this.c = t, this.a = e
        }

        function $(t, e) {
            this.c = t, this.f = e, this.a = []
        }
        var tt = Date.now || function() {
                return +new Date
            },
            et = !!window.FontFace;
        f.prototype.c = function(t) {
            for (var e = [], i = 0; i < arguments.length; i++) e.push(arguments[i].replace(/[\W_]+/g, "").toLowerCase());
            return e.join(this.a)
        }, L.prototype.start = function() {
            var t = this.c.o.document,
                e = this,
                i = tt(),
                s = new Promise(function(s, o) {
                    function n() {
                        tt() - i >= e.f ? o() : t.fonts.load(_(e.a), e.h).then(function(t) {
                            1 <= t.length ? s() : setTimeout(n, 25)
                        }, function() {
                            o()
                        })
                    }
                    n()
                }),
                o = null,
                n = new Promise(function(t, i) {
                    o = setTimeout(i, e.f)
                });
            Promise.race([n, s]).then(function() {
                o && (clearTimeout(o), o = null), e.g(e.a)
            }, function() {
                e.j(e.a)
            })
        };
        var it = {
                D: "serif",
                C: "sans-serif"
            },
            st = null;
        M.prototype.start = function() {
            this.f.serif = this.j.a.offsetWidth, this.f["sans-serif"] = this.m.a.offsetWidth, this.A = tt(), R(this)
        };
        var ot = null;
        N.prototype.g = function(t) {
            var e = this.a;
            e.g && r(e.f, [e.a.c("wf", t.c, b(t).toString(), "active")], [e.a.c("wf", t.c, b(t).toString(), "loading"), e.a.c("wf", t.c, b(t).toString(), "inactive")]), T(e, "fontactive", t), this.m = !0, V(this)
        }, N.prototype.h = function(t) {
            var e = this.a;
            if (e.g) {
                var i = h(e.f, e.a.c("wf", t.c, b(t).toString(), "active")),
                    s = [],
                    o = [e.a.c("wf", t.c, b(t).toString(), "loading")];
                i || s.push(e.a.c("wf", t.c, b(t).toString(), "inactive")), r(e.f, s, o)
            }
            T(e, "fontinactive", t), V(this)
        }, U.prototype.load = function(t) {
            this.c = new s(this.j, t.context || this.j), this.g = !1 !== t.events, this.f = !1 !== t.classes, j(this, new S(this.c, t), t)
        }, X.prototype.load = function(t) {
            function e() {
                if (n["__mti_fntLst" + s]) {
                    var i, o = n["__mti_fntLst" + s](),
                        a = [];
                    if (o)
                        for (var r = 0; r < o.length; r++) {
                            var h = o[r].fontfamily;
                            void 0 != o[r].fontStyle && void 0 != o[r].fontWeight ? (i = o[r].fontStyle + o[r].fontWeight, a.push(new g(h, i))) : a.push(new g(h))
                        }
                    t(a)
                } else setTimeout(function() {
                    e()
                }, 50)
            }
            var i = this,
                s = i.a.projectId,
                o = i.a.version;
            if (s) {
                var n = i.c.o;
                p(this.c, (i.a.api || "https://fast.fonts.net/jsapi") + "/" + s + ".js" + (o ? "?v=" + o : ""), function(o) {
                    o ? t([]) : (n["__MonotypeConfiguration__" + s] = function() {
                        return i.a
                    }, e())
                }).id = "__MonotypeAPIScript__" + s
            } else t([])
        }, K.prototype.load = function(t) {
            var e, i, s = this.a.urls || [],
                o = this.a.families || [],
                n = this.a.testStrings || {},
                a = new u;
            for (e = 0, i = s.length; e < i; e++) c(this.c, s[e], d(a));
            var r = [];
            for (e = 0, i = o.length; e < i; e++)
                if ((s = o[e].split(":"))[1])
                    for (var h = s[1].split(","), l = 0; l < h.length; l += 1) r.push(new g(s[0], h[l]));
                else r.push(new g(s[0]));
            m(a, function() {
                t(r, n)
            })
        };
        var nt = "https://fonts.googleapis.com/css",
            at = {
                latin: "BESbswy",
                "latin-ext": "çöüğş",
                cyrillic: "йяЖ",
                greek: "αβΣ",
                khmer: "កខគ",
                Hanuman: "កខគ"
            },
            rt = {
                thin: "1",
                extralight: "2",
                "extra-light": "2",
                ultralight: "2",
                "ultra-light": "2",
                light: "3",
                regular: "4",
                book: "4",
                medium: "5",
                "semi-bold": "6",
                semibold: "6",
                "demi-bold": "6",
                demibold: "6",
                bold: "7",
                "extra-bold": "8",
                extrabold: "8",
                "ultra-bold": "8",
                ultrabold: "8",
                black: "9",
                heavy: "9",
                l: "3",
                r: "4",
                b: "7"
            },
            ht = {
                i: "i",
                italic: "i",
                n: "n",
                normal: "n"
            },
            lt = /^(thin|(?:(?:extra|ultra)-?)?light|regular|book|medium|(?:(?:semi|demi|extra|ultra)-?)?bold|black|heavy|l|r|b|[1-9]00)?(n|i|normal|italic)?$/,
            ct = {
                Arimo: !0,
                Cousine: !0,
                Tinos: !0
            };
        Z.prototype.load = function(t) {
            var e = new u,
                i = this.c,
                s = new H(this.a.api, this.a.text),
                o = this.a.families;
            q(s, o);
            var n = new z(o);
            Y(n), c(i, J(s), d(e)), m(e, function() {
                t(n.a, n.c, ct)
            })
        }, Q.prototype.load = function(t) {
            var e = this.a.id,
                i = this.c.o;
            e ? p(this.c, (this.a.api || "https://use.typekit.net") + "/" + e + ".js", function(e) {
                if (e) t([]);
                else if (i.Typekit && i.Typekit.config && i.Typekit.config.fn) {
                    e = i.Typekit.config.fn;
                    for (var s = [], o = 0; o < e.length; o += 2)
                        for (var n = e[o], a = e[o + 1], r = 0; r < a.length; r++) s.push(new g(n, a[r]));
                    try {
                        i.Typekit.load({
                            events: !1,
                            classes: !1,
                            async: !0
                        })
                    } catch (t) {}
                    t(s)
                }
            }, 2e3) : t([])
        }, $.prototype.load = function(t) {
            var e = this.f.id,
                i = this.c.o,
                s = this;
            e ? (i.__webfontfontdeckmodule__ || (i.__webfontfontdeckmodule__ = {}), i.__webfontfontdeckmodule__[e] = function(e, i) {
                for (var o = 0, n = i.fonts.length; o < n; ++o) {
                    var a = i.fonts[o];
                    s.a.push(new g(a.name, C("font-weight:" + a.weight + ";font-style:" + a.style)))
                }
                t(s.a)
            }, p(this.c, (this.f.api || "https://f.fontdeck.com/s/css/js/") + l(this.c) + "/" + e + ".js", function(e) {
                e && t([])
            })) : t([])
        };
        var pt = new U(window);
        pt.a.c.custom = function(t, e) {
            return new K(e, t)
        }, pt.a.c.fontdeck = function(t, e) {
            return new $(e, t)
        }, pt.a.c.monotype = function(t, e) {
            return new X(e, t)
        }, pt.a.c.typekit = function(t, e) {
            return new Q(e, t)
        }, pt.a.c.google = function(t, e) {
            return new Z(e, t)
        };
        var ut = {
            load: i(pt.load, pt)
        };
        "function" == typeof define && define.amd ? define(function() {
            return ut
        }) : "undefined" != typeof module && module.exports ? module.exports = ut : (window.WebFont = ut, window.WebFontConfig && pt.load(window.WebFontConfig))
    }();
var __extends = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }(),
    Constants = function() {
        function t() {}
        return t.GAME_SCALE = 1, t.CALCULATED_WIDTH = 1280, t.CALCULATED_HEIGHT = 720, t.GAME_WIDTH = 1280, t.GAME_HEIGHT = 720, t.LANDSCAPE_LOCKED = !0, t.PORTRAIT_LOCKED = !1, t.STORAGE_KEY = "xbt_02", t.GAME_KEY = "0afa9a707d517aec69baf490dbac065d", t.SECRET_KEY = "7023e28995b64d19aa2616ee401b3637ea96c6f0", t.GOOGLE_ID = "UA-78960661-44", t.GOOGLE_APP_NAME = "Extreme Bikers", t.GAMEDISTRIBUTION_ID = "070d0680bbe24d5aafa44d8b9b629c2d", t.GAMEDISTRIBUTION_USER = "ABD36C6C-E74B-4BA7-BE87-0AB01F98D30D-s1", t
    }(),
    GameSrc;
! function(t) {
    ! function(e) {
        var i;
        ! function(t) {
            t[t.PHYSICS = 1] = "PHYSICS", t[t.GRAPHICS = 2] = "GRAPHICS", t[t.USER = 3] = "USER"
        }(i || (i = {}));
        var s;
        ! function(t) {
            t[t.DEV = 1] = "DEV", t[t.DIST = 2] = "DIST", t[t.USER = 3] = "USER"
        }(s || (s = {}));
        var o = function() {
            function e() {}
            return e.init = function() {
                e.isInited || (e.phaserRenderType === Phaser.WEBGL ? (e.buildStr = "-webgl", e.enablePhaserDebug = !1) : e.phaserRenderType === Phaser.CANVAS ? e.buildStr = "-canvas" : e.phaserRenderType === Phaser.AUTO && (e.enablePhaserDebug = !1, e.buildStr = "-auto"), e.viewMode === i.GRAPHICS ? (e.enableGraphics = !0, e.enableBox2DDebugDraw = !1) : e.viewMode === i.PHYSICS && (e.enableGraphics = !1, e.enableBox2DDebugDraw = !0), e.buildVersion === s.DIST ? e.isDistVersion = !0 : e.buildVersion === s.DEV && (e.isDistVersion = !1), e.isInited = !0)
            }, e.getCurrentVersion = function() {
                var i = t.config.GameConfig.currentVersion;
                return t.config.GameConfig.isDistVersion ? i += "-dist" : i += "-dev", t.config.GameConfig.enableGraphics && t.config.GameConfig.enableBox2DDebugDraw ? i += "-pg" : t.config.GameConfig.enableGraphics || t.config.GameConfig.enableBox2DDebugDraw ? t.config.GameConfig.enableGraphics ? i += "-g" : t.config.GameConfig.enableBox2DDebugDraw && (i += "-p") : i += "-no_p_or_g", i + e.buildStr
            }, e.phaserRenderType = Phaser.WEBGL, e.viewMode = i.GRAPHICS, e.buildVersion = s.DEV, e.startUpLevelDataPath = "assets/levels/testLevel6_copy_data.json", e.startUpGameMapDataPath = "assets/maps/game_map_data.json", e.startUpGameCommonSettingsDataPath = "assets/settings/game_common_settings.json", e.enablePhaserDebug = !1, e.enableGameCameraDeadZoneVisibleState = !1, e.enableGameCameraCheats = !0, e.enableGameCheats = !0, e.isOnMobileDevice = !1, e.calcGameScale = 1, e.isDistVersion = !1, e.currentVersion = "xb-1.10.3.58", e.gameBuildVersion = "xb-1.10.32", e.enableGraphics = !1, e.enableBox2DDebugDraw = !0, e.verticalGravity = 10, e.b2WorldScale = 50, e.b2Scale = 15, e.PI = 3.141592653589793, e.b2MaxTranslation = 100, e.b2MaxTranslationSquared = 1e4, e.isInited = !1, e.buildStr = "", e
        }();
        e.GameConfig = o
    }(t.config || (t.config = {}))
}(GameSrc || (GameSrc = {}));
var BoilerPlate;
! function(t) {
    var e = function(t) {
        function e(e, i, s, o, n, a, r) {
            var h = t.call(this, e, i, s, o, n) || this;
            return h.maxWidth = a, h.maxHeight = r, h.game.add.existing(h), h
        }
        return __extends(e, t), e.prototype.setText = function(e) {
            return t.prototype.setText.call(this, e), (this.maxWidth || this.maxHeight) && this.makeFontFit(), this
        }, e.prototype.setMaxSize = function(t, e) {
            this.maxWidth = t, this.maxHeight = e
        }, e.prototype.makeFontFit = function() {
            for (var t; this.width > this.maxWidth || this.height > this.maxHeight;) {
                if ((t = parseInt(this.fontSize.toString().replace("px", ""), 10) - 1) < 10) {
                    t = 10, this.fontSize = t;
                    break
                }
                this.fontSize = t
            }
        }, e
    }(Phaser.Text);
    t.Label = e
}(BoilerPlate || (BoilerPlate = {}));
var BoilerPlate;
! function(t) {
    ! function(t) {
        var e = function() {
            function t(t, e, i, s) {
                void 0 === s && (s = !1);
                var o = this;
                this.musicOn = !1, this.sfxOn = !1, this.starsList = null, this.openedLevels = null, this.game = t, this.callback = e, this.callbackContext = i, this.game.storage.getItem(Constants.STORAGE_KEY).then(function(t) {
                    null === t || void 0 === t || s ? (o.sfxOn = !0, o.musicOn = !0, o.createStarsList(), o.createOpenedLevels(), o.save(), o.callback && o.callbackContext && o.callback.call(o.callbackContext)) : o.restore()
                })
            }
            return t.getInstance = function(e, i, s, o) {
                return void 0 === o && (o = !1), t.instance || (t.instance = new t(e, i, s, o)), t.instance
            }, Object.defineProperty(t.prototype, "music", {
                get: function() {
                    return this.musicOn
                },
                set: function(t) {
                    this.musicOn = t, this.save()
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(t.prototype, "sfx", {
                get: function() {
                    return this.sfxOn
                },
                set: function(t) {
                    this.sfxOn = t, this.save()
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(t.prototype, "StarsList", {
                get: function() {
                    return this.starsList
                },
                set: function(t) {
                    this.starsList = t, null === this.starsList && (this.starsList = []), this.save()
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(t.prototype, "OpenedLevels", {
                get: function() {
                    return this.openedLevels
                },
                set: function(t) {
                    null !== t && (this.openedLevels = t), this.save()
                },
                enumerable: !0,
                configurable: !0
            }), t.prototype.createStarsList = function() {
                this.starsList = [];
                var t = 1;
                for (t = 1; t <= 15; t++) this.starsList.push(this.createStarsListItem(t))
            }, t.prototype.createOpenedLevels = function() {
                this.openedLevels = {}, this.openedLevels[1] = !0, this.openedLevels[2] = !1, this.openedLevels[3] = !1, this.openedLevels[4] = !1, this.openedLevels[5] = !1, this.openedLevels[6] = !1, this.openedLevels[7] = !1, this.openedLevels[8] = !1, this.openedLevels[9] = !1, this.openedLevels[10] = !1, this.openedLevels[11] = !1, this.openedLevels[12] = !1
            }, t.prototype.createStarsListItem = function(t, e, i, s) {
                void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = !1);
                var o = {};
                return o.levelId = t, o.seconds = e, o.milliseconds = i, o.activeFlag = s, o
            }, t.prototype.save = function() {
                var t = JSON.stringify({
                        m: this.musicOn,
                        sf: this.sfxOn,
                        starsList: this.starsList,
                        openedLevels: this.openedLevels
                    }),
                    e = this.hash(t);
                this.game.storage.setItem(Constants.STORAGE_KEY, t), this.game.storage.setItem("h", e)
            }, t.prototype.restore = function() {
                var t, e, i = this,
                    s = this.game.storage.getItem(Constants.STORAGE_KEY),
                    o = this.game.storage.getItem("h");
                Promise.all([s, o]).then(function(s) {
                    if (t = s[0] || "", e = s[1] || "0", "" !== t)
                        if (e === i.hash(t)) {
                            if (t && "" !== t) try {
                                var o = JSON.parse(t);
                                i.musicOn = o.m, i.sfxOn = o.sf, i.starsList = o.starsList, i.openedLevels = o.openedLevels
                            } catch (t) {
                                console.warn("Unable to parse save game.", t)
                            } else console.log("No saved data.");
                            i.callback && i.callbackContext && i.callback.call(i.callbackContext)
                        } else console.warn("Incorrect save data.")
                })
            }, t.prototype.hash = function(t) {
                var e, i, s = 0;
                if (0 === t.length) return s.toString();
                for (e = 0, i = t.length; e < i; e++) s = (s << 5) - s + t.charCodeAt(e), s |= 0;
                return s.toString()
            }, t
        }();
        t.Game = e
    }(t.Save || (t.Save = {}))
}(BoilerPlate || (BoilerPlate = {}));
var GameSrc;
! function(t) {
    ! function(t) {
        var e = function() {
            function t(t) {
                this.resetData(), this.game = t, this.initData()
            }
            return Object.defineProperty(t.prototype, "OnFocusIn", {
                get: function() {
                    return this.onFocusIn
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(t.prototype, "OnFocusOut", {
                get: function() {
                    return this.onFocusOut
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(t.prototype, "HasFocus", {
                get: function() {
                    return this.hasFocus
                },
                enumerable: !0,
                configurable: !0
            }), t.init = function(e) {
                null === t.instance && (t.instance = new t(e))
            }, t.getInstance = function() {
                return this.instance
            }, t.prototype.focusIn = function() {
                this.hasFocus = !0, this.onFocusIn.dispatch()
            }, t.prototype.focusOut = function() {
                this.hasFocus = !1, this.onFocusOut.dispatch()
            }, t.prototype.cleanOnFocusSignalHandlers = function() {
                this.onFocusIn.removeAll(), this.onFocusOut.removeAll()
            }, t.prototype.initData = function() {
                this.onFocusIn = new Phaser.Signal, this.onFocusOut = new Phaser.Signal, this.hasFocus = !0
            }, t.prototype.resetData = function() {
                this.game = null, this.onFocusIn = null, this.onFocusOut = null, this.hasFocus = !1
            }, t.instance = null, t
        }();
        t.AppFocusManager = e
    }(t.managers || (t.managers = {}))
}(GameSrc || (GameSrc = {}));
var BoilerPlate;
! function(t) {
    var e = function() {
        function e(t) {
            this.audioInstances = {}, this.resetData(), this.soundMan = t.sound, this.initData()
        }
        return e.getInstance = function(t) {
            if (null === e.instance) {
                if (!t) throw new Error("Cant create a new instance without a game");
                e.instance = new e(t)
            }
            return e.instance
        }, e.prototype.playMusic = function(e, i) {
            void 0 === i && (i = 1), null !== this.music && this.music.name === e || (null !== this.music && this.music.name !== e && this.music.stop(), this.music = this.soundMan.play(e, i, !0), t.Save.Game.getInstance().music || this.setMusicMuteState(!0))
        }, e.prototype.stopMusic = function() {
            null !== this.music && this.music.isPlaying && this.music.stop()
        }, e.prototype.muteMusic = function() {
            null !== this.music && this.setMusicMuteState(!0)
        }, e.prototype.unmuteMusic = function() {
            null !== this.music && this.setMusicMuteState(!1)
        }, e.prototype.playSound = function(e, i, s) {
            void 0 === i && (i = 1), void 0 === s && (s = !1);
            var o = null;
            return this.audioInstances.hasOwnProperty(e) || (this.audioInstances[e] = this.soundMan.add(e)), (o = this.audioInstances[e]).play(void 0, void 0, i, s, !0), t.Save.Game.getInstance().music || (o.mute = !0), o
        }, e.prototype.stopSound = function(t) {
            this.audioInstances.hasOwnProperty(t) && this.audioInstances[t].stop()
        }, e.prototype.muteSounds = function() {
            this.setSoundsMuteState(!0)
        }, e.prototype.unmuteSounds = function() {
            this.setSoundsMuteState(!1)
        }, e.prototype.initData = function() {
            this.saveManager = t.Save.Game.getInstance(), this.focusManager = GameSrc.managers.AppFocusManager.getInstance(), this.focusManager.OnFocusIn.add(this.onAppFocusIn, this), this.focusManager.OnFocusOut.add(this.onAppFocusOut, this)
        }, e.prototype.setMusicMuteState = function(t) {
            this.music.mute = t
        }, e.prototype.setSoundsMuteState = function(t) {
            var e = null;
            for (e in this.audioInstances) this.audioInstances.hasOwnProperty(e) && (this.audioInstances[e].mute = t)
        }, e.prototype.resetData = function() {
            this.soundMan = null, this.saveManager = null, this.focusManager = null, this.music = null
        }, e.prototype.onAppFocusIn = function() {
            this.soundMan.mute = !1
        }, e.prototype.onAppFocusOut = function() {
            this.soundMan.mute = !0
        }, e.instance = null, e
    }();
    t.SoundManager = e
}(BoilerPlate || (BoilerPlate = {}));
var GameSrc;
! function(t) {
    ! function(t) {
        ! function(t) {
            t[t.UNKNOWN = 0] = "UNKNOWN", t[t.ROAD_SURFACE = 1] = "ROAD_SURFACE", t[t.BIKE = 2] = "BIKE", t[t.CHECK_POINT = 3] = "CHECK_POINT", t[t.STICK = 4] = "STICK", t[t.CIRCLE = 5] = "CIRCLE", t[t.VERTICAL_LIFT = 6] = "VERTICAL_LIFT", t[t.TRIGGER = 7] = "TRIGGER", t[t.MULTI_TRIGGER = 8] = "MULTI_TRIGGER", t[t.ROTATING_OBJECT = 9] = "ROTATING_OBJECT", t[t.DESTRUCTIBLE_OBJECT = 10] = "DESTRUCTIBLE_OBJECT", t[t.SURFACE_OBJECT = 11] = "SURFACE_OBJECT", t[t.PISTON = 12] = "PISTON", t[t.BOMB = 14] = "BOMB", t[t.ACTION_AREA = 15] = "ACTION_AREA", t[t.FINISH_ZONE = 16] = "FINISH_ZONE", t[t.CAMERA_TRIGGER = 17] = "CAMERA_TRIGGER", t[t.DOOR = 18] = "DOOR", t[t.HORIZONTAL_LIFT = 19] = "HORIZONTAL_LIFT"
        }(t.GameObjectType || (t.GameObjectType = {}))
    }(t.types || (t.types = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(t) {
        ! function(t) {
            t[t.UNKNOWN = 0] = "UNKNOWN", t[t.GROUND = 1] = "GROUND", t[t.BIKE_WHEEL = 2] = "BIKE_WHEEL", t[t.BIKE_BODY = 4] = "BIKE_BODY", t[t.BIKE_AXLE = 8] = "BIKE_AXLE", t[t.GAME_OBJECT = 16] = "GAME_OBJECT", t[t.BIKE_BODY_SENSOR_BODY = 32] = "BIKE_BODY_SENSOR_BODY", t[t.BIKE_BODY_SENSOR_HEAD = 64] = "BIKE_BODY_SENSOR_HEAD", t[t.BIKE_WHEEL_REAR = 128] = "BIKE_WHEEL_REAR", t[t.BIKE_WHEEL_FRONT = 256] = "BIKE_WHEEL_FRONT"
        }(t.EntityCategory || (t.EntityCategory = {}))
    }(t.types || (t.types = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(t) {
        ! function(t) {
            t[t.UNKNOWN = 0] = "UNKNOWN", t[t.THORNS = 1] = "THORNS"
        }(t.GameObjectMaterialType || (t.GameObjectMaterialType = {}))
    }(t.types || (t.types = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(t) {
        ! function(t) {
            t[t.UNKNOWN = 0] = "UNKNOWN", t[t.STATIC = 1] = "STATIC", t[t.KINEMATIC = 2] = "KINEMATIC", t[t.DYNAMIC = 3] = "DYNAMIC"
        }(t.GameObjectPhysicType || (t.GameObjectPhysicType = {}))
    }(t.types || (t.types = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(e) {
        var i = function() {
            function e() {
                this.Type = t.types.GameObjectType.UNKNOWN, this.PhysicType = t.types.GameObjectPhysicType.UNKNOWN, this.EntityCategory = t.types.EntityCategory.UNKNOWN, this.MaterialType = t.types.GameObjectMaterialType.UNKNOWN, this.UserData1 = null, this.UserData2 = null
            }
            return e.prototype.toString = function() {
                return "type: " + t.tools.Convertor.getStringFromGameObjectType(this.Type) + "; physic type: " + t.tools.Convertor.getStringFromGameObjectPhysicType(this.PhysicType) + "; material type: " + t.tools.Convertor.getStringFromGameObjectMaterialType(this.MaterialType) + "; entity category: " + t.tools.Convertor.getStringFromEntityCategory(this.EntityCategory)
            }, e
        }();
        e.GameObjectData = i
    }(t.types || (t.types = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(t) {
        ! function(t) {
            t[t.UNKNOWN = 0] = "UNKNOWN", t[t.REQUEST_BIKE = 1] = "REQUEST_BIKE", t[t.REQUEST_GAME_CAMERA_CONTROLLER = 2] = "REQUEST_GAME_CAMERA_CONTROLLER", t[t.CHANGE_START_UP_LEVEL_PART = 3] = "CHANGE_START_UP_LEVEL_PART", t[t.TRIGGER_ACTION = 4] = "TRIGGER_ACTION"
        }(t.GameObjectActions || (t.GameObjectActions = {}))
    }(t.types || (t.types = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(t) {
        ! function(t) {
            t[t.LEVEL_UNKNOWN = -1] = "LEVEL_UNKNOWN", t[t.LEVEL_0 = 0] = "LEVEL_0", t[t.LEVEL_1 = 1] = "LEVEL_1", t[t.LEVEL_2 = 2] = "LEVEL_2", t[t.LEVEL_3 = 3] = "LEVEL_3", t[t.LEVEL_4 = 4] = "LEVEL_4", t[t.LEVEL_5 = 5] = "LEVEL_5", t[t.LEVEL_6 = 6] = "LEVEL_6", t[t.LEVEL_7 = 7] = "LEVEL_7", t[t.LEVEL_8 = 8] = "LEVEL_8", t[t.LEVEL_9 = 9] = "LEVEL_9", t[t.LEVEL_10 = 10] = "LEVEL_10", t[t.LEVEL_11 = 11] = "LEVEL_11", t[t.LEVEL_12 = 12] = "LEVEL_12", t[t.LEVEL_13 = 13] = "LEVEL_13", t[t.LEVEL_14 = 14] = "LEVEL_14", t[t.LEVEL_15 = 15] = "LEVEL_15"
        }(t.GameMapButtonLevelIds || (t.GameMapButtonLevelIds = {}))
    }(t.types || (t.types = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(t) {
        ! function(t) {
            t[t.UNKNOWN = 0] = "UNKNOWN", t[t.ZOOM_1 = 1] = "ZOOM_1", t[t.ZOOM_2 = 2] = "ZOOM_2", t[t.ZOOM_3 = 3] = "ZOOM_3"
        }(t.GameCameraZoomId || (t.GameCameraZoomId = {}))
    }(t.types || (t.types = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(t) {
        ! function(t) {
            t[t.UNKNOWN = 0] = "UNKNOWN", t[t.TOP = 1] = "TOP", t[t.MIDDLE = 2] = "MIDDLE", t[t.BOTTOM = 3] = "BOTTOM"
        }(t.GameCameraOffsetType || (t.GameCameraOffsetType = {}))
    }(t.types || (t.types = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(e) {
        var i = function() {
            function e() {}
            return e.w_to_ws = function(e) {
                return e / t.config.GameConfig.b2WorldScale
            }, e.ws_to_w = function(e) {
                return e * t.config.GameConfig.b2WorldScale
            }, e.deg_to_rad = function(t) {
                return t * Math.PI / 180
            }, e.rad_to_deg = function(t) {
                return 180 * t / Math.PI
            }, e.w_to_b2s = function(e) {
                return e / t.config.GameConfig.b2Scale
            }, e.b2s_to_w = function(e) {
                return e * t.config.GameConfig.b2Scale
            }, e.getRotatedPositionFor = function(t, e) {
                var i = new Box2D.Common.Math.b2Vec2;
                return i.x = t.x * Math.cos(e) - t.y * Math.sin(e), i.y = t.x * Math.sin(e) + t.y * Math.cos(e), i
            }, e.getGameObjectTypeFromStr = function(e) {
                return "go_check_point" === e ? t.types.GameObjectType.CHECK_POINT : "go_stick" === e ? t.types.GameObjectType.STICK : "go_circle" === e ? t.types.GameObjectType.CIRCLE : "go_v_lift" === e ? t.types.GameObjectType.VERTICAL_LIFT : "go_trigger" === e ? t.types.GameObjectType.TRIGGER : "go_multi_trigger" === e ? t.types.GameObjectType.MULTI_TRIGGER : "go_rotating_object" === e ? t.types.GameObjectType.ROTATING_OBJECT : "go_destructible_object" === e ? t.types.GameObjectType.DESTRUCTIBLE_OBJECT : "go_piston" === e ? t.types.GameObjectType.PISTON : "go_bomb" === e ? t.types.GameObjectType.BOMB : "go_surface" === e ? t.types.GameObjectType.SURFACE_OBJECT : "goActionArea" === e ? t.types.GameObjectType.ACTION_AREA : "go_finish_zone" === e ? t.types.GameObjectType.FINISH_ZONE : "go_camera_trigger" === e ? t.types.GameObjectType.CAMERA_TRIGGER : "go_door" === e ? t.types.GameObjectType.DOOR : "go_h_lift" === e ? t.types.GameObjectType.HORIZONTAL_LIFT : t.types.GameObjectType.UNKNOWN
            }, e.getGameObjectMaterialTypeFromStr = function(e) {
                return "thorns" === e ? t.types.GameObjectMaterialType.THORNS : t.types.GameObjectMaterialType.UNKNOWN
            }, e.getGameObjectPhysicTypeFromStr = function(e) {
                return "static" === e ? t.types.GameObjectPhysicType.STATIC : "kinematic" === e ? t.types.GameObjectPhysicType.KINEMATIC : "dynamic" === e ? t.types.GameObjectPhysicType.DYNAMIC : t.types.GameObjectPhysicType.UNKNOWN
            }, e.getStringFromGameObjectType = function(e) {
                return e === t.types.GameObjectType.ROAD_SURFACE ? "ROAD_SURFACE" : e === t.types.GameObjectType.BIKE ? "BIKE" : e === t.types.GameObjectType.CHECK_POINT ? "CHECK_POINT" : e === t.types.GameObjectType.STICK ? "STICK" : e === t.types.GameObjectType.CIRCLE ? "CIRCLE" : e === t.types.GameObjectType.VERTICAL_LIFT ? "VERTICAL_LIFT" : e === t.types.GameObjectType.TRIGGER ? "TRIGGER" : e === t.types.GameObjectType.MULTI_TRIGGER ? "MULTI_TRIGGER" : e === t.types.GameObjectType.ROTATING_OBJECT ? "ROTATING_OBJECT" : e === t.types.GameObjectType.DESTRUCTIBLE_OBJECT ? "DESTRUCTIBLE_OBJECT" : e === t.types.GameObjectType.SURFACE_OBJECT ? "SURFACE_OBJECT" : e === t.types.GameObjectType.PISTON ? "PISTON" : e === t.types.GameObjectType.BOMB ? "BOMB" : e === t.types.GameObjectType.ACTION_AREA ? "ACTION_AREA" : e === t.types.GameObjectType.FINISH_ZONE ? "FINISH_ZONE" : e === t.types.GameObjectType.CAMERA_TRIGGER ? "CAMERA_TRIGGER" : e === t.types.GameObjectType.DOOR ? "DOOR" : e === t.types.GameObjectType.HORIZONTAL_LIFT ? "HORIZONTAL_LIFT" : "UNKNOWN"
            }, e.getStringFromGameObjectMaterialType = function(e) {
                return e === t.types.GameObjectMaterialType.THORNS ? "THORNS" : "UNKNOWN"
            }, e.getStringFromGameObjectPhysicType = function(e) {
                return e === t.types.GameObjectPhysicType.STATIC ? "STATIC" : e === t.types.GameObjectPhysicType.KINEMATIC ? "KINEMATIC" : e === t.types.GameObjectPhysicType.DYNAMIC ? "DYNAMIC" : "UNKNOWN"
            }, e.getStringFromGameObjectAction = function(e) {
                return e === t.types.GameObjectActions.REQUEST_BIKE ? "REQUEST_BIKE" : e === t.types.GameObjectActions.CHANGE_START_UP_LEVEL_PART ? "CHANGE_START_UP_LEVEL_PART" : "UNKNOWN"
            }, e.getStringFromEntityCategory = function(e) {
                return e === t.types.EntityCategory.GROUND ? "GROUND" : e === t.types.EntityCategory.BIKE_WHEEL ? "BIKE_WHEEL" : e === t.types.EntityCategory.BIKE_BODY ? "BIKE_BODY" : e === t.types.EntityCategory.BIKE_AXLE ? "THORN_1" : e === t.types.EntityCategory.GAME_OBJECT ? "GAME_OBJECT" : e === t.types.EntityCategory.BIKE_BODY_SENSOR_BODY ? "BIKE_BODY_SENSOR_BODY" : e === t.types.EntityCategory.BIKE_BODY_SENSOR_HEAD ? "BIKE_BODY_SENSOR_HEAD" : "UNKNOWN"
            }, e.getGameObjectDataFromData = function(e) {
                var i = null;
                return null != e && e instanceof t.types.GameObjectData && (i = e), i
            }, e.hasJSONDataField = function(t, e) {
                return !(null == t || !t.hasOwnProperty(e))
            }, e.getGameMapLevelIdWithButtonId = function(e) {
                return "MapButton_l0" === e ? t.types.GameMapButtonLevelIds.LEVEL_0 : "MapButton_l1" === e ? t.types.GameMapButtonLevelIds.LEVEL_1 : "MapButton_l2" === e ? t.types.GameMapButtonLevelIds.LEVEL_2 : "MapButton_l3" === e ? t.types.GameMapButtonLevelIds.LEVEL_3 : "MapButton_l4" === e ? t.types.GameMapButtonLevelIds.LEVEL_4 : "MapButton_l5" === e ? t.types.GameMapButtonLevelIds.LEVEL_5 : "MapButton_l6" === e ? t.types.GameMapButtonLevelIds.LEVEL_6 : "MapButton_l7" === e ? t.types.GameMapButtonLevelIds.LEVEL_7 : "MapButton_l8" === e ? t.types.GameMapButtonLevelIds.LEVEL_8 : "MapButton_l9" === e ? t.types.GameMapButtonLevelIds.LEVEL_9 : "MapButton_l10" === e ? t.types.GameMapButtonLevelIds.LEVEL_10 : "MapButton_l11" === e ? t.types.GameMapButtonLevelIds.LEVEL_11 : "MapButton_l12" === e ? t.types.GameMapButtonLevelIds.LEVEL_12 : "MapButton_l13" === e ? t.types.GameMapButtonLevelIds.LEVEL_13 : "MapButton_l14" === e ? t.types.GameMapButtonLevelIds.LEVEL_14 : "MapButton_l15" === e ? t.types.GameMapButtonLevelIds.LEVEL_15 : t.types.GameMapButtonLevelIds.LEVEL_UNKNOWN
            }, e.getGameCameraZoomIdFromStr = function(e) {
                return "zoom1" === e ? t.types.GameCameraZoomId.ZOOM_1 : "zoom2" === e ? t.types.GameCameraZoomId.ZOOM_2 : "zoom3" === e ? t.types.GameCameraZoomId.ZOOM_3 : t.types.GameCameraZoomId.UNKNOWN
            }, e.getTimeDataFromMs = function(t) {
                var e = {},
                    i = new Date(t);
                return e.milliseconds = Math.floor(i.getMilliseconds() / 10), e.seconds = i.getSeconds(), e.minutes = i.getMinutes(), e
            }, e.isTimeALessTimeB = function(t, e, i, s, o, n) {
                return t < s || t === s && e < o || t === s && e === o && i <= n
            }, e.getCameraOffsetTypeFromStr = function(e) {
                return "top" === e ? t.types.GameCameraOffsetType.TOP : "middle" === e ? t.types.GameCameraOffsetType.MIDDLE : "bottom" === e ? t.types.GameCameraOffsetType.BOTTOM : t.types.GameCameraOffsetType.UNKNOWN
            }, e
        }();
        e.Convertor = i
    }(t.tools || (t.tools = {}))
}(GameSrc || (GameSrc = {}));
var Atlases = function() {
        function t() {}
        return t.GUI_GENERAL = "gui_general", t.GUI_GAME_SET1 = "gui_game_set1", t.GUI_GAME_SET2 = "gui_game_set2", t.GUI_GAME_SET3 = "gui_game_set3", t.preloadList = [], t.list = [t.GUI_GENERAL, t.GUI_GAME_SET1, t.GUI_GAME_SET2, t.GUI_GAME_SET3], t
    }(),
    Settings = function() {
        function t() {}
        return t.levelStarsPath = "assets/settings/level_stars_settings.json", t.LevelStars = "level_stars_settings", t.gameMapPath = "assets/settings/game_map_settings.json", t.GameMap = "game_map_settings", t.bikerAnimationPath = "assets/settings/biker_animation_settings.json", t.BikerAnimation = "biker_animation", t.list = [{
            key: t.LevelStars,
            path: t.levelStarsPath
        }, {
            key: t.GameMap,
            path: t.gameMapPath
        }, {
            key: t.BikerAnimation,
            path: t.bikerAnimationPath
        }], t
    }(),
    GameSrc;
! function(t) {
    ! function(e) {
        var i = function(t) {
                function e() {
                    var e = t.call(this) || this;
                    return e.Id = 0, e.Mode = null, e.ModeId = 0, e.BackgroundKey = null, e
                }
                return __extends(e, t), e
            }(function() {
                return function() {
                    this.AtlasKey = null, this.DataKey = null, this.DataPath = null
                }
            }()),
            s = function() {
                function e() {}
                return e.init = function(t) {
                    e.isInited || (e.loadSettings(t), e.setStartUpLevelData(1), e.isInited = !0)
                }, e.getGameLevelStartUpAtlasKey = function() {
                    return e.gameLevelStartUpData.AtlasKey
                }, e.getGameLevelStartUpDataKey = function() {
                    return e.gameLevelStartUpData.DataKey
                }, e.getLevelId = function() {
                    return e.gameLevelStartUpData.Id
                }, e.getGameLevelStartUpBackgroundKey = function() {
                    return e.gameLevelStartUpData.BackgroundKey
                }, e.setStartUpLevelData = function(i) {
                    if (e.isInited) {
                        var s = 0;
                        for (s = 0; s < e.gameLevelsDataList.length; s++)
                            if (e.gameLevelsDataList[s].Id === i) {
                                (e.gameLevelStartUpData = e.gameLevelsDataList[s]).ModeId === e.LevelModeGraphics ? (t.config.GameConfig.enableBox2DDebugDraw = !1, t.config.GameConfig.enableGraphics = !0) : (t.config.GameConfig.enableBox2DDebugDraw = !0, t.config.GameConfig.enableGraphics = !1);
                                break
                            }
                    }
                }, e.loadSettings = function(t) {
                    e.data = t.cache.getJSON(e.DataKey), e.loadGameLevelsSettings()
                }, e.loadGameLevelsSettings = function() {
                    var t = e.data.levels,
                        i = 0;
                    for (e.gameLevelsDataList = [], i = 0; i < t.length; i++) e.loadGameLevelSetting(t[i])
                }, e.loadGameLevelSetting = function(t) {
                    var s = new i;
                    s.Id = t.id, s.Mode = t.mode, s.ModeId = e.getLevelModeFromStr(s.Mode), s.AtlasKey = t.atlas.key, s.DataKey = t.data.key, s.DataPath = t.data.path, s.BackgroundKey = t.backgroundKey, s.ModeId === e.LevelModeGraphics && Atlases.list.push(s.AtlasKey);
                    var o = {};
                    o.key = s.DataKey, o.path = s.DataPath, Settings.list.push(o), e.gameLevelsDataList.push(s)
                }, e.getLevelModeFromStr = function(t) {
                    return "physics" === t ? e.LevelModePhysics : "graphics" === t ? e.LevelModeGraphics : e.LevelModeUnknown
                }, e.DataKey = "game_level_settings", e.LevelModeUnknown = 0, e.LevelModePhysics = 1, e.LevelModeGraphics = 2, e.isInited = !1, e.data = null, e.gameMapData = null, e.gameTitleData = null, e.gameBikerAnimationData = null, e.levelStarsData = null, e.gameLevelsDataList = null, e.gameLevelStartUpData = null, e
            }();
        e.GameCommonSettings = s
    }(t.settings || (t.settings = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(t) {
        var e = function() {
            function t(t, e, i, s, o, n, a, r, h, l) {
                this.resetData(), this.isDisposed = !1, this.game = t, this.parentContainer = e, this.position = new Phaser.Point(0, 0), this.position.x = i, this.position.y = s, this.rotation = o, this.buttonId = n, this.atlasKey = a, this.frameUpId = r, this.frameOverId = h, this.frameDownId = l, this.initData()
            }
            return Object.defineProperty(t.prototype, "ButtonId", {
                get: function() {
                    return this.buttonId
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(t.prototype, "Button", {
                get: function() {
                    return this.button
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(t.prototype, "Visible", {
                get: function() {
                    return this.isVisible
                },
                set: function(t) {
                    this.setVisibleState(t)
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(t.prototype, "OnButtonUpSignal", {
                get: function() {
                    return this.onButtonUpSignal
                },
                enumerable: !0,
                configurable: !0
            }), t.prototype.init = function() {
                this.isInited || (this.createGraphicsContainer(), this.createButton(), this.isInited = !0, this.isVisible = !0)
            }, t.prototype.dispose = function() {
                this.isDisposed || (this.disposeSignals(), this.disposeButton(), this.disposeGraphicsContainer(), this.resetData(), this.isDisposed = !0)
            }, t.prototype.initData = function() {
                this.onButtonUpSignal = new Phaser.Signal
            }, t.prototype.createGraphicsContainer = function() {
                this.graphicsContainer = this.game.add.group(this.parentContainer)
            }, t.prototype.createButton = function() {
                this.button = this.game.add.button(this.position.x, this.position.y, this.atlasKey, void 0, void 0, this.frameOverId, this.frameUpId, this.frameDownId, this.frameUpId, this.graphicsContainer), this.button.anchor.set(.5, .5), this.button.onInputUp.add(this.onButtonUp, this)
            }, t.prototype.setVisibleState = function(t) {
                !this.isDisposed && this.isInited && (this.isVisible = t, this.graphicsContainer.visible = this.isVisible)
            }, t.prototype.disposeSignals = function() {
                null !== this.onButtonUpSignal && this.onButtonUpSignal.removeAll()
            }, t.prototype.disposeButton = function() {
                null !== this.button && this.button.onInputUp.removeAll()
            }, t.prototype.disposeGraphicsContainer = function() {
                null !== this.graphicsContainer && (this.graphicsContainer.removeAll(!0, !0), null !== this.graphicsContainer.parent && this.graphicsContainer.parent.removeChild(this.graphicsContainer))
            }, t.prototype.resetData = function() {
                this.isInited = !1, this.game = null, this.parentContainer = null, this.graphicsContainer = null, this.position = null, this.rotation = 0, this.buttonId = null, this.atlasKey = null, this.frameUpId = null, this.frameOverId = null, this.frameDownId = null, this.button = null, this.isVisible = !1
            }, t.prototype.onButtonUp = function() {
                if (this.isVisible) {
                    var t = {};
                    t.sender = this, this.onButtonUpSignal.dispatch(t)
                }
            }, t
        }();
        t.GameGUIButtonS = e
    }(t.entities || (t.entities = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(t) {
        var e = function() {
            function t(t, e, i) {
                void 0 === i && (i = 1), this.resetData(), this.isDisposed = !1, this.buttonOn = t, this.buttonOff = e, this.state = i, this.initData()
            }
            return Object.defineProperty(t.prototype, "OnButtonOnUpSignal", {
                get: function() {
                    return this.onButtonOnUpSignal
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(t.prototype, "OnButtonOffUpSignal", {
                get: function() {
                    return this.onButtonOffUpSignal
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(t.prototype, "Visible", {
                get: function() {
                    return this.visible
                },
                set: function(t) {
                    !this.isDisposed && this.isInited && (this.visible = t, this.checkVisibleState())
                },
                enumerable: !0,
                configurable: !0
            }), t.prototype.init = function() {
                this.isInited || (this.validateState(), this.registerSingnalHandlers(), this.isInited = !0, this.visible = !0, this.setState(this.state, !0))
            }, t.prototype.on = function() {
                !this.isDisposed && this.isInited && this.setState(t.STATE_ON)
            }, t.prototype.off = function() {
                !this.isDisposed && this.isInited && this.setState(t.STATE_OFF)
            }, t.prototype.toggle = function() {
                !this.isDisposed && this.isInited && this.setState(this.getInvertedState(this.state))
            }, t.prototype.dispose = function() {
                this.isDisposed || (this.disposeSignals(), this.disposeSignalHandlers(), this.resetData(), this.isDisposed = !0)
            }, t.prototype.initData = function() {
                this.onButtonOnUpSignal = new Phaser.Signal, this.onButtonOffUpSignal = new Phaser.Signal
            }, t.prototype.validateState = function() {
                this.state !== t.STATE_ON && this.state !== t.STATE_OFF && (this.state = t.STATE_ON)
            }, t.prototype.setState = function(e, i) {
                void 0 === i && (i = !1), (i || e !== this.state) && (this.state = e, this.state === t.STATE_ON ? this.setStateOn() : this.state === t.STATE_OFF && this.setStateOff())
            }, t.prototype.setStateOn = function() {
                this.setButtonsState(!0, this.visible)
            }, t.prototype.setStateOff = function() {
                this.setButtonsState(!1, this.visible)
            }, t.prototype.setButtonsState = function(t, e) {
                this.buttonOn.Visible = !!t && e, this.buttonOff.Visible = !t && e
            }, t.prototype.checkVisibleState = function() {
                this.state === t.STATE_ON ? this.buttonOn.Visible = this.visible : this.state === t.STATE_OFF && (this.buttonOff.Visible = this.visible)
            }, t.prototype.registerSingnalHandlers = function() {
                this.buttonOn.OnButtonUpSignal.add(this.onButtonOnUp, this), this.buttonOff.OnButtonUpSignal.add(this.onButtonOffUp, this)
            }, t.prototype.getInvertedState = function(e) {
                return e === t.STATE_ON ? t.STATE_OFF : t.STATE_ON
            }, t.prototype.disposeSignalHandlers = function() {
                null !== this.buttonOn && this.buttonOn.OnButtonUpSignal.removeAll(), null !== this.buttonOff && this.buttonOff.OnButtonUpSignal.removeAll()
            }, t.prototype.disposeSignals = function() {
                null !== this.onButtonOnUpSignal && this.onButtonOnUpSignal.removeAll(), null !== this.onButtonOffUpSignal && this.onButtonOffUpSignal.removeAll()
            }, t.prototype.resetData = function() {
                this.isInited = !1, this.visible = !1, this.buttonOn = null, this.buttonOff = null, this.state = 0, this.onButtonOnUpSignal = null, this.onButtonOffUpSignal = null
            }, t.prototype.onButtonOnUp = function(e) {
                this.state = t.STATE_OFF, this.setStateOff(), this.onButtonOffUpSignal.dispatch(e)
            }, t.prototype.onButtonOffUp = function(e) {
                this.state = t.STATE_ON, this.setStateOn(), this.onButtonOnUpSignal.dispatch(e)
            }, t.STATE_ON = 1, t.STATE_OFF = 2, t
        }();
        t.GameGUIToggleButtonS = e
    }(t.entities || (t.entities = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(t) {
        var e = function() {
            function t() {
                this.resetData(), this.isDisposed = !1
            }
            return Object.defineProperty(t.prototype, "Seconds", {
                get: function() {
                    return this.seconds
                },
                set: function(t) {
                    this.isDisposed || (this.seconds = t)
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(t.prototype, "Milliseconds", {
                get: function() {
                    return this.milliseconds
                },
                set: function(t) {
                    this.isDisposed || (this.milliseconds = t)
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(t.prototype, "ActiveFlag", {
                get: function() {
                    return this.activeFlag
                },
                set: function(t) {
                    this.isDisposed || (this.activeFlag = t)
                },
                enumerable: !0,
                configurable: !0
            }), t.prototype.clone = function() {
                var e = new t;
                return e.seconds = this.seconds, e.milliseconds = this.milliseconds, e.activeFlag = this.activeFlag, e
            }, t.prototype.setValuesFromTime = function(t) {
                this.isDisposed || (this.seconds = t.Seconds, this.milliseconds = t.Milliseconds, this.activeFlag = t.ActiveFlag)
            }, t.prototype.setValuesFromTotalMs = function(t) {
                if (!this.isDisposed) {
                    var e = Math.floor(t / 1e3),
                        i = Math.floor((t - 1e3 * e) / 10);
                    this.seconds = e, this.milliseconds = i
                }
            }, t.prototype.isLessOrEqualTo = function(t) {
                if (!this.isDisposed) return this.seconds < t.Seconds || this.seconds === t.Seconds && this.milliseconds <= t.Milliseconds
            }, t.prototype.getTimeAsString = function() {
                return this.isDisposed ? null : this.seconds.toString() + " . " + this.milliseconds.toString()
            }, t.prototype.dispose = function() {
                this.isDisposed || (this.resetData(), this.isDisposed = !0)
            }, t.prototype.resetData = function() {
                this.seconds = 0, this.milliseconds = 0, this.activeFlag = !1
            }, t
        }();
        t.LevelStarsTimeItem = e
    }(t.entities || (t.entities = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(t) {
        var e = function() {
            function e() {
                this.resetData(), this.isDisposed = !1, this.initData()
            }
            return Object.defineProperty(e.prototype, "Time", {
                get: function() {
                    return this.time
                },
                enumerable: !0,
                configurable: !0
            }), e.prototype.clone = function() {
                if (this.isDisposed) return null;
                var t = new e;
                return t.Time.setValuesFromTime(this.time), t
            }, e.prototype.dispose = function() {
                this.isDisposed || (this.disposeTime(), this.resetData(), this.isDisposed = !0)
            }, e.prototype.initData = function() {
                this.time = new t.LevelStarsTimeItem
            }, e.prototype.disposeTime = function() {
                null !== this.time && this.time.dispose()
            }, e.prototype.resetData = function() {
                this.time = null
            }, e
        }();
        t.LevelStarsStarItem = e
    }(t.entities || (t.entities = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(t) {
        var e = function() {
            function e() {
                this.resetData(), this.isDisposed = !1, this.initData()
            }
            return Object.defineProperty(e.prototype, "LevelId", {
                get: function() {
                    return this.levelId
                },
                set: function(t) {
                    this.isDisposed || (this.levelId = t)
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(e.prototype, "StarsList", {
                get: function() {
                    return this.starsList
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(e.prototype, "BestTime", {
                get: function() {
                    return this.bestTime
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(e.prototype, "LevelPassedTime", {
                get: function() {
                    return this.levelPassedTime
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(e.prototype, "LastLevelPassedTime", {
                get: function() {
                    return this.lastLevelPassedTime
                },
                enumerable: !0,
                configurable: !0
            }), e.createFromData = function(i) {
                var s = new e;
                s.levelId = i.id;
                var o = i.stars,
                    n = 0;
                for (n = 0; n < o.length; n++) s.addStarItem(function(e) {
                    var i = new t.LevelStarsStarItem;
                    return i.Time.Seconds = e.time, i
                }(o[n]));
                return s
            }, e.prototype.addStarItem = function(t) {
                this.isDisposed || null === t || this.starsList.push(t)
            }, e.prototype.getStarsCountForTime = function(t) {
                if (this.isDisposed || 0 === this.starsList.length) return 0;
                var e = this.starsCountLimit,
                    i = 0;
                for (i = this.starsList.length - 1; i >= 0 && !t.isLessOrEqualTo(this.starsList[i].Time); i--) e--;
                return e < 0 && (e = 0), e
            }, e.prototype.isLevelPassedTimeLessToBestTime = function() {
                return !this.isDisposed && this.levelPassedTime.isLessOrEqualTo(this.bestTime)
            }, e.prototype.isLevelPassedTimeLessToLastLevelPassedTime = function() {
                return !this.isDisposed && this.levelPassedTime.isLessOrEqualTo(this.lastLevelPassedTime)
            }, e.prototype.updateBestTimeToLevelPassedTime = function() {
                this.isDisposed || this.bestTime.setValuesFromTime(this.levelPassedTime)
            }, e.prototype.updateLastLevelPassedTime = function() {
                this.isDisposed || this.lastLevelPassedTime.setValuesFromTime(this.levelPassedTime)
            }, e.prototype.clone = function() {
                if (this.isDisposed) return null;
                var t = new e;
                t.LevelId = this.levelId;
                var i = 0;
                for (i = 0; i < this.starsList.length; i++) t.addStarItem(this.starsList[i].clone());
                return t.BestTime.setValuesFromTime(this.bestTime), t.LevelPassedTime.setValuesFromTime(this.levelPassedTime), t.LastLevelPassedTime.setValuesFromTime(this.lastLevelPassedTime), t
            }, e.prototype.dispose = function() {
                this.isDisposed || (this.disposeStarsList(), this.disposeBestTime(), this.disposeLevelPassedTime(), this.disposeLastLevelPassedTime(), this.resetData(), this.isDisposed = !0)
            }, e.prototype.initData = function() {
                this.starsList = [], this.bestTime = new t.LevelStarsTimeItem, this.levelPassedTime = new t.LevelStarsTimeItem, this.lastLevelPassedTime = new t.LevelStarsTimeItem, this.starsCountLimit = 3
            }, e.prototype.disposeStarsList = function() {
                if (null !== this.starsList) {
                    var t = 0;
                    for (t = 0; t < this.starsList.length; t++) this.starsList[t].dispose()
                }
            }, e.prototype.disposeBestTime = function() {
                null !== this.bestTime && this.bestTime.dispose()
            }, e.prototype.disposeLevelPassedTime = function() {
                null !== this.levelPassedTime && this.levelPassedTime.dispose()
            }, e.prototype.disposeLastLevelPassedTime = function() {
                null !== this.lastLevelPassedTime && this.lastLevelPassedTime.dispose()
            }, e.prototype.resetData = function() {
                this.levelId = 0, this.starsList = null, this.bestTime = null, this.levelPassedTime = null, this.lastLevelPassedTime = null, this.starsCountLimit = 0
            }, e
        }();
        t.LevelStarsItem = e
    }(t.entities || (t.entities = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(e) {
        var i = function() {
            function e(t) {
                this.resetData(), this.game = t, this.initData(), this.loadData(), this.initItemsList()
            }
            return Object.defineProperty(e.prototype, "LevelStarsItemList", {
                get: function() {
                    return this.levelStarsItemList
                },
                enumerable: !0,
                configurable: !0
            }), e.init = function(t) {
                e.m_instance = new e(t)
            }, e.getInstance = function() {
                return e.m_instance
            }, e.prototype.getLevelStarsItemWithLevelId = function(t) {
                var e = 0;
                for (e = 0; e < this.levelStarsItemList.length; e++)
                    if (this.levelStarsItemList[e].LevelId === t) return this.levelStarsItemList[e];
                return null
            }, e.prototype.initData = function() {
                this.levelStarsItemList = []
            }, e.prototype.loadData = function() {
                this.data = this.game.cache.getJSON(Settings.LevelStars)
            }, e.prototype.initItemsList = function() {
                var e = this.data.levels,
                    i = 0;
                for (i = 0; i < e.length; i++) this.levelStarsItemList.push(t.entities.LevelStarsItem.createFromData(e[i]))
            }, e.prototype.resetData = function() {
                this.game = null, this.data = null, this.levelStarsItemList = null
            }, e.m_instance = null, e
        }();
        e.LevelStarsSettings = i
    }(t.settings || (t.settings = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(t) {
        ! function(t) {
            t[t.UNKNOWN = 0] = "UNKNOWN", t[t.RESUMED = 1] = "RESUMED", t[t.RESUME_PREPARE = 2] = "RESUME_PREPARE", t[t.PAUSED = 3] = "PAUSED", t[t.PAUSE_PREPARE = 4] = "PAUSE_PREPARE", t[t.FINISHED = 5] = "FINISHED", t[t.FINISH_PREPARE = 6] = "FINISH_PREPARE", t[t.EXIT = 7] = "EXIT", t[t.EXIT_PREPARE = 8] = "EXIT_PREPARE", t[t.RESET = 9] = "RESET", t[t.RESET_PREPARE = 10] = "RESET_PREPARE", t[t.START_NEXT_LEVEL = 11] = "START_NEXT_LEVEL", t[t.START_NEXT_LEVEL_PREPARE = 12] = "START_NEXT_LEVEL_PREPARE"
        }(t.GameStates || (t.GameStates = {}))
    }(t.types || (t.types = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(e) {
        var i = function() {
            function e(t, e) {
                this.resetData(), this.game = t, this.saveManager = e, this.initData()
            }
            return Object.defineProperty(e.prototype, "GameState", {
                get: function() {
                    return this.gameState
                },
                set: function(t) {
                    this.gameState = t
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(e.prototype, "IsMusicOn", {
                get: function() {
                    return this.isMusicOn
                },
                set: function(t) {
                    this.isMusicOn = t
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(e.prototype, "MaxLevels", {
                get: function() {
                    return this.maxLevels
                },
                set: function(t) {
                    this.maxLevels = t
                },
                enumerable: !0,
                configurable: !0
            }), e.init = function(t, i) {
                null === e.m_instance && (e.m_instance = new e(t, i))
            }, e.getInstance = function() {
                return e.m_instance
            }, e.prototype.getLevelStarsItemWithLevelId = function(t) {
                if (0 === this.levelStarsItemList.length || !(t > 0 && t <= 15)) return null;
                var e = t - 1;
                return this.levelStarsItemList[e]
            }, e.prototype.isLevelOpened = function(t) {
                return this.openedLevels[t]
            }, e.prototype.setLevelOpened = function(t) {
                this.openedLevels[t] = !0
            }, e.prototype.loadSavedData = function() {
                null !== this.saveManager && (this.loadSavedDataForMusic(), this.loadSavedDataForStarsList(), this.loadSavedDataForOpenedLevels(), console.log("saved data loaded"))
            }, e.prototype.saveData = function() {
                null !== this.saveManager && (this.saveDataMusic(), this.saveDataStarsList(), this.saveOpenedLevels(), console.log("data saved"))
            }, e.prototype.initData = function() {
                this.initLevelStarsList(), this.initOpenedLevels()
            }, e.prototype.initLevelStarsList = function() {
                var e = t.settings.LevelStarsSettings.getInstance().LevelStarsItemList;
                this.levelStarsItemList = [];
                var i = 0;
                for (i = 0; i < e.length; i++) this.levelStarsItemList.push(e[i].clone());
                this.levelStarsItemList.sort(function(t, e) {
                    return t.LevelId - e.LevelId
                })
            }, e.prototype.initOpenedLevels = function() {
                this.openedLevels = {}, this.openedLevels[1] = !0, this.openedLevels[2] = !1, this.openedLevels[3] = !1, this.openedLevels[4] = !1, this.openedLevels[5] = !1, this.openedLevels[6] = !1, this.openedLevels[7] = !1, this.openedLevels[8] = !1, this.openedLevels[9] = !1, this.openedLevels[10] = !1, this.openedLevels[11] = !1, this.openedLevels[12] = !1
            }, e.prototype.loadSavedDataForMusic = function() {
                this.isMusicOn = this.saveManager.music
            }, e.prototype.loadSavedDataForStarsList = function() {
                var t = this.saveManager.StarsList;
                if (0 !== t.length) {
                    var e = 0;
                    for (e = 0; e < t.length; e++) this.levelStarsItemList[e].LastLevelPassedTime.ActiveFlag = t[e].activeFlag, this.levelStarsItemList[e].LastLevelPassedTime.Seconds = t[e].seconds, this.levelStarsItemList[e].LastLevelPassedTime.Milliseconds = t[e].milliseconds
                }
            }, e.prototype.loadSavedDataForOpenedLevels = function() {
                this.openedLevels = this.saveManager.OpenedLevels
            }, e.prototype.saveDataMusic = function() {
                this.saveManager.music = this.isMusicOn
            }, e.prototype.saveDataStarsList = function() {
                var t = this.saveManager.StarsList,
                    e = Math.min(t.length, this.levelStarsItemList.length),
                    i = 0;
                for (i = 0; i < e; i++) t[i].activeFlag = this.levelStarsItemList[i].LastLevelPassedTime.ActiveFlag, t[i].seconds = this.levelStarsItemList[i].LastLevelPassedTime.Seconds, t[i].milliseconds = this.levelStarsItemList[i].LastLevelPassedTime.Milliseconds;
                this.saveManager.StarsList = t
            }, e.prototype.saveOpenedLevels = function() {
                this.saveManager.OpenedLevels = this.openedLevels
            }, e.prototype.resetData = function() {
                this.game = null, this.saveManager = null, this.levelStarsItemList = null, this.gameState = 0, this.isMusicOn = !1, this.maxLevels = 0, this.openedLevels = null
            }, e.m_instance = null, e
        }();
        e.UserProfileSettings = i
    }(t.settings || (t.settings = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(t) {
        var e = function() {
            function t(t) {
                this.resetData(), this.game = t
            }
            return t.init = function(e) {
                null === t.instance && (t.instance = new t(e))
            }, t.getInstance = function() {
                return this.instance
            }, t.prototype.switchToState = function(t) {
                this.game.state.start(t)
            }, t.prototype.resetData = function() {
                this.game = null
            }, t.instance = null, t
        }();
        t.StateManager = e
    }(t.managers || (t.managers = {}))
}(GameSrc || (GameSrc = {}));
var Sounds = function() {
        function t() {}
        return t.ButtonClick = "button_click", t.BikeFlip = "flip", t.BikeEngineIdling = "engine_idling", t.BikeEngineGas = "engine_drowngas", t.VoiceDeath = "voice_death", t.Explosion = "explosion", t.Checkpoint = "checkpoint", t.FinishGame = "finish", t.Star = "star", t.Piston = "piston", t.Trigger = "trigger", t.Turn = "turn", t.Wood = "wood", t.GameMusic = "game_music", t.preloadList = [], t.list = [t.GameMusic, t.ButtonClick, t.BikeFlip, t.VoiceDeath, t.Explosion, t.Checkpoint, t.FinishGame, t.BikeEngineIdling, t.BikeEngineGas, t.Star, t.Piston, t.Trigger, t.Turn, t.Wood], t
    }(),
    GameSrc;
! function(t) {
    ! function(t) {
        var e = function() {
                function t(t, e, i, s, o, n) {
                    this.resetData(), this.isDisposed = !1, this.game = t, this.parentContainer = e, this.x = i, this.y = s, this.rotation = o, this.num = n, this.initData(), this.init()
                }
                return t.prototype.show = function() {
                    this.isDisposed || this.setVisibleState(!0)
                }, t.prototype.hide = function() {
                    this.isDisposed || this.setVisibleState(!1)
                }, t.prototype.dispose = function() {
                    this.isDisposed || (this.disposeGraphicsContainer(), this.resetData(), this.isDisposed = !0)
                }, t.prototype.initData = function() {
                    this.atlasKey = Atlases.GUI_GENERAL
                }, t.prototype.init = function() {
                    this.createGraphics()
                }, t.prototype.createGraphics = function() {
                    this.graphicsContainer = this.game.add.group(this.parentContainer), 2 === this.getNumberDigitsCount() ? (this.game.add.image(-50, -48.35, this.atlasKey, this.getAtlasKeyForDecDigit(), this.graphicsContainer), this.game.add.image(-20, -48.35, this.atlasKey, this.getAtlasKeyForUnitDigit(), this.graphicsContainer)) : this.game.add.image(-36.55, -48.35, this.atlasKey, this.getAtlasKeyForUnitDigit(), this.graphicsContainer)
                }, t.prototype.getNumberDigitsCount = function() {
                    return this.num > 9 ? 2 : 1
                }, t.prototype.getAtlasKeyForDecDigit = function() {
                    return "a_03_mb_o_s_d1_agp_p10000"
                }, t.prototype.getAtlasKeyForUnitDigit = function() {
                    var t = 10 * Math.floor(this.num / 10),
                        e = this.num - t,
                        i = e + 2;
                    return "a_" + (i < 10 ? "0" : "") + i.toString() + "_mb_o_s_d" + e.toString() + "_agp_p10000"
                }, t.prototype.setVisibleState = function(t) {
                    this.graphicsContainer.visible = t
                }, t.prototype.disposeGraphicsContainer = function() {
                    null !== this.graphicsContainer && (this.graphicsContainer.removeAll(!0, !0), null !== this.graphicsContainer.parent && this.graphicsContainer.parent.removeChild(this.graphicsContainer))
                }, t.prototype.resetData = function() {
                    this.game = null, this.parentContainer = null, this.graphicsContainer = null, this.x = 0, this.y = 0, this.rotation = 0, this.num = 0, this.atlasKey = null
                }, t
            }(),
            i = function() {
                function t(t, e, i, s, o) {
                    this.resetData(), this.isDisposed = !1, this.game = t, this.parentContainer = e, this.x = i, this.y = s, this.rotation = o, this.initData(), this.init()
                }
                return t.prototype.setNumber = function(t) {
                    this.isDisposed || t < 0 || t > 12 || (this.digitIndex = t - 1, this.digitsList[this.prevDigitIndex].hide(), this.digitsList[this.digitIndex].show(), this.prevDigitIndex = this.digitIndex)
                }, t.prototype.dispose = function() {
                    this.isDisposed || (this.disposeDigitsList(), this.disposeGraphicsContainer(), this.resetData(), this.isDisposed = !0)
                }, t.prototype.initData = function() {
                    this.digitsList = []
                }, t.prototype.init = function() {
                    this.createGraphics(), this.initDigits()
                }, t.prototype.createGraphics = function() {
                    this.graphicsContainer = this.game.add.group(this.parentContainer), this.digitsList.push(this.createGraphicsDigitItem(this.graphicsContainer, 0, 0, 0, 1)), this.digitsList.push(this.createGraphicsDigitItem(this.graphicsContainer, 0, 0, 0, 2)), this.digitsList.push(this.createGraphicsDigitItem(this.graphicsContainer, 0, 0, 0, 3)), this.digitsList.push(this.createGraphicsDigitItem(this.graphicsContainer, 0, 0, 0, 4)), this.digitsList.push(this.createGraphicsDigitItem(this.graphicsContainer, 0, 0, 0, 5)), this.digitsList.push(this.createGraphicsDigitItem(this.graphicsContainer, 0, 0, 0, 6)), this.digitsList.push(this.createGraphicsDigitItem(this.graphicsContainer, 0, 0, 0, 7)), this.digitsList.push(this.createGraphicsDigitItem(this.graphicsContainer, 0, 0, 0, 8)), this.digitsList.push(this.createGraphicsDigitItem(this.graphicsContainer, 0, 0, 0, 9)), this.digitsList.push(this.createGraphicsDigitItem(this.graphicsContainer, 0, 0, 0, 10)), this.digitsList.push(this.createGraphicsDigitItem(this.graphicsContainer, 0, 0, 0, 11)), this.digitsList.push(this.createGraphicsDigitItem(this.graphicsContainer, 0, 0, 0, 12))
                }, t.prototype.createGraphicsDigitItem = function(t, i, s, o, n) {
                    return new e(this.game, t, i, s, o, n)
                }, t.prototype.initDigits = function() {
                    var t = 0;
                    for (t = 0; t < this.digitsList.length; t++) this.digitsList[t].hide();
                    this.digitsList[this.digitIndex].show()
                }, t.prototype.disposeDigitsList = function() {
                    if (null !== this.digitsList) {
                        var t = 0;
                        for (t = 0; t < this.digitsList.length; t++) this.digitsList[t].dispose()
                    }
                }, t.prototype.disposeGraphicsContainer = function() {
                    null !== this.graphicsContainer && (this.graphicsContainer.removeAll(!0, !0), null !== this.graphicsContainer.parent && this.graphicsContainer.parent.removeChild(this.graphicsContainer))
                }, t.prototype.resetData = function() {
                    this.game = null, this.parentContainer = null, this.graphicsContainer = null, this.x = 0, this.y = 0, this.rotation = 0, this.digitsList = null, this.prevDigitIndex = 0, this.digitIndex = 0
                }, t
            }(),
            s = function() {
                function t(t, e, i, s, o) {
                    this.resetData(), this.isDisposed = !1, this.game = t, this.parentContainer = e, this.x = i, this.y = s, this.rotation = o, this.initData(), this.init()
                }
                return t.prototype.show = function() {
                    this.isDisposed || this.setVisibleState(!0)
                }, t.prototype.hide = function() {
                    this.isDisposed || this.setVisibleState(!1)
                }, t.prototype.dispose = function() {
                    this.isDisposed || (this.disposeGraphicsContainer(), this.resetData(), this.isDisposed = !0)
                }, t.prototype.initData = function() {
                    this.atlasKey = Atlases.GUI_GENERAL
                }, t.prototype.init = function() {
                    this.createGraphics()
                }, t.prototype.createGraphics = function() {
                    this.graphicsContainer = this.game.add.group(this.parentContainer), this.game.add.image(-20.4, -19.4, this.atlasKey, "a_19_mb_o_s_star_agp_p10000", this.graphicsContainer), this.graphicsContainer.x = this.x, this.graphicsContainer.y = this.y, this.graphicsContainer.angle = this.rotation
                }, t.prototype.setVisibleState = function(t) {
                    this.graphicsContainer.visible = t
                }, t.prototype.disposeGraphicsContainer = function() {
                    null !== this.graphicsContainer && (this.graphicsContainer.removeAll(!0, !0), null !== this.graphicsContainer.parent && this.graphicsContainer.parent.removeChild(this.graphicsContainer))
                }, t.prototype.resetData = function() {
                    this.game = null, this.parentContainer = null, this.graphicsContainer = null, this.x = 0, this.y = 0, this.rotation = 0, this.atlasKey = null
                }, t
            }(),
            o = function() {
                function t(t, e, i, s, o) {
                    this.resetData(), this.isDisposed = !1, this.game = t, this.parentContainer = e, this.x = i, this.y = s, this.rotation = o, this.initData(), this.init()
                }
                return t.prototype.setStarsCount = function(t) {
                    if (!(this.isDisposed || t < 0 || t > 3)) {
                        var e = 0;
                        for (e = 0; e < t; e++) this.starsList[e].show()
                    }
                }, t.prototype.dispose = function() {
                    this.isDisposed || (this.disposeStarsList(), this.disposeGraphicsContainer(), this.resetData(), this.isDisposed = !0)
                }, t.prototype.initData = function() {
                    this.starsList = []
                }, t.prototype.init = function() {
                    this.createGraphics(), this.initStars()
                }, t.prototype.createGraphics = function() {
                    this.graphicsContainer = this.game.add.group(this.parentContainer), this.starsList.push(this.createGraphicsStar(-45, 15.25, -37.3712)), this.starsList.push(this.createGraphicsStar(0, 0, 0)), this.starsList.push(this.createGraphicsStar(43, 15.25, 37.8485)), this.graphicsContainer.x = this.x, this.graphicsContainer.y = this.y, this.graphicsContainer.angle = this.rotation
                }, t.prototype.createGraphicsStar = function(t, e, i) {
                    return new s(this.game, this.graphicsContainer, t, e, i)
                }, t.prototype.initStars = function() {
                    var t = 0;
                    for (t = 0; t < this.starsList.length; t++) this.starsList[t].hide()
                }, t.prototype.disposeStarsList = function() {
                    if (null !== this.starsList) {
                        var t = 0;
                        for (t = 0; t < this.starsList.length; t++) this.starsList[t].dispose()
                    }
                }, t.prototype.disposeGraphicsContainer = function() {
                    null !== this.graphicsContainer && (this.graphicsContainer.removeAll(!0, !0), null !== this.graphicsContainer.parent && this.graphicsContainer.parent.removeChild(this.graphicsContainer))
                }, t.prototype.resetData = function() {
                    this.game = null, this.parentContainer = null, this.graphicsContainer = null, this.x = 0, this.y = 0, this.rotation = 0, this.starsList = null
                }, t
            }(),
            n = function() {
                function t(t, e, i, s, o, n, a) {
                    void 0 === a && (a = !1), this.resetData(), this.isDisposed = !1, this.game = t, this.parentContainer = e, this.x = i, this.y = s, this.rotation = o, this.levelId = n, this.isOpened = a, this.initData()
                }
                return Object.defineProperty(t.prototype, "LevelId", {
                    get: function() {
                        return this.levelId
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "OnButtonUpSignal", {
                    get: function() {
                        return this.onButtonUpSignal
                    },
                    enumerable: !0,
                    configurable: !0
                }), t.prototype.init = function() {
                    this.createGraphics(), this.updateGraphicsContainerTransform(), this.checkOpenedState()
                }, t.prototype.setGivenStars = function(t) {
                    this.starsBlock.setStarsCount(t)
                }, t.prototype.setOpenedState = function(t) {
                    this.isOpened = t, this.checkOpenedState()
                }, t.prototype.dispose = function() {
                    this.isDisposed || (this.disposeSignals(), this.disposeDigitsBlock(), this.disposeStars(), this.disposeButtons(), this.disposeGraphicsContainer(), this.resetData(), this.isDisposed = !0)
                }, t.prototype.initData = function() {
                    this.atlasKey = Atlases.GUI_GENERAL, this.onButtonUpSignal = new Phaser.Signal
                }, t.prototype.createGraphics = function() {
                    this.graphicsContainer = this.game.add.group(this.parentContainer), this.createBlockedStateGraphics(), this.createOpenedStateGraphics()
                }, t.prototype.createBlockedStateGraphics = function() {
                    this.blockedStateGraphicsContainer = this.game.add.group(this.graphicsContainer), this.createGraphicImage(-43.25, -43.25, 0, "a_18_mb_b_s_agp_p10000", this.blockedStateGraphicsContainer)
                }, t.prototype.createOpenedStateGraphics = function() {
                    this.openedStateGraphicsContainer = this.game.add.group(this.graphicsContainer), this.createOpenedStateGraphicsBack(), this.createOpenedStateGraphicsButton(), this.createOpenedStateGraphicsStars(), this.createOpenedStateGraphicsDigits()
                }, t.prototype.createOpenedStateGraphicsBack = function() {
                    var t = this.game.add.group(this.openedStateGraphicsContainer);
                    this.createGraphicImage(-67.15, -97.6, 0, "a_20_mb_o_s_back_agp_p10000", t)
                }, t.prototype.createOpenedStateGraphicsButton = function() {
                    var t = this.game.add.group(this.openedStateGraphicsContainer);
                    this.openedStateButton = this.createGraphicButton(-48.55, -48.55, 0, "a_16_mb_o_s_but_agp_p10000", "a_16_mb_o_s_but_agp_p10001", "a_16_mb_o_s_but_agp_p10002", t), this.openedStateButton.onInputUp.add(this.onMapButtonUp, this)
                }, t.prototype.createOpenedStateGraphicsStars = function() {
                    var t = this.game.add.group(this.openedStateGraphicsContainer);
                    this.starsBlock = new o(this.game, t, 1, -73.7, 0)
                }, t.prototype.createOpenedStateGraphicsDigits = function() {
                    var t = this.game.add.group(this.openedStateGraphicsContainer);
                    this.digitsBlock = new i(this.game, t, 0, 0, 0), this.digitsBlock.setNumber(this.levelId)
                }, t.prototype.createGraphicImage = function(t, e, i, s, o, n, a) {
                    void 0 === n && (n = 0), void 0 === a && (a = 0);
                    var r = this.game.add.image(t, e, this.atlasKey, s, o);
                    return r.angle = i, r.anchor = new Phaser.Point(n, a), r
                }, t.prototype.createGraphicButton = function(t, e, i, s, o, n, a, r, h) {
                    void 0 === r && (r = 0), void 0 === h && (h = 0);
                    var l = this.game.add.button(t, e, this.atlasKey, void 0, void 0, o, s, n, s, a);
                    return l.angle = i, l.anchor = new Phaser.Point(r, h), l
                }, t.prototype.updateGraphicsContainerTransform = function() {
                    this.graphicsContainer.x = this.x, this.graphicsContainer.y = this.y, this.graphicsContainer.angle = this.rotation
                }, t.prototype.checkOpenedState = function() {
                    this.blockedStateGraphicsContainer.visible = !this.isOpened, this.openedStateGraphicsContainer.visible = this.isOpened
                }, t.prototype.disposeSignals = function() {
                    null !== this.onButtonUpSignal && this.onButtonUpSignal.removeAll()
                }, t.prototype.disposeDigitsBlock = function() {
                    null !== this.digitsBlock && this.digitsBlock.dispose()
                }, t.prototype.disposeStars = function() {
                    null !== this.starsBlock && this.starsBlock.dispose()
                }, t.prototype.disposeButtons = function() {
                    null !== this.openedStateButton && this.openedStateButton.onInputUp.removeAll()
                }, t.prototype.disposeGraphicsContainer = function() {
                    null != this.graphicsContainer && (this.graphicsContainer.removeAll(!0, !0), null !== this.graphicsContainer.parent && this.graphicsContainer.parent.removeChild(this.graphicsContainer))
                }, t.prototype.resetData = function() {
                    this.isOpened = !1, this.game = null, this.parentContainer = null, this.graphicsContainer = null, this.blockedStateGraphicsContainer = null, this.openedStateGraphicsContainer = null, this.openedStateButton = null, this.starsBlock = null, this.digitsBlock = null, this.x = 0, this.y = 0, this.rotation = 0, this.levelId = 0, this.onButtonUpSignal = null, this.atlasKey = null
                }, t.prototype.onMapButtonUp = function() {
                    if (this.isOpened) {
                        var t = {};
                        t.sender = this, this.onButtonUpSignal.dispatch(t)
                    }
                }, t
            }();
        t.GameMapButtonS = n
    }(t.entities || (t.entities = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(t) {
        ! function(t) {
            t[t.NONE = 0] = "NONE", t[t.IDLE = 1] = "IDLE", t[t.ACCELERATE = 2] = "ACCELERATE", t[t.ACCUMULATE_POWER = 3] = "ACCUMULATE_POWER", t[t.BRAKE = 4] = "BRAKE", t[t.TILT_LEFT = 5] = "TILT_LEFT", t[t.TILT_RIGHT = 6] = "TILT_RIGHT", t[t.ALIVE = 7] = "ALIVE", t[t.DIE = 8] = "DIE", t[t.DEAD = 9] = "DEAD", t[t.DEATH_START = 10] = "DEATH_START", t[t.DEATH_PHYSICS_WAIT = 11] = "DEATH_PHYSICS_WAIT", t[t.DEATH_GRAPHICS_WAIT = 12] = "DEATH_GRAPHICS_WAIT", t[t.DEATH_END = 13] = "DEATH_END"
        }(t.BikeState || (t.BikeState = {}))
    }(t.types || (t.types = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(e) {
        var i;
        ! function(t) {
            t.IDLE = "anim_idle", t.ACCELERATE = "anim_accelerate", t.ACCELERATE_REVERSE = "anim_accelerate_reverse", t.BRAKE = "anim_brake", t.BRAKE_REVERSE = "anim_brake_reverse", t.TILT_LEFT = "anim_tilt_left", t.TILT_LEFT_REVERSE = "anim_tilt_left_reverse", t.TILT_RIGHT = "anim_tilt_right", t.TILT_RIGHT_REVERSE = "anim_tilt_right_reverse", t.DEATH = "anim_death"
        }(i || (i = {}));
        var s;
        ! function(t) {
            t[t.UNKNOWN = 0] = "UNKNOWN", t[t.AT_IDLE = 1] = "AT_IDLE", t[t.ACCELERATING = 2] = "ACCELERATING", t[t.BRAKING = 3] = "BRAKING", t[t.TILTING_LEFT = 4] = "TILTING_LEFT", t[t.TILTING_RIGHT = 5] = "TILTING_RIGHT", t[t.DEATH = 6] = "DEATH"
        }(s || (s = {}));
        var o;
        (o || (o = {})).EXPLOSION = "explosion";
        var n = function() {
            function e(t, e, i, s, o) {
                this.resetData(), this.isDisposed = !1, this.game = t, this.parentContainer = e, this.startPosition = i, this.b2World = s, this.atlasKey = o, this.initData(), this.init()
            }
            return Object.defineProperty(e.prototype, "Body", {
                get: function() {
                    return this.b2Body
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(e.prototype, "Sprite", {
                get: function() {
                    return this.bodyNormalSprite
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(e.prototype, "GraphicsContainer", {
                get: function() {
                    return this.graphicsContainer
                },
                enumerable: !0,
                configurable: !0
            }), e.prototype.playBikerIdle = function() {
                this.isDisposed || !this.isGraphicsEnabled || this.animationTiltingFlag || this.setBikerAnimationState(s.AT_IDLE)
            }, e.prototype.playBikerAccelerate = function() {
                this.isDisposed || !this.isGraphicsEnabled || this.animationTiltingFlag || this.setBikerAnimationState(s.ACCELERATING)
            }, e.prototype.playBikerBrake = function() {
                this.isDisposed || !this.isGraphicsEnabled || this.animationTiltingFlag || this.setBikerAnimationState(s.BRAKING)
            }, e.prototype.playBikerTiltLeft = function() {
                !this.isDisposed && this.isGraphicsEnabled && (this.animationTiltingFlag = !0, this.setBikerAnimationState(s.TILTING_LEFT))
            }, e.prototype.playBikerTiltRight = function() {
                !this.isDisposed && this.isGraphicsEnabled && (this.animationTiltingFlag = !0, this.setBikerAnimationState(s.TILTING_RIGHT))
            }, e.prototype.playBikerNoTilt = function() {
                !this.isDisposed && this.isGraphicsEnabled && this.animationTiltingFlag && (this.animationTiltingFlag = !1, this.setBikerAnimationState(s.AT_IDLE))
            }, e.prototype.updateGraphics = function(t) {
                !this.isDisposed && this.isGraphicsEnabled && (this.checkBikerAnimationState(), this.updateGrpahicPartsPosition())
            }, e.prototype.setActive = function(t) {
                this.isDisposed || this.isActive === t || (this.isActive = t, this.setActiveState(this.isActive))
            }, e.prototype.pauseAnimation = function() {
                !this.isDisposed && this.isGraphicsEnabled && null !== this.bikerSprite.animations.currentAnim && (this.bikerSprite.animations.currentAnim.paused = !0)
            }, e.prototype.resumeAnimation = function() {
                !this.isDisposed && this.isGraphicsEnabled && null !== this.bikerSprite.animations.currentAnim && (this.bikerSprite.animations.currentAnim.paused = !1)
            }, e.prototype.switchToDeathState = function() {
                this.isDisposed || this.deathStateFlag || (this.deathStateFlag = !0, this.createDeathBody(), this.isGraphicsEnabled && (this.switchBikeBodyToDeathState(), this.switchBikerToDeathState(), this.startExplosionAnimation()), this.applyDeathBodyImpulse())
            }, e.prototype.dispose = function() {
                this.isDisposed || (this.disposeGraphics(), this.disposePhysics(), this.resetData(), this.isDisposed = !0)
            }, e.prototype.init = function() {
                this.loadData(), this.createPhysics(), this.isGraphicsEnabled && (this.createGraphics(), this.setBikerAFIMap(), this.createAnimations(), this.updateGrpahicPartsPosition()), this.isActive = !0, this.isGraphicsEnabled && this.setBikerAnimationState(s.AT_IDLE)
            }, e.prototype.initData = function() {
                this.isGraphicsEnabled = t.config.GameConfig.enableGraphics, this.bikerAFIMap = {}
            }, e.prototype.loadData = function() {
                this.animationData = this.game.cache.getJSON(Settings.BikerAnimation)
            }, e.prototype.createPhysics = function() {
                var e = new t.types.GameObjectData;
                e.Type = t.types.GameObjectType.BIKE;
                var i = new Box2D.Dynamics.b2BodyDef;
                i.position.Set(t.tools.Convertor.w_to_ws(this.startPosition.x), t.tools.Convertor.w_to_ws(this.startPosition.y)), i.type = Box2D.Dynamics.b2Body.b2_dynamicBody, i.userData = e, i.angularDamping = 5, i.linearDamping = 1;
                var s = new Box2D.Collision.Shapes.b2PolygonShape;
                s.SetAsBox(t.tools.Convertor.w_to_ws(65), t.tools.Convertor.w_to_ws(15));
                var o = new t.types.GameObjectData;
                o.Type = e.Type, o.EntityCategory = t.types.EntityCategory.BIKE_BODY;
                var n = new Box2D.Dynamics.b2FixtureDef;
                n.density = .01, n.friction = 5, n.restitution = 0, n.shape = s, n.filter.categoryBits = o.EntityCategory, n.filter.maskBits = t.types.EntityCategory.GROUND | t.types.EntityCategory.GAME_OBJECT, n.userData = o;
                var a = new Box2D.Collision.Shapes.b2PolygonShape;
                a.SetAsOrientedBox(t.tools.Convertor.w_to_ws(20), t.tools.Convertor.w_to_ws(7.5), new Box2D.Common.Math.b2Vec2(t.tools.Convertor.w_to_ws(-45.5), t.tools.Convertor.w_to_ws(15)), t.tools.Convertor.deg_to_rad(-72));
                var r = new t.types.GameObjectData;
                r.Type = e.Type, r.EntityCategory = t.types.EntityCategory.BIKE_BODY;
                var h = new Box2D.Dynamics.b2FixtureDef;
                h.density = .01, h.friction = 5, h.restitution = 0, h.shape = a, h.filter.categoryBits = r.EntityCategory, h.filter.maskBits = t.types.EntityCategory.GROUND | t.types.EntityCategory.GAME_OBJECT, h.userData = r;
                var l = new Box2D.Collision.Shapes.b2PolygonShape;
                l.SetAsOrientedBox(t.tools.Convertor.w_to_ws(20), t.tools.Convertor.w_to_ws(7.5), new Box2D.Common.Math.b2Vec2(t.tools.Convertor.w_to_ws(49.5), t.tools.Convertor.w_to_ws(15)), t.tools.Convertor.deg_to_rad(72));
                var c = new t.types.GameObjectData;
                c.Type = e.Type, c.EntityCategory = t.types.EntityCategory.BIKE_BODY;
                var p = new Box2D.Dynamics.b2FixtureDef;
                p.density = .01, p.friction = 5, p.restitution = 0, p.shape = l, p.filter.categoryBits = c.EntityCategory, p.filter.maskBits = t.types.EntityCategory.GROUND | t.types.EntityCategory.GAME_OBJECT, p.userData = c;
                var u = new Box2D.Collision.Shapes.b2PolygonShape;
                u.SetAsOrientedBox(t.tools.Convertor.w_to_ws(67.5), t.tools.Convertor.w_to_ws(10), new Box2D.Common.Math.b2Vec2(0, t.tools.Convertor.w_to_ws(-5)));
                var d = new t.types.GameObjectData;
                d.Type = e.Type, d.EntityCategory = t.types.EntityCategory.BIKE_BODY_SENSOR_BODY;
                var m = new Box2D.Dynamics.b2FixtureDef;
                m.density = 0, m.friction = 0, m.restitution = 0, m.shape = u, m.filter.categoryBits = d.EntityCategory, m.filter.maskBits = t.types.EntityCategory.GROUND | t.types.EntityCategory.GAME_OBJECT, m.userData = d, m.isSensor = !0;
                var y = new Box2D.Collision.Shapes.b2CircleShape(t.tools.Convertor.w_to_ws(27.5));
                y.SetLocalPosition(new Box2D.Common.Math.b2Vec2(t.tools.Convertor.w_to_ws(9.35), t.tools.Convertor.w_to_ws(-63.4)));
                var f = new t.types.GameObjectData;
                f.Type = e.Type, f.EntityCategory = t.types.EntityCategory.BIKE_BODY_SENSOR_HEAD;
                var g = new Box2D.Dynamics.b2FixtureDef;
                g.density = 0, g.friction = 0, g.restitution = 0, g.shape = y, g.filter.categoryBits = f.EntityCategory, g.filter.maskBits = t.types.EntityCategory.GROUND | t.types.EntityCategory.GAME_OBJECT, g.userData = f, g.isSensor = !0, this.b2Body = this.b2World.CreateBody(i), this.b2Body.CreateFixture(n), this.b2Body.CreateFixture(h), this.b2Body.CreateFixture(p), this.b2Body.CreateFixture(m), this.b2Body.CreateFixture(g), this.b2Body.ResetMassData()
            }, e.prototype.createDeathBody = function() {
                var e = this.b2Body.GetPosition().Copy(),
                    i = this.b2Body.GetAngle();
                this.b2Body.SetActive(!1), this.b2World.DestroyBody(this.b2Body);
                var s = new Box2D.Dynamics.b2BodyDef;
                s.position.Set(e.x, e.y), s.angle = i, s.type = Box2D.Dynamics.b2Body.b2_dynamicBody;
                var o = new Box2D.Collision.Shapes.b2PolygonShape;
                o.SetAsBox(t.tools.Convertor.w_to_ws(65), t.tools.Convertor.w_to_ws(15));
                var n = new Box2D.Dynamics.b2FixtureDef;
                n.density = .01, n.friction = 5, n.restitution = .1, n.shape = o, n.filter.categoryBits = t.types.EntityCategory.BIKE_BODY, n.filter.maskBits = t.types.EntityCategory.GROUND | t.types.EntityCategory.GAME_OBJECT | t.types.EntityCategory.BIKE_WHEEL;
                var a = new Box2D.Collision.Shapes.b2PolygonShape;
                a.SetAsOrientedBox(t.tools.Convertor.w_to_ws(20), t.tools.Convertor.w_to_ws(7.5), new Box2D.Common.Math.b2Vec2(t.tools.Convertor.w_to_ws(-45.5), t.tools.Convertor.w_to_ws(15)), t.tools.Convertor.deg_to_rad(-72));
                var r = new Box2D.Dynamics.b2FixtureDef;
                r.density = .01, r.friction = 5, r.restitution = .1, r.shape = a, r.filter.categoryBits = t.types.EntityCategory.BIKE_BODY, r.filter.maskBits = t.types.EntityCategory.GROUND | t.types.EntityCategory.GAME_OBJECT | t.types.EntityCategory.BIKE_WHEEL;
                var h = new Box2D.Collision.Shapes.b2PolygonShape;
                h.SetAsOrientedBox(t.tools.Convertor.w_to_ws(20), t.tools.Convertor.w_to_ws(7.5), new Box2D.Common.Math.b2Vec2(t.tools.Convertor.w_to_ws(49.5), t.tools.Convertor.w_to_ws(15)), t.tools.Convertor.deg_to_rad(72));
                var l = new Box2D.Dynamics.b2FixtureDef;
                l.density = .01, l.friction = 5, l.restitution = .1, l.shape = h, l.filter.categoryBits = t.types.EntityCategory.BIKE_BODY, l.filter.maskBits = t.types.EntityCategory.GROUND | t.types.EntityCategory.GAME_OBJECT | t.types.EntityCategory.BIKE_WHEEL, this.b2Body = this.b2World.CreateBody(s), this.b2Body.CreateFixture(n), this.b2Body.CreateFixture(r), this.b2Body.CreateFixture(l), this.b2Body.ResetMassData()
            }, e.prototype.applyDeathBodyImpulse = function() {
                var e = this.b2Body.GetPosition(),
                    i = t.tools.Convertor.w_to_ws(1),
                    s = new Box2D.Common.Math.b2Vec2;
                s.y = e.y - t.tools.Convertor.w_to_ws(100);
                var o = new Box2D.Common.Math.b2Vec2;
                o.y = i * s.y, this.b2Body.ApplyImpulse(o, e)
            }, e.prototype.createGraphics = function() {
                this.graphicsContainer = this.game.add.group(this.parentContainer), this.createBodyGraphics(), this.createBikerGraphics(), this.createExplosionGraphics()
            }, e.prototype.createBodyGraphics = function() {
                this.bodyRearPointer = this.game.add.group(this.graphicsContainer), this.bodyRearPointer.x = 0, this.bodyRearPointer.y = 60, this.bodyNormalSprite = this.game.add.sprite(0, 0, this.atlasKey, "a_36_bike_body_bike_agp_p10000", this.graphicsContainer), this.bodyNormalSprite.anchor = new Phaser.Point(.48, .22), this.bodyDeathSprite = this.game.add.sprite(0, 0, this.atlasKey, "a_36_bike_body_bike_agp_p10001", this.graphicsContainer), this.bodyDeathSprite.anchor = new Phaser.Point(.48, .22), this.bodyDeathSprite.visible = !1
            }, e.prototype.createBikerGraphics = function() {
                this.bikerSprite = this.game.add.sprite(-60, -96.05, this.atlasKey, "a_39_biker1b_bike_agp_p10000", this.graphicsContainer)
            }, e.prototype.createExplosionGraphics = function() {
                this.explosionSprite = this.game.add.sprite(0, 0, this.atlasKey, "a_40_explosion_bike_agp_p10000", this.graphicsContainer), this.explosionSprite.anchor = new Phaser.Point(.5, .5), this.explosionSprite.visible = !1
            }, e.prototype.createAnimations = function() {
                this.isGraphicsEnabled && (this.createBikerIdleAnimations(), this.createBikerAccelerateAnimations(), this.createBikerBrakeAnimations(), this.createBikerTiltLeftAnimations(), this.createBikerTiltRightAnimations(), this.createExplosionAnimations())
            }, e.prototype.createBikerIdleAnimations = function() {
                var t = this.animationData.states.idle;
                this.bikerSprite.animations.add(i.IDLE, t)
            }, e.prototype.createBikerAccelerateAnimations = function() {
                var t = this.animationData.states.accelerate,
                    e = this.animationData.states.accelerate_reverse;
                this.bikerSprite.animations.add(i.ACCELERATE, t), this.bikerSprite.animations.add(i.ACCELERATE_REVERSE, e)
            }, e.prototype.createBikerBrakeAnimations = function() {
                var t = this.animationData.states.brake,
                    e = this.animationData.states.brake_reverse;
                this.bikerSprite.animations.add(i.BRAKE, t), this.bikerSprite.animations.add(i.BRAKE_REVERSE, e)
            }, e.prototype.createBikerTiltLeftAnimations = function() {
                var t = this.animationData.states.tilt_left,
                    e = this.animationData.states.tilt_left_reverse;
                this.bikerSprite.animations.add(i.TILT_LEFT, t), this.bikerSprite.animations.add(i.TILT_LEFT_REVERSE, e)
            }, e.prototype.createBikerTiltRightAnimations = function() {
                var t = this.animationData.states.tilt_right,
                    e = this.animationData.states.tilt_right_reverse;
                this.bikerSprite.animations.add(i.TILT_RIGHT, t), this.bikerSprite.animations.add(i.TILT_RIGHT_REVERSE, e)
            }, e.prototype.createExplosionAnimations = function() {
                var t = this.animationData.states.explosion;
                this.explosionSprite.animations.add(o.EXPLOSION, t)
            }, e.prototype.checkBikerAnimationState = function() {
                var t = this;
                if (this.isActive && !this.bikerAnimationFlag && this.bikerNextAnimationState !== this.bikerAnimationState && !this.deathStateFlag) {
                    var e = null,
                        o = null,
                        n = null,
                        a = this.bikerAnimationState,
                        r = this.bikerNextAnimationState;
                    a === s.UNKNOWN ? (this.setBikerAnimationIdle(), this.bikerAnimationState = s.AT_IDLE) : a === s.AT_IDLE ? (e = this.getBikerAnimationSetFnNameFromState(r), this.switchToBikerAnimationFromIdle(i.IDLE, function() {
                        t.stopBikerCurrentAnimation(), null !== e && t[e](), t.bikerAnimationState = r
                    })) : (o = this.getBikerAnimationIdFromState(a), n = this.getBikerReverseAnimationIdFromState(a), e = this.getBikerAnimationSetFnNameFromState(r), this.switchToBikerAnimation(o, n, function() {
                        t.stopBikerCurrentAnimation(), null !== e && t[e](), t.bikerAnimationState = r
                    }))
                }
            }, e.prototype.calcReverseAnimStartFrameIndex = function(t, e, i) {
                return void 0 === e && (e = 4), void 0 === i && (i = 12), e - Math.floor(t * (e / i))
            }, e.prototype.switchToBikerAnimationFromIdle = function(t, e) {
                void 0 === e && (e = null), this.bikerAnimationFlag = !0, this.bikerSprite.animations.getAnimation(t).stop(), this.bikerAnimationFlag = !1, e()
            }, e.prototype.switchToBikerAnimation = function(t, e, i) {
                void 0 === i && (i = null), this.bikerAnimationFlag = !0;
                var s = this.bikerSprite.animations.getAnimation(t),
                    o = this.bikerSprite.animations.getAnimation(e),
                    n = s.frame;
                s.stop();
                var a = this.bikerAFIMap[t].frames[n].index,
                    r = this.calcReverseAnimStartFrameIndex(a + 1);
                r < 0 && (r = 0), r >= o.frameTotal && (r = o.frameTotal - 1);
                this.bikerAFIMap[e].indexes[r].frame;
                o.onComplete.addOnce(this.onSwitchToBikerAnimationComplete, this, 0, i), o.play(30), o.paused = !0, o.frame = r, o.paused = !1
            }, e.prototype.switchBikeBodyToDeathState = function() {
                this.bodyNormalSprite.visible = !1, this.bodyDeathSprite.visible = !0
            }, e.prototype.switchBikerToDeathState = function() {
                this.stopBikerCurrentAnimation(), this.bikerSprite.visible = !1
            }, e.prototype.startExplosionAnimation = function() {
                this.explosionSprite.visible = !0, this.explosionSprite.animations.play(o.EXPLOSION, 30, !1, !0)
            }, e.prototype.stopBikerCurrentAnimation = function() {
                null !== this.bikerSprite.animations.currentAnim && this.bikerSprite.animations.currentAnim.stop()
            }, e.prototype.getBikerAnimationIdFromState = function(t) {
                return t === s.AT_IDLE ? i.IDLE : t === s.ACCELERATING ? i.ACCELERATE : t === s.BRAKING ? i.BRAKE : t === s.TILTING_LEFT ? i.TILT_LEFT : t === s.TILTING_RIGHT ? i.TILT_RIGHT : t === s.DEATH ? i.DEATH : null
            }, e.prototype.getBikerReverseAnimationIdFromState = function(t) {
                return t === s.ACCELERATING ? i.ACCELERATE_REVERSE : t === s.BRAKING ? i.BRAKE_REVERSE : t === s.TILTING_LEFT ? i.TILT_LEFT_REVERSE : t === s.TILTING_RIGHT ? i.TILT_RIGHT_REVERSE : null
            }, e.prototype.getBikerAnimationSetFnNameFromState = function(t) {
                return t === s.AT_IDLE ? "setBikerAnimationIdle" : t === s.ACCELERATING ? "setBikerAnimationAccelerate" : t === s.BRAKING ? "setBikerAnimationBrake" : t === s.TILTING_LEFT ? "setBikerAnimationTiltLeft" : t === s.TILTING_RIGHT ? "setBikerAnimationTiltRight" : (s.DEATH, null)
            }, e.prototype.getBikerAnimationSubAnimationIdsFromState = function(t) {
                var e = {};
                if (e.normalId = "", e.reverseId = "", t === s.ACCELERATING) e.normalId = i.ACCELERATE, e.reverseId = i.ACCELERATE_REVERSE;
                else if (t === s.BRAKING) e.normalId = i.BRAKE, e.reverseId = i.BRAKE_REVERSE;
                else if (t === s.TILTING_LEFT) e.normalId = i.TILT_LEFT, e.reverseId = i.TILT_LEFT_REVERSE;
                else {
                    if (t !== s.TILTING_RIGHT) return null;
                    e.normalId = i.TILT_RIGHT, e.reverseId = i.TILT_RIGHT_REVERSE
                }
                return e
            }, e.prototype.setBikerAFIMap = function() {
                var t = this.animationData.states;
                this.setBikerAFIMapItem(this.bikerSprite, this.bikerAFIMap, i.IDLE, t.idle), this.setBikerAFIMapItem(this.bikerSprite, this.bikerAFIMap, i.ACCELERATE, t.accelerate), this.setBikerAFIMapItem(this.bikerSprite, this.bikerAFIMap, i.ACCELERATE_REVERSE, t.accelerate_reverse), this.setBikerAFIMapItem(this.bikerSprite, this.bikerAFIMap, i.BRAKE, t.brake), this.setBikerAFIMapItem(this.bikerSprite, this.bikerAFIMap, i.BRAKE_REVERSE, t.brake_reverse), this.setBikerAFIMapItem(this.bikerSprite, this.bikerAFIMap, i.TILT_LEFT, t.tilt_left), this.setBikerAFIMapItem(this.bikerSprite, this.bikerAFIMap, i.TILT_LEFT_REVERSE, t.tilt_left_reverse), this.setBikerAFIMapItem(this.bikerSprite, this.bikerAFIMap, i.TILT_RIGHT, t.tilt_right), this.setBikerAFIMapItem(this.bikerSprite, this.bikerAFIMap, i.TILT_RIGHT_REVERSE, t.tilt_right_reverse)
            }, e.prototype.setBikerAFIMapItem = function(t, e, i, s) {
                var o = s,
                    n = t.animations.frameData.getFrameIndexes(o, !1),
                    a = 0,
                    r = 0;
                e[i] = {};
                var h = e[i];
                h.frames = {}, h.indexes = {};
                var l = h.frames,
                    c = h.indexes,
                    p = null;
                for (a = 0; a < n.length; a++) p = {
                    frame: r = n[a],
                    index: a
                }, l[r] = p, c[a] = p
            }, e.prototype.setBikerAnimationState = function(t) {
                this.isGraphicsEnabled && this.isActive && (this.bikerNextAnimationState = t)
            }, e.prototype.setBikerAnimationIdle = function() {
                this.bikerSprite.animations.play(i.IDLE, 12, !0)
            }, e.prototype.setBikerAnimationAccelerate = function() {
                this.bikerSprite.animations.play(i.ACCELERATE, 30, !1)
            }, e.prototype.setBikerAnimationBrake = function() {
                this.bikerSprite.animations.play(i.BRAKE, 30, !1)
            }, e.prototype.setBikerAnimationTiltLeft = function() {
                this.bikerSprite.animations.play(i.TILT_LEFT, 30, !1)
            }, e.prototype.setBikerAnimationTiltRight = function() {
                this.bikerSprite.animations.play(i.TILT_RIGHT, 30, !1)
            }, e.prototype.setActiveState = function(t) {
                this.b2Body.SetActive(t)
            }, e.prototype.updateGrpahicPartsPosition = function() {
                var e = this.b2Body.GetWorldCenter();
                this.graphicsContainer.position.x = e.x * t.config.GameConfig.b2WorldScale, this.graphicsContainer.position.y = e.y * t.config.GameConfig.b2WorldScale, this.graphicsContainer.rotation = this.b2Body.GetAngle()
            }, e.prototype.disposeGraphics = function() {
                null !== this.graphicsContainer && (this.graphicsContainer.removeAll(!0, !0), null !== this.graphicsContainer.parent && this.graphicsContainer.parent.removeChild(this.graphicsContainer))
            }, e.prototype.disposePhysics = function() {
                this.b2Body.SetActive(!1), this.b2World.DestroyBody(this.b2Body)
            }, e.prototype.resetData = function() {
                this.b2Body = null, this.b2World = null, this.game = null, this.parentContainer = null, this.graphicsContainer = null, this.startPosition = null, this.bodyNormalSprite = null, this.bodyDeathSprite = null, this.bikerSprite = null, this.explosionSprite = null, this.isActive = !1, this.bikerAnimationState = 0, this.bikerNextAnimationState = 0, this.bikerAnimationAction = 0, this.bikerAnimationFlag = !1, this.animationData = null, this.animationTiltingFlag = !1, this.isGraphicsEnabled = !1, this.bikerAFIMap = null, this.deathStateFlag = !1, this.atlasKey = null
            }, e.prototype.onSwitchToBikerAnimationComplete = function(t, e, i) {
                null !== i && i(), this.bikerAnimationFlag = !1
            }, e
        }();
        e.BikeBodyEntity = n
    }(t.entities || (t.entities = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(e) {
        var i = function() {
            function e(t, e) {
                this.resetData(), this.b2World = t, this.bikeBody = e, this.initData(), this.init(), this.isDisposed = !1
            }
            return Object.defineProperty(e.prototype, "Spring", {
                get: function() {
                    return this.spring
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(e.prototype, "Body", {
                get: function() {
                    return this.b2Body
                },
                enumerable: !0,
                configurable: !0
            }), e.prototype.setActive = function(t) {
                this.isDisposed || this.isActive === t || (this.isActive = t, this.isActive ? this.setActiveState() : this.setInActiveState())
            }, e.prototype.switchToDeathState = function() {
                this.isDisposed || this.deathStateFlag || (this.deathStateFlag = !0, this.b2Body.SetActive(!1), this.b2World.DestroyJoint(this.spring), this.b2World.DestroyBody(this.b2Body), this.spring = null, this.bikeBody = null)
            }, e.prototype.dispose = function() {
                this.isDisposed || (this.disposePhysics(), this.resetData(), this.isDisposed = !0)
            }, e.prototype.initData = function() {
                this.angle = t.tools.Convertor.deg_to_rad(-72)
            }, e.prototype.init = function() {
                this.createPhysics(), this.isActive = !0
            }, e.prototype.createPhysics = function() {
                this.createBody(), this.createSpring()
            }, e.prototype.createBody = function() {
                var e = this.bikeBody.GetPosition(),
                    i = new t.types.GameObjectData;
                i.Type = t.types.GameObjectType.BIKE;
                var s = new Box2D.Dynamics.b2BodyDef;
                s.position.Set(e.x, e.y), s.type = Box2D.Dynamics.b2Body.b2_dynamicBody, s.userData = i, s.angularDamping = .5, s.linearDamping = 0;
                var o = new Box2D.Collision.Shapes.b2PolygonShape;
                o.SetAsOrientedBox(t.tools.Convertor.w_to_ws(20), t.tools.Convertor.w_to_ws(5), new Box2D.Common.Math.b2Vec2(t.tools.Convertor.w_to_ws(-55.75), t.tools.Convertor.w_to_ws(47)), this.angle);
                var n = new t.types.GameObjectData;
                n.Type = i.Type, n.EntityCategory = t.types.EntityCategory.BIKE_AXLE;
                var a = new Box2D.Dynamics.b2FixtureDef;
                a.density = .005, a.friction = 0, a.restitution = 0, a.shape = o, a.filter.categoryBits = n.EntityCategory, a.filter.maskBits = t.types.EntityCategory.GROUND | t.types.EntityCategory.GAME_OBJECT, a.userData = n, this.b2Body = this.b2World.CreateBody(s), this.b2Body.CreateFixture(a), this.b2Body.ResetMassData()
            }, e.prototype.createSpring = function() {
                var e = new Box2D.Dynamics.Joints.b2PrismaticJointDef;
                e.Initialize(this.b2Body, this.bikeBody, this.b2Body.GetWorldCenter(), new Box2D.Common.Math.b2Vec2(Math.cos(this.angle), Math.sin(this.angle))), e.collideConnected = !1, e.lowerTranslation = t.tools.Convertor.w_to_ws(-25), e.upperTranslation = t.tools.Convertor.w_to_ws(5), e.enableLimit = !0, e.enableMotor = !0, this.spring = this.b2World.CreateJoint(e)
            }, e.prototype.setActiveState = function() {
                this.b2Body.SetActive(!0), this.spring.EnableLimit(!0), this.spring.EnableMotor(!0)
            }, e.prototype.setInActiveState = function() {
                this.spring.EnableLimit(!1), this.spring.EnableMotor(!1), this.b2Body.SetActive(!1)
            }, e.prototype.disposePhysics = function() {
                this.deathStateFlag || (this.b2Body.SetActive(!1), this.b2World.DestroyJoint(this.spring), this.b2World.DestroyBody(this.b2Body))
            }, e.prototype.resetData = function() {
                this.b2World = null, this.b2Body = null, this.bikeBody = null, this.spring = null, this.angle = 0, this.isActive = !1, this.deathStateFlag = !1
            }, e
        }();
        e.BikeRearAxleEntity = i
    }(t.entities || (t.entities = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(e) {
        var i = function() {
            function e(t, e) {
                this.resetData(), this.b2World = t, this.bikeBody = e, this.initData(), this.init(), this.isDisposed = !1
            }
            return Object.defineProperty(e.prototype, "Spring", {
                get: function() {
                    return this.spring
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(e.prototype, "Body", {
                get: function() {
                    return this.b2Body
                },
                enumerable: !0,
                configurable: !0
            }), e.prototype.setActive = function(t) {
                this.isDisposed || this.isActive === t || (this.isActive = t, this.isActive ? this.setActiveState() : this.setInActiveState())
            }, e.prototype.switchToDeathState = function() {
                this.isDisposed || this.deathStateFlag || (this.deathStateFlag = !0, this.b2Body.SetActive(!1), this.b2World.DestroyJoint(this.spring), this.b2World.DestroyBody(this.b2Body), this.spring = null, this.bikeBody = null)
            }, e.prototype.dispose = function() {
                this.isDisposed || (this.disposePhysics(), this.resetData(), this.isDisposed = !0)
            }, e.prototype.initData = function() {
                this.angle = t.tools.Convertor.deg_to_rad(72)
            }, e.prototype.init = function() {
                this.createPhysics(), this.isActive = !0
            }, e.prototype.createPhysics = function() {
                this.createBody(), this.createSpring()
            }, e.prototype.createBody = function() {
                var e = this.bikeBody.GetPosition(),
                    i = new t.types.GameObjectData;
                i.Type = t.types.GameObjectType.BIKE;
                var s = new Box2D.Dynamics.b2BodyDef;
                s.position.Set(e.x, e.y), s.type = Box2D.Dynamics.b2Body.b2_dynamicBody, s.userData = i, s.angularDamping = .5, s.linearDamping = 0;
                var o = new Box2D.Collision.Shapes.b2PolygonShape;
                o.SetAsOrientedBox(t.tools.Convertor.w_to_ws(20), t.tools.Convertor.w_to_ws(5), new Box2D.Common.Math.b2Vec2(t.tools.Convertor.w_to_ws(60), t.tools.Convertor.w_to_ws(47)), this.angle);
                var n = new t.types.GameObjectData;
                n.Type = i.Type, n.EntityCategory = t.types.EntityCategory.BIKE_AXLE;
                var a = new Box2D.Dynamics.b2FixtureDef;
                a.density = .005, a.friction = 0, a.restitution = 0, a.shape = o, a.filter.categoryBits = n.EntityCategory, a.filter.maskBits = t.types.EntityCategory.GROUND | t.types.EntityCategory.GAME_OBJECT, a.userData = n, this.b2Body = this.b2World.CreateBody(s), this.b2Body.CreateFixture(a), this.b2Body.ResetMassData()
            }, e.prototype.createSpring = function() {
                var e = new Box2D.Dynamics.Joints.b2PrismaticJointDef;
                e.Initialize(this.b2Body, this.bikeBody, this.b2Body.GetWorldCenter(), new Box2D.Common.Math.b2Vec2(-Math.cos(this.angle), -Math.sin(this.angle))), e.collideConnected = !1, e.lowerTranslation = t.tools.Convertor.w_to_ws(-25), e.upperTranslation = t.tools.Convertor.w_to_ws(5), e.enableLimit = !0, e.enableMotor = !0, this.spring = this.b2World.CreateJoint(e)
            }, e.prototype.setActiveState = function() {
                this.b2Body.SetActive(!0), this.spring.EnableLimit(!0), this.spring.EnableMotor(!0)
            }, e.prototype.setInActiveState = function() {
                this.spring.EnableLimit(!1), this.spring.EnableMotor(!1), this.b2Body.SetActive(!1)
            }, e.prototype.disposePhysics = function() {
                this.deathStateFlag || (this.b2Body.SetActive(!1), this.b2World.DestroyJoint(this.spring), this.b2World.DestroyBody(this.b2Body))
            }, e.prototype.resetData = function() {
                this.b2World = null, this.b2Body = null, this.bikeBody = null, this.spring = null, this.angle = 0, this.isActive = !1, this.deathStateFlag = !1
            }, e
        }();
        e.BikeFrontAxleEntity = i
    }(t.entities || (t.entities = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(e) {
        var i = function() {
            function e(t, e, i, s, o) {
                this.resetData(), this.isDisposed = !1, this.game = t, this.parentContainer = e, this.axleBody = s, this.b2World = i, this.atlasKey = o, this.init()
            }
            return Object.defineProperty(e.prototype, "Motor", {
                get: function() {
                    return this.motor
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(e.prototype, "Body", {
                get: function() {
                    return this.b2Body
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(e.prototype, "GraphicsContainer", {
                get: function() {
                    return this.graphicsContainer
                },
                enumerable: !0,
                configurable: !0
            }), e.prototype.updateGraphics = function(t) {
                !this.isDisposed && this.isGraphicsEnabled && this.updateGrpahicPartsPosition()
            }, e.prototype.setActive = function(t) {
                this.isDisposed || this.isActive === t || this.deathStateFlag || (this.isActive = t, this.setActiveState(this.isActive))
            }, e.prototype.switchToDeathState = function(t) {
                this.isDisposed || this.deathStateFlag || (this.deathStateFlag = !0, this.createDeathBody(), this.applyDeathBodyImpulse(t))
            }, e.prototype.dispose = function() {
                this.isDisposed || (this.disposeGraphics(), this.disposePhysics(), this.resetData(), this.isDisposed = !0)
            }, e.prototype.init = function() {
                this.isGraphicsEnabled = t.config.GameConfig.enableGraphics, this.createPhysics(), this.createGraphics(), this.isGraphicsEnabled && this.updateGrpahicPartsPosition(), this.isActive = !0
            }, e.prototype.createPhysics = function() {
                this.createBody(), this.createMotor()
            }, e.prototype.createBody = function() {
                var e = this.axleBody.GetPosition(),
                    i = new t.types.GameObjectData;
                i.Type = t.types.GameObjectType.BIKE;
                var s = new Box2D.Dynamics.b2BodyDef;
                s.type = Box2D.Dynamics.b2Body.b2_dynamicBody, s.position.Set(e.x + t.tools.Convertor.w_to_ws(-60.4), e.y + t.tools.Convertor.w_to_ws(61.25)), s.allowSleep = !1, s.userData = i, s.angularDamping = .01;
                var o = new Box2D.Collision.Shapes.b2CircleShape(t.tools.Convertor.w_to_ws(30)),
                    n = new t.types.GameObjectData;
                n.Type = i.Type, n.EntityCategory = t.types.EntityCategory.BIKE_WHEEL | t.types.EntityCategory.BIKE_WHEEL_REAR;
                var a = new Box2D.Dynamics.b2FixtureDef;
                a.density = .02, a.friction = 2, a.restitution = 0, a.shape = o, a.filter.categoryBits = n.EntityCategory, a.filter.maskBits = t.types.EntityCategory.GROUND | t.types.EntityCategory.BIKE_WHEEL | t.types.EntityCategory.GAME_OBJECT, a.userData = n, this.b2Body = this.b2World.CreateBody(s), this.b2Body.SetActive(!1), this.b2Body.CreateFixture(a), this.b2Body.ResetMassData(), this.b2Body.SetActive(!0)
            }, e.prototype.createDeathBody = function() {
                var e = this.b2Body.GetPosition().Copy();
                this.b2Body.SetActive(!1), this.b2World.DestroyJoint(this.motor), this.b2World.DestroyBody(this.b2Body), this.motor = null, this.axleBody = null;
                var i = new Box2D.Dynamics.b2BodyDef;
                i.type = Box2D.Dynamics.b2Body.b2_dynamicBody, i.position.Set(e.x, e.y);
                var s = new Box2D.Collision.Shapes.b2CircleShape(t.tools.Convertor.w_to_ws(30)),
                    o = new Box2D.Dynamics.b2FixtureDef;
                o.density = .02, o.friction = 2, o.restitution = .5, o.shape = s, o.filter.categoryBits = t.types.EntityCategory.BIKE_WHEEL | t.types.EntityCategory.BIKE_WHEEL_REAR, o.filter.maskBits = t.types.EntityCategory.GROUND | t.types.EntityCategory.BIKE_WHEEL | t.types.EntityCategory.BIKE_BODY | t.types.EntityCategory.GAME_OBJECT, this.b2Body = this.b2World.CreateBody(i), this.b2Body.SetActive(!1), this.b2Body.CreateFixture(o), this.b2Body.ResetMassData(), this.b2Body.SetActive(!0)
            }, e.prototype.applyDeathBodyImpulse = function(e) {
                var i = e.GetPosition(),
                    s = this.b2Body.GetPosition(),
                    o = t.tools.Convertor.w_to_ws(10),
                    n = new Box2D.Common.Math.b2Vec2;
                n.x = s.x - i.x, n.y = s.y - i.y;
                var a = new Box2D.Common.Math.b2Vec2;
                a.x = o * n.x, a.y = o * n.y, this.b2Body.ApplyImpulse(a, s)
            }, e.prototype.createMotor = function() {
                var t = new Box2D.Dynamics.Joints.b2RevoluteJointDef;
                t.Initialize(this.b2Body, this.axleBody, this.b2Body.GetWorldCenter()), t.collideConnected = !1, t.enableMotor = !0, this.motor = this.b2World.CreateJoint(t)
            }, e.prototype.createGraphics = function() {
                this.isGraphicsEnabled && (this.graphicsContainer = this.game.add.group(this.parentContainer), this.sprite = this.game.add.sprite(0, 0, this.atlasKey, "a_38_rear_wheel_bike_agp_p10000", this.graphicsContainer), this.sprite.anchor = new Phaser.Point(.5, .5))
            }, e.prototype.updateGrpahicPartsPosition = function() {
                var e = this.b2Body.GetWorldCenter();
                this.graphicsContainer.position.x = e.x * t.config.GameConfig.b2WorldScale, this.graphicsContainer.position.y = e.y * t.config.GameConfig.b2WorldScale, this.graphicsContainer.rotation = this.b2Body.GetAngle()
            }, e.prototype.setActiveState = function(t) {
                this.b2Body.SetActive(t), this.motor.EnableMotor(t)
            }, e.prototype.disposeGraphics = function() {
                null !== this.graphicsContainer && (this.graphicsContainer.removeAll(!0, !0), null !== this.graphicsContainer.parent && this.graphicsContainer.parent.removeChild(this.graphicsContainer))
            }, e.prototype.disposePhysics = function() {
                this.b2Body.SetActive(!1), this.deathStateFlag || this.b2World.DestroyJoint(this.motor), this.b2World.DestroyBody(this.b2Body)
            }, e.prototype.resetData = function() {
                this.b2World = null, this.b2Body = null, this.axleBody = null, this.motor = null, this.game = null, this.parentContainer = null, this.graphicsContainer = null, this.sprite = null, this.isActive = !1, this.isGraphicsEnabled = !1, this.deathStateFlag = !1, this.atlasKey = null
            }, e
        }();
        e.BikeRearWheelEntity = i
    }(t.entities || (t.entities = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(e) {
        var i = function() {
            function e(t, e, i, s, o) {
                this.resetData(), this.game = t, this.parentContainer = e, this.axleBody = s, this.b2World = i, this.atlasKey = o, this.init(), this.isDisposed = !1
            }
            return Object.defineProperty(e.prototype, "Motor", {
                get: function() {
                    return this.motor
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(e.prototype, "Body", {
                get: function() {
                    return this.b2Body
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(e.prototype, "GraphicsContainer", {
                get: function() {
                    return this.graphicsContainer
                },
                enumerable: !0,
                configurable: !0
            }), e.prototype.updateGraphics = function(t) {
                !this.isDisposed && this.isGraphicsEnabled && this.updateGrpahicPartsPosition()
            }, e.prototype.setActive = function(t) {
                this.isDisposed || this.isActive === t || (this.isActive = t, this.setActiveState(this.isActive))
            }, e.prototype.switchToDeathState = function(t) {
                this.isDisposed || this.deathStateFlag || (this.deathStateFlag = !0, this.createDeathBody(), this.applyDeathBodyImpulse(t))
            }, e.prototype.dispose = function() {
                this.isDisposed || (this.disposeGraphics(), this.disposePhysics(), this.resetData(), this.isDisposed = !0)
            }, e.prototype.init = function() {
                this.isGraphicsEnabled = t.config.GameConfig.enableGraphics, this.createPhysics(), this.createGraphics(), this.isGraphicsEnabled && this.updateGrpahicPartsPosition(), this.isActive = !0
            }, e.prototype.createPhysics = function() {
                this.createBody(), this.createMotor()
            }, e.prototype.createBody = function() {
                var e = this.axleBody.GetPosition(),
                    i = new t.types.GameObjectData;
                i.Type = t.types.GameObjectType.BIKE;
                var s = new Box2D.Dynamics.b2BodyDef;
                s.type = Box2D.Dynamics.b2Body.b2_dynamicBody, s.position.Set(e.x + t.tools.Convertor.w_to_ws(65), e.y + t.tools.Convertor.w_to_ws(61.25)), s.allowSleep = !1, s.userData = i, s.angularDamping = .01;
                var o = new Box2D.Collision.Shapes.b2CircleShape(t.tools.Convertor.w_to_ws(30)),
                    n = new t.types.GameObjectData;
                n.Type = i.Type, n.EntityCategory = t.types.EntityCategory.BIKE_WHEEL | t.types.EntityCategory.BIKE_WHEEL_FRONT;
                var a = new Box2D.Dynamics.b2FixtureDef;
                a.density = .03, a.friction = 2, a.restitution = 0, a.shape = o, a.filter.categoryBits = n.EntityCategory, a.filter.maskBits = t.types.EntityCategory.GROUND | t.types.EntityCategory.BIKE_WHEEL | t.types.EntityCategory.GAME_OBJECT, a.userData = n, this.b2Body = this.b2World.CreateBody(s), this.b2Body.CreateFixture(a), this.b2Body.ResetMassData()
            }, e.prototype.createDeathBody = function() {
                var e = this.b2Body.GetPosition().Copy();
                this.b2Body.SetActive(!1), this.b2World.DestroyJoint(this.motor), this.b2World.DestroyBody(this.b2Body), this.motor = null, this.axleBody = null;
                var i = new Box2D.Dynamics.b2BodyDef;
                i.type = Box2D.Dynamics.b2Body.b2_dynamicBody, i.position.Set(e.x, e.y);
                var s = new Box2D.Collision.Shapes.b2CircleShape(t.tools.Convertor.w_to_ws(30)),
                    o = new Box2D.Dynamics.b2FixtureDef;
                o.density = .02, o.friction = 2, o.restitution = .5, o.shape = s, o.filter.categoryBits = t.types.EntityCategory.BIKE_WHEEL | t.types.EntityCategory.BIKE_WHEEL_REAR, o.filter.maskBits = t.types.EntityCategory.GROUND | t.types.EntityCategory.BIKE_WHEEL | t.types.EntityCategory.BIKE_BODY | t.types.EntityCategory.GAME_OBJECT, this.b2Body = this.b2World.CreateBody(i), this.b2Body.SetActive(!1), this.b2Body.CreateFixture(o), this.b2Body.ResetMassData(), this.b2Body.SetActive(!0)
            }, e.prototype.applyDeathBodyImpulse = function(e) {
                var i = e.GetPosition(),
                    s = this.b2Body.GetPosition(),
                    o = t.tools.Convertor.w_to_ws(10),
                    n = new Box2D.Common.Math.b2Vec2;
                n.x = s.x - i.x, n.y = s.y - i.y;
                var a = new Box2D.Common.Math.b2Vec2;
                a.x = o * n.x, a.y = o * n.y, this.b2Body.ApplyImpulse(a, s)
            }, e.prototype.createMotor = function() {
                var t = new Box2D.Dynamics.Joints.b2RevoluteJointDef;
                t.Initialize(this.b2Body, this.axleBody, this.b2Body.GetWorldCenter()), t.collideConnected = !1, t.enableMotor = !0, this.motor = this.b2World.CreateJoint(t)
            }, e.prototype.createGraphics = function() {
                this.isGraphicsEnabled && (this.graphicsContainer = this.game.add.group(this.parentContainer), this.sprite = this.game.add.sprite(0, 0, this.atlasKey, "a_37_front_wheel_bike_agp_p10000", this.graphicsContainer), this.sprite.anchor = new Phaser.Point(.5, .5))
            }, e.prototype.updateGrpahicPartsPosition = function() {
                var e = this.b2Body.GetWorldCenter();
                this.graphicsContainer.position.x = e.x * t.config.GameConfig.b2WorldScale, this.graphicsContainer.position.y = e.y * t.config.GameConfig.b2WorldScale, this.graphicsContainer.rotation = this.b2Body.GetAngle()
            }, e.prototype.setActiveState = function(t) {
                this.b2Body.SetActive(t), this.motor.EnableMotor(t)
            }, e.prototype.disposeGraphics = function() {
                null !== this.graphicsContainer && (this.graphicsContainer.removeAll(!0, !0), null !== this.graphicsContainer.parent && this.graphicsContainer.parent.removeChild(this.graphicsContainer))
            }, e.prototype.disposePhysics = function() {
                this.b2Body.SetActive(!1), this.deathStateFlag || this.b2World.DestroyJoint(this.motor), this.b2World.DestroyBody(this.b2Body)
            }, e.prototype.resetData = function() {
                this.b2World = null, this.b2Body = null, this.axleBody = null, this.motor = null, this.game = null, this.parentContainer = null, this.graphicsContainer = null, this.sprite = null, this.isActive = !1, this.isGraphicsEnabled = !1, this.deathStateFlag = !1, this.atlasKey = null
            }, e
        }();
        e.BikeFrontWheelEntity = i
    }(t.entities || (t.entities = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(t) {
        var e = function() {
                function t() {
                    this.resetData(), this.timeAccLimit = 1
                }
                return t.prototype.addReference = function() {
                    this.refCounter += 1, this.timeCounter = 0
                }, t.prototype.subReference = function() {
                    this.refCounter > 0 && (this.refCounter -= 1, this.refCounter <= 0 && (this.timeAcc = 0, this.timeAccFlag = !0))
                }, t.prototype.update = function(t) {
                    this.timeAccFlag && (this.timeAcc += t, this.timeAcc >= this.timeAccLimit && (this.timeAcc = 0, this.timeAccFlag = !1))
                }, t.prototype.isOnAir = function() {
                    return 0 === this.refCounter && !this.timeAccFlag
                }, t.prototype.resetCounters = function() {
                    this.refCounter = 0, this.timeCounter = 0, this.timeAcc = 0, this.timeAccFlag = !1
                }, t.prototype.setTimeCounterLimit = function(t) {
                    this.timeCounterLimit = t
                }, t.prototype.resetData = function() {
                    this.refCounter = 0, this.timeCounter = 0, this.timeCounterLimit = 0, this.timeAccFlag = !1, this.timeAcc = 0, this.timeAccLimit = 0
                }, t
            }(),
            i = function() {
                function t() {
                    this.resetData(), this.isDisposed = !1, this.initData()
                }
                return t.prototype.addRearWheelReference = function() {
                    this.isDisposed || this.addWheelItemReference(this.rearWheelItem)
                }, t.prototype.addFrontWheelReference = function() {
                    this.isDisposed || this.addWheelItemReference(this.frontWheelItem)
                }, t.prototype.subRearWheelReference = function() {
                    this.isDisposed || this.subWheelItemReference(this.rearWheelItem)
                }, t.prototype.subFrontWheelReference = function() {
                    this.isDisposed || this.subWheelItemReference(this.frontWheelItem)
                }, t.prototype.update = function(t) {
                    this.isDisposed || (this.rearWheelItem.update(t), this.frontWheelItem.update(t))
                }, t.prototype.isWheelsOnAir = function() {
                    return !this.isDisposed && (this.rearWheelItem.isOnAir() && this.frontWheelItem.isOnAir())
                }, t.prototype.reset = function() {
                    this.isDisposed || (this.rearWheelItem.resetCounters(), this.frontWheelItem.resetCounters())
                }, t.prototype.dispose = function() {
                    this.isDisposed || (this.resetData(), this.isDisposed = !0)
                }, t.prototype.initData = function() {
                    this.rearWheelItem = new e, this.rearWheelItem.setTimeCounterLimit(30), this.frontWheelItem = new e, this.frontWheelItem.setTimeCounterLimit(30)
                }, t.prototype.addWheelItemReference = function(t) {
                    t.addReference()
                }, t.prototype.subWheelItemReference = function(t) {
                    t.subReference()
                }, t.prototype.resetData = function() {
                    this.rearWheelItem = null, this.frontWheelItem = null
                }, t
            }();
        t.WheelsOnGroundCounter = i
    }(t.entities || (t.entities = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(e) {
        var i = function() {
            function e(e, i, s, o, n) {
                this.wheelsTorqueMin = 0, this.wheelsTorqueMax = .35, this.wheelsTorque = 0, this.isWheelsAtIdleBreaking = !0, this.wheelsAngularDampingMin = 0, this.wheelsAngularDampingMax = .01, this.wheelsAngularVelocityMax = 55, this.isMotorOn = !1, this.isMotorOnAccelerate = !1, this.isMotorOnBrake = !1, this.wheelsSpringValA = .3, this.wheelsSpringValB = .3, this.wheelsSpringValC = 2, this.wheelsSpringValD = 10, this.wheelsSpringValE = .5, this.wheelsSpringValF = 2, this.tiltTorqueMin = 0, this.tiltTorqueMax = .8, this.tiltTorque = 0, this.tiltAngularDampingMin = 0, this.tiltAngularDampingMax = 30, this.isTiltOn = !1, this.isTiltDampingOn = !1, this.isTiltOnLeft = !1, this.isTiltOnRight = !1, this.tiltDir = 0, this.tiltDampingFlag = !1, this.testAngleLimit = t.tools.Convertor.deg_to_rad(360), this.testAngleLimitBack = -t.tools.Convertor.deg_to_rad(360), this.testAngleLimitFront = t.tools.Convertor.deg_to_rad(360), this.testAnglePoint = 0, this.testAngleCheckPoint = 0, this.resetData(), this.isDisposed = !1, this.game = e, this.b2World = i, this.parentContainer = s, this.startPosition = o, this.atlasKey = n, this.initData()
            }
            return Object.defineProperty(e.prototype, "OnBikeDeadSignal", {
                get: function() {
                    return this.onBikeDeadSignal
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(e.prototype, "OnBikeFlipSignal", {
                get: function() {
                    return this.onBikeFlipSignal
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(e.prototype, "OnBikeFalloutSignal", {
                get: function() {
                    return this.onBikeFalloutSignal
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(e.prototype, "BikeBody", {
                get: function() {
                    return this.bikeBody.Body
                },
                enumerable: !0,
                configurable: !0
            }), e.prototype.init = function() {
                this.isGraphicsEnabled && this.createGraphicsContainer(), this.createBikeParts(), this.isGraphicsEnabled && this.updateBikeGraphics(), this.soundManager.playSound(Sounds.BikeEngineIdling, 1, !0)
            }, e.prototype.getBodySprite = function() {
                return this.bikeBody.Sprite
            }, e.prototype.getBodyGraphicsContainer = function() {
                return this.bikeBody.GraphicsContainer
            }, e.prototype.getTrackedObject = function() {
                return this.calcTrackedObjectPosition(), this.trackedObject
            }, e.prototype.getCenterPosition = function() {
                return this.bikeBody.Body.GetWorldCenter()
            }, e.prototype.updateLogic = function(t) {
                this.isAliveState() ? (this.wheelsOnGroundCounter.update(t), this.updateBikeLogic(t), this.checkBikeFallOut(), this.checkBikeFlipLogic(t)) : this.updateDeathBikeLogic(t)
            }, e.prototype.updateGraphics = function(t) {
                this.isGraphicsEnabled && (this.updateBikeGraphics(t), this.calcTrackedObjectPosition())
            }, e.prototype.accelerate = function() {
                this.soundGasFlag || (this.soundGasFlag = !0, this.soundManager.playSound(Sounds.BikeEngineGas)), this.moveState = t.types.BikeState.ACCELERATE
            }, e.prototype.brake = function() {
                this.soundGasFlag || (this.soundGasFlag = !0, this.soundManager.playSound(Sounds.BikeEngineGas)), this.moveState = t.types.BikeState.BRAKE
            }, e.prototype.idle = function() {
                this.soundGasFlag && (this.soundGasFlag = !1), this.moveState = t.types.BikeState.IDLE
            }, e.prototype.tiltLeft = function() {
                this.tiltState = t.types.BikeState.TILT_LEFT
            }, e.prototype.tiltRight = function() {
                this.tiltState = t.types.BikeState.TILT_RIGHT
            }, e.prototype.tiltStop = function() {
                this.tiltState = t.types.BikeState.IDLE
            }, e.prototype.isAlive = function() {
                return !this.isDisposed && this.isAliveState()
            }, e.prototype.die = function() {
                this.isDisposed || this.isAliveState() && (this.soundManager.stopSound(Sounds.BikeEngineIdling), this.soundManager.stopSound(Sounds.BikeEngineGas), this.soundManager.playSound(Sounds.Explosion), this.soundManager.playSound(Sounds.VoiceDeath), this.aliveState = t.types.BikeState.DIE)
            }, e.prototype.muffleEngine = function() {
                this.isDisposed || (this.soundManager.stopSound(Sounds.BikeEngineIdling), this.soundManager.stopSound(Sounds.BikeEngineGas))
            }, e.prototype.pauseAnimation = function() {
                this.isDisposed || this.bikeBody.pauseAnimation()
            }, e.prototype.resumeAnimation = function() {
                this.isDisposed || this.bikeBody.resumeAnimation()
            }, e.prototype.addRearWheelRefCounter = function() {
                this.isDisposed || this.wheelsOnGroundCounter.addRearWheelReference()
            }, e.prototype.addFrontWheelRefCounter = function() {
                this.isDisposed || this.wheelsOnGroundCounter.addFrontWheelReference()
            }, e.prototype.subRearWheelRefCounter = function() {
                this.isDisposed || this.wheelsOnGroundCounter.subRearWheelReference()
            }, e.prototype.subFrontWheelRefCounter = function() {
                this.isDisposed || this.wheelsOnGroundCounter.subFrontWheelReference()
            }, e.prototype.dispose = function() {
                this.isDisposed || (this.soundManager.stopSound(Sounds.BikeEngineGas), this.soundManager.stopSound(Sounds.BikeEngineIdling), this.disposeSignals(), this.disposeWheelsOnGroundCounter(), this.disposeBikeParts(), this.disposeGraphicsContainer(), this.resetData(), this.isDisposed = !0)
            }, e.prototype.initData = function() {
                this.isGraphicsEnabled = t.config.GameConfig.enableGraphics, this.moveState = t.types.BikeState.IDLE, this.tiltState = t.types.BikeState.IDLE, this.aliveState = t.types.BikeState.ALIVE, this.tempPosition = new Box2D.Common.Math.b2Vec2(t.tools.Convertor.w_to_ws(this.startPosition.x), t.tools.Convertor.w_to_ws(this.startPosition.y)), this.onBikeDeadSignal = new Phaser.Signal, this.onBikeFlipSignal = new Phaser.Signal, this.onBikeFalloutSignal = new Phaser.Signal, this.flipAngleLimit = t.tools.Convertor.deg_to_rad(360), this.flipForwardAngleLimit = this.flipAngleLimit, this.flipBackwardAngleLimit = -this.flipAngleLimit, this.wheelsOnGroundCounter = new t.entities.WheelsOnGroundCounter, this.deathStatePhysicsWaitTimeCounterLimit = 5, this.deathStateGraphicsWaitTimeCounterLimit = 2, this.soundManager = BoilerPlate.SoundManager.getInstance(), this.trackedObject = {}, this.trackedObject.x = 0, this.trackedObject.y = 0, this.rearSprite && (this.rearSprite.visible = !0), console.log("flip forward angle limit: " + t.tools.Convertor.rad_to_deg(this.flipForwardAngleLimit)), console.log("flip backward angle limit: " + t.tools.Convertor.rad_to_deg(this.flipBackwardAngleLimit))
            }, e.prototype.createGraphicsContainer = function() {
                this.graphicsContainer = this.game.add.group(this.parentContainer), this.rearSprite = this.game.add.sprite(-165, 60, this.atlasKey, "a_36_bike_body_axle_r_agp_p10000", this.graphicsContainer), this.rearSprite.anchor.set(.1, .9), this.rearSprite.angle = 21
            }, e.prototype.createBikeParts = function() {
                this.createBikeBody(), this.createBikeAxles(), this.createBikeWheels()
            }, e.prototype.createBikeBody = function() {
                this.bikeBody = new t.entities.BikeBodyEntity(this.game, this.graphicsContainer, this.startPosition, this.b2World, this.atlasKey)
            }, e.prototype.createBikeAxles = function() {
                this.bikeRearAxle = new t.entities.BikeRearAxleEntity(this.b2World, this.bikeBody.Body), this.bikeFrontAxle = new t.entities.BikeFrontAxleEntity(this.b2World, this.bikeBody.Body)
            }, e.prototype.createBikeWheels = function() {
                this.bikeRearWheel = new t.entities.BikeRearWheelEntity(this.game, this.graphicsContainer, this.b2World, this.bikeRearAxle.Body, this.atlasKey), this.bikeFrontWheel = new t.entities.BikeFrontWheelEntity(this.game, this.graphicsContainer, this.b2World, this.bikeFrontAxle.Body, this.atlasKey)
            }, e.prototype.calcTrackedObjectPosition = function() {
                var t = this.bikeBody.GraphicsContainer.position,
                    e = this.bikeRearWheel.GraphicsContainer.position,
                    i = this.bikeFrontWheel.GraphicsContainer.position,
                    s = (e.x + t.x + i.x) / 3,
                    o = (e.y + t.y + i.y) / 3;
                this.trackedObject.x = s, this.trackedObject.y = o
            }, e.prototype.updateBikeLogic = function(t) {
                this.updateBikeMotors(), this.updateBikeSprings(), this.updateBikeTilts()
            }, e.prototype.updateDeathBikeLogic = function(e) {
                if (this.aliveState === t.types.BikeState.DIE) this.setBikeDeathStartState();
                else if (this.aliveState === t.types.BikeState.DEATH_START) this.isGraphicsEnabled ? this.setBikeDeathGraphicsWaitState() : this.setBikeDeathPhysicsWaitState();
                else if ((this.aliveState === t.types.BikeState.DEATH_PHYSICS_WAIT || this.aliveState === t.types.BikeState.DEATH_GRAPHICS_WAIT) && (this.countBikeDeathStateWaitTime(e), this.isBikeDeathStateWaitTimeReached())) return void this.setBikeDeathDeadState()
            }, e.prototype.updateBikeMotors = function() {
                var e = this.moveState === t.types.BikeState.ACCELERATE,
                    i = this.moveState === t.types.BikeState.BRAKE;
                if (!e && !i || e && i) {
                    if (this.isMotorOn) {
                        this.isMotorOn = !1, this.isMotorOnAccelerate = !1, this.isMotorOnBrake = !1;
                        s = -this.wheelsTorque;
                        this.wheelsTorque = this.wheelsTorqueMin, this.bikeRearWheel.Body.ApplyTorque(s), this.bikeFrontWheel.Body.ApplyTorque(s)
                    }
                    this.isWheelsAtIdleBreaking || (this.bikeRearWheel.Body.SetAngularDamping(this.wheelsAngularDampingMax), this.bikeFrontWheel.Body.SetAngularDamping(this.wheelsAngularDampingMax), this.isWheelsAtIdleBreaking = !0), this.bikeBody.playBikerIdle()
                } else {
                    if (this.isWheelsAtIdleBreaking && (this.bikeRearWheel.Body.SetAngularDamping(this.wheelsAngularDampingMin), this.bikeFrontWheel.Body.SetAngularDamping(this.wheelsAngularDampingMin), this.isWheelsAtIdleBreaking = !1), e ? this.bikeBody.playBikerAccelerate() : this.bikeBody.playBikerBrake(), this.isMotorOn || (this.isMotorOn = !0, e ? (this.isMotorOnAccelerate = !0, this.isMotorOnBrake = !1, this.wheelsTorque = this.wheelsTorqueMax) : (this.isMotorOnAccelerate = !1, this.isMotorOnBrake = !0, this.wheelsTorque = -this.wheelsTorqueMax), this.bikeRearWheel.Body.ApplyTorque(this.wheelsTorque), this.bikeFrontWheel.Body.ApplyTorque(this.wheelsTorque)), this.isMotorOn && (e && this.isMotorOnBrake || i && this.isMotorOnAccelerate)) {
                        var s = -this.wheelsTorque;
                        e && this.isMotorOnBrake ? (this.isMotorOnAccelerate = !0, this.isMotorOnBrake = !1, this.wheelsTorque = this.wheelsTorqueMax) : i && this.isMotorOnAccelerate && (this.isMotorOnAccelerate = !1, this.isMotorOnBrake = !0, this.wheelsTorque = -this.wheelsTorqueMax), this.bikeRearWheel.Body.ApplyTorque(s), this.bikeFrontWheel.Body.ApplyTorque(s), this.bikeRearWheel.Body.ApplyTorque(this.wheelsTorque), this.bikeFrontWheel.Body.ApplyTorque(this.wheelsTorque)
                    }
                    this.bikeRearWheel.Body.GetAngularVelocity() * this.wheelsTorque < 0 && this.bikeRearWheel.Body.SetAngularVelocity(0), this.bikeFrontWheel.Body.GetAngularVelocity() * this.wheelsTorque < 0 && this.bikeFrontWheel.Body.SetAngularVelocity(0)
                }
                var o = this.bikeRearWheel.Body.GetAngularVelocity(),
                    n = this.bikeFrontWheel.Body.GetAngularVelocity();
                o >= this.wheelsAngularVelocityMax && this.bikeRearWheel.Body.SetAngularVelocity(this.wheelsAngularVelocityMax), o <= -this.wheelsAngularVelocityMax && this.bikeRearWheel.Body.SetAngularVelocity(-this.wheelsAngularVelocityMax), n >= this.wheelsAngularVelocityMax && this.bikeFrontWheel.Body.SetAngularVelocity(this.wheelsAngularVelocityMax), n <= -this.wheelsAngularVelocityMax && this.bikeFrontWheel.Body.SetAngularVelocity(-this.wheelsAngularVelocityMax)
            }, e.prototype.updateBikeSprings = function() {
                this.bikeRearAxle.Spring.SetMaxMotorForce(this.wheelsSpringValA + Math.abs(this.wheelsSpringValC * Math.pow(this.bikeRearAxle.Spring.GetJointTranslation(), this.wheelsSpringValF))), this.bikeRearAxle.Spring.SetMotorSpeed((this.bikeRearAxle.Spring.GetMotorSpeed() - this.wheelsSpringValD * this.bikeRearAxle.Spring.GetJointTranslation()) * this.wheelsSpringValE), this.bikeFrontAxle.Spring.SetMaxMotorForce(this.wheelsSpringValB + Math.abs(this.wheelsSpringValC * Math.pow(this.bikeFrontAxle.Spring.GetJointTranslation(), this.wheelsSpringValF))), this.bikeFrontAxle.Spring.SetMotorSpeed((this.bikeFrontAxle.Spring.GetMotorSpeed() - this.wheelsSpringValD * this.bikeFrontAxle.Spring.GetJointTranslation()) * this.wheelsSpringValE)
            }, e.prototype.updateBikeTilts = function() {
                var e = this.tiltState === t.types.BikeState.TILT_LEFT;
                this.tiltState, t.types.BikeState.TILT_RIGHT;
                this.tiltState === t.types.BikeState.IDLE ? (0 !== this.tiltDir && (this.tiltDir = 0, this.bikeBody.Body.ApplyTorque(-this.tiltTorque), this.tiltTorque = this.tiltTorqueMin), this.isTiltDampingOn || (this.isTiltDampingOn = !0, this.bikeBody.Body.SetAngularDamping(this.tiltAngularDampingMax)), this.bikeBody.playBikerNoTilt()) : (this.isTiltDampingOn && (this.isTiltDampingOn = !1, this.bikeBody.Body.SetAngularDamping(this.tiltAngularDampingMin)), e ? (0 !== this.tiltDir && 1 !== this.tiltDir || (1 === this.tiltDir && this.bikeBody.Body.ApplyTorque(-this.tiltTorque), this.tiltDir = -1, this.tiltTorque = -this.tiltTorqueMax, this.bikeBody.Body.ApplyTorque(this.tiltTorque)), this.bikeBody.Body.GetAngularVelocity() > 0 && this.bikeBody.Body.SetAngularVelocity(0)) : (0 !== this.tiltDir && -1 !== this.tiltDir || (-1 === this.tiltDir && this.bikeBody.Body.ApplyTorque(-this.tiltTorque), this.tiltDir = 1, this.tiltTorque = this.tiltTorqueMax, this.bikeBody.Body.ApplyTorque(this.tiltTorque)), this.bikeBody.Body.GetAngularVelocity() < 0 && this.bikeBody.Body.SetAngularVelocity(0)), e ? this.bikeBody.playBikerTiltLeft() : this.bikeBody.playBikerTiltRight())
            }, e.prototype.updateBikeGraphics = function(t) {
                void 0 === t && (t = 0), this.bikeBody.updateGraphics(t), this.bikeRearWheel.updateGraphics(t), this.bikeFrontWheel.updateGraphics(t);
                var e = this.bikeBody.bodyRearPointer.getBounds(this.bikeBody.GraphicsContainer.parent),
                    i = new Phaser.Point(e.x, e.y),
                    s = new Phaser.Point(this.bikeRearWheel.GraphicsContainer.x, this.bikeRearWheel.GraphicsContainer.y);
                this.rearSprite.x = s.x, this.rearSprite.y = s.y, this.rearSprite.angle = 21 + Phaser.Math.radToDeg(Phaser.Point.angle(i, s))
            }, e.prototype.checkBikeFallOut = function() {
                var e = this.getCenterPosition();
                t.tools.Convertor.ws_to_w(e.y) >= 5e3 && this.onBikeFalloutSignal.dispatch()
            }, e.prototype.checkBikeFlipLogic = function(t) {
                var e = this.bikeBody.Body.GetAngle();
                if (e >= this.testAngleLimitFront ? (this.testAnglePoint = this.testAngleLimitFront, this.testAngleLimitFront += this.testAngleLimit, this.testAngleLimitBack += this.testAngleLimit) : e <= this.testAngleLimitBack && (this.testAnglePoint = this.testAngleLimitBack, this.testAngleLimitFront -= this.testAngleLimit, this.testAngleLimitBack -= this.testAngleLimit), this.wheelsOnGroundCounter.isWheelsOnAir()) this.registerFlipFlag || (this.registerFlipFlag = !0, this.testAngleCheckPoint = this.testAnglePoint);
                else if (this.registerFlipFlag) {
                    this.registerFlipFlag = !1;
                    var i = e - this.testAngleCheckPoint,
                        s = Math.abs(Math.round(i / this.testAngleLimit));
                    s > 0 && this.onBikeFlipSignal.dispatch(s)
                }
            }, e.prototype.isAliveState = function() {
                return this.aliveState === t.types.BikeState.ALIVE
            }, e.prototype.setBikeDeathStartState = function() {
                if (this.aliveState = t.types.BikeState.DEATH_START, this.bikeRearAxle.Spring.SetMaxMotorForce(0), this.bikeRearAxle.Spring.SetMotorSpeed(0), this.bikeFrontAxle.Spring.SetMaxMotorForce(0), this.bikeFrontAxle.Spring.SetMotorSpeed(0), this.bikeRearWheel.Motor.SetMotorSpeed(0), this.bikeRearWheel.Motor.SetMaxMotorTorque(0), this.isTiltOn) {
                    this.isTiltOn = !1;
                    var e = -this.tiltTorque;
                    this.tiltTorque = this.tiltTorqueMin, this.bikeBody.Body.ApplyTorque(e)
                }
                this.bikeRearWheel.setActive(!1), this.bikeFrontWheel.setActive(!1), this.bikeRearAxle.setActive(!1), this.bikeFrontAxle.setActive(!1), this.bikeBody.setActive(!1), this.bikeBody.switchToDeathState(), this.bikeRearWheel.switchToDeathState(this.bikeBody.Body), this.bikeRearAxle.switchToDeathState(), this.bikeFrontWheel.switchToDeathState(this.bikeBody.Body), this.bikeFrontAxle.switchToDeathState(), this.rearSprite.visible = !1
            }, e.prototype.setBikeDeathPhysicsWaitState = function() {
                this.aliveState = t.types.BikeState.DEATH_PHYSICS_WAIT, this.deathStateWaitTimeCounter = this.deathStatePhysicsWaitTimeCounterLimit, this.deathStateWaitTimeMs = 0
            }, e.prototype.setBikeDeathGraphicsWaitState = function() {
                this.aliveState = t.types.BikeState.DEATH_GRAPHICS_WAIT, this.deathStateWaitTimeCounter = this.deathStateGraphicsWaitTimeCounterLimit, this.deathStateWaitTimeMs = 0
            }, e.prototype.setBikeDeathDeadState = function() {
                this.aliveState = t.types.BikeState.DEAD, this.onBikeDeadSignal.dispatch()
            }, e.prototype.setBikeDeadState = function() {
                this.bikeRearAxle.Spring.SetMaxMotorForce(0), this.bikeRearAxle.Spring.SetMotorSpeed(0), this.bikeFrontAxle.Spring.SetMaxMotorForce(0), this.bikeFrontAxle.Spring.SetMotorSpeed(0), this.bikeRearWheel.Motor.SetMotorSpeed(0), this.bikeRearWheel.Motor.SetMaxMotorTorque(0), this.bikeRearWheel.setActive(!1), this.bikeFrontWheel.setActive(!1), this.bikeRearAxle.setActive(!1), this.bikeFrontAxle.setActive(!1), this.bikeBody.setActive(!1), this.aliveState = t.types.BikeState.DEAD, this.onBikeDeadSignal.dispatch()
            }, e.prototype.countBikeDeathStateWaitTime = function(t) {
                0 !== this.deathStateWaitTimeCounter && (this.deathStateWaitTimeMs += t, this.deathStateWaitTimeMs >= 1 && (this.deathStateWaitTimeMs = 0, this.deathStateWaitTimeCounter -= 1), this.deathStateWaitTimeCounter <= 0 && (this.deathStateWaitTimeCounter = 0))
            }, e.prototype.isBikeDeathStateWaitTimeReached = function() {
                return 0 === this.deathStateWaitTimeCounter
            }, e.prototype.stampTempPositionFromBody = function() {
                var t = this.bikeBody.Body.GetPosition();
                this.tempPosition.x = t.x, this.tempPosition.y = t.y
            }, e.prototype.disposeSignals = function() {
                null !== this.onBikeDeadSignal && this.onBikeDeadSignal.removeAll(), null !== this.onBikeFlipSignal && this.onBikeFlipSignal.removeAll(), null !== this.onBikeFalloutSignal && this.onBikeFalloutSignal.removeAll()
            }, e.prototype.disposeWheelsOnGroundCounter = function() {
                null !== this.wheelsOnGroundCounter && this.wheelsOnGroundCounter.dispose()
            }, e.prototype.disposeBikeParts = function() {
                this.disposeBikeWheels(), this.disposeBikeAxles(), this.disposeBikeBody()
            }, e.prototype.disposeBikeWheels = function() {
                this.bikeRearWheel.dispose(), this.bikeFrontWheel.dispose()
            }, e.prototype.disposeBikeAxles = function() {
                this.bikeRearAxle.dispose(), this.bikeFrontAxle.dispose()
            }, e.prototype.disposeBikeBody = function() {
                this.bikeBody.dispose()
            }, e.prototype.disposeGraphicsContainer = function() {
                null !== this.graphicsContainer && (this.graphicsContainer.removeAll(!0, !0), null !== this.graphicsContainer.parent && this.graphicsContainer.parent.removeChild(this.graphicsContainer))
            }, e.prototype.resetData = function() {
                this.isGraphicsEnabled = !1, this.game = null, this.b2World = null, this.parentContainer = null, this.graphicsContainer = null, this.rearSprite = null, this.bikeBody = null, this.bikeRearAxle = null, this.bikeFrontAxle = null, this.bikeRearWheel = null, this.bikeFrontWheel = null, this.moveState = t.types.BikeState.NONE, this.tiltState = t.types.BikeState.NONE, this.aliveState = t.types.BikeState.NONE, this.startPosition = null, this.tempPosition = null, this.onBikeDeadSignal = null, this.onBikeFlipSignal = null, this.onBikeFalloutSignal = null, this.flipAngleLimit = 0, this.flipAngleFlag = !1, this.flipForwardAngleLimit = 0, this.flipBackwardAngleLimit = 0, this.registeredFlips = 0, this.registerFlipFlag = !1, this.wheelsOnGroundCounter = null, this.deathStateWaitTimeMs = 0, this.deathStateWaitTimeCounter = 0, this.deathStatePhysicsWaitTimeCounterLimit = 0, this.deathStateGraphicsWaitTimeCounterLimit = 0, this.soundManager = null, this.soundGasFlag = !1, this.trackedObject = null, this.atlasKey = null
            }, e
        }();
        e.Bike = i
    }(t.game_objects || (t.game_objects = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(e) {
        var i = function() {
            function e() {
                this.worldBounds = new Phaser.Rectangle(0, 0, 0, 0), this.playerStartPosition = new Phaser.Point(0, 0), this.gameDesignWidth = 0, this.gameDesignHeight = 0, this.context2DStartPosition = new Phaser.Point(0, 0), this.levelSet = {}, this.startPartName = "part1"
            }
            return e.prototype.updatePlayerStartPosition = function() {
                var t = 0,
                    e = 0,
                    i = this.levelSet.levels,
                    s = 0,
                    o = i.length,
                    n = 0;
                for (s = 0; s < o; s++) {
                    var a = i[s];
                    a.id === this.startPartName && (t = n + a.playerStartPosition.x, e = a.playerStartPosition.y), n += a.bounds.width
                }
                this.playerStartPosition.x = Math.round(t), this.playerStartPosition.y = Math.round(e), this.context2DStartPosition.x = this.playerStartPosition.x - this.gameDesignWidth / 2, this.context2DStartPosition.y = this.playerStartPosition.y - this.gameDesignHeight + this.gameDesignHeight / 3
            }, e.createFromJSON = function(e, i) {
                var s = new t.settings.GameSettings,
                    o = e.cache.getJSON(i),
                    n = 0,
                    a = 0,
                    r = 0,
                    h = 0,
                    l = o.levels,
                    c = 0,
                    p = l.length,
                    u = s.startPartName,
                    d = 0;
                o.hasOwnProperty("startPartName") && (u = o.startPartName);
                var m = function(t, e) {
                    var i = -1,
                        s = e;
                    return -1 !== (i = s.indexOf(t)) ? (s = s.substr(i + t.length), parseInt(s, 10)) : 0
                };
                for (l.sort(function(t, e) {
                        return m("part", t.id) - m("part", e.id)
                    }), o.levels = l, c = 0; c < p; c++) {
                    var y = l[c];
                    y.id === u && (r = d + y.playerStartPosition.x, h = y.playerStartPosition.y);
                    var f = y.bounds.height;
                    f > a && (a = f), n += y.bounds.width, d += y.bounds.width
                }
                return s.gameDesignWidth = e.width, s.gameDesignHeight = e.height, s.worldBounds.width = Math.ceil(n), s.worldBounds.height = Math.ceil(a), s.playerStartPosition.x = Math.round(r), s.playerStartPosition.y = Math.round(h), s.context2DStartPosition.x = s.playerStartPosition.x - s.gameDesignWidth / 2, s.context2DStartPosition.y = s.playerStartPosition.y - s.gameDesignHeight + s.gameDesignHeight / 3, s.startPartName = u, s.levelSet = o, s
            }, e
        }();
        e.GameSettings = i
    }(t.settings || (t.settings = {}))
}(GameSrc || (GameSrc = {}));
var Levels = function() {
        function t() {}
        return t.TestLevelJSONKey = "test_level", t
    }(),
    GameSrc;
! function(t) {
    ! function(t) {
        ! function(t) {
            t.BOX = "box", t.POINT = "point"
        }(t.PhysicElementType || (t.PhysicElementType = {}))
    }(t.types || (t.types = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(e) {
        var i = function() {
            function e(t, e, i, s) {
                this.resetData(), this.parentContainer = t, this.game = e, this.b2World = i, this.gameSettings = s, this.initData(), this.isDisposed = !1
            }
            return Object.defineProperty(e.prototype, "SignalOnGameObjectCreate", {
                get: function() {
                    return this.signalOnGameObjectCreate
                },
                enumerable: !0,
                configurable: !0
            }), e.prototype.init = function() {
                this.isDisposed || this.isInited || (this.initLevels(), this.isInited = !0)
            }, e.prototype.dispose = function() {
                this.isDisposed || (this.disposeLevels(), this.resetData(), this.isDisposed = !0)
            }, e.prototype.initData = function() {
                this.signalOnGameObjectCreate = new Phaser.Signal
            }, e.prototype.initLevels = function() {
                this.graphicsContainer = this.game.add.group(this.parentContainer);
                var t = this.gameSettings.levelSet.levels,
                    e = t.length,
                    i = 0,
                    s = 0;
                for (i = 0; i < e; i++) {
                    var o = t[i],
                        n = o.bounds.width;
                    this.initLevelPart(o, s, 0), s += n
                }
            }, e.prototype.initLevelPart = function(e, i, s) {
                var o = e.roadPhysicParts,
                    n = e.roadGraphicParts,
                    a = e.gameObjectMarkers,
                    r = 0;
                for (r = 0; r < o.length; r++) this.initRoadPhysicPart(o[r], i, s);
                if (t.config.GameConfig.enableGraphics)
                    for (r = 0; r < n.length; r++) this.initRoadGraphicPart(n[r], i, s);
                for (r = 0; r < a.length; ++r) this.initGameObjectItem(a[r], e, i, s)
            }, e.prototype.initRoadPhysicPart = function(e, i, s) {
                var o = e.points,
                    n = o.length;
                if (!(n < 2)) {
                    var a = o[0],
                        r = o[n - 1],
                        h = n;
                    a.x === r.x && a.y === r.y && (h -= 1);
                    var l = 0,
                        c = t.tools.Convertor.w_to_ws(i) + t.tools.Convertor.w_to_ws(e.x),
                        p = t.tools.Convertor.w_to_ws(s) + t.tools.Convertor.w_to_ws(e.y),
                        u = t.tools.Convertor.deg_to_rad(e.rotation),
                        d = new t.types.GameObjectData;
                    d.Type = t.types.GameObjectType.ROAD_SURFACE, d.PhysicType = t.types.GameObjectPhysicType.STATIC;
                    var m = new Box2D.Dynamics.b2BodyDef;
                    m.type = Box2D.Dynamics.b2Body.b2_staticBody, m.position.Set(c, p), m.userData = d, m.angle = u;
                    var y = this.b2World.CreateBody(m),
                        f = new t.types.GameObjectData;
                    f.Type = d.Type, f.PhysicType = d.PhysicType, f.EntityCategory = t.types.EntityCategory.GROUND;
                    var g = new Box2D.Dynamics.b2FixtureDef;
                    g.density = 1, g.friction = 3, g.restitution = 0, g.filter.categoryBits = f.EntityCategory, g.filter.maskBits = t.types.EntityCategory.BIKE_BODY | t.types.EntityCategory.BIKE_AXLE | t.types.EntityCategory.BIKE_WHEEL | t.types.EntityCategory.GAME_OBJECT | t.types.EntityCategory.BIKE_BODY_SENSOR_BODY | t.types.EntityCategory.BIKE_BODY_SENSOR_HEAD, g.userData = f;
                    var _ = [];
                    for (l = 0; l < h; l++) {
                        var v = o[l],
                            b = new poly2tri.Point(t.tools.Convertor.w_to_ws(v.x), t.tools.Convertor.w_to_ws(v.y));
                        _.push(b)
                    }
                    var x = new poly2tri.SweepContext(_);
                    x.triangulate();
                    var C = x.getTriangles(),
                        S = new Box2D.Common.Math.b2Vec2,
                        w = new Box2D.Common.Math.b2Vec2,
                        A = new Box2D.Common.Math.b2Vec2,
                        T = null;
                    for (l = 0; l < C.length; l++) {
                        var B = C[l].getPoints();
                        S = new Box2D.Common.Math.b2Vec2(B[0].x, B[0].y), w = new Box2D.Common.Math.b2Vec2(B[1].x, B[1].y), A = new Box2D.Common.Math.b2Vec2(B[2].x, B[2].y), (T = new Box2D.Collision.Shapes.b2PolygonShape).SetAsArray([S, w, A]), g.shape = T, y.CreateFixture(g)
                    }
                }
            }, e.prototype.initGameObjectItem = function(t, e, i, s) {
                var o = t;
                o.levelPartId = e.id, this.signalOnGameObjectCreate.dispatch(o, i, s)
            }, e.prototype.initRoadGraphicPart = function(t, e, i) {
                var s = e + t.x,
                    o = i + t.y,
                    n = t.rotation,
                    a = t.parts,
                    r = a.length,
                    h = 0,
                    l = this.game.add.group(this.graphicsContainer);
                for (l.position.set(s, o), l.angle = n, h = 0; h < r; h++) {
                    var c = a[h];
                    this.initRoadGraphicPartItem(c, l)
                }
            }, e.prototype.initRoadGraphicPartItem = function(e, i) {
                var s = e.x,
                    o = e.y,
                    n = e.rotation,
                    a = e.atlasKey,
                    r = this.game.add.image(s, o, t.settings.GameCommonSettings.getGameLevelStartUpAtlasKey(), a);
                r.angle = n, i.add(r)
            }, e.prototype.disposeLevels = function() {
                this.disposeGraphics(), this.disposePhysics()
            }, e.prototype.disposeGraphics = function() {
                null !== this.graphicsContainer && (this.graphicsContainer.removeAll(!0, !0), null !== this.graphicsContainer.parent && this.graphicsContainer.parent.removeChild(this.graphicsContainer))
            }, e.prototype.disposePhysics = function() {
                for (var e = this.b2World.GetBodyList(); e; e = e.GetNext()) {
                    var i = e.GetUserData();
                    null != i && i.Type === t.types.GameObjectType.ROAD_SURFACE && (e.SetActive(!1), this.b2World.DestroyBody(e))
                }
            }, e.prototype.resetData = function() {
                this.game = null, this.b2World = null, this.gameSettings = null, this.parentContainer = null, this.graphicsContainer = null, this.signalOnGameObjectCreate = null, this.isInited = !1
            }, e
        }();
        e.LevelController = i
    }(t.controllers || (t.controllers = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(t) {
        var e = function() {
            function t(t, e, i, s, o, n, a) {
                this.resetData(), this.isDisposed = !1, this.game = t, this.parentContainer = e, this.position = new Phaser.Point(0, 0), this.position.x = i, this.position.y = s, this.rotation = o, this.iconId = n, this.atlasKey = a
            }
            return Object.defineProperty(t.prototype, "IconId", {
                get: function() {
                    return this.iconId
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(t.prototype, "Visible", {
                get: function() {
                    return this.isVisible
                },
                set: function(t) {
                    this.setVisibleState(t)
                },
                enumerable: !0,
                configurable: !0
            }), t.prototype.init = function() {
                this.isInited || (this.createGraphicsContainer(), this.createIcon(), this.isInited = !0, this.isVisible = !0)
            }, t.prototype.dispose = function() {
                this.isDisposed || (this.disposeGraphicsContainer(), this.resetData(), this.isDisposed = !0)
            }, t.prototype.createGraphicsContainer = function() {
                this.graphicsContainer = this.game.add.group(this.parentContainer), this.graphicsContainer.position.set(this.position.x, this.position.y), this.graphicsContainer.angle = this.rotation
            }, t.prototype.createIcon = function() {
                this.game.add.image(-86.5, -41.1, this.atlasKey, "a_14_level_t_s_gui_agp_p10000", this.graphicsContainer)
            }, t.prototype.disposeGraphicsContainer = function() {
                null !== this.graphicsContainer && (this.graphicsContainer.removeAll(!0, !0), null !== this.graphicsContainer.parent && this.graphicsContainer.parent.removeChild(this.graphicsContainer))
            }, t.prototype.setVisibleState = function(t) {
                !this.isDisposed && this.isInited && (this.isVisible = t, this.graphicsContainer.visible = this.isVisible)
            }, t.prototype.resetData = function() {
                this.isInited = !1, this.game = null, this.parentContainer = null, this.graphicsContainer = null, this.position = null, this.rotation = 0, this.atlasKey = null, this.isVisible = !1, this.iconId = null
            }, t
        }();
        t.GameLevelIndicatorLabelIconS = e
    }(t.entities || (t.entities = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(t) {
        var e = function() {
            function t(t, e, i, s, o, n, a, r, h, l, c) {
                this.resetData(), this.isDisposed = !1, this.game = t, this.parentContainer = e, this.position = new Phaser.Point(0, 0), this.position.x = i, this.position.y = s, this.rotation = o, this.offsetPosition = new Phaser.Point(0, 0), this.offsetPosition.x = n, this.offsetPosition.y = a, this.offsetRotation = r, this.numberId = h, this.atlasKey = l, this.frameId = c
            }
            return Object.defineProperty(t.prototype, "NumberId", {
                get: function() {
                    return this.numberId
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(t.prototype, "Visible", {
                get: function() {
                    return this.isVisible
                },
                set: function(t) {
                    this.setVisibleState(t)
                },
                enumerable: !0,
                configurable: !0
            }), t.prototype.init = function() {
                this.isInited || (this.createGraphicsContainer(), this.createImage(), this.isInited = !0, this.isVisible = !0)
            }, t.prototype.dispose = function() {
                this.isDisposed || (this.disposeGraphicsContainer(), this.resetData(), this.isDisposed = !0)
            }, t.prototype.createGraphicsContainer = function() {
                this.graphicsContainer = this.game.add.group(this.parentContainer), this.graphicsContainer.position.set(this.position.x, this.position.y), this.graphicsContainer.angle = this.rotation
            }, t.prototype.createImage = function() {
                this.game.add.image(this.offsetPosition.x, this.offsetPosition.y, this.atlasKey, this.frameId, this.graphicsContainer).angle = this.offsetRotation
            }, t.prototype.disposeGraphicsContainer = function() {
                null !== this.graphicsContainer && (this.graphicsContainer.removeAll(!0, !0), null !== this.graphicsContainer.parent && this.graphicsContainer.parent.removeChild(this.graphicsContainer))
            }, t.prototype.setVisibleState = function(t) {
                !this.isDisposed && this.isInited && (this.isVisible = t, this.graphicsContainer.visible = this.isVisible)
            }, t.prototype.resetData = function() {
                this.isInited = !1, this.game = null, this.parentContainer = null, this.graphicsContainer = null, this.position = null, this.offsetPosition = null, this.rotation = 0, this.offsetRotation = 0, this.atlasKey = null, this.isVisible = !1, this.numberId = null, this.frameId = null
            }, t
        }();
        t.GameGUINumberItemS = e
    }(t.entities || (t.entities = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(t) {
        var e = function() {
            function e(t, e, i, s, o, n, a) {
                this.resetData(), this.isDisposed = !1, this.game = t, this.parentContainer = e, this.position = new Phaser.Point(0, 0), this.position.x = i, this.position.y = s, this.rotation = o, this.digitId = n, this.atlasKey = a, this.initData()
            }
            return Object.defineProperty(e.prototype, "DigitId", {
                get: function() {
                    return this.digitId
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(e.prototype, "Visible", {
                get: function() {
                    return this.isVisible
                },
                set: function(t) {
                    this.setVisibleState(t)
                },
                enumerable: !0,
                configurable: !0
            }), e.prototype.init = function() {
                this.isInited || (this.createGraphicsContainer(), this.createNums(), this.isInited = !0, this.isVisible = !0, this._showNumber(0))
            }, e.prototype.showNumber = function(t) {
                this.isDisposed || !this.isInited || t < 0 || t > 9 || this._showNumber(t)
            }, e.prototype.dispose = function() {
                this.isDisposed || (this.disposeNums(), this.disposeGraphicsContainer(), this.resetData(), this.isDisposed = !0)
            }, e.prototype.initData = function() {
                this.numbersList = []
            }, e.prototype.createGraphicsContainer = function() {
                this.graphicsContainer = this.game.add.group(this.parentContainer), this.graphicsContainer.position.set(this.position.x, this.position.y), this.graphicsContainer.angle = this.rotation
            }, e.prototype.createNums = function() {
                var e = this.createNumsList(),
                    i = 0;
                for (i = 0; i < e.length; i++) {
                    var s = e[i],
                        o = new t.GameGUINumberItemS(this.game, this.graphicsContainer, s.x, s.y, s.rotation, s.offsetX, s.offsetY, s.offsetRotation, s.numberId, this.atlasKey, s.frameId);
                    o.init(), o.Visible = !1, this.numbersList.push(o)
                }
                this.prevNum = this.numbersList[0], this.curNum = this.numbersList[0]
            }, e.prototype.createNumsList = function() {
                var t = [];
                return t.push(this.createNumsListItem(0, 0, 0, -18.5, -41.1, 0, "num_0", "a_02_d_s0_gui_agp_p10000")), t.push(this.createNumsListItem(0, 0, 0, -18.5, -41.1, 0, "num_1", "a_03_d_s1_gui_agp_p10000")), t.push(this.createNumsListItem(0, 0, 0, -18.5, -41.1, 0, "num_2", "a_04_d_s2_gui_agp_p10000")), t.push(this.createNumsListItem(0, 0, 0, -18.5, -41.1, 0, "num_3", "a_05_d_s3_gui_agp_p10000")), t.push(this.createNumsListItem(0, 0, 0, -18.5, -41.1, 0, "num_4", "a_06_d_s4_gui_agp_p10000")), t.push(this.createNumsListItem(0, 0, 0, -18.5, -41.1, 0, "num_5", "a_07_d_s5_gui_agp_p10000")), t.push(this.createNumsListItem(0, 0, 0, -18.5, -41.1, 0, "num_6", "a_08_d_s6_gui_agp_p10000")), t.push(this.createNumsListItem(0, 0, 0, -18.5, -41.1, 0, "num_7", "a_09_d_s7_gui_agp_p10000")), t.push(this.createNumsListItem(0, 0, 0, -18.5, -41.1, 0, "num_8", "a_10_d_s8_gui_agp_p10000")), t.push(this.createNumsListItem(0, 0, 0, -18.5, -41.1, 0, "num_9", "a_11_d_s9_gui_agp_p10000")), t
            }, e.prototype.createNumsListItem = function(t, e, i, s, o, n, a, r) {
                var h = {};
                return h.x = t, h.y = e, h.rotation = i, h.offsetX = s, h.offsetY = o, h.offsetRotation = n, h.numberId = a, h.frameId = r, h
            }, e.prototype._showNumber = function(t) {
                this.prevNum.Visible = !1, this.curNum = this.numbersList[t], this.curNum.Visible = !0, this.prevNum = this.numbersList[t]
            }, e.prototype.disposeNums = function() {
                if (null !== this.numbersList) {
                    var t = 0;
                    for (t = 0; t < this.numbersList.length; t++) this.numbersList[t].dispose()
                }
            }, e.prototype.disposeGraphicsContainer = function() {
                null !== this.graphicsContainer && (this.graphicsContainer.removeAll(!0, !0), null !== this.graphicsContainer.parent && this.graphicsContainer.parent.removeChild(this.graphicsContainer))
            }, e.prototype.setVisibleState = function(t) {
                !this.isDisposed && this.isInited && (this.isVisible = t, this.graphicsContainer.visible = this.isVisible)
            }, e.prototype.resetData = function() {
                this.isInited = !1, this.game = null, this.parentContainer = null, this.graphicsContainer = null, this.position = null, this.rotation = 0, this.atlasKey = null, this.isVisible = !1, this.digitId = null, this.numbersList = null, this.prevNum = null, this.curNum = null
            }, e
        }();
        t.GameGUIDigitItemS = e
    }(t.entities || (t.entities = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(t) {
        var e = function() {
            function e(t, e, i, s, o, n, a) {
                this.resetData(), this.isDisposed = !1, this.game = t, this.parentContainer = e, this.position = new Phaser.Point(0, 0), this.position.x = i, this.position.y = s, this.rotation = o, this.blockId = n, this.atlasKey = a
            }
            return Object.defineProperty(e.prototype, "BlockId", {
                get: function() {
                    return this.blockId
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(e.prototype, "Visible", {
                get: function() {
                    return this.isVisible
                },
                set: function(t) {
                    this.setVisibleState(t)
                },
                enumerable: !0,
                configurable: !0
            }), e.prototype.init = function() {
                this.isInited || (this.createGraphicsContainer(), this.createDigits(), this.isInited = !0, this.isVisible = !0)
            }, e.prototype.setNumber = function(t) {
                this.isDisposed || !this.isInited || t < 0 || t > 99 || this._setNumber(t)
            }, e.prototype.dispose = function() {
                this.isDisposed || (this.disposeDigits(), this.disposeGraphicsContainer(), this.resetData(), this.isDisposed = !0)
            }, e.prototype.createGraphicsContainer = function() {
                this.graphicsContainer = this.game.add.group(this.parentContainer), this.graphicsContainer.position.set(this.position.x, this.position.y), this.graphicsContainer.angle = this.rotation
            }, e.prototype.createDigits = function() {
                this.digitDec = this.createDigitItem(-18.5, 0, 0, "digit_1"), this.digitUnit = this.createDigitItem(18.5, 0, 0, "digit_2")
            }, e.prototype.createDigitItem = function(e, i, s, o) {
                var n = new t.GameGUIDigitItemS(this.game, this.graphicsContainer, e, i, s, o, this.atlasKey);
                return n.init(), n
            }, e.prototype._setNumber = function(t) {
                if (t < 10) this.digitDec.showNumber(0), this.digitUnit.showNumber(t);
                else {
                    var e = Math.floor(t / 10),
                        i = t - 10 * e;
                    this.digitDec.showNumber(e), this.digitUnit.showNumber(i)
                }
            }, e.prototype.disposeDigits = function() {
                null !== this.digitDec && this.digitDec.dispose(), null !== this.digitUnit && this.digitUnit.dispose()
            }, e.prototype.disposeGraphicsContainer = function() {
                null !== this.graphicsContainer && (this.graphicsContainer.removeAll(!0, !0), null !== this.graphicsContainer.parent && this.graphicsContainer.parent.removeChild(this.graphicsContainer))
            }, e.prototype.setVisibleState = function(t) {
                !this.isDisposed && this.isInited && (this.isVisible = t, this.graphicsContainer.visible = this.isVisible)
            }, e.prototype.resetData = function() {
                this.isInited = !1, this.game = null, this.parentContainer = null, this.graphicsContainer = null, this.position = null, this.rotation = 0, this.atlasKey = null, this.isVisible = !1, this.blockId = null, this.digitDec = null, this.digitUnit = null
            }, e
        }();
        t.GameLevelIndicatorDigitsBlockS = e
    }(t.entities || (t.entities = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(t) {
        var e = function() {
            function e(t, e, i, s, o, n, a) {
                this.resetData(), this.isDisposed = !1, this.game = t, this.parentContainer = e, this.position = new Phaser.Point(0, 0), this.position.x = i, this.position.y = s, this.rotation = o, this.indicatorId = n, this.atlasKey = a
            }
            return Object.defineProperty(e.prototype, "IndicatorId", {
                get: function() {
                    return this.indicatorId
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(e.prototype, "Visible", {
                get: function() {
                    return this.isVisible
                },
                set: function(t) {
                    this.setVisibleState(t)
                },
                enumerable: !0,
                configurable: !0
            }), e.prototype.init = function() {
                this.isInited || (this.createGraphicsContainer(), this.createContent(), this.isInited = !0, this.isVisible = !0)
            }, e.prototype.showLevel = function(t) {
                !this.isDisposed && this.isInited && this.digitsBlock.setNumber(t)
            }, e.prototype.dispose = function() {
                this.isDisposed || (this.disposeContent(), this.disposeGraphicsContainer(), this.resetData(), this.isDisposed = !0)
            }, e.prototype.createGraphicsContainer = function() {
                this.graphicsContainer = this.game.add.group(this.parentContainer), this.graphicsContainer.position.set(this.position.x, this.position.y), this.graphicsContainer.angle = this.rotation
            }, e.prototype.createContent = function() {
                this.createLabelIcon(), this.createDigitsBlock()
            }, e.prototype.createLabelIcon = function() {
                this.labelIcon = new t.GameLevelIndicatorLabelIconS(this.game, this.graphicsContainer, -36.75, 0, 0, "LabelIcon", this.atlasKey), this.labelIcon.init()
            }, e.prototype.createDigitsBlock = function() {
                this.digitsBlock = new t.GameLevelIndicatorDigitsBlockS(this.game, this.graphicsContainer, 86.25, 0, 0, "DigitsBlock", this.atlasKey), this.digitsBlock.init()
            }, e.prototype.disposeContent = function() {
                this.disposeDigitsBlock(), this.disposeLabelIcon()
            }, e.prototype.disposeLabelIcon = function() {
                null !== this.labelIcon && this.labelIcon.dispose()
            }, e.prototype.disposeDigitsBlock = function() {
                null !== this.digitsBlock && this.digitsBlock.dispose()
            }, e.prototype.disposeGraphicsContainer = function() {
                null !== this.graphicsContainer && (this.graphicsContainer.removeAll(!0, !0), null !== this.graphicsContainer.parent && this.graphicsContainer.parent.removeChild(this.graphicsContainer))
            }, e.prototype.setVisibleState = function(t) {
                !this.isDisposed && this.isInited && (this.isVisible = t, this.graphicsContainer.visible = this.isVisible)
            }, e.prototype.resetData = function() {
                this.isInited = !1, this.game = null, this.parentContainer = null, this.graphicsContainer = null, this.position = null, this.rotation = 0, this.atlasKey = null, this.isVisible = !1, this.indicatorId = null, this.labelIcon = null, this.digitsBlock = null
            }, e
        }();
        t.GameLevelIndicatorS = e
    }(t.entities || (t.entities = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(t) {
        var e = function() {
            function t(t, e, i, s, o, n, a) {
                this.resetData(), this.isDisposed = !1, this.game = t, this.parentContainer = e, this.position = new Phaser.Point(0, 0), this.position.x = i, this.position.y = s, this.rotation = o, this.iconId = n, this.atlasKey = a
            }
            return Object.defineProperty(t.prototype, "IconId", {
                get: function() {
                    return this.iconId
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(t.prototype, "Visible", {
                get: function() {
                    return this.isVisible
                },
                set: function(t) {
                    this.setVisibleState(t)
                },
                enumerable: !0,
                configurable: !0
            }), t.prototype.init = function() {
                this.isInited || (this.createGraphicsContainer(), this.createIcon(), this.isInited = !0, this.isVisible = !0)
            }, t.prototype.dispose = function() {
                this.isDisposed || (this.disposeGraphicsContainer(), this.resetData(), this.isDisposed = !0)
            }, t.prototype.createGraphicsContainer = function() {
                this.graphicsContainer = this.game.add.group(this.parentContainer), this.graphicsContainer.position.set(this.position.x, this.position.y), this.graphicsContainer.angle = this.rotation
            }, t.prototype.createIcon = function() {
                this.game.add.image(-26.75, -31.1, this.atlasKey, "a_01_ico_timer_gui_agp_p10000", this.graphicsContainer)
            }, t.prototype.disposeGraphicsContainer = function() {
                null !== this.graphicsContainer && (this.graphicsContainer.removeAll(!0, !0), null !== this.graphicsContainer.parent && this.graphicsContainer.parent.removeChild(this.graphicsContainer))
            }, t.prototype.setVisibleState = function(t) {
                !this.isDisposed && this.isInited && (this.isVisible = t, this.graphicsContainer.visible = this.isVisible)
            }, t.prototype.resetData = function() {
                this.isInited = !1, this.game = null, this.parentContainer = null, this.graphicsContainer = null, this.position = null, this.rotation = 0, this.atlasKey = null, this.isVisible = !1, this.iconId = null
            }, t
        }();
        t.GameTimerIndicatorTimerIconS = e
    }(t.entities || (t.entities = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(t) {
        var e = function() {
            function e(t, e, i, s, o, n, a) {
                this.resetData(), this.isDisposed = !1, this.game = t, this.parentContainer = e, this.position = new Phaser.Point(0, 0), this.position.x = i, this.position.y = s, this.rotation = o, this.digitId = n, this.atlasKey = a, this.initData()
            }
            return Object.defineProperty(e.prototype, "DigitId", {
                get: function() {
                    return this.digitId
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(e.prototype, "Visible", {
                get: function() {
                    return this.isVisible
                },
                set: function(t) {
                    this.setVisibleState(t)
                },
                enumerable: !0,
                configurable: !0
            }), e.prototype.init = function() {
                this.isInited || (this.createGraphicsContainer(), this.isInited = !0, this.isVisible = !0)
            }, e.prototype.addNewItem = function(e, i, s, o, n, a, r, h) {
                if (this.isDisposed || !this.isInited) return -1;
                var l = new t.GameGUINumberItemS(this.game, this.graphicsContainer, e, i, s, o, n, a, r, this.atlasKey, h);
                return l.init(), l.Visible = !1, this.itemsList.push(l), this.itemsList.length
            }, e.prototype.showItemAtIndex = function(t) {
                this.isDisposed || !this.isInited || t < 0 || t >= this.itemsList.length || this._showItemAtIndex(t)
            }, e.prototype.dispose = function() {
                this.isDisposed || (this.disposeItemsList(), this.disposeGraphicsContainer(), this.resetData(), this.isDisposed = !0)
            }, e.prototype.initData = function() {
                this.itemsList = []
            }, e.prototype.createGraphicsContainer = function() {
                this.graphicsContainer = this.game.add.group(this.parentContainer), this.graphicsContainer.position.set(this.position.x, this.position.y), this.graphicsContainer.angle = this.rotation
            }, e.prototype._showItemAtIndex = function(t) {
                this.curItemsListIndex = t, this.itemsList[this.prevItemsListIndex].Visible = !1, this.itemsList[this.curItemsListIndex].Visible = !0, this.prevItemsListIndex = this.curItemsListIndex
            }, e.prototype.disposeItemsList = function() {
                if (null !== this.itemsList) {
                    var t = 0;
                    for (t = 0; t < this.itemsList.length; t++) this.itemsList[t].dispose()
                }
            }, e.prototype.disposeGraphicsContainer = function() {
                null !== this.graphicsContainer && (this.graphicsContainer.removeAll(!0, !0), null !== this.graphicsContainer.parent && this.graphicsContainer.parent.removeChild(this.graphicsContainer))
            }, e.prototype.setVisibleState = function(t) {
                !this.isDisposed && this.isInited && (this.isVisible = t, this.graphicsContainer.visible = this.isVisible)
            }, e.prototype.resetData = function() {
                this.isInited = !1, this.game = null, this.parentContainer = null, this.graphicsContainer = null, this.position = null, this.rotation = 0, this.atlasKey = null, this.isVisible = !1, this.digitId = null, this.itemsList = null, this.prevItemsListIndex = 0, this.curItemsListIndex = 0
            }, e
        }();
        t.GameGUIDigitCustomItemS = e
    }(t.entities || (t.entities = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(t) {
        var e = function() {
            function e(t, e, i, s, o, n, a) {
                this.resetData(), this.isDisposed = !1, this.game = t, this.parentContainer = e, this.position = new Phaser.Point(0, 0), this.position.x = i, this.position.y = s, this.rotation = o, this.blockId = n, this.atlasKey = a, this.initData()
            }
            return Object.defineProperty(e.prototype, "BlockId", {
                get: function() {
                    return this.blockId
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(e.prototype, "Visible", {
                get: function() {
                    return this.isVisible
                },
                set: function(t) {
                    this.setVisibleState(t)
                },
                enumerable: !0,
                configurable: !0
            }), e.prototype.init = function() {
                this.isInited || (this.createGraphicsContainer(), this.createDigits(), this.isInited = !0, this.isVisible = !0)
            }, e.prototype.showTimerFromMS = function(t) {
                if (!this.isDisposed && this.isInited) {
                    var e = Math.floor(t / 1e3),
                        i = Math.floor((t - 1e3 * e) / 10);
                    e > 99 && (e = 99, i = 99), this.setDigitsValues(e, i)
                }
            }, e.prototype.resetTimer = function() {
                !this.isDisposed && this.isInited && this.setDigitsValues(0, 0)
            }, e.prototype.dispose = function() {
                this.isDisposed || (this.disposeDigits(), this.disposeGraphicsContainer(), this.resetData(), this.isDisposed = !0)
            }, e.prototype.initData = function() {
                this.digitsList = [], this.customDigitsList = []
            }, e.prototype.createGraphicsContainer = function() {
                this.graphicsContainer = this.game.add.group(this.parentContainer), this.graphicsContainer.position.set(this.position.x, this.position.y), this.graphicsContainer.angle = this.rotation
            }, e.prototype.createDigits = function() {
                this.createSecondsDigits(), this.createDotDigit(), this.createTicksDigits()
            }, e.prototype.createSecondsDigits = function() {
                this.digitSecs2 = this.createDigitItem(-60, 0, 0, "digit_seconds_2"), this.digitSecs3 = this.createDigitItem(-23, 0, 0, "digit_seconds_3"), this.digitsList.push(this.digitSecs2), this.digitsList.push(this.digitSecs3)
            }, e.prototype.createDotDigit = function() {
                this.digitDot = this.createCustomDigitItem(8, 0, 0, "digit_dot", 0, 0, 0, -18.5, -41.1, 0, "dot_sym", "a_13_d_s_dot_gui_agp_p10000"), this.customDigitsList.push(this.digitDot)
            }, e.prototype.createTicksDigits = function() {
                this.digitTicks1 = this.createDigitItem(37, 0, 0, "digit_ticks_1"), this.digitTicks2 = this.createDigitItem(70, 0, 0, "digit_ticks_2"), this.digitsList.push(this.digitTicks1), this.digitsList.push(this.digitTicks2)
            }, e.prototype.createDigitItem = function(e, i, s, o) {
                var n = new t.GameGUIDigitItemS(this.game, this.graphicsContainer, e, i, s, o, this.atlasKey);
                return n.init(), n
            }, e.prototype.createCustomDigitItem = function(e, i, s, o, n, a, r, h, l, c, p, u) {
                var d = new t.GameGUIDigitCustomItemS(this.game, this.graphicsContainer, e, i, s, o, this.atlasKey);
                return d.init(), d.addNewItem(n, a, r, h, l, c, p, u), d.showItemAtIndex(0), d
            }, e.prototype.setDigitsValues = function(t, e) {
                this.setDigitItemValue(null, this.digitSecs2, this.digitSecs3, t), this.setDigitItemValue(null, this.digitTicks1, this.digitTicks2, e)
            }, e.prototype.setDigitItemValue = function(t, e, i, s) {
                if (s < 10) null !== t && t.showNumber(0), e.showNumber(0), i.showNumber(s);
                else if (s >= 10 && s < 100) {
                    null !== t && t.showNumber(0);
                    var o = s - 10 * (n = Math.floor(s / 10));
                    e.showNumber(n), i.showNumber(o)
                } else {
                    var n = Math.floor(s / 100),
                        a = s - 100 * n,
                        r = a - 10 * (o = Math.floor(a / 10));
                    null !== t && t.showNumber(n), e.showNumber(o), i.showNumber(r)
                }
            }, e.prototype.disposeDigits = function() {
                var t = 0;
                if (null !== this.digitsList)
                    for (t = 0; t < this.digitsList.length; t++) this.digitsList[t].dispose();
                if (null !== this.customDigitsList)
                    for (t = 0; t < this.customDigitsList.length; t++) this.customDigitsList[t].dispose()
            }, e.prototype.disposeGraphicsContainer = function() {
                null !== this.graphicsContainer && (this.graphicsContainer.removeAll(!0, !0), null !== this.graphicsContainer.parent && this.graphicsContainer.parent.removeChild(this.graphicsContainer))
            }, e.prototype.setVisibleState = function(t) {
                !this.isDisposed && this.isInited && (this.isVisible = t, this.graphicsContainer.visible = this.isVisible)
            }, e.prototype.resetData = function() {
                this.isInited = !1, this.game = null, this.parentContainer = null, this.graphicsContainer = null, this.position = null, this.rotation = 0, this.atlasKey = null, this.isVisible = !1, this.blockId = null, this.digitMinsDec = null, this.digitMinsUnit = null, this.digitSecs2 = null, this.digitSecs3 = null, this.digitTicks1 = null, this.digitTicks2 = null, this.digitColon = null, this.digitDot = null, this.digitsList = null, this.customDigitsList = null
            }, e
        }();
        t.GameTimerIndicatorDigitsBlockS = e
    }(t.entities || (t.entities = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(t) {
        var e = function() {
            function e(t, e, i, s, o, n, a) {
                this.resetData(), this.isDisposed = !1, this.game = t, this.parentContainer = e, this.position = new Phaser.Point(0, 0), this.position.x = i, this.position.y = s, this.rotation = o, this.indicatorId = n, this.atlasKey = a
            }
            return Object.defineProperty(e.prototype, "IndicatorId", {
                get: function() {
                    return this.indicatorId
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(e.prototype, "Visible", {
                get: function() {
                    return this.isVisible
                },
                set: function(t) {
                    this.setVisibleState(t)
                },
                enumerable: !0,
                configurable: !0
            }), e.prototype.init = function() {
                this.isInited || (this.createGraphicsContainer(), this.createContent(), this.isInited = !0, this.isVisible = !0)
            }, e.prototype.showGameTimerFromMS = function(t) {
                !this.isDisposed && this.isInited && this.digitsBlock.showTimerFromMS(t)
            }, e.prototype.resetGameTimer = function() {
                !this.isDisposed && this.isInited && this.digitsBlock.resetTimer()
            }, e.prototype.dispose = function() {
                this.isDisposed || (this.disposeContent(), this.disposeGraphicsContainer(), this.resetData(), this.isDisposed = !0)
            }, e.prototype.createGraphicsContainer = function() {
                this.graphicsContainer = this.game.add.group(this.parentContainer), this.graphicsContainer.position.set(this.position.x, this.position.y), this.graphicsContainer.angle = this.rotation
            }, e.prototype.createContent = function() {
                this.createTimerIcon(), this.createDigitsBlock()
            }, e.prototype.createTimerIcon = function() {
                this.timerIcon = new t.GameTimerIndicatorTimerIconS(this.game, this.graphicsContainer, -111.85, 0, 0, "TimerIcon", this.atlasKey), this.timerIcon.init()
            }, e.prototype.createDigitsBlock = function() {
                this.digitsBlock = new t.GameTimerIndicatorDigitsBlockS(this.game, this.graphicsContainer, 13.15, 0, 0, "DigitsBlock", this.atlasKey), this.digitsBlock.init()
            }, e.prototype.disposeContent = function() {
                this.disposeDigitsBlock(), this.disposeTimerIcon()
            }, e.prototype.disposeTimerIcon = function() {
                null !== this.timerIcon && this.timerIcon.dispose()
            }, e.prototype.disposeDigitsBlock = function() {
                null !== this.digitsBlock && this.digitsBlock.dispose()
            }, e.prototype.disposeGraphicsContainer = function() {
                null !== this.graphicsContainer && (this.graphicsContainer.removeAll(!0, !0), null !== this.graphicsContainer.parent && this.graphicsContainer.parent.removeChild(this.graphicsContainer))
            }, e.prototype.setVisibleState = function(t) {
                !this.isDisposed && this.isInited && (this.isVisible = t, this.graphicsContainer.visible = this.isVisible)
            }, e.prototype.resetData = function() {
                this.isInited = !1, this.game = null, this.parentContainer = null, this.graphicsContainer = null, this.position = null, this.rotation = 0, this.atlasKey = null, this.isVisible = !1, this.indicatorId = null, this.timerIcon = null, this.digitsBlock = null
            }, e
        }();
        t.GameTimerIndicatorS = e
    }(t.entities || (t.entities = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(e) {
        var i = function() {
            function i(t, e, i, s, o, n, a) {
                this.resetData(), this.isDisposed = !1, this.game = t, this.parentContainer = e, this.position = new Phaser.Point(0, 0), this.position.x = i, this.position.y = s, this.rotation = o, this.windowId = n, this.atlasKey = a, this.initData()
            }
            return Object.defineProperty(i.prototype, "WindowId", {
                get: function() {
                    return this.windowId
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(i.prototype, "Visible", {
                get: function() {
                    return this.isVisible
                },
                set: function(t) {
                    this.setVisibleState(t)
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(i.prototype, "OnButtonResumeGameSignal", {
                get: function() {
                    return this.onButtonResumeGameSignal
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(i.prototype, "OnButtonExitGameSignal", {
                get: function() {
                    return this.onButtonExitGameSignal
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(i.prototype, "OnButtonRestartLevelSignal", {
                get: function() {
                    return this.onButtonRestartLevelSignal
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(i.prototype, "OnButtonMusicOnSignal", {
                get: function() {
                    return this.onButtonMusicOnSignal
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(i.prototype, "OnButtonMusicOffSignal", {
                get: function() {
                    return this.onButtonMusicOffSignal
                },
                enumerable: !0,
                configurable: !0
            }), i.prototype.init = function() {
                this.createGraphicsContainer(), this.createContent(), this.isVisible = !0
            }, i.prototype.resize = function() {
                var e = t.config.GameConfig.calcGameScale;
                this.bottomLayer.scale.set(e), this.bottomLayer.y = this.game.height, this.game.height / this.game.width < Constants.GAME_HEIGHT / Constants.GAME_WIDTH ? (this.bottomLayer.x = (this.game.width - Constants.GAME_WIDTH) / 2, this.backgroundScalable.x = -1 * this.bottomLayer.x) : (this.bottomLayer.x = 0, this.backgroundScalable.x = 0), this.backgroundScalable.width = this.game.width / e
            }, i.prototype.dispose = function() {
                this.isDisposed || (this.disposeSignals(), this.disposeContent(), this.disposeGraphicsContainer(), this.resetData(), this.isDisposed = !0)
            }, i.prototype.initData = function() {
                this.isOnMobileDevice = t.config.GameConfig.isOnMobileDevice, this.userProfile = t.settings.UserProfileSettings.getInstance(), this.buttonsList = [], this.onButtonResumeGameSignal = new Phaser.Signal, this.onButtonExitGameSignal = new Phaser.Signal, this.onButtonRestartLevelSignal = new Phaser.Signal, this.onButtonMusicOnSignal = new Phaser.Signal, this.onButtonMusicOffSignal = new Phaser.Signal
            }, i.prototype.createGraphicsContainer = function() {
                this.bottomLayer = this.game.add.group(this.parentContainer), this.bottomLayer.y = this.game.height, this.graphicsContainer = this.game.add.group(this.bottomLayer), this.graphicsContainer.position.set(this.position.x, this.position.y), this.graphicsContainer.angle = this.rotation
            }, i.prototype.createContent = function() {
                this.createBackground(), this.createButtons(), this.createBranding()
            }, i.prototype.createBackground = function() {
                this.backgroundScalable = this.game.add.image(0, -517, this.atlasKey, "a_45_bg_wnd_pf_gui_agp_p10000", this.graphicsContainer), this.backgroundTitle = this.game.add.group(this.graphicsContainer), this.backgroundTitle.position.set(640, -533.1);
                this.game.add.image(-289, -18.9, this.atlasKey, "a_25_title_t_s_wnd_paused_gui_agp_p10000", this.backgroundTitle)
            }, i.prototype.createBranding = function() {
                var t = Fabrique.Branding.getLogoWithLink(this.game, "extreme-bikers");
                t.y = -t.height - 50, this.graphicsContainer.addChild(t)
            }, i.prototype.createButtons = function() {
                this.createNormalButtons(), this.createToggleButtons()
            }, i.prototype.createNormalButtons = function() {
                this.buttonExitGame = this.createButtonItem(210, -257.5, 0, "ExitGame", "a_16_btn_exit_game_wnd_paused_gui_agp_p10000", "a_16_btn_exit_game_wnd_paused_gui_agp_p10001", "a_16_btn_exit_game_wnd_paused_gui_agp_p10002"), this.buttonRestartGame = this.createButtonItem(479, -257.5, 0, "RestartGame", "a_17_btn_game_restart_wnd_paused_gui_agp_p10000", "a_17_btn_game_restart_wnd_paused_gui_agp_p10001", "a_17_btn_game_restart_wnd_paused_gui_agp_p10002"), this.buttonResumeGame = this.createButtonItem(1050, -257.5, 0, "ResumeGame", "a_18_btn_game_resume_wnd_paused_gui_agp_p10000", "a_18_btn_game_resume_wnd_paused_gui_agp_p10001", "a_18_btn_game_resume_wnd_paused_gui_agp_p10002"), this.buttonExitGame.Button.onInputUp.add(this.onButtonExitGame, this), this.buttonRestartGame.Button.onInputUp.add(this.onButtonRestartLevel, this), this.buttonResumeGame.Button.onInputUp.add(this.onButtonResumeGame, this)
            }, i.prototype.createToggleButtons = function() {
                var t = this.createButtonItem(785, -257.5, 0, "MusicOn", "a_20_btn_music_on_wnd_paused_gui_agp_p10000", "a_20_btn_music_on_wnd_paused_gui_agp_p10001", "a_20_btn_music_on_wnd_paused_gui_agp_p10002"),
                    i = this.createButtonItem(785, -257.5, 0, "MusicOff", "a_19_btn_music_off_wnd_paused_gui_agp_p10000", "a_19_btn_music_off_wnd_paused_gui_agp_p10001", "a_19_btn_music_off_wnd_paused_gui_agp_p10002");
                this.toggleButtonMusic = new e.GameGUIToggleButtonS(t, i, e.GameGUIToggleButtonS.STATE_ON), this.toggleButtonMusic.OnButtonOnUpSignal.add(this.onButtonMusicOn, this), this.toggleButtonMusic.OnButtonOffUpSignal.add(this.onButtonMusicOff, this), this.toggleButtonMusic.init(), this.userProfile.IsMusicOn ? this.toggleButtonMusic.on() : this.toggleButtonMusic.off()
            }, i.prototype.createButtonItem = function(t, i, s, o, n, a, r, h) {
                void 0 === h && (h = !0);
                var l = new e.GameGUIButtonS(this.game, this.graphicsContainer, t, i, s, o, this.atlasKey, n, a, r);
                return l.init(), h && this.buttonsList.push(l), l
            }, i.prototype.disposeSignals = function() {
                null !== this.onButtonResumeGameSignal && this.onButtonResumeGameSignal.removeAll(), null !== this.onButtonExitGameSignal && this.onButtonExitGameSignal.removeAll(), null !== this.onButtonRestartLevelSignal && this.onButtonRestartLevelSignal.removeAll(), null !== this.onButtonMusicOnSignal && this.onButtonMusicOnSignal.removeAll(), null !== this.onButtonMusicOffSignal && this.onButtonMusicOffSignal.removeAll()
            }, i.prototype.disposeContent = function() {
                this.disposeButtons()
            }, i.prototype.disposeButtons = function() {
                if (null !== this.toggleButtonMusic && this.toggleButtonMusic.dispose(), null !== this.buttonsList) {
                    var t = 0;
                    for (t = 0; t < this.buttonsList.length; t++) this.buttonsList[t].Button.onInputUp.removeAll(), this.buttonsList[t].dispose();
                    this.buttonsList.length = 0
                }
            }, i.prototype.disposeGraphicsContainer = function() {
                null !== this.bottomLayer && (this.bottomLayer.removeAll(!0, !0), null !== this.bottomLayer.parent && this.bottomLayer.parent.removeChild(this.bottomLayer))
            }, i.prototype.setVisibleState = function(t) {
                this.isDisposed || (this.isVisible = t, this.graphicsContainer.visible = this.isVisible)
            }, i.prototype.resetData = function() {
                this.isOnMobileDevice = !1, this.game = null, this.userProfile = null, this.parentContainer = null, this.graphicsContainer = null, this.bottomLayer = null, this.position = null, this.rotation = 0, this.atlasKey = null, this.isVisible = !1, this.windowId = null, this.backgroundScalable = null, this.backgroundTitle = null, this.buttonsList = null, this.buttonExitGame = null, this.buttonRestartGame = null, this.buttonResumeGame = null, this.toggleButtonMusic = null, this.onButtonResumeGameSignal = null, this.onButtonExitGameSignal = null, this.onButtonRestartLevelSignal = null, this.onButtonMusicOnSignal = null, this.onButtonMusicOffSignal = null
            }, i.prototype.onButtonResumeGame = function() {
                this.onButtonResumeGameSignal.dispatch()
            }, i.prototype.onButtonExitGame = function() {
                this.onButtonExitGameSignal.dispatch()
            }, i.prototype.onButtonRestartLevel = function() {
                this.onButtonRestartLevelSignal.dispatch()
            }, i.prototype.onButtonMusicOn = function() {
                this.onButtonMusicOnSignal.dispatch()
            }, i.prototype.onButtonMusicOff = function() {
                this.onButtonMusicOffSignal.dispatch()
            }, i
        }();
        e.GameWindowGamePausedS = i
    }(t.entities || (t.entities = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(t) {
        var e = function() {
            function t(t, e, i, s, o, n, a, r) {
                this.resetData(), this.isDisposed = !1, this.game = t, this.parentContainer = e, this.atlasKey = i, this.passedSeconds = s, this.x = o, this.y = n, this.starAnimEffectId = a, this.delayBefore = r, this.initData()
            }
            return Object.defineProperty(t.prototype, "OnStarAnimationComplete", {
                get: function() {
                    return this.onStarAnimationComplete
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(t.prototype, "Visible", {
                get: function() {
                    return this.visible
                },
                set: function(t) {
                    this.isDisposed || (this.visible = t, this.checkVisibleState())
                },
                enumerable: !0,
                configurable: !0
            }), t.prototype.init = function() {
                this.createGraphicsContainer(), this.createContent(), this.visible = !0
            }, t.prototype.startAnimation = function() {
                this.prepareAnimation(), this._startAnimation()
            }, t.prototype.dispose = function() {
                this.isDisposed || (this.disposeTweensList(), this.disposeGraphicsContainer(), this.resetData(), this.isDisposed = !0)
            }, t.prototype.initData = function() {
                this.onStarAnimationComplete = new Phaser.Signal, this.onStarCraterGlowTweenCompleteCounter = 2, this.onStarItemTweenCompleteCounter = 2, this.starCraterSparkImgList = [], this.tweensList = []
            }, t.prototype.createGraphicsContainer = function() {
                this.graphicsContainer = this.game.add.group(this.parentContainer), this.graphicsContainer.position.set(this.x, this.y)
            }, t.prototype.createContent = function() {
                this.createStar()
            }, t.prototype.createStar = function() {
                this.createStarCraterGlow(), this.createStarCraterSparks(), this.createStarContainer(), this.createStarImage(), this.createStarBlinkSprite()
            }, t.prototype.createStarCraterGlow = function() {
                this.starCraterGlowImg = this.game.add.image(-6, 6, this.atlasKey, "a_32_anim_star_wnd_finished_gui_agp_p20000", this.graphicsContainer), this.starCraterGlowImg.anchor = new Phaser.Point(.5, .5), this.starCraterGlowImg.visible = !1
            }, t.prototype.createStarCraterSparks = function() {
                this.starCraterSparkImgList.push(this.createStarCraterSpark(-20.65, -5.75, 0)), this.starCraterSparkImgList.push(this.createStarCraterSpark(4.8, -2.5, 128.3)), this.starCraterSparkImgList.push(this.createStarCraterSpark(8.9, 28.75, -131.34)), this.starCraterSparkImgList.push(this.createStarCraterSpark(-10.9, 33.3, -93.03)), this.starCraterSparkImgList.push(this.createStarCraterSpark(-30.8, 24.35, -71.7));
                var t = 0;
                for (t = 0; t < this.starCraterSparkImgList.length; t++) this.starCraterSparkImgList[t].visible = !1
            }, t.prototype.createStarCraterSpark = function(t, e, i) {
                var s = this.game.add.image(t, e, this.atlasKey, "a_15_anim_star_wnd_finished_gui_agp_p30000", this.graphicsContainer);
                return s.anchor = new Phaser.Point(.34, .39), s.angle = i, s
            }, t.prototype.createStarContainer = function() {
                this.starContainer = this.game.add.group(this.graphicsContainer), this.starContainer.scale.set(.75, .75)
            }, t.prototype.createStarImage = function() {
                this.starImg = this.game.add.image(0, 0, this.atlasKey, "a_33_anim_star_wnd_finished_gui_agp_p40000", this.starContainer), this.starImg.anchor = new Phaser.Point(.5, .5)
            }, t.prototype.createStarBlinkSprite = function() {
                this.starBlinkSpr = this.game.add.sprite(0, 0, this.atlasKey, "a_34_anim_star_wnd_finished_gui_agp_p50000", this.starContainer), this.starBlinkSpr.anchor = new Phaser.Point(.5, .5), this.starBlinkSpr.animations.add("star_blink_anim", ["a_34_anim_star_wnd_finished_gui_agp_p50000", "a_34_anim_star_wnd_finished_gui_agp_p50001", "a_34_anim_star_wnd_finished_gui_agp_p50001", "a_34_anim_star_wnd_finished_gui_agp_p50002", "a_34_anim_star_wnd_finished_gui_agp_p50002", "a_34_anim_star_wnd_finished_gui_agp_p50003", "a_34_anim_star_wnd_finished_gui_agp_p50003", "a_34_anim_star_wnd_finished_gui_agp_p50004", "a_34_anim_star_wnd_finished_gui_agp_p50004", "a_34_anim_star_wnd_finished_gui_agp_p50005", "a_34_anim_star_wnd_finished_gui_agp_p50005", "a_34_anim_star_wnd_finished_gui_agp_p50006", "a_34_anim_star_wnd_finished_gui_agp_p50006", "a_34_anim_star_wnd_finished_gui_agp_p50007", "a_34_anim_star_wnd_finished_gui_agp_p50007", "a_34_anim_star_wnd_finished_gui_agp_p50000", "a_34_anim_star_wnd_finished_gui_agp_p50000", "a_34_anim_star_wnd_finished_gui_agp_p50000", "a_34_anim_star_wnd_finished_gui_agp_p50000", "a_34_anim_star_wnd_finished_gui_agp_p50000", "a_34_anim_star_wnd_finished_gui_agp_p50000", "a_34_anim_star_wnd_finished_gui_agp_p50000", "a_34_anim_star_wnd_finished_gui_agp_p50000", "a_34_anim_star_wnd_finished_gui_agp_p50000", "a_34_anim_star_wnd_finished_gui_agp_p50000", "a_34_anim_star_wnd_finished_gui_agp_p50000", "a_34_anim_star_wnd_finished_gui_agp_p50000", "a_34_anim_star_wnd_finished_gui_agp_p50000", "a_34_anim_star_wnd_finished_gui_agp_p50000", "a_34_anim_star_wnd_finished_gui_agp_p50000", "a_34_anim_star_wnd_finished_gui_agp_p50000", "a_34_anim_star_wnd_finished_gui_agp_p50000", "a_34_anim_star_wnd_finished_gui_agp_p50000", "a_34_anim_star_wnd_finished_gui_agp_p50000", "a_34_anim_star_wnd_finished_gui_agp_p50000", "a_34_anim_star_wnd_finished_gui_agp_p50000", "a_34_anim_star_wnd_finished_gui_agp_p50000", "a_34_anim_star_wnd_finished_gui_agp_p50000", "a_34_anim_star_wnd_finished_gui_agp_p50000", "a_34_anim_star_wnd_finished_gui_agp_p50000", "a_34_anim_star_wnd_finished_gui_agp_p50000", "a_34_anim_star_wnd_finished_gui_agp_p50000", "a_34_anim_star_wnd_finished_gui_agp_p50000", "a_34_anim_star_wnd_finished_gui_agp_p50000", "a_34_anim_star_wnd_finished_gui_agp_p50000", "a_34_anim_star_wnd_finished_gui_agp_p50000", "a_34_anim_star_wnd_finished_gui_agp_p50000", "a_34_anim_star_wnd_finished_gui_agp_p50000", "a_34_anim_star_wnd_finished_gui_agp_p50000", "a_34_anim_star_wnd_finished_gui_agp_p50000", "a_34_anim_star_wnd_finished_gui_agp_p50000", "a_34_anim_star_wnd_finished_gui_agp_p50000", "a_34_anim_star_wnd_finished_gui_agp_p50000", "a_34_anim_star_wnd_finished_gui_agp_p50000", "a_34_anim_star_wnd_finished_gui_agp_p50000", "a_34_anim_star_wnd_finished_gui_agp_p50000", "a_34_anim_star_wnd_finished_gui_agp_p50000", "a_34_anim_star_wnd_finished_gui_agp_p50000", "a_34_anim_star_wnd_finished_gui_agp_p50000", "a_34_anim_star_wnd_finished_gui_agp_p50000"])
            }, t.prototype.prepareAnimation = function() {
                this.prepareStarItemAnimation()
            }, t.prototype.prepareStarItemAnimation = function() {
                var e = 0;
                this.starAnimEffectId === t.STAR_ANIM_EFFECT_LEFT ? e = -170 : this.starAnimEffectId === t.STAR_ANIM_EFFECT_RIGHT && (e = 170), this.starContainer.scale.set(1.25, 1.25), this.starContainer.position.set(e, -138), this.starContainer.alpha = .25, this.onStarItemTweenCompleteCounter = 2
            }, t.prototype._startAnimation = function() {
                this.startStarItemAnimation()
            }, t.prototype.startStarItemAnimation = function() {
                var t = this.game.add.tween(this.starContainer).to({
                        x: 0,
                        y: 0,
                        alpha: 1
                    }, 250, Phaser.Easing.Linear.None, !1),
                    e = this.game.add.tween(this.starContainer.scale).to({
                        x: .75,
                        y: .75
                    }, 250, Phaser.Easing.Linear.None, !1);
                t.onComplete.addOnce(this.onStarItemTween1Complete, this), e.onComplete.addOnce(this.onStarItemTween1Complete, this), t.start(), e.start(), this.tweensList.push(t), this.tweensList.push(e)
            }, t.prototype.startStarGlowAnimation = function() {
                this.starCraterGlowImg.visible = !0, this.onStarCraterGlowTweenCompleteCounter = 2;
                var t = this.game.add.tween(this.starCraterGlowImg.scale).to({
                        x: 1.25,
                        y: 1.25
                    }, 67, Phaser.Easing.Linear.None, !1),
                    e = this.game.add.tween(this.starCraterGlowImg).to({
                        alpha: .75
                    }, 67, Phaser.Easing.Linear.None, !1);
                t.onComplete.addOnce(this.onStarCraterGlowTweenComplete, this), e.onComplete.addOnce(this.onStarCraterGlowTweenComplete, this), t.start(), e.start(), this.tweensList.push(t), this.tweensList.push(e)
            }, t.prototype.startStarCraterSparksAnimation = function() {
                var t = 0;
                for (t = 0; t < this.starCraterSparkImgList.length; t++) this.starCraterSparkImgList[t].visible = !0;
                var e = [{
                    index: 0,
                    onTweenCompleteCounter: 0,
                    tweens: [{
                        duration: 117,
                        properties: {
                            x: -42.15,
                            y: -28.25
                        }
                    }, {
                        key: "scale",
                        duration: 117,
                        properties: {
                            x: .83,
                            y: .83
                        }
                    }],
                    onTweensComplete: {
                        onTweenCompleteCounter: 0,
                        tweens: [{
                            duration: 300,
                            properties: {
                                x: -55.9,
                                y: -31.5,
                                alpha: .64
                            }
                        }, {
                            key: "scale",
                            duration: 300,
                            properties: {
                                x: .38,
                                y: .38
                            }
                        }],
                        onTweensComplete: {
                            instants: [{
                                key: "visible",
                                value: !1
                            }]
                        }
                    }
                }, {
                    index: 1,
                    onTweenCompleteCounter: 0,
                    tweens: [{
                        duration: 117,
                        properties: {
                            x: 26.8,
                            y: -24.5
                        }
                    }, {
                        key: "scale",
                        duration: 117,
                        properties: {
                            x: .75,
                            y: .75
                        }
                    }],
                    onTweensComplete: {
                        onTweenCompleteCounter: 0,
                        tweens: [{
                            duration: 300,
                            properties: {
                                x: 43.65,
                                y: -30.15,
                                alpha: .64
                            }
                        }, {
                            key: "scale",
                            duration: 300,
                            properties: {
                                x: .38,
                                y: .38
                            }
                        }],
                        onTweensComplete: {
                            instants: [{
                                key: "visible",
                                value: !1
                            }]
                        }
                    }
                }, {
                    index: 2,
                    onTweenCompleteCounter: 0,
                    tweens: [{
                        duration: 117,
                        properties: {
                            x: 31.9,
                            y: 41.8
                        }
                    }, {
                        key: "scale",
                        duration: 117,
                        properties: {
                            x: .93,
                            y: .93
                        }
                    }],
                    onTweensComplete: {
                        onTweenCompleteCounter: 0,
                        tweens: [{
                            duration: 300,
                            properties: {
                                x: 40.9,
                                y: 52.15,
                                alpha: .64
                            }
                        }, {
                            key: "scale",
                            duration: 300,
                            properties: {
                                x: .38,
                                y: .38
                            }
                        }],
                        onTweensComplete: {
                            instants: [{
                                key: "visible",
                                value: !1
                            }]
                        }
                    }
                }, {
                    index: 3,
                    onTweenCompleteCounter: 0,
                    tweens: [{
                        duration: 117,
                        properties: {
                            x: -17.6,
                            y: 56.85
                        }
                    }, {
                        key: "scale",
                        duration: 117,
                        properties: {
                            x: .88,
                            y: .88
                        }
                    }],
                    onTweensComplete: {
                        onTweenCompleteCounter: 0,
                        tweens: [{
                            duration: 300,
                            properties: {
                                x: -18.75,
                                y: 71.25,
                                alpha: .64
                            }
                        }, {
                            key: "scale",
                            duration: 300,
                            properties: {
                                x: .38,
                                y: .38
                            }
                        }],
                        onTweensComplete: {
                            instants: [{
                                key: "visible",
                                value: !1
                            }]
                        }
                    }
                }, {
                    index: 4,
                    onTweenCompleteCounter: 0,
                    tweens: [{
                        duration: 117,
                        properties: {
                            x: -57.4,
                            y: 32.8
                        }
                    }, {
                        key: "scale",
                        duration: 117,
                        properties: {
                            x: .69,
                            y: .69
                        }
                    }],
                    onTweensComplete: {
                        onTweenCompleteCounter: 0,
                        tweens: [{
                            duration: 300,
                            properties: {
                                x: -76.8,
                                y: 50.05,
                                alpha: .64
                            }
                        }, {
                            key: "scale",
                            duration: 300,
                            properties: {
                                x: .38,
                                y: .38
                            }
                        }],
                        onTweensComplete: {
                            instants: [{
                                key: "visible",
                                value: !1
                            }]
                        }
                    }
                }];
                for (t = 0; t < e.length; t++) this.startStarCraterSparkAnimation(e[t])
            }, t.prototype.startStarCraterSparkAnimation = function(t) {
                var e = this.starCraterSparkImgList[t.index];
                this.continueStarCraterSparkAnimation(e, t)
            }, t.prototype.startStarCraterSparkInstants = function(t, e) {
                var i = e.instants,
                    s = 0;
                for (s = 0; s < i.length; s++) {
                    var o = i[s];
                    t[o.key] = o.value
                }
                e.hasOwnProperty("onInstantsComplete") && this.continueStarCraterSparkAnimation(t, e.onInstantsComplete)
            }, t.prototype.startStarCraterSparkTweens = function(t, e) {
                var i = e.tweens;
                e.onTweenCompleteCounter = i.length;
                var s = e.hasOwnProperty("onTweensComplete"),
                    o = 0;
                for (o = 0; o < i.length; o++) {
                    var n = i[o],
                        a = n.hasOwnProperty("key") ? n.key : "",
                        r = a.length > 0 ? t[a] : t,
                        h = n.hasOwnProperty("delayBefore") ? n.delayBefore : 0,
                        l = this.game.add.tween(r).to(n.properties, n.duration, Phaser.Easing.Linear.None, !1, h);
                    s && l.onComplete.addOnce(this.onStarCraterSparkTweenComplete, this, 0, t, e, e.onTweensComplete), l.start(), this.tweensList.push(l)
                }
            }, t.prototype.continueStarCraterSparkAnimation = function(t, e) {
                e.hasOwnProperty("instants") && this.startStarCraterSparkInstants(t, e), e.hasOwnProperty("tweens") && this.startStarCraterSparkTweens(t, e)
            }, t.prototype.checkVisibleState = function() {
                this.graphicsContainer.visible = this.visible
            }, t.prototype.onStarCraterSparkTweenComplete = function(t, e, i, s, o) {
                s.onTweenCompleteCounter--, s.onTweenCompleteCounter > 0 || this.continueStarCraterSparkAnimation(i, o)
            }, t.prototype.onStarItemTween1Complete = function() {
                if (!(--this.onStarItemTweenCompleteCounter > 0)) {
                    this.onStarItemTweenCompleteCounter = 1;
                    var t = this.game.add.tween(this.starContainer.scale).to({
                        x: .66,
                        y: .66
                    }, 50, Phaser.Easing.Linear.None, !1).to({
                        x: .75,
                        y: .75
                    }, 50, Phaser.Easing.Linear.None, !1);
                    t.onComplete.addOnce(this.onStarItemTween2Complete, this), t.start(), this.tweensList.push(t)
                }
            }, t.prototype.onStarItemTween2Complete = function() {
                --this.onStarItemTweenCompleteCounter > 0 || (this.startStarGlowAnimation(), this.startStarCraterSparksAnimation(), this.onStarAnimationComplete.dispatch())
            }, t.prototype.onStarCraterGlowTweenComplete = function() {
                --this.onStarCraterGlowTweenCompleteCounter > 0 || (this.starCraterGlowImg.visible = !1, this.starBlinkSpr.animations.play("star_blink_anim", 30, !0))
            }, t.prototype.disposeSignals = function() {
                null !== this.onStarAnimationComplete && this.onStarAnimationComplete.removeAll()
            }, t.prototype.disposeGraphicsContainer = function() {
                null !== this.graphicsContainer && (this.graphicsContainer.removeAll(!0, !0), null !== this.graphicsContainer.parent && this.graphicsContainer.parent.removeChild(this.graphicsContainer))
            }, t.prototype.disposeTweensList = function() {
                if (null !== this.tweensList) {
                    var t = 0;
                    for (t = 0; t < this.tweensList.length; t++) this.tweensList[t].onComplete.removeAll(), this.tweensList[t].stop()
                }
            }, t.prototype.resetData = function() {
                this.game = null, this.parentContainer = null, this.graphicsContainer = null, this.atlasKey = null, this.passedSeconds = 0, this.x = 0, this.y = 0, this.starCraterGlowImg = null, this.starCraterSparkImgList = null, this.starContainer = null, this.starImg = null, this.starBlinkSpr = null, this.starAnimEffectId = 0, this.delayBefore = 0, this.tweensList = null, this.onStarAnimationComplete = null, this.onStarCraterGlowTweenCompleteCounter = 0, this.onStarItemTweenCompleteCounter = 0, this.visible = !1
            }, t.STAR_ANIM_EFFECT_LEFT = 1, t.STAR_ANIM_EFFECT_CENTER = 2, t.STAR_ANIM_EFFECT_RIGHT = 3, t
        }();
        t.AnimStarS = e
    }(t.entities || (t.entities = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(e) {
        var i;
        ! function(t) {
            t[t.ANIMATE_STAR = 1] = "ANIMATE_STAR", t[t.SHOW_BEST_TIME = 2] = "SHOW_BEST_TIME"
        }(i || (i = {}));
        var s = function() {
            function s(t, e, i, s, o, n, a, r, h, l, c, p) {
                this.resetData(), this.isDisposed = !1, this.game = t, this.parentContainer = e, this.shakeContainer = i, this.position = new Phaser.Point(0, 0), this.position.x = s, this.position.y = o, this.rotation = n, this.windowId = a, this.atlasKey = r, this.levelId = h, this.starsCount = l, this.starPassedSecondsList = c, this.showBestTime = p, this.initData()
            }
            return Object.defineProperty(s.prototype, "WindowId", {
                get: function() {
                    return this.windowId
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(s.prototype, "Visible", {
                get: function() {
                    return this.isVisible
                },
                set: function(t) {
                    this.setVisibleState(t)
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(s.prototype, "OnButtonExitGameSignal", {
                get: function() {
                    return this.onButtonExitGameSignal
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(s.prototype, "OnButtonRestartLevelSignal", {
                get: function() {
                    return this.onButtonRestartLevelSignal
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(s.prototype, "OnButtonNextLevelSignal", {
                get: function() {
                    return this.onButtonNextLevelSignal
                },
                enumerable: !0,
                configurable: !0
            }), s.prototype.init = function() {
                this.createGraphicsContainer(), this.createContent(), this.isVisible = !0
            }, s.prototype.resize = function() {
                var e = t.config.GameConfig.calcGameScale;
                this.bottomLayer.scale.set(e), this.bottomLayer.y = this.game.height, this.game.height / this.game.width < Constants.GAME_HEIGHT / Constants.GAME_WIDTH ? (this.bottomLayer.x = (this.game.width - Constants.GAME_WIDTH) / 2, this.backgroundScalable.x = -1 * this.bottomLayer.x) : (this.bottomLayer.x = 0, this.backgroundScalable.x = 0), this.backgroundScalable.width = this.game.width / e, this.levelIdLabel.setTextBounds(this.backgroundScalable.x, -566, this.game.width / e, 70)
            }, s.prototype.dispose = function() {
                this.isDisposed || (this.disposeSignals(), this.disposeTweensList(), this.disposeContent(), this.disposeGraphicsContainer(), this.animateActionsList.length = 0, this.resetData(), this.isDisposed = !0)
            }, s.prototype.initData = function() {
                this.isOnMobileDevice = t.config.GameConfig.isOnMobileDevice, this.buttonsList = [], this.starsList = [], this.secondsLabelList = [], this.tweensList = [], this.animateActionsList = [], this.onButtonNextLevelSignal = new Phaser.Signal, this.onButtonExitGameSignal = new Phaser.Signal, this.onButtonRestartLevelSignal = new Phaser.Signal, this.soundManager = BoilerPlate.SoundManager.getInstance()
            }, s.prototype.createGraphicsContainer = function() {
                this.bottomLayer = this.game.add.group(this.parentContainer), this.bottomLayer.y = this.game.height, this.graphicsContainer = this.game.add.group(this.bottomLayer), this.graphicsContainer.position.set(this.position.x, this.position.y), this.graphicsContainer.angle = this.rotation
            }, s.prototype.createContent = function() {
                this.createBackground(), this.createIndicators(), this.createButtons(), this.createBranding(), this.createStarsContent(), this.createBestTime(), this.createAnimateActionsList(), this.startAnimation()
            }, s.prototype.createBackground = function() {
                this.backgroundScalable = this.game.add.image(0, -517, this.atlasKey, "a_45_bg_wnd_pf_gui_agp_p10000", this.graphicsContainer)
            }, s.prototype.createIndicators = function() {
                this.createLevelIdIndicator()
            }, s.prototype.createLevelIdIndicator = function() {
                var t = "level " + (this.levelId > 9 ? this.levelId.toString() : "0" + this.levelId.toString()) + "  finished",
                    e = {};
                e.font = "QuickExpress", e.fontSize = "52px", e.fill = "#ffffff", e.boundsAlignH = "center", e.boundsAlignV = "middle", this.levelIdLabel = this.game.add.text(0, 0, t, e, this.graphicsContainer), this.levelIdLabel.stroke = "#243A68", this.levelIdLabel.strokeThickness = 6, this.levelIdLabel.smoothed = !0, this.levelIdLabel.setTextBounds(0, -566, this.game.width, 70)
            }, s.prototype.createBranding = function() {
                var t = Fabrique.Branding.getLogoWithLink(this.game, "extreme-bikers");
                t.y = -t.height - 40, this.graphicsContainer.addChild(t)
            }, s.prototype.createButtons = function() {
                this.createNormalButtons()
            }, s.prototype.createNormalButtons = function() {
                this.buttonExitGame = this.createButtonItem(220, -170, 0, "ExitGame", "a_16_btn_exit_game_wnd_paused_gui_agp_p10000", "a_16_btn_exit_game_wnd_paused_gui_agp_p10001", "a_16_btn_exit_game_wnd_paused_gui_agp_p10002"), this.buttonRestartGame = this.createButtonItem(640, -170, 0, "RestartGame", "a_17_btn_game_restart_wnd_paused_gui_agp_p10000", "a_17_btn_game_restart_wnd_paused_gui_agp_p10001", "a_17_btn_game_restart_wnd_paused_gui_agp_p10002"), this.buttonResumeGame = this.createButtonItem(1050, -170, 0, "ResumeGame", "a_18_btn_game_resume_wnd_paused_gui_agp_p10000", "a_18_btn_game_resume_wnd_paused_gui_agp_p10001", "a_18_btn_game_resume_wnd_paused_gui_agp_p10002"), this.buttonExitGame.Button.onInputUp.add(this.onButtonExitGame, this), this.buttonRestartGame.Button.onInputUp.add(this.onButtonRestartLevel, this), this.buttonResumeGame.Button.onInputUp.add(this.onButtonNextLevel, this)
            }, s.prototype.createButtonItem = function(t, i, s, o, n, a, r, h) {
                void 0 === h && (h = !0);
                var l = new e.GameGUIButtonS(this.game, this.graphicsContainer, t, i, s, o, this.atlasKey, n, a, r);
                return l.init(), h && this.buttonsList.push(l), l
            }, s.prototype.createStarsContent = function() {
                this.createStarsContainer(), this.createStarsSubstrate(), this.createSecondsLabels(), this.createStars()
            }, s.prototype.createStarsContainer = function() {
                this.starsContainer = this.game.add.group(this.graphicsContainer), this.starsContainer.position.set(640, -410)
            }, s.prototype.createStarsSubstrate = function() {
                var t = [{
                        x: -200,
                        y: 0
                    }, {
                        x: 0,
                        y: 0
                    }, {
                        x: 200,
                        y: 0
                    }],
                    e = 0;
                for (e = 0; e < t.length; e++) this.game.add.image(t[e].x - 80.25, t[e].y - 76, this.atlasKey, "a_31_anim_star_wnd_finished_gui_agp_p10000", this.starsContainer)
            }, s.prototype.createSecondsLabels = function() {
                var t = [{
                        x: -200,
                        y: 0,
                        sec: this.starPassedSecondsList[0]
                    }, {
                        x: 0,
                        y: 0,
                        sec: this.starPassedSecondsList[1]
                    }, {
                        x: 200,
                        y: 0,
                        sec: this.starPassedSecondsList[2]
                    }],
                    e = 0;
                for (e = 0; e < t.length; e++) this.secondsLabelList.push(this.createSecondsLabel(t[e].x, t[e].y, t[e].sec))
            }, s.prototype.createSecondsLabel = function(t, e, i) {
                var s = {
                        font: "QuickExpress",
                        fontSize: "20px",
                        fill: "#ffffff",
                        boundsAlignH: "center",
                        boundsAlignV: "middle"
                    },
                    o = (i > 9 ? i.toString() : "0" + i.toString()) + "sec",
                    n = this.game.add.text(t, e, o, s, this.starsContainer);
                return n.stroke = "#243A68", n.strokeThickness = 2, n.smoothed = !0, n.setTextBounds(-100, 90, 200, 40), n
            }, s.prototype.createStars = function() {
                var t = this.starPassedSecondsList[0],
                    i = this.starPassedSecondsList[1],
                    s = this.starPassedSecondsList[2],
                    o = this.onStarAnimationComplete,
                    n = [{
                        x: -200,
                        y: 0,
                        passedSeconds: t,
                        animEffectId: e.AnimStarS.STAR_ANIM_EFFECT_LEFT,
                        delayBefore: 0,
                        callback: o
                    }, {
                        x: 0,
                        y: 0,
                        passedSeconds: i,
                        animEffectId: e.AnimStarS.STAR_ANIM_EFFECT_CENTER,
                        delayBefore: 1500,
                        callback: o
                    }, {
                        x: 200,
                        y: 0,
                        passedSeconds: s,
                        animEffectId: e.AnimStarS.STAR_ANIM_EFFECT_RIGHT,
                        delayBefore: 3e3,
                        callback: o
                    }],
                    a = 0,
                    r = Math.min(this.starsCount, n.length);
                for (a = 0; a < r; a++) this.createStarItem(n[a].x, n[a].y, n[a].passedSeconds, n[a].animEffectId, n[a].delayBefore, n[a].callback)
            }, s.prototype.createStarItem = function(t, i, s, o, n, a) {
                var r = new e.AnimStarS(this.game, this.starsContainer, this.atlasKey, s, t, i, o, n);
                r.OnStarAnimationComplete.add(a, this), r.init(), this.starsList.push(r)
            }, s.prototype.createBestTime = function() {
                this.showBestTime && (this.bestTimeImg = this.game.add.image(1108.75, -370.35, this.atlasKey, "a_35_best_time_ico_wnd_finished_gui_agp_p10000", this.graphicsContainer), this.bestTimeImg.anchor = new Phaser.Point(.5, .5))
            }, s.prototype.createAnimateActionsList = function() {
                var t = 0;
                for (t = 0; t < this.starsCount; t++) this.animateActionsList.push(this.createAnimateActionItem(i.ANIMATE_STAR, {
                    index: t
                }));
                this.showBestTime && this.animateActionsList.push(this.createAnimateActionItem(i.SHOW_BEST_TIME, null))
            }, s.prototype.createAnimateActionItem = function(t, e) {
                var i = {};
                return i.id = t, i.data = e, i
            }, s.prototype.startAnimation = function() {
                this.prepareAnimation(), this.startNextAnimation(!0)
            }, s.prototype.prepareAnimation = function() {
                var t = 0;
                for (t = 0; t < this.starsList.length; t++) this.starsList[t].Visible = !1;
                this.showBestTime && (this.bestTimeImg.visible = !1)
            }, s.prototype.startNextAnimation = function(t) {
                if (void 0 === t && (t = !1), t || this.animateActionsListIndex++, !(this.animateActionsListIndex >= this.animateActionsList.length)) {
                    var e = this.animateActionsList[this.animateActionsListIndex];
                    e.id === i.ANIMATE_STAR ? this.startStarAnimation(e.data) : e.id === i.SHOW_BEST_TIME && this.startBestTimeAnimation()
                }
            }, s.prototype.startStarAnimation = function(t) {
                var e = this.starsList[t.index];
                e.Visible = !0, e.startAnimation()
            }, s.prototype.startBestTimeAnimation = function() {
                this.bestTimeImg.visible = !0, this.bestTimeImg.scale.set(0, 0);
                var t = this.game.add.tween(this.bestTimeImg.scale).to({
                    x: 1.25,
                    y: 1.25
                }, 250, Phaser.Easing.Linear.None, !1).to({
                    x: 1,
                    y: 1
                }, 125, Phaser.Easing.Linear.None, !1).start();
                this.tweensList.push(t)
            }, s.prototype.onStarAnimationComplete = function() {
                this.soundManager.playSound(Sounds.Star), this.game.camera.shake(.005, 500, !0, Phaser.Camera.SHAKE_BOTH, !0), this.game.camera.onShakeComplete.addOnce(this.onCameraShakeComplete, this)
            }, s.prototype.onCameraShakeComplete = function() {
                this.startNextAnimation()
            }, s.prototype.disposeSignals = function() {
                null !== this.onButtonNextLevelSignal && this.onButtonNextLevelSignal.removeAll(), null !== this.onButtonExitGameSignal && this.onButtonExitGameSignal.removeAll(), null !== this.onButtonRestartLevelSignal && this.onButtonRestartLevelSignal.removeAll(), this.game.camera.onShakeComplete.removeAll()
            }, s.prototype.disposeContent = function() {
                this.disposeButtons(), this.disposeStarsList()
            }, s.prototype.disposeButtons = function() {
                if (null !== this.buttonsList) {
                    var t = 0;
                    for (t = 0; t < this.buttonsList.length; t++) this.buttonsList[t].Button.onInputUp.removeAll(), this.buttonsList[t].dispose();
                    this.buttonsList.length = 0
                }
            }, s.prototype.disposeStarsList = function() {
                if (null !== this.starsList) {
                    var t = 0;
                    for (t = 0; t < this.starsList.length; t++) this.starsList[t].dispose()
                }
            }, s.prototype.disposeGraphicsContainer = function() {
                null !== this.bottomLayer && (this.bottomLayer.removeAll(!0, !0), null !== this.bottomLayer.parent && this.bottomLayer.parent.removeChild(this.graphicsContainer))
            }, s.prototype.disposeTweensList = function() {
                if (null !== this.tweensList) {
                    var t = 0;
                    for (t = 0; t < this.tweensList.length; t++) this.tweensList[t].stop()
                }
            }, s.prototype.setVisibleState = function(t) {
                this.isDisposed || (this.isVisible = t, this.graphicsContainer.visible = this.isVisible)
            }, s.prototype.resetData = function() {
                this.isOnMobileDevice = !1, this.game = null, this.parentContainer = null, this.graphicsContainer = null, this.bottomLayer = null, this.position = null, this.rotation = 0, this.atlasKey = null, this.isVisible = !1, this.windowId = null, this.backgroundScalable = null, this.backgroundTitle = null, this.buttonsList = null, this.buttonExitGame = null, this.buttonRestartGame = null, this.buttonResumeGame = null, this.onButtonNextLevelSignal = null, this.onButtonExitGameSignal = null, this.onButtonRestartLevelSignal = null, this.levelId = 0, this.starsCount = 0, this.levelIdLabel = null, this.starsContainer = null, this.starsList = null, this.secondsLabelList = null, this.starPassedSecondsList = null, this.showBestTime = !1, this.bestTimeImg = null, this.tweensList = null, this.animateActionsList = null, this.animateActionsListIndex = 0, this.soundManager = null
            }, s.prototype.onButtonExitGame = function() {
                this.onButtonExitGameSignal.dispatch()
            }, s.prototype.onButtonRestartLevel = function() {
                this.onButtonRestartLevelSignal.dispatch()
            }, s.prototype.onButtonNextLevel = function() {
                this.onButtonNextLevelSignal.dispatch()
            }, s
        }();
        e.GameWindowGameFinishedS = s
    }(t.entities || (t.entities = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(e) {
        var i = function() {
            function e(t, e, i, s) {
                this.buttonTiltLeft = null, this.buttonTiltRight = null, this.buttonMoveLeft = null, this.buttonMoveRight = null, this.resetData(), this.isDisposed = !1, this.parentContainer = t, this.shakeContainer = e, this.game = i, this.atlasKey = s, this.initData()
            }
            return Object.defineProperty(e.prototype, "OnGamePausedResumeGameSignal", {
                get: function() {
                    return this.onGamePausedResumeGameSignal
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(e.prototype, "OnGamePausedExitGameSignal", {
                get: function() {
                    return this.onGamePausedExitGameSignal
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(e.prototype, "OnGamePausedRestartLevelSignal", {
                get: function() {
                    return this.onGamePausedRestartLevelSignal
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(e.prototype, "OnGamePausedMusicOnSignal", {
                get: function() {
                    return this.onGamePausedMusicOnSignal
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(e.prototype, "OnGamePausedMusicOffSignal", {
                get: function() {
                    return this.onGamePausedMusicOffSignal
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(e.prototype, "OnGameFinishedExitGameSignal", {
                get: function() {
                    return this.onGameFinishedExitGameSignal
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(e.prototype, "OnGameFinishedRestartLevelSignal", {
                get: function() {
                    return this.onGameFinishedRestartLevelSignal
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(e.prototype, "OnGameFinishedNextLevelSignal", {
                get: function() {
                    return this.onGameFinishedNextLevelSignal
                },
                enumerable: !0,
                configurable: !0
            }), e.prototype.init = function() {
                this.createGraphicsContainer(), this.createLayers(), this.createButtons(), this.createIndicators()
            }, e.prototype.resize = function() {
                this.isDisposed || (this.isOnMobileDevice && (this.resizeTopLayer(), this.resizeBottomLayer()), null !== this.popupWndGamePaused && this.popupWndGamePaused.resize(), null !== this.popupWndGameFinished && this.popupWndGameFinished.resize())
            }, e.prototype.showGameLevel = function(t) {
                this.indicatorGameLevel.showLevel(t)
            }, e.prototype.showGameTimerFromMS = function(t) {
                this.indicatorGameTimer.showGameTimerFromMS(t)
            }, e.prototype.showGamePausedWindow = function() {
                null === this.popupWndGamePaused && (this.createPopupWindowGamePaused(), this.popupWndGamePaused.resize())
            }, e.prototype.showGameFinishedWindow = function(t, e, i, s) {
                null === this.popupWndGameFinished && (this.createPopupWindowGameFinished(t, e, i, s), this.popupWndGameFinished.resize())
            }, e.prototype.hideGamePausedWindow = function() {
                null !== this.popupWndGamePaused && (this.disposePopupWindowGamePaused(), this.popupWndGamePaused = null)
            }, e.prototype.hideGameFinishedWindow = function() {
                null !== this.popupWndGameFinished && (this.disposePopupWindowGameFinished(), this.popupWndGameFinished = null)
            }, e.prototype.resetGameTimer = function() {
                this.indicatorGameTimer.resetGameTimer()
            }, e.prototype.dispose = function() {
                this.isDisposed || (this.disposeSignals(), this.disposePopupWindowGamePaused(), this.disposePopupWindowGameFinished(), this.disposeIndicators(), this.disposeButtons(), this.disposeGraphicsContainer(), this.resetData(), this.isDisposed = !0)
            }, e.prototype.initData = function() {
                this.isOnMobileDevice = t.config.GameConfig.isOnMobileDevice, this.buttonsList = [], this.onGamePausedResumeGameSignal = new Phaser.Signal, this.onGamePausedExitGameSignal = new Phaser.Signal, this.onGamePausedRestartLevelSignal = new Phaser.Signal, this.onGamePausedMusicOnSignal = new Phaser.Signal, this.onGamePausedMusicOffSignal = new Phaser.Signal, this.onGameFinishedExitGameSignal = new Phaser.Signal, this.onGameFinishedRestartLevelSignal = new Phaser.Signal, this.onGameFinishedNextLevelSignal = new Phaser.Signal
            }, e.prototype.createGraphicsContainer = function() {
                this.graphicsContainer = this.game.add.group(this.parentContainer)
            }, e.prototype.createLayers = function() {
                this.bottomLayer = this.game.add.group(this.graphicsContainer), this.bottomLayer.y = this.game.height, this.topLayer = this.game.add.group(this.graphicsContainer)
            }, e.prototype.createButtons = function() {
                this.game.device.desktop || (this.buttonTiltLeft = this.createButton(150.45, -131.85, 0, this.bottomLayer, "TiltLeft", "a_28_btn_tl_gui_agp_p10000", "a_28_btn_tl_gui_agp_p10001", "a_28_btn_tl_gui_agp_p10002"), this.buttonTiltRight = this.createButton(372, -131.85, 0, this.bottomLayer, "TiltRight", "a_29_btn_tr_gui_agp_p10000", "a_29_btn_tr_gui_agp_p10001", "a_29_btn_tr_gui_agp_p10002"), this.buttonMoveLeft = this.createButton(882.95, -131.85, 0, this.bottomLayer, "MoveLeft", "a_26_btn_mb_agp_p10000", "a_26_btn_mb_agp_p10001", "a_26_btn_mb_agp_p10002"), this.buttonMoveRight = this.createButton(1123.55, -131.85, 0, this.bottomLayer, "MoveRight", "a_27_btn_mf_gui_agp_p10000", "a_27_btn_mf_gui_agp_p10001", "a_27_btn_mf_gui_agp_p10002")), this.buttonPauseGame = this.createButton(1142.15, 60, 0, this.topLayer, "PauseGame", "a_21_btn_pause_gui_agp_p10000", "a_21_btn_pause_gui_agp_p10001", "a_21_btn_pause_gui_agp_p10002")
            }, e.prototype.createButton = function(e, i, s, o, n, a, r, h) {
                var l = new t.entities.GameGUIButtonS(this.game, o, e, i, s, n, this.atlasKey, a, r, h);
                return l.init(), l
            }, e.prototype.createIndicators = function() {
                this.createGameLevelIndicator(), this.createGameTimerIndicator()
            }, e.prototype.createGameLevelIndicator = function() {
                this.indicatorGameLevel = new t.entities.GameLevelIndicatorS(this.game, this.topLayer, 202.95, 60, 0, "IndicatorGameLevel", this.atlasKey), this.indicatorGameLevel.init()
            }, e.prototype.createGameTimerIndicator = function() {
                this.indicatorGameTimer = new t.entities.GameTimerIndicatorS(this.game, this.topLayer, 640, 60, 0, "IndicatorGameTimer", this.atlasKey), this.indicatorGameTimer.init()
            }, e.prototype.createPopupWindowGamePaused = function() {
                this.popupWndGamePaused = new t.entities.GameWindowGamePausedS(this.game, this.graphicsContainer, 0, 0, 0, "window_game_paused", this.atlasKey), this.popupWndGamePaused.OnButtonExitGameSignal.add(this.onGamePausedExitGame, this), this.popupWndGamePaused.OnButtonResumeGameSignal.add(this.onGamePausedResumeGame, this), this.popupWndGamePaused.OnButtonRestartLevelSignal.add(this.onGamePausedRestartLevel, this), this.popupWndGamePaused.OnButtonMusicOnSignal.add(this.onGamePausedMusicOn, this), this.popupWndGamePaused.OnButtonMusicOffSignal.add(this.onGamePausedMusicOff, this), this.popupWndGamePaused.init()
            }, e.prototype.createPopupWindowGameFinished = function(e, i, s, o) {
                this.popupWndGameFinished = new t.entities.GameWindowGameFinishedS(this.game, this.graphicsContainer, this.shakeContainer, 0, 0, 0, "window_game_finished", this.atlasKey, e, i, s, o), this.popupWndGameFinished.OnButtonExitGameSignal.add(this.onGameFinishedExitGame, this), this.popupWndGameFinished.OnButtonRestartLevelSignal.add(this.onGameFinishedRestartLevel, this), this.popupWndGameFinished.OnButtonNextLevelSignal.add(this.onGameFinishedNextLevel, this), this.popupWndGameFinished.init()
            }, e.prototype.resizeTopLayer = function() {
                var t = this.game.width / Constants.GAME_WIDTH;
                this.topLayer.scale.set(t)
            }, e.prototype.resizeBottomLayer = function() {
                var t = this.game.width / Constants.GAME_WIDTH;
                this.bottomLayer.scale.set(t), this.bottomLayer.y = this.game.height
            }, e.prototype.disposeIndicators = function() {
                this.disposeGameTimerIndicator(), this.disposeGameLevelIndicator()
            }, e.prototype.disposeGameLevelIndicator = function() {
                null !== this.indicatorGameLevel && this.indicatorGameLevel.dispose()
            }, e.prototype.disposeGameTimerIndicator = function() {
                null !== this.indicatorGameTimer && this.indicatorGameTimer.dispose()
            }, e.prototype.disposeButtons = function() {
                var t = 0;
                for (t = 0; t < this.buttonsList.length; t++) this.buttonsList[t].dispose()
            }, e.prototype.disposePopupWindowGamePaused = function() {
                null !== this.popupWndGamePaused && this.popupWndGamePaused.dispose()
            }, e.prototype.disposePopupWindowGameFinished = function() {
                null !== this.popupWndGameFinished && this.popupWndGameFinished.dispose()
            }, e.prototype.disposeSignals = function() {
                null !== this.onGamePausedResumeGameSignal && this.onGamePausedResumeGameSignal.removeAll(), null !== this.onGamePausedExitGameSignal && this.onGamePausedExitGameSignal.removeAll(), null !== this.onGamePausedRestartLevelSignal && this.onGamePausedRestartLevelSignal.removeAll(), null !== this.onGamePausedMusicOnSignal && this.onGamePausedMusicOnSignal.removeAll(), null !== this.onGamePausedMusicOffSignal && this.onGamePausedMusicOffSignal.removeAll(), null !== this.onGameFinishedExitGameSignal && this.onGameFinishedExitGameSignal.removeAll(), null !== this.onGameFinishedRestartLevelSignal && this.onGameFinishedRestartLevelSignal.removeAll(), null !== this.onGameFinishedNextLevelSignal && this.onGameFinishedNextLevelSignal.removeAll()
            }, e.prototype.disposeGraphicsContainer = function() {
                null !== this.graphicsContainer && (this.graphicsContainer.removeAll(!0, !0, !0), null !== this.graphicsContainer.parent && this.graphicsContainer.parent.removeChild(this.graphicsContainer))
            }, e.prototype.resetData = function() {
                this.game = null, this.parentContainer = null, this.shakeContainer = null, this.graphicsContainer = null, this.topLayer = null, this.bottomLayer = null, this.isOnMobileDevice = !1, this.buttonsList = null, this.buttonTiltLeft = null, this.buttonTiltRight = null, this.buttonMoveLeft = null, this.buttonMoveRight = null, this.buttonPauseGame = null, this.indicatorGameLevel = null, this.indicatorGameTimer = null, this.popupWndGamePaused = null, this.popupWndGameFinished = null, this.onGamePausedResumeGameSignal = null, this.onGamePausedExitGameSignal = null, this.onGamePausedRestartLevelSignal = null, this.onGamePausedMusicOnSignal = null, this.onGamePausedMusicOffSignal = null, this.onGameFinishedExitGameSignal = null, this.onGameFinishedRestartLevelSignal = null, this.onGameFinishedNextLevelSignal = null, this.atlasKey = null
            }, e.prototype.onGamePausedResumeGame = function() {
                this.onGamePausedResumeGameSignal.dispatch()
            }, e.prototype.onGamePausedExitGame = function() {
                this.showAd(this.onGamePausedExitGameSignal)
            }, e.prototype.onGamePausedRestartLevel = function() {
                this.showAd(this.onGamePausedRestartLevelSignal)
            }, e.prototype.onGamePausedMusicOn = function() {
                this.onGamePausedMusicOnSignal.dispatch()
            }, e.prototype.onGamePausedMusicOff = function() {
                this.onGamePausedMusicOffSignal.dispatch()
            }, e.prototype.onGameFinishedExitGame = function() {
                this.showAd(this.onGameFinishedExitGameSignal)
            }, e.prototype.onGameFinishedRestartLevel = function() {
                this.showAd(this.onGameFinishedRestartLevelSignal)
            }, e.prototype.onGameFinishedNextLevel = function() {
                this.showAd(this.onGameFinishedNextLevelSignal)
            }, e.prototype.showAd = function(t) {
                var e = this;
                Fabrique.LoaderHelper.show(), this.game.ads.onContentPaused.addOnce(function() {
                    Fabrique.LoaderHelper.hide(), e.game.analytics.google.sendScreenView("advertisement")
                }), this.game.ads.onContentResumed.addOnce(function() {
                    Fabrique.LoaderHelper.hide(), t.dispatch(), e.game.ads.onContentPaused.removeAll(), e.game.ads.onContentResumed.removeAll()
                }), this.game.ads.showAd()
            }, e
        }();
        e.GameGUIController = i
    }(t.controllers || (t.controllers = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(t) {
        ! function(t) {
            t[t.TILT_BACK = 1] = "TILT_BACK", t[t.TILT_FORWARD = 2] = "TILT_FORWARD", t[t.MOVE_BACK = 3] = "MOVE_BACK", t[t.MOVE_FORWARD = 4] = "MOVE_FORWARD"
        }(t.UserInputKeys || (t.UserInputKeys = {}))
    }(t.types || (t.types = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(e) {
        var i = function() {
            function e(t) {
                this.resetData(), this.isDisposed = !1, this.game = t, this.isMobileDevice = !this.game.device.desktop, this.isMobileDevice || (this.game.input.keyboard.addKeyCapture(Phaser.Keyboard.RIGHT), this.game.input.keyboard.addKeyCapture(Phaser.Keyboard.LEFT), this.game.input.keyboard.addKeyCapture(Phaser.Keyboard.DOWN), this.game.input.keyboard.addKeyCapture(Phaser.Keyboard.UP)), this.initData()
            }
            return e.prototype.registerButtonKey = function(e, i) {
                i === t.types.UserInputKeys.TILT_BACK ? (e.onInputDown.add(this.onButtonTiltBackDown, this), e.onInputUp.add(this.onButtonTiltBackUp, this)) : i === t.types.UserInputKeys.TILT_FORWARD ? (e.onInputDown.add(this.onButtonTiltForwardDown, this), e.onInputUp.add(this.onButtonTiltForwardUp, this)) : i === t.types.UserInputKeys.MOVE_BACK ? (e.onInputDown.add(this.onButtonMoveBackDown, this), e.onInputUp.add(this.onButtonMoveBackUp, this)) : i === t.types.UserInputKeys.MOVE_FORWARD && (e.onInputDown.add(this.onButtonMoveForwardDown, this), e.onInputUp.add(this.onButtonMoveForwardUp, this)), this.buttonsList.push(e)
            }, e.prototype.isInputDown = function(t) {
                return this.isMobileDevice ? this.isButtonDown(t) : this.isKeyboardKeyDown(t)
            }, e.prototype.reset = function() {
                this.isBtnTiltLeftDown = !1, this.isBtnTiltRightDown = !1, this.isBtnMoveForwardDown = !1, this.isBtnMoveBackDown = !1
            }, e.prototype.dispose = function() {
                this.disposeButtonsList(), this.resetData(), this.isDisposed = !0
            }, e.prototype.initData = function() {
                this.buttonsList = []
            }, e.prototype.isKeyboardKeyDown = function(e) {
                return e === t.types.UserInputKeys.TILT_BACK ? this.game.input.keyboard.isDown(Phaser.KeyCode.LEFT) : e === t.types.UserInputKeys.TILT_FORWARD ? this.game.input.keyboard.isDown(Phaser.KeyCode.RIGHT) : e === t.types.UserInputKeys.MOVE_BACK ? this.game.input.keyboard.isDown(Phaser.KeyCode.DOWN) : e === t.types.UserInputKeys.MOVE_FORWARD ? this.game.input.keyboard.isDown(Phaser.KeyCode.UP) : void 0
            }, e.prototype.isButtonDown = function(e) {
                return e === t.types.UserInputKeys.TILT_BACK ? this.isBtnTiltLeftDown : e === t.types.UserInputKeys.TILT_FORWARD ? this.isBtnTiltRightDown : e === t.types.UserInputKeys.MOVE_BACK ? this.isBtnMoveBackDown : e === t.types.UserInputKeys.MOVE_FORWARD ? this.isBtnMoveForwardDown : void 0
            }, e.prototype.disposeButtonsList = function() {
                if (null !== this.buttonsList) {
                    var t = 0;
                    for (t = 0; t < this.buttonsList.length; t++) {
                        var e = this.buttonsList[t];
                        e.onInputDown.removeAll(), e.onInputUp.removeAll(), this.buttonsList[t] = null
                    }
                }
            }, e.prototype.resetData = function() {
                this.game = null, this.isBtnTiltLeftDown = !1, this.isBtnTiltRightDown = !1, this.isBtnMoveForwardDown = !1, this.isBtnMoveBackDown = !1, this.buttonsList = null, this.isMobileDevice = !1
            }, e.prototype.onButtonTiltBackDown = function() {
                this.isBtnTiltLeftDown = !0
            }, e.prototype.onButtonTiltBackUp = function() {
                this.isBtnTiltLeftDown = !1
            }, e.prototype.onButtonTiltForwardDown = function() {
                this.isBtnTiltRightDown = !0
            }, e.prototype.onButtonTiltForwardUp = function() {
                this.isBtnTiltRightDown = !1
            }, e.prototype.onButtonMoveBackDown = function() {
                this.isBtnMoveBackDown = !0
            }, e.prototype.onButtonMoveBackUp = function() {
                this.isBtnMoveBackDown = !1
            }, e.prototype.onButtonMoveForwardDown = function() {
                this.isBtnMoveForwardDown = !0
            }, e.prototype.onButtonMoveForwardUp = function() {
                this.isBtnMoveForwardDown = !1
            }, e
        }();
        e.InputManager = i
    }(t.managers || (t.managers = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(t) {
        ! function(t) {
            t[t.TILT_BACK = 1] = "TILT_BACK", t[t.TILT_FORWARD = 2] = "TILT_FORWARD", t[t.MOVE_BACK = 3] = "MOVE_BACK", t[t.MOVE_FORWARD = 4] = "MOVE_FORWARD"
        }(t.UserInputPadType || (t.UserInputPadType = {}))
    }(t.types || (t.types = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(t) {
        ! function(t) {
            t.BACKGROUND = "bg_layer", t.LEVEL = "game_level_layer", t.GUI = "game_gui_layer"
        }(t.GroupCategory || (t.GroupCategory = {}))
    }(t.types || (t.types = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(t) {
        var e = function() {
            return function() {
                this.dataA = null, this.dataB = null, this.contact = null
            }
        }();
        t.Box2DContactListenerData = e
    }(t.types || (t.types = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(e) {
        var i = function() {
            function e() {
                this.Type = t.types.GameObjectType.UNKNOWN, this.Sender = null, this.Action = t.types.GameObjectActions.UNKNOWN, this.Data = null
            }
            return e.prototype.toString = function() {
                return "type: " + t.tools.Convertor.getStringFromGameObjectType(this.Type) + "; action: " + t.tools.Convertor.getStringFromGameObjectAction(this.Action)
            }, e
        }();
        e.GameObjectActionData = i
    }(t.types || (t.types = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(t) {
        ! function(t) {
            t[t.UNKNOWN = 0] = "UNKNOWN", t[t.VERTICAL_LIFT_1_BOTTOM_STATE = 1] = "VERTICAL_LIFT_1_BOTTOM_STATE", t[t.VERTICAL_LIFT_1_MOVING_UP_STATE = 2] = "VERTICAL_LIFT_1_MOVING_UP_STATE", t[t.VERTICAL_LIFT_1_TOP_STATE = 3] = "VERTICAL_LIFT_1_TOP_STATE", t[t.VERTICAL_LIFT_1_MOVING_DOWN_STATE = 4] = "VERTICAL_LIFT_1_MOVING_DOWN_STATE", t[t.VERTICAL_LIFT_MOVING_UP_STATE = 5] = "VERTICAL_LIFT_MOVING_UP_STATE"
        }(t.GameObjectStates || (t.GameObjectStates = {}))
    }(t.types || (t.types = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(t) {
        ! function(t) {
            ! function(t) {
                var e = function() {
                    return function() {}
                }();
                t.DictionaryItemObject = e
            }(t.number || (t.number = {}))
        }(t.dictionary || (t.dictionary = {}))
    }(t.types || (t.types = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(e) {
        var i = function(e) {
            function i(t, i, s, o, n, a, r) {
                void 0 === r && (r = null);
                var h = e.call(this) || this;
                return h.resetData(), h.isDisposed = !1, h.game = t, h.b2World = i, h.parentContainer = s, h.type = o, h.data = n, h.gameSettings = a, h.gameAtlasKey = r, h.initData(), h
            }
            return __extends(i, e), Object.defineProperty(i.prototype, "Id", {
                get: function() {
                    return this.id
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(i.prototype, "Type", {
                get: function() {
                    return this.type
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(i.prototype, "State", {
                get: function() {
                    return this.state
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(i.prototype, "SignalOnAction", {
                get: function() {
                    return this.signalOnAction
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(i.prototype, "IsDisposed", {
                get: function() {
                    return this.isDisposed
                },
                enumerable: !0,
                configurable: !0
            }), i.prototype.setPositionXY = function(t, e) {}, i.prototype.setRotation = function(t) {}, i.prototype.startDefaultAction = function() {}, i.prototype.startAction = function(t) {}, i.prototype.startActionWithData = function(t, e) {}, i.prototype.updateLogic = function(t) {}, i.prototype.updateGraphics = function(t) {}, i.prototype.dispose = function() {
                this.isDisposed || (this.disposeSignals(), this.customDispose(), this.resetData(), this.isDisposed = !0)
            }, i.prototype.initData = function() {
                if (this.signalOnAction = new Phaser.Signal, this.isGraphicsEnabled = t.config.GameConfig.enableGraphics, this.id = "none", null != this.data && this.data.hasOwnProperty("settings")) {
                    var e = this.data.settings;
                    e.hasOwnProperty("id") && (this.id = e.id)
                }
                this.customInitData()
            }, i.prototype.customInitData = function() {}, i.prototype.disposeSignals = function() {
                this.signalOnAction.getNumListeners() > 0 && this.signalOnAction.removeAll()
            }, i.prototype.customDispose = function() {}, i.prototype.resetData = function() {
                this.customResetData(), this.id = null, this.game = null, this.b2World = null, this.parentContainer = null, this.data = null, this.gameSettings = null, this.state = t.types.GameObjectStates.UNKNOWN, this.signalOnAction = null, this.isGraphicsEnabled = !1, this.isComponentInited = !1, this.gameAtlasKey = null
            }, i.prototype.customResetData = function() {}, i
        }(t.types.dictionary.number.DictionaryItemObject);
        e.GameObject = i
    }(t.game_objects || (t.game_objects = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(e) {
        var i = function(e) {
            function i(i, s, o, n, a) {
                var r = e.call(this, i, s, o, t.types.GameObjectType.VERTICAL_LIFT, n, a) || this;
                return r.init(), r
            }
            return __extends(i, e), i.prototype.startAction = function(t) {
                !this.isDisposed && this.isInited && (this.liftAction = this.getLiftActionFromStr(t), this.restartLiftAction())
            }, i.prototype.setPositionXY = function(t, e) {
                !this.isDisposed && this.isInited && this.updateStartPosition(t, e)
            }, i.prototype.startDefaultAction = function() {
                !this.isDisposed && this.isInited && (this.liftAction = this.getLiftActionFromStr(this.data.settings.defaultAction), this.restartLiftAction())
            }, i.prototype.updateLogic = function(t) {
                !this.isDisposed && this.isInited && this.updateLiftLogic(t)
            }, i.prototype.updateGraphics = function(t) {
                !this.isDisposed && this.isInited && this.updateGraphicsPosition()
            }, i.prototype.activatePhysics = function() {
                this.isDisposed || !this.isInited || this.isPhysicsActivated || this._activatePhysics()
            }, i.prototype.deactivatePhysics = function() {
                !this.isDisposed && this.isInited && this.isPhysicsActivated && this._deactivatePhysics()
            }, i.prototype.init = function() {
                this.createPhysics(), this.createGraphics(), this.updateStartPosition(0, 0), this.isInited = !0
            }, i.prototype.createPhysics = function() {
                var t = this.data.physics,
                    e = t.length,
                    i = 0;
                for (i = 0; i < e; ++i) this.createPhysicItem(t[i]);
                this.isPhysicsActivated = !0
            }, i.prototype.createPhysicItem = function(e) {
                var i = {};
                i.x = t.tools.Convertor.w_to_ws(e.x), i.y = t.tools.Convertor.w_to_ws(e.x), i.rot = t.tools.Convertor.deg_to_rad(e.rotation);
                var s = t.tools.Convertor.getGameObjectPhysicTypeFromStr(this.data.settings.physicType),
                    o = new t.types.GameObjectData;
                o.Type = t.types.GameObjectType.VERTICAL_LIFT, o.PhysicType = s, o.MaterialType = t.tools.Convertor.getGameObjectMaterialTypeFromStr(this.data.settings.material), o.UserData1 = i;
                var n = new Box2D.Dynamics.b2BodyDef;
                s === t.types.GameObjectPhysicType.DYNAMIC ? n.type = Box2D.Dynamics.b2Body.b2_dynamicBody : s === t.types.GameObjectPhysicType.KINEMATIC ? n.type = Box2D.Dynamics.b2Body.b2_kinematicBody : n.type = Box2D.Dynamics.b2Body.b2_staticBody, n.userData = o, n.position.Set(i.x, i.y), n.allowSleep = !1, n.angle = i.rot;
                var a = this.b2World.CreateBody(n);
                a.SetActive(!1), e.hasOwnProperty("boxes") && this.createPhysicPartBoxes(e, a, o.Type, o.PhysicType, o.MaterialType), a.ResetMassData(), a.SetActive(!0), this.b2BodyList.push(a)
            }, i.prototype.createPhysicPartBoxes = function(t, e, i, s, o) {
                var n = t.boxes,
                    a = n.length,
                    r = 0;
                for (r = 0; r < a; ++r) this.createPhysicPartBoxesItem(n[r], e, i, s, o)
            }, i.prototype.createPhysicPartBoxesItem = function(e, i, s, o, n) {
                var a = new t.types.GameObjectData;
                a.Type = s, a.PhysicType = o, a.MaterialType = n, a.EntityCategory = t.types.EntityCategory.GAME_OBJECT;
                var r = new Box2D.Collision.Shapes.b2PolygonShape;
                r.SetAsOrientedBox(t.tools.Convertor.w_to_ws(e.width / 2), t.tools.Convertor.w_to_ws(e.height / 2), new Box2D.Common.Math.b2Vec2(t.tools.Convertor.w_to_ws(e.x), t.tools.Convertor.w_to_ws(e.y)), t.tools.Convertor.deg_to_rad(e.rotation));
                var h = new Box2D.Dynamics.b2FixtureDef;
                h.density = this.data.settings.density, h.friction = this.data.settings.friction, h.restitution = this.data.settings.restitution, h.shape = r, h.filter.categoryBits = a.EntityCategory, h.filter.maskBits = t.types.EntityCategory.BIKE_WHEEL | t.types.EntityCategory.BIKE_BODY | t.types.EntityCategory.BIKE_AXLE | t.types.EntityCategory.GAME_OBJECT | t.types.EntityCategory.BIKE_BODY_SENSOR_HEAD | t.types.EntityCategory.BIKE_BODY_SENSOR_BODY, a.PhysicType === t.types.GameObjectPhysicType.DYNAMIC && (h.filter.maskBits = h.filter.maskBits | t.types.EntityCategory.GROUND), h.userData = a, i.CreateFixture(h)
            }, i.prototype.createGraphics = function() {
                if (this.graphicsContainer = this.game.add.group(), this.parentContainer.add(this.graphicsContainer), t.config.GameConfig.enableGraphics) {
                    var e = this.data.graphics,
                        i = e.length,
                        s = 0;
                    for (s = 0; s < i; ++s) this.createGraphicItem(e[s])
                }
            }, i.prototype.createGraphicItem = function(t) {
                var e = t.parts,
                    i = e.length,
                    s = 0,
                    o = this.game.add.group();
                for (o.position.set(t.x, t.y), o.angle = t.rotation, this.graphicsContainer.add(o), s = 0; s < i; s++) this.createGraphicItemPart(e[s], o)
            }, i.prototype.createGraphicItemPart = function(e, i) {
                var s = e.x,
                    o = e.y,
                    n = e.rotation,
                    a = e.atlasKey,
                    r = this.game.add.image(s, o, t.settings.GameCommonSettings.getGameLevelStartUpAtlasKey(), a);
                r.angle = n, i.add(r)
            }, i.prototype._activatePhysics = function() {
                var t = this.b2BodyList.length,
                    e = 0;
                for (e = 0; e < t; ++e) this.b2BodyList[e].SetActive(!0);
                this.isPhysicsActivated = !0
            }, i.prototype.updateStartPosition = function(e, i) {
                var s = this.isPhysicsActivated;
                s && this._deactivatePhysics(), this.startPosition.x = t.tools.Convertor.w_to_ws(e), this.startPosition.y = t.tools.Convertor.w_to_ws(i), this.calcPhysicsTopPosition(), this.calcPhysicsBottomPosition(), this.setLiftStartUpState(), this.updateGraphicsPosition(), s && this._activatePhysics()
            }, i.prototype.updatePhysicsStartUpPosition = function(t, e) {
                var i = this.b2BodyList.length,
                    s = 0;
                for (s = 0; s < i; ++s) {
                    var o = this.b2BodyList[s],
                        n = o.GetUserData().UserData1;
                    o.SetPosition(new Box2D.Common.Math.b2Vec2(t + n.x, e + n.y))
                }
            }, i.prototype.calcPhysicsTopPosition = function() {
                this.topPosition.y = this.startPosition.y + t.tools.Convertor.w_to_ws(this.data.states.top.y)
            }, i.prototype.calcPhysicsBottomPosition = function() {
                this.bottomPosition.y = this.startPosition.y + t.tools.Convertor.w_to_ws(this.data.states.bottom.y)
            }, i.prototype.setLiftStartUpState = function() {
                this.liftState = this.getLiftStateFromStr(this.data.settings.startUpState), this.liftState === s.TOP ? this.setLiftStartUpTopState() : this.liftState === s.BOTTOM ? this.setLiftStartUpBottomState() : this.updatePhysicsStartUpPosition(this.startPosition.x, this.startPosition.y)
            }, i.prototype.setLiftStartUpTopState = function() {
                this.updatePhysicsStartUpPosition(this.startPosition.x, this.topPosition.y)
            }, i.prototype.setLiftStartUpBottomState = function() {
                this.updatePhysicsStartUpPosition(this.startPosition.x, this.bottomPosition.y)
            }, i.prototype.getLiftStateFromStr = function(t) {
                return "top" === t ? s.TOP : "bottom" === t ? s.BOTTOM : s.UNKNOWN
            }, i.prototype.getLiftActionFromStr = function(t) {
                return "move_up" === t ? o.MOVE_UP : "move_down" === t ? o.MOVE_DOWN : "loop" === t ? o.LOOP : o.UNKNOWN
            }, i.prototype.updateGraphicsPosition = function() {
                var e, i = Math.min(this.b2BodyList.length, this.graphicsContainer.children.length);
                for (e = 0; e < i; ++e) {
                    var s = this.b2BodyList[e],
                        o = this.graphicsContainer.getChildAt(e),
                        n = s.GetPosition(),
                        a = s.GetAngle();
                    o.position.x = n.x * t.config.GameConfig.b2WorldScale, o.position.y = n.y * t.config.GameConfig.b2WorldScale, o.rotation = a
                }
            }, i.prototype.restartLiftAction = function() {
                this.isLiftActionRestarted = !0, this.stopLiftAction(), this.startNewLiftAction(), this.isLiftActionRestarted = !1
            }, i.prototype.stopLiftAction = function() {
                this.stopLift(), this.resetLiftProcessActionsList()
            }, i.prototype.startNewLiftAction = function() {
                this.liftAction === o.MOVE_UP ? (this.liftProcessActionsList.push(n.MOVE_UP), this.liftProcessActionsList.push(n.STOP)) : this.liftAction === o.MOVE_DOWN ? (this.liftProcessActionsList.push(n.MOVE_DOWN), this.liftProcessActionsList.push(n.STOP)) : this.liftAction === o.LOOP && (this.liftState === s.BOTTOM ? (this.liftProcessActionsList.push(n.MOVE_UP), this.liftProcessActionsList.push(n.WAIT), this.liftProcessActionsList.push(n.MOVE_DOWN), this.liftProcessActionsList.push(n.WAIT)) : this.liftState === s.TOP && (this.liftProcessActionsList.push(n.MOVE_DOWN), this.liftProcessActionsList.push(n.WAIT), this.liftProcessActionsList.push(n.MOVE_UP), this.liftProcessActionsList.push(n.WAIT)))
            }, i.prototype.stopLift = function() {
                var t = this.b2BodyList.length,
                    e = 0;
                for (this.moveVelocity.y = 0, e = 0; e < t; ++e) this.b2BodyList[e].SetLinearVelocity(this.moveVelocity);
                var i = this.isPhysicsActivated;
                i && this._deactivatePhysics(), this.setLiftStartUpState(), i && this._activatePhysics()
            }, i.prototype.stopLiftAtCurrentState = function() {
                var t = this.b2BodyList.length,
                    e = 0;
                for (this.moveVelocity.y = 0, e = 0; e < t; ++e) this.b2BodyList[e].SetLinearVelocity(this.moveVelocity);
                var i = this.isPhysicsActivated;
                i && this._deactivatePhysics(), this.liftState === s.TOP ? this.setLiftStartUpTopState() : this.setLiftStartUpBottomState(), i && this._activatePhysics()
            }, i.prototype.canMoveLiftUp = function() {
                return this.liftState !== s.TOP
            }, i.prototype.moveLiftUp = function() {
                var t = this.b2BodyList.length,
                    e = 0;
                for (this.moveVelocity.y = -this.liftVelocityY, e = 0; e < t; ++e) this.b2BodyList[e].SetLinearVelocity(this.moveVelocity);
                this.liftState = s.MOVING_UP
            }, i.prototype.canMoveLiftDown = function() {
                return this.liftState !== s.BOTTOM
            }, i.prototype.moveLiftDown = function() {
                var t = this.b2BodyList.length,
                    e = 0;
                for (this.moveVelocity.y = this.liftVelocityY, e = 0; e < t; ++e) this.b2BodyList[e].SetLinearVelocity(this.moveVelocity);
                this.liftState = s.MOVING_DOWN
            }, i.prototype.setLiftForWait = function() {
                this.liftState !== s.WAITING && (this.liftPrevState = this.liftState), this.liftWaitingTime = 0, this.liftState = s.WAITING
            }, i.prototype.updateLiftLogic = function(t) {
                this.isLiftActionRestarted || (this.isLiftProcessActionFinished ? this.startNextProcessAction() : this.isLiftProcessActionStarted && this.checkLiftState(t))
            }, i.prototype.startNextProcessAction = function() {
                this.isLiftProcessActionFinished = !1;
                var t = this.liftProcessActionsList.length;
                if (0 !== t) {
                    var e = this.liftProcessActionsList[this.liftProcessActionsListIndex],
                        i = !1;
                    ++this.liftProcessActionsListIndex >= t && (this.liftProcessActionsListIndex = 0), e === n.MOVE_UP ? this.canMoveLiftUp() && this.moveLiftUp() : e === n.MOVE_DOWN ? this.canMoveLiftDown() && this.moveLiftDown() : e === n.WAIT ? (this.stopLiftAtCurrentState(), this.setLiftForWait()) : e === n.STOP ? (this.stopLiftAtCurrentState(), this.resetLiftProcessActionsList(), i = !0) : i = !0, i ? this.isLiftProcessActionFinished = !0 : this.isLiftProcessActionStarted = !0
                } else this.isLiftProcessActionFinished = !0
            }, i.prototype.checkLiftState = function(t) {
                var e = !1;
                this.liftState === s.MOVING_UP && this.isLiftTopStateReached() ? (this.liftState = s.TOP, e = !0) : this.liftState === s.MOVING_DOWN && this.isLiftBottomStateReached() ? (this.liftState = s.BOTTOM, e = !0) : this.liftState === s.WAITING && (this.liftWaitingTime += t, this.isLiftWaitingTimeReached() && (this.liftState = this.liftPrevState, e = !0)), e && (this.isLiftProcessActionStarted = !1, this.isLiftProcessActionFinished = !0)
            }, i.prototype.isLiftTopStateReached = function() {
                var t = !1,
                    e = this.b2BodyList.length,
                    i = 0;
                for (i = 0; i < e; ++i)
                    if (this.b2BodyList[i].GetPosition().y <= this.topPosition.y) {
                        t = !0;
                        break
                    }
                return t
            }, i.prototype.isLiftBottomStateReached = function() {
                var t = !1,
                    e = this.b2BodyList.length,
                    i = 0;
                for (i = 0; i < e; ++i)
                    if (this.b2BodyList[i].GetPosition().y >= this.bottomPosition.y) {
                        t = !0;
                        break
                    }
                return t
            }, i.prototype.isLiftWaitingTimeReached = function() {
                return this.liftWaitingTime >= this.liftWaitingTimeLimit
            }, i.prototype.resetLiftProcessActionsList = function() {
                this.liftProcessActionsList.length = 0, this.liftProcessActionsListIndex = 0
            }, i.prototype._deactivatePhysics = function() {
                var t = this.b2BodyList.length,
                    e = 0;
                for (e = 0; e < t; ++e) this.b2BodyList[e].SetActive(!1);
                this.isPhysicsActivated = !1
            }, i.prototype.disposePhysics = function() {
                var t = this.b2BodyList.length,
                    e = 0;
                if (t > 0)
                    for (e = 0; e < t; ++e) {
                        var i = this.b2BodyList[e];
                        i.SetActive(!1), this.b2World.DestroyBody(i)
                    }
                this.b2BodyList.length = 0
            }, i.prototype.disposeGraphics = function() {
                null != this.parentContainer && null != this.graphicsContainer && this.parentContainer.remove(this.graphicsContainer, !0, !0)
            }, i.prototype.initData = function() {
                e.prototype.initData.call(this), this.b2BodyList = [], this.startPosition = new Box2D.Common.Math.b2Vec2(0, 0), this.topPosition = new Box2D.Common.Math.b2Vec2(0, 0), this.bottomPosition = new Box2D.Common.Math.b2Vec2(0, 0), this.liftVelocityY = t.tools.Convertor.w_to_ws(this.data.settings.movingVelocity), this.moveVelocity = new Box2D.Common.Math.b2Vec2(0, 0), this.liftWaitingTimeLimit = this.data.settings.inStateWaitingTime, this.liftProcessActionsList = [], this.isLiftProcessActionFinished = !0
            }, i.prototype.customDispose = function() {
                this.resetLiftProcessActionsList(), this.disposePhysics(), this.disposeGraphics()
            }, i.prototype.resetData = function() {
                e.prototype.resetData.call(this), this.b2BodyList = null, this.isPhysicsActivated = !1, this.isInited = !1, this.graphicsContainer = null, this.startPosition = null, this.topPosition = null, this.bottomPosition = null, this.moveVelocity = null, this.liftVelocityY = 0, this.liftWaitingTime = 0, this.liftWaitingTimeLimit = 0, this.liftState = s.UNKNOWN, this.liftPrevState = s.UNKNOWN, this.liftAction = o.UNKNOWN, this.liftProcessActionsList = null, this.liftProcessActionsListIndex = 0, this.isLiftProcessActionFinished = !1, this.isLiftProcessActionStarted = !1, this.isLiftActionRestarted = !1
            }, i
        }(t.game_objects.GameObject);
        e.GOVerticalLift = i;
        var s;
        ! function(t) {
            t[t.UNKNOWN = 0] = "UNKNOWN", t[t.TOP = 1] = "TOP", t[t.BOTTOM = 2] = "BOTTOM", t[t.WAITING = 3] = "WAITING", t[t.MOVING_UP = 4] = "MOVING_UP", t[t.MOVING_DOWN = 5] = "MOVING_DOWN"
        }(s || (s = {}));
        var o;
        ! function(t) {
            t[t.UNKNOWN = 0] = "UNKNOWN", t[t.MOVE_UP = 1] = "MOVE_UP", t[t.MOVE_DOWN = 2] = "MOVE_DOWN", t[t.LOOP = 3] = "LOOP"
        }(o || (o = {}));
        var n;
        ! function(t) {
            t[t.UNKNOWN = 0] = "UNKNOWN", t[t.MOVE_UP = 1] = "MOVE_UP", t[t.MOVE_DOWN = 2] = "MOVE_DOWN", t[t.WAIT = 3] = "WAIT", t[t.STOP = 4] = "STOP"
        }(n || (n = {}))
    }(t.game_objects || (t.game_objects = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(e) {
        var i = function() {
            return function() {
                this.ScaleMiddleCoefficient = 500, this.ScaleBottomCoefficient = -60, this.BottomLimit = 0, this.Type = t.types.GameCameraOffsetType.MIDDLE, this.ActiveFlag = !1
            }
        }();
        e.GameCameraOffset = i
    }(t.entities || (t.entities = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(t) {
        var e = function() {
                return function() {}
            }(),
            i = function() {
                function t(t, e) {
                    this.calcX = 0, this.calcY = 0, this.targetOffset = 0, this.targetScale = 1, this.defScale = 1, this.oldScale = 1, this.defOffset = 0, this.resetData(), this.isDisposed = !1, this.game = t, this.levelContainer = e, this.initData()
                }
                return t.prototype.setSettings = function(t) {
                    this.settings = t, this.levelContainer.x = 0, this.levelContainer.y = 0, this.init()
                }, t.prototype.getOffset = function(t) {
                    t.Type;
                    return -1 === t.BottomLimit ? -.5 * Constants.GAME_HEIGHT : Constants.GAME_HEIGHT * -t.BottomLimit / this.settings.worldBounds.height
                }, t.prototype.zoomTo = function(t, e, i) {
                    void 0 === e && (e = 0), void 0 === i && (i = null), !this.isDisposed && this.isInited && (console.log("zoomTo " + t + " " + e), e > 0 ? (this.targetOffset = this.getOffset(i) / t, this.targetScale = t, this.oldScale = this.levelContainer.parent.scale.x, this.defScale = this.targetScale - this.oldScale, this.defOffset = this.targetOffset - this.scaleData.cameraPositionOffsetY) : (this.levelContainer.parent.scale.set(t, t), this.scaleData.cameraPositionOffsetY = -Math.floor(Constants.GAME_HEIGHT / 2), this.targetScale = -1))
                }, t.prototype.init = function() {
                    this.isDisposed || this.isInited || (this.isInited = !0)
                }, t.prototype.render = function(t, e) {
                    !this.isDisposed && this.isInited && this.updateCamera(t, e)
                }, t.prototype.dispose = function() {
                    this.isDisposed || (this.resetData(), this.isDisposed = !0)
                }, t.prototype.updateZoom = function(t) {
                    var e = this.defScale * t;
                    Phaser.Math.max(this.targetScale, this.levelContainer.parent.scale.x + e) - Phaser.Math.min(this.targetScale, this.levelContainer.parent.scale.x + e) > .001 ? (this.levelContainer.parent.scale.set(this.levelContainer.parent.scale.x + e, this.levelContainer.parent.scale.y + e), this.scaleData.cameraPositionOffsetY += t * this.defOffset) : (this.levelContainer.parent.scale.set(this.targetScale, this.targetScale), this.targetScale = -1, this.scaleData.cameraPositionOffsetY = this.targetOffset)
                }, t.prototype.updateCamera = function(t, e) {
                    -1 === this.targetScale ? this.calcY = -this.settings.playerStartPosition.y / 50 - 50 * t.y - this.scaleData.cameraPositionOffsetY : (this.updateZoom(e), this.calcY = -this.settings.playerStartPosition.y / 50 - 50 * t.y - this.scaleData.cameraPositionOffsetY), this.calcX = 50 * -t.x - this.scaleData.cameraPositionOffsetX;
                    var i = Phaser.Math.max(this.game.width, this.game.height);
                    this.calcX > 0 ? this.levelContainer.x = 0 : this.calcX < -this.settings.worldBounds.width + i / this.levelContainer.parent.scale.x ? this.levelContainer.x = -this.settings.worldBounds.width + i / this.levelContainer.parent.scale.x : this.levelContainer.x = this.calcX, this.levelContainer.y = this.calcY
                }, t.prototype.initData = function() {
                    this.scaleData = new e, this.scaleData.cameraWidth = Constants.GAME_WIDTH, this.scaleData.cameraHeight = Constants.GAME_HEIGHT, this.scaleData.cameraBoundsWidth = 2e3, this.scaleData.cameraBoundsHeight = 2e3, this.scaleData.cameraPositionOffsetX = -Math.floor(Constants.GAME_WIDTH / 4), this.scaleData.cameraPositionOffsetY = -Math.floor(Constants.GAME_HEIGHT / 2)
                }, t.prototype.resetData = function() {
                    this.isInited = !1, this.game = null, this.levelContainer = null, this.scaleData = null
                }, t
            }();
        t.GameCamera = i
    }(t.entities || (t.entities = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(e) {
        var i;
        ! function(t) {
            t[t.PHYSICS = 1] = "PHYSICS", t[t.GRAPHICS = 2] = "GRAPHICS"
        }(i || (i = {}));
        var s = function() {
            function e(t) {
                this.resetData(), this.isDisposed = !1, this.game = t, this.initData()
            }
            return e.prototype.setB2DebugDrawRef = function(t) {
                this.b2DebugDrawRef = t
            }, e.prototype.setCameraRef = function(t) {
                this.cameraRef = t
            }, e.prototype.init = function() {
                this.isDisposed || this.isInited || (this.initViewMode(), this.isInited = !0)
            }, e.prototype.render = function(t, e) {
                !this.isDisposed && this.isInited && (this.cameraRef.render(t, e), this.isUserInputMode ? (this.camZoomId = this.camZoomUserId, this.camZoomDuration = this.camZoomUserDuration) : (this.camZoomId = this.camZoomSetId, this.camZoomDuration = this.camZoomSetDuration), this.camPrevZoomId !== this.camZoomId && (this.camPrevZoomId = this.camZoomId, this.camZoomListIndex = this.getCamZoomListIndexFromZoomId(this.camZoomId), this.viewMode === i.PHYSICS ? this.setZoomInPhysicsMode(this.camZoomListSet.physics[this.camZoomListIndex]) : this.viewMode === i.GRAPHICS && this.setZoomInGraphicsMode(this.camZoomListSet.graphics[this.camZoomListIndex], this.camZoomDuration)))
            }, e.prototype.reset = function() {
                this.camPrevZoomId = -1
            }, e.prototype.activateZoomId = function(t, e, i) {
                void 0 === e && (e = 0), void 0 === i && (i = null), !this.isDisposed && this.isInited && (this.isUserInputMode && !this.isUserInput && (this.isUserInputMode = !1), this.camZoomSetId = t, this.camZoomSetDuration = 1e3 * e, this.camZoomSetBottom = i)
            }, e.prototype.dispose = function() {
                !this.isDisposed && this.isInited && (this.resetData(), this.isDisposed = !0)
            }, e.prototype.initData = function() {
                this.camZoomListSet = {}, this.camZoomListSet.physics = [50, 25, 15], this.camZoomListSet.graphics = [1, .7, .4], this.camZoomUserDuration = 1500
            }, e.prototype.initViewMode = function() {
                var e = t.config.GameConfig.enableGraphics,
                    s = t.config.GameConfig.enableBox2DDebugDraw,
                    o = e && s || !e && !s;
                this.viewMode = o ? 0 : s ? i.PHYSICS : i.GRAPHICS
            }, e.prototype.getCamZoomListIndexFromZoomId = function(e) {
                return e === t.types.GameCameraZoomId.ZOOM_1 ? 0 : e === t.types.GameCameraZoomId.ZOOM_2 ? 1 : e === t.types.GameCameraZoomId.ZOOM_3 ? 2 : -1
            }, e.prototype.setZoomInPhysicsMode = function(e) {
                t.config.GameConfig.b2Scale = e, this.b2DebugDrawRef.SetDrawScale(e)
            }, e.prototype.setZoomInGraphicsMode = function(t, e) {
                this.cameraRef.zoomTo(t, e, this.camZoomSetBottom)
            }, e.prototype.resetData = function() {
                this.isInited = !1, this.game = null, this.cameraRef = null, this.b2DebugDrawRef = null, this.viewMode = 0, this.camPrevZoomId = -1, this.camZoomId = 0, this.camZoomUserId = 0, this.camZoomSetId = 0, this.camZoomListSet = null, this.camZoomListIndex = 0, this.camZoomDuration = 0, this.camZoomUserDuration = 0, this.camZoomSetDuration = 0, this.isUserInput = !1, this.isUserInputMode = !1
            }, e
        }();
        e.GameCameraController = s
    }(t.controllers || (t.controllers = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(e) {
        var i;
        (i || (i = {})).GO_ANIM = "go_anim";
        var s = function(e) {
            function s(i, s, o, n, a, r) {
                var h = e.call(this, i, s, o, t.types.GameObjectType.CHECK_POINT, n, a, r) || this;
                return h.init(), h
            }
            return __extends(s, e), s.prototype.setPositionXY = function(e, i) {
                !this.isDisposed && this.isComponentInited && (this.setPhysicsActiveState(!1), this.componentStartPosition = new Box2D.Common.Math.b2Vec2(t.tools.Convertor.w_to_ws(e), t.tools.Convertor.w_to_ws(i)), this.checkPhysPosX = this.componentStartPosition.x, this.updateCompomentStartTranslation(), this.setPhysicsActiveState(!0), this.calcComponentGraphicsTweensValues())
            }, s.prototype.startDefaultAction = function() {
                if (!this.isDisposed && this.isComponentInited) {
                    var e = new t.types.GameObjectActionData;
                    e.Type = this.type, e.Sender = this, e.Action = t.types.GameObjectActions.REQUEST_BIKE, this.signalOnAction.dispatch(e), e.Action = t.types.GameObjectActions.REQUEST_GAME_CAMERA_CONTROLLER, this.signalOnAction.dispatch(e)
                }
            }, s.prototype.updateLogic = function(t) {
                !this.isDisposed && this.isComponentInited && null != this.bikeRef && this.isComponentActive && this.checkPointPassed() && this.bikeRef.isAlive() && (this.isComponentActive = !1, this.componentGraphicsActionFlag = !0, this.alertPointPassed())
            }, s.prototype.updateGraphics = function(t) {
                !this.isDisposed && this.isComponentInited && this.isGraphicsEnabled && this.componentGraphicsActionFlag && (this.componentGraphicsActionFlag = !1, this.startComponentAnimations(), this.startComponentTweens())
            }, s.prototype.setBikeRef = function(t) {
                this.isDisposed || (this.bikeRef = t, this.gameSettings.startPartName === this.levelPartId || this.bikeRef.getCenterPosition().x >= this.checkPhysPosX || (this.isComponentActive = !0, this.createAnimationsGraphics(), this.createTweenGraphics()))
            }, s.prototype.setGameCameraControllerRef = function(e) {
                if (!this.isDisposed && (this.gameCameraControllerRef = e, this.gameSettings.startPartName === this.levelPartId)) {
                    new t.entities.GameCameraOffset;
                    this.gameCameraControllerRef.activateZoomId(this.gameCameraZoomId, 0)
                }
            }, s.prototype.init = function() {
                this.createPhysics(), this.createGraphics(), this.updateCompomentStartTranslation(), this.calcComponentGraphicsTweensValues(), this.isComponentInited = !0
            }, s.prototype.createPhysics = function() {
                var t = this.data.physics;
                this.createPhysicItem(t[0])
            }, s.prototype.createPhysicItem = function(e) {
                var i = {};
                i.x = t.tools.Convertor.w_to_ws(e.x), i.y = t.tools.Convertor.w_to_ws(e.x), i.rot = t.tools.Convertor.deg_to_rad(e.rotation);
                var s = new t.types.GameObjectData;
                s.Type = this.type, s.UserData1 = i;
                var o = new Box2D.Dynamics.b2BodyDef;
                o.type = Box2D.Dynamics.b2Body.b2_staticBody, o.userData = s, o.position.Set(i.x, i.y), o.angle = i.rot;
                var n = this.b2World.CreateBody(o);
                n.SetActive(!1), e.hasOwnProperty("boxes") && this.createPhysicPartBoxes(e, n, s.Type), n.ResetMassData(), n.SetActive(!0), this.b2Body = n
            }, s.prototype.createPhysicPartBoxes = function(t, e, i) {
                var s = t.boxes,
                    o = s.length,
                    n = 0;
                for (n = 0; n < o; ++n) this.createPhysicPartBoxesItem(s[n], e, i)
            }, s.prototype.createPhysicPartBoxesItem = function(e, i, s) {
                var o = new t.types.GameObjectData;
                o.Type = s;
                var n = new Box2D.Collision.Shapes.b2PolygonShape;
                n.SetAsOrientedBox(t.tools.Convertor.w_to_ws(e.width / 2), t.tools.Convertor.w_to_ws(e.height / 2), new Box2D.Common.Math.b2Vec2(t.tools.Convertor.w_to_ws(e.x), t.tools.Convertor.w_to_ws(e.y)), t.tools.Convertor.deg_to_rad(e.rotation));
                var a = new Box2D.Dynamics.b2FixtureDef;
                a.density = 1e-4, a.friction = 0, a.restitution = 0, a.shape = n, a.userData = o, a.filter.categoryBits = t.types.EntityCategory.UNKNOWN, a.filter.maskBits = t.types.EntityCategory.UNKNOWN, i.CreateFixture(a)
            }, s.prototype.createGraphics = function() {
                this.isGraphicsEnabled && (this.createGraphicsContainers(), this.createStaticGraphics())
            }, s.prototype.createGraphicsContainers = function() {
                this.graphicsContainer = this.game.add.group(this.parentContainer), this.graphicsAnimationsContainer = this.game.add.group(this.graphicsContainer), this.graphicsStaticContainer = this.game.add.group(this.graphicsContainer), this.graphicsTweensContainer = this.game.add.group(this.graphicsContainer)
            }, s.prototype.createAnimationsGraphics = function() {
                var t = this.data.animations;
                this.createAnimationGraphicItem(this.graphicsAnimationsContainer, t[0])
            }, s.prototype.createStaticGraphics = function() {
                var t = this.data.graphics;
                this.createStaticGraphicItem(this.graphicsStaticContainer, t[0])
            }, s.prototype.createTweenGraphics = function() {
                var t = this.data.tweens;
                this.createStaticGraphicItem(this.graphicsTweensContainer, t[0])
            }, s.prototype.createStaticGraphicItem = function(t, e) {
                var i = e.parts,
                    s = 0,
                    o = this.game.add.group(t);
                for (o.position.set(e.x, e.y), o.angle = e.rotation, s = 0; s < i.length; s++) this.createStaticGraphicItemPart(i[s], o)
            }, s.prototype.createStaticGraphicItemPart = function(e, i) {
                var s = e.x,
                    o = e.y,
                    n = e.rotation,
                    a = e.atlasKey;
                this.game.add.image(s, o, t.settings.GameCommonSettings.getGameLevelStartUpAtlasKey(), a, i).angle = n
            }, s.prototype.createAnimationGraphicItem = function(t, e) {
                var i = e.parts,
                    s = this.game.add.group(t);
                s.position.set(e.x, e.y), s.angle = e.rotation, this.animationSprite = this.createStaticAnimationItemPart(i[0], s)
            }, s.prototype.createStaticAnimationItemPart = function(t, e) {
                var s = t.x,
                    o = t.y,
                    n = t.rotation,
                    a = ["a_41_go_check_point_v1_aap_p10000", "a_41_go_check_point_v1_aap_p10001", "a_41_go_check_point_v1_aap_p10002", "a_41_go_check_point_v1_aap_p10003", "a_41_go_check_point_v1_aap_p10004", "a_41_go_check_point_v1_aap_p10005", "a_41_go_check_point_v1_aap_p10006", "a_41_go_check_point_v1_aap_p10007", "a_41_go_check_point_v1_aap_p10008", "a_41_go_check_point_v1_aap_p10009", "a_41_go_check_point_v1_aap_p10010", "a_41_go_check_point_v1_aap_p10011", "a_41_go_check_point_v1_aap_p10012", "a_41_go_check_point_v1_aap_p10013", "a_41_go_check_point_v1_aap_p10014", "a_41_go_check_point_v1_aap_p10015", "a_41_go_check_point_v1_aap_p10016", "a_41_go_check_point_v1_aap_p10017"],
                    r = this.game.add.sprite(s - 10, o, this.gameAtlasKey, a[0], e);
                return r.angle = n, r.animations.add(i.GO_ANIM, a), r
            }, s.prototype.updateCompomentStartTranslation = function() {
                this.updatePhysicsStartTranslation(), this.updateGraphicsTranslation()
            }, s.prototype.updatePhysicsStartTranslation = function() {
                var t = this.b2Body.GetUserData().UserData1;
                this.b2Body.SetPosition(new Box2D.Common.Math.b2Vec2(this.componentStartPosition.x + t.x, this.componentStartPosition.y + t.y)), this.b2Body.SetAngle(this.componentStartRotation + t.rot)
            }, s.prototype.updateGraphicsTranslation = function() {
                if (this.isGraphicsEnabled) {
                    var e = this.b2Body.GetWorldCenter();
                    this.graphicsContainer.position.x = e.x * t.config.GameConfig.b2WorldScale, this.graphicsContainer.position.y = e.y * t.config.GameConfig.b2WorldScale, this.graphicsContainer.rotation = this.b2Body.GetAngle()
                }
            }, s.prototype.checkPointPassed = function() {
                return this.bikeRef.getCenterPosition().x >= this.checkPhysPosX
            }, s.prototype.alertPointPassed = function() {
                var e = new t.types.GameObjectActionData;
                e.Type = this.type, e.Sender = this, e.Action = t.types.GameObjectActions.CHANGE_START_UP_LEVEL_PART, e.Data = {}, e.Data.startPartName = this.levelPartId, this.signalOnAction.dispatch(e), this.soundManager.playSound(Sounds.Checkpoint)
            }, s.prototype.startComponentAnimations = function() {
                this.animationSprite.animations.play(i.GO_ANIM, 24, !1, !0)
            }, s.prototype.startComponentTweens = function() {
                this.game.add.tween(this.graphicsTweensContainer).to({
                    y: this.componentGraphicsTweenUpSide
                }, this.componentGraphicsTweenDuration, Phaser.Easing.Linear.None, !1).start()
            }, s.prototype.calcComponentGraphicsTweensValues = function() {
                if (this.isGraphicsEnabled) {
                    var t = this.gameSettings.worldBounds.height + this.componentGraphicsTweenTopOffset,
                        e = this.graphicsContainer.y;
                    this.componentGraphicsTweenUpSide = -(e + this.componentGraphicsTweenTopOffset), this.componentGraphicsTweenDuration = e * this.componentGraphicsTweenDurationSet / t
                }
            }, s.prototype.setPhysicsActiveState = function(t) {
                this.b2Body.SetActive(t)
            }, s.prototype.disposePhysics = function() {
                this.b2Body.SetActive(!1), this.b2World.DestroyBody(this.b2Body)
            }, s.prototype.disposeGraphics = function() {
                null !== this.graphicsContainer && (this.graphicsContainer.removeAll(!0, !0), null !== this.graphicsContainer.parent && this.graphicsContainer.parent.removeChild(this.graphicsContainer))
            }, s.prototype.customInitData = function() {
                this.levelPartId = this.data.levelPartId, this.gameCameraZoomId = t.tools.Convertor.getGameCameraZoomIdFromStr(this.data.settings.zoomId), this.componentStartPosition = new Box2D.Common.Math.b2Vec2(t.tools.Convertor.w_to_ws(this.data.x), t.tools.Convertor.w_to_ws(this.data.y)), this.componentStartRotation = t.tools.Convertor.deg_to_rad(this.data.rotation), this.componentGraphicsTweenDurationSet = 3e4, this.componentGraphicsTweenTopOffset = 300, this.soundManager = BoilerPlate.SoundManager.getInstance()
            }, s.prototype.customDispose = function() {
                this.disposePhysics(), this.disposeGraphics()
            }, s.prototype.customResetData = function() {
                this.b2Body = null, this.componentStartPosition = null, this.componentStartRotation = 0, this.componentGraphicsActionFlag = !1, this.componentGraphicsTweenUpSide = 0, this.componentGraphicsTweenTopOffset = 0, this.componentGraphicsTweenDuration = 0, this.componentGraphicsTweenDurationSet = 0, this.isComponentActive = !1, this.bikeRef = null, this.gameCameraControllerRef = null, this.gameCameraZoomId = 0, this.levelPartId = null, this.checkPhysPosX = 0, this.graphicsContainer = null, this.graphicsStaticContainer = null, this.graphicsAnimationsContainer = null, this.graphicsTweensContainer = null, this.animationSprite = null, this.soundManager = null
            }, s
        }(t.game_objects.GameObject);
        e.GOCheckPoint = s
    }(t.game_objects || (t.game_objects = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(e) {
        var i = function(e) {
            function i(i, s, o, n, a) {
                var r = e.call(this, i, s, o, t.types.GameObjectType.STICK, n, a) || this;
                return r.init(), r
            }
            return __extends(i, e), i.prototype.setPositionXY = function(e, i) {
                !this.isDisposed && this.isInited && (this.startPosition.x = t.tools.Convertor.w_to_ws(e), this.startPosition.y = t.tools.Convertor.w_to_ws(i), this.updateComponentTranslation())
            }, i.prototype.activatePhysics = function() {
                this.isDisposed || !this.isInited || this.isPhysicsActivated || this.setPhysicsActiveState(!0)
            }, i.prototype.deactivatePhysics = function() {
                !this.isDisposed && this.isInited && this.isPhysicsActivated && this.setPhysicsActiveState(!1)
            }, i.prototype.updateGraphics = function(e) {
                !this.isDisposed && this.isInited && t.config.GameConfig.enableGraphics && this.updateGraphicsTranslation()
            }, i.prototype.init = function() {
                this.createPhysics(), this.createGraphics(), this.updateComponentTranslation(), this.isInited = !0
            }, i.prototype.createPhysics = function() {
                var t = this.data.physics,
                    e = t.length,
                    i = 0;
                for (i = 0; i < e; ++i) this.createPhysicItem(t[i]);
                this.isPhysicsActivated = !0
            }, i.prototype.createPhysicItem = function(e) {
                var i = {};
                i.x = t.tools.Convertor.w_to_ws(e.x), i.y = t.tools.Convertor.w_to_ws(e.y), i.rot = t.tools.Convertor.deg_to_rad(e.rotation);
                var s = t.tools.Convertor.getGameObjectPhysicTypeFromStr(this.data.settings.physicType),
                    o = new t.types.GameObjectData;
                o.Type = t.types.GameObjectType.STICK, o.PhysicType = s, o.MaterialType = t.tools.Convertor.getGameObjectMaterialTypeFromStr(this.data.settings.material), o.UserData1 = i;
                var n = new Box2D.Dynamics.b2BodyDef;
                s === t.types.GameObjectPhysicType.DYNAMIC ? n.type = Box2D.Dynamics.b2Body.b2_dynamicBody : n.type = Box2D.Dynamics.b2Body.b2_staticBody, n.userData = o, n.position.Set(i.x, i.y), n.angle = i.rot;
                var a = this.b2World.CreateBody(n);
                a.SetActive(!1), e.hasOwnProperty("boxes") && this.createPhysicPartBoxes(e, a, o), a.ResetMassData(), a.SetActive(!0), this.b2BodyList.push(a)
            }, i.prototype.createPhysicPartBoxes = function(t, e, i) {
                var s = t.boxes,
                    o = s.length,
                    n = 0;
                for (n = 0; n < o; ++n) this.createPhysicPartBoxesItem(s[n], e, i)
            }, i.prototype.createPhysicPartBoxesItem = function(e, i, s) {
                var o = new t.types.GameObjectData;
                o.Type = s.Type, o.PhysicType = s.PhysicType, o.MaterialType = s.MaterialType, o.EntityCategory = t.types.EntityCategory.GAME_OBJECT;
                var n = new Box2D.Collision.Shapes.b2PolygonShape;
                n.SetAsOrientedBox(t.tools.Convertor.w_to_ws(e.width / 2), t.tools.Convertor.w_to_ws(e.height / 2), new Box2D.Common.Math.b2Vec2(t.tools.Convertor.w_to_ws(e.x), t.tools.Convertor.w_to_ws(e.y)), t.tools.Convertor.deg_to_rad(e.rotation));
                var a = new Box2D.Dynamics.b2FixtureDef;
                a.density = this.data.settings.density, a.friction = this.data.settings.friction, a.restitution = this.data.settings.restitution, a.shape = n, a.filter.categoryBits = o.EntityCategory, a.filter.maskBits = t.types.EntityCategory.BIKE_WHEEL | t.types.EntityCategory.BIKE_BODY | t.types.EntityCategory.BIKE_AXLE | t.types.EntityCategory.GAME_OBJECT | t.types.EntityCategory.BIKE_BODY_SENSOR_HEAD, o.PhysicType === t.types.GameObjectPhysicType.DYNAMIC && (a.filter.maskBits = a.filter.maskBits | t.types.EntityCategory.GROUND), a.userData = o, i.CreateFixture(a)
            }, i.prototype.createGraphics = function() {
                if (this.graphicsContainer = this.game.add.group(), this.parentContainer.add(this.graphicsContainer), t.config.GameConfig.enableGraphics) {
                    var e = this.data.graphics,
                        i = 0;
                    for (i = 0; i < e.length; ++i) this.createGraphicItem(e[i])
                }
            }, i.prototype.createGraphicItem = function(t) {
                var e = t.parts,
                    i = 0,
                    s = this.game.add.group();
                for (s.position.set(t.x, t.y), s.angle = t.rotation, this.graphicsContainer.add(s), i = 0; i < e.length; i++) this.createGraphicItemPart(e[i], s)
            }, i.prototype.createGraphicItemPart = function(e, i) {
                var s = e.x,
                    o = e.y,
                    n = e.rotation,
                    a = e.atlasKey,
                    r = this.game.add.image(s, o, t.settings.GameCommonSettings.getGameLevelStartUpAtlasKey(), a);
                r.angle = n, i.add(r)
            }, i.prototype.updateComponentTranslation = function() {
                this.updatePhysicsTranslation(), t.config.GameConfig.enableGraphics && this.updateGraphicsTranslation()
            }, i.prototype.updatePhysicsTranslation = function() {
                var t = this.isPhysicsActivated;
                t && this.setPhysicsActiveState(!1);
                var e = this.b2BodyList.length,
                    i = 0;
                for (i = 0; i < e; ++i) {
                    var s = this.b2BodyList[i],
                        o = s.GetUserData().UserData1;
                    s.SetPosition(new Box2D.Common.Math.b2Vec2(this.startPosition.x + o.x, this.startPosition.y + o.y)), s.SetAngle(this.componentRotation + o.rot)
                }
                t && this.setPhysicsActiveState(!0)
            }, i.prototype.updateGraphicsTranslation = function() {
                var e, i = Math.min(this.b2BodyList.length, this.graphicsContainer.children.length);
                for (e = 0; e < i; ++e) {
                    var s = this.b2BodyList[e],
                        o = this.graphicsContainer.getChildAt(e),
                        n = s.GetPosition(),
                        a = s.GetAngle();
                    o.position.x = n.x * t.config.GameConfig.b2WorldScale, o.position.y = n.y * t.config.GameConfig.b2WorldScale, o.rotation = a
                }
            }, i.prototype.setPhysicsActiveState = function(t) {
                var e = this.b2BodyList.length,
                    i = 0;
                for (i = 0; i < e; ++i) this.b2BodyList[i].SetActive(t);
                this.isPhysicsActivated = t
            }, i.prototype.disposePhysics = function() {
                var t = this.b2BodyList.length,
                    e = 0;
                if (t > 0)
                    for (e = 0; e < t; ++e) {
                        var i = this.b2BodyList[e];
                        i.SetActive(!1), this.b2World.DestroyBody(i)
                    }
                this.b2BodyList.length = 0
            }, i.prototype.disposeGraphics = function() {
                null != this.parentContainer && null != this.graphicsContainer && this.parentContainer.remove(this.graphicsContainer, !0, !0)
            }, i.prototype.initData = function() {
                e.prototype.initData.call(this), this.b2BodyList = [], this.startPosition = new Box2D.Common.Math.b2Vec2(t.tools.Convertor.w_to_ws(this.data.x), t.tools.Convertor.w_to_ws(this.data.y)), this.componentRotation = t.tools.Convertor.deg_to_rad(this.data.rotation)
            }, i.prototype.customDispose = function() {
                this.disposePhysics(), this.disposeGraphics()
            }, i.prototype.resetData = function() {
                e.prototype.resetData.call(this), this.b2BodyList = null, this.isPhysicsActivated = !1, this.isInited = !1, this.graphicsContainer = null, this.startPosition = null, this.componentRotation = 0
            }, i
        }(t.game_objects.GameObject);
        e.GOStick = i
    }(t.game_objects || (t.game_objects = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(e) {
        var i = function(e) {
            function i(i, s, o, n, a) {
                var r = e.call(this, i, s, o, t.types.GameObjectType.CIRCLE, n, a) || this;
                return r.init(), r
            }
            return __extends(i, e), i.prototype.setPositionXY = function(e, i) {
                !this.isDisposed && this.isInited && (this.startPosition.x = t.tools.Convertor.w_to_ws(e), this.startPosition.y = t.tools.Convertor.w_to_ws(i), this.updateComponentTranslation())
            }, i.prototype.activatePhysics = function() {
                this.isDisposed || !this.isInited || this.isPhysicsActivated || this.setPhysicsActiveState(!0)
            }, i.prototype.deactivatePhysics = function() {
                !this.isDisposed && this.isInited && this.isPhysicsActivated && this.setPhysicsActiveState(!1)
            }, i.prototype.updateGraphics = function(e) {
                !this.isDisposed && this.isInited && t.config.GameConfig.enableGraphics && this.updateGraphicsTranslation()
            }, i.prototype.init = function() {
                this.createPhysics(), this.createGraphics(), this.updateComponentTranslation(), this.isInited = !0
            }, i.prototype.createPhysics = function() {
                var t = this.data.physics,
                    e = t.length,
                    i = 0;
                for (i = 0; i < e; ++i) this.createPhysicItem(t[i]);
                this.isPhysicsActivated = !0
            }, i.prototype.createPhysicItem = function(e) {
                var i = {};
                i.x = t.tools.Convertor.w_to_ws(e.x), i.y = t.tools.Convertor.w_to_ws(e.x), i.rot = t.tools.Convertor.deg_to_rad(e.rotation);
                var s = t.tools.Convertor.getGameObjectPhysicTypeFromStr(this.data.settings.physicType),
                    o = new t.types.GameObjectData;
                o.Type = t.types.GameObjectType.CIRCLE, o.PhysicType = s, o.MaterialType = t.tools.Convertor.getGameObjectMaterialTypeFromStr(this.data.settings.material), o.UserData1 = i;
                var n = new Box2D.Dynamics.b2BodyDef;
                s === t.types.GameObjectPhysicType.DYNAMIC ? n.type = Box2D.Dynamics.b2Body.b2_dynamicBody : n.type = Box2D.Dynamics.b2Body.b2_staticBody, n.userData = o, n.position.Set(i.x, i.y), n.angle = i.rot;
                var a = this.b2World.CreateBody(n);
                a.SetActive(!1), e.hasOwnProperty("circles") && this.createPhysicPartCircles(e, a, o.Type, o.PhysicType, o.MaterialType), a.ResetMassData(), a.SetActive(!0), this.b2BodyList.push(a)
            }, i.prototype.createPhysicPartCircles = function(t, e, i, s, o) {
                var n = t.circles,
                    a = n.length,
                    r = 0;
                for (r = 0; r < a; ++r) this.createPhysicPartCirclesItem(n[r], e, i, s, o)
            }, i.prototype.createPhysicPartCirclesItem = function(e, i, s, o, n) {
                var a = new t.types.GameObjectData;
                a.Type = s, a.PhysicType = o, a.MaterialType = n, a.EntityCategory = t.types.EntityCategory.GAME_OBJECT;
                var r = new Box2D.Collision.Shapes.b2CircleShape(t.tools.Convertor.w_to_ws(e.width / 2));
                r.SetLocalPosition(new Box2D.Common.Math.b2Vec2(t.tools.Convertor.w_to_ws(e.x), t.tools.Convertor.w_to_ws(e.y)));
                var h = new Box2D.Dynamics.b2FixtureDef;
                h.density = this.data.settings.density, h.friction = this.data.settings.friction, h.restitution = this.data.settings.restitution, h.shape = r, h.filter.categoryBits = a.EntityCategory, h.filter.maskBits = t.types.EntityCategory.BIKE_WHEEL | t.types.EntityCategory.BIKE_BODY | t.types.EntityCategory.BIKE_AXLE | t.types.EntityCategory.GAME_OBJECT | t.types.EntityCategory.BIKE_BODY_SENSOR_HEAD, a.PhysicType === t.types.GameObjectPhysicType.DYNAMIC && (h.filter.maskBits = h.filter.maskBits | t.types.EntityCategory.GROUND), h.userData = a, i.CreateFixture(h)
            }, i.prototype.createGraphics = function() {
                if (this.graphicsContainer = this.game.add.group(), this.parentContainer.add(this.graphicsContainer), t.config.GameConfig.enableGraphics) {
                    var e = this.data.graphics,
                        i = 0;
                    for (i = 0; i < e.length; ++i) this.createGraphicItem(e[i])
                }
            }, i.prototype.createGraphicItem = function(t) {
                var e = t.parts,
                    i = 0,
                    s = this.game.add.group();
                for (s.position.set(t.x, t.y), s.angle = t.rotation, this.graphicsContainer.add(s), i = 0; i < e.length; i++) this.createGraphicItemPart(e[i], s)
            }, i.prototype.createGraphicItemPart = function(e, i) {
                var s = e.x,
                    o = e.y,
                    n = e.rotation,
                    a = e.atlasKey,
                    r = this.game.add.image(s, o, t.settings.GameCommonSettings.getGameLevelStartUpAtlasKey(), a);
                r.angle = n, i.add(r)
            }, i.prototype.updateComponentTranslation = function() {
                this.updatePhysicsTranslation(), t.config.GameConfig.enableGraphics && this.updateGraphicsTranslation()
            }, i.prototype.updatePhysicsTranslation = function() {
                var t = this.isPhysicsActivated;
                t && this.setPhysicsActiveState(!1);
                var e = this.b2BodyList.length,
                    i = 0;
                for (i = 0; i < e; ++i) {
                    var s = this.b2BodyList[i],
                        o = s.GetUserData().UserData1;
                    s.SetPosition(new Box2D.Common.Math.b2Vec2(this.startPosition.x + o.x, this.startPosition.y + o.y)), s.SetAngle(this.componentRotation + o.rot)
                }
                t && this.setPhysicsActiveState(!0)
            }, i.prototype.updateGraphicsTranslation = function() {
                var e, i = Math.min(this.b2BodyList.length, this.graphicsContainer.children.length);
                for (e = 0; e < i; ++e) {
                    var s = this.b2BodyList[e],
                        o = this.graphicsContainer.getChildAt(e),
                        n = s.GetPosition(),
                        a = s.GetAngle();
                    o.position.x = n.x * t.config.GameConfig.b2WorldScale, o.position.y = n.y * t.config.GameConfig.b2WorldScale, o.rotation = a
                }
            }, i.prototype.setPhysicsActiveState = function(t) {
                var e = this.b2BodyList.length,
                    i = 0;
                for (i = 0; i < e; ++i) this.b2BodyList[i].SetActive(t);
                this.isPhysicsActivated = t
            }, i.prototype.disposePhysics = function() {
                var t = this.b2BodyList.length,
                    e = 0;
                if (t > 0)
                    for (e = 0; e < t; ++e) {
                        var i = this.b2BodyList[e];
                        i.SetActive(!1), this.b2World.DestroyBody(i)
                    }
                this.b2BodyList.length = 0
            }, i.prototype.disposeGraphics = function() {
                null != this.parentContainer && null != this.graphicsContainer && this.parentContainer.remove(this.graphicsContainer, !0, !0)
            }, i.prototype.initData = function() {
                e.prototype.initData.call(this), this.b2BodyList = [], this.startPosition = new Box2D.Common.Math.b2Vec2(t.tools.Convertor.w_to_ws(this.data.x), t.tools.Convertor.w_to_ws(this.data.y)), this.componentRotation = t.tools.Convertor.deg_to_rad(this.data.rotation)
            }, i.prototype.customDispose = function() {
                this.disposePhysics(), this.disposeGraphics()
            }, i.prototype.resetData = function() {
                e.prototype.resetData.call(this), this.b2BodyList = null, this.isPhysicsActivated = !1, this.isInited = !1, this.graphicsContainer = null, this.startPosition = null, this.componentRotation = 0
            }, i
        }(t.game_objects.GameObject);
        e.GOCircle = i
    }(t.game_objects || (t.game_objects = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(e) {
        var i = function(e) {
            function i(i, s, o, n, a) {
                var r = e.call(this, i, s, o, t.types.GameObjectType.TRIGGER, n, a) || this;
                return r.init(), r
            }
            return __extends(i, e), Object.defineProperty(i.prototype, "IsTriggerActive", {
                get: function() {
                    return this.isTriggerActive
                },
                enumerable: !0,
                configurable: !0
            }), i.prototype.activateTrigger = function() {
                if (!this.isDisposed && this.isInited) {
                    this.isTriggerActive = !1, console.log("trigger activated!");
                    var e = new t.types.GameObjectActionData;
                    e.Type = this.type, e.Sender = this, e.Action = t.types.GameObjectActions.TRIGGER_ACTION, e.Data = {}, e.Data.objectId = this.data.settings.actionObjectId, e.Data.objectAction = this.data.settings.action, this.signalOnAction.dispatch(e)
                }
            }, i.prototype.setPositionXY = function(e, i) {
                if (!this.isDisposed && this.isInited) {
                    var s = this.isPhysicsActivated;
                    s && this._deactivatePhysics();
                    var o = t.tools.Convertor.w_to_ws(e),
                        n = t.tools.Convertor.w_to_ws(i),
                        a = this.b2BodyList.length,
                        r = 0;
                    for (r = 0; r < a; ++r) {
                        var h = this.b2BodyList[r],
                            l = h.GetUserData().UserData1;
                        h.SetPosition(new Box2D.Common.Math.b2Vec2(o + l.x, n + l.y))
                    }
                    s && this._activatePhysics()
                }
            }, i.prototype.activatePhysics = function() {
                this.isDisposed || !this.isInited || this.isPhysicsActivated || this._activatePhysics()
            }, i.prototype.deactivatePhysics = function() {
                !this.isDisposed && this.isInited && this.isPhysicsActivated && this._deactivatePhysics()
            }, i.prototype.init = function() {
                this.createPhysics(), this.isInited = !0
            }, i.prototype.createPhysics = function() {
                var t = this.data.physics,
                    e = t.length,
                    i = 0;
                for (i = 0; i < e; ++i) this.createPhysicItem(t[i]);
                this.isPhysicsActivated = !0, this.isTriggerActive = !0
            }, i.prototype.createPhysicItem = function(e) {
                var i = {};
                i.x = t.tools.Convertor.w_to_ws(e.x), i.y = t.tools.Convertor.w_to_ws(e.x), i.rot = t.tools.Convertor.deg_to_rad(e.rotation);
                var s = t.tools.Convertor.getGameObjectPhysicTypeFromStr(this.data.settings.physicType),
                    o = new t.types.GameObjectData;
                o.Type = t.types.GameObjectType.TRIGGER, o.PhysicType = s, o.MaterialType = t.tools.Convertor.getGameObjectMaterialTypeFromStr(this.data.settings.material), o.UserData1 = i, o.UserData2 = this;
                var n = new Box2D.Dynamics.b2BodyDef;
                s === t.types.GameObjectPhysicType.DYNAMIC ? n.type = Box2D.Dynamics.b2Body.b2_dynamicBody : n.type = Box2D.Dynamics.b2Body.b2_staticBody, n.userData = o, n.position.Set(i.x, i.y), n.angle = i.rot;
                var a = this.b2World.CreateBody(n);
                a.SetActive(!1), e.hasOwnProperty("boxes") && this.createPhysicPartBoxes(e, a, o), a.ResetMassData(), a.SetActive(!0), this.b2BodyList.push(a)
            }, i.prototype.createPhysicPartBoxes = function(t, e, i) {
                var s = t.boxes,
                    o = s.length,
                    n = 0;
                for (n = 0; n < o; ++n) this.createPhysicPartBoxesItem(s[n], e, i)
            }, i.prototype.createPhysicPartBoxesItem = function(e, i, s) {
                var o = new t.types.GameObjectData;
                o.Type = s.Type, o.PhysicType = s.PhysicType, o.MaterialType = s.MaterialType, o.UserData2 = s.UserData2, o.EntityCategory = t.types.EntityCategory.GAME_OBJECT;
                var n = new Box2D.Collision.Shapes.b2PolygonShape;
                n.SetAsOrientedBox(t.tools.Convertor.w_to_ws(e.width / 2), t.tools.Convertor.w_to_ws(e.height / 2), new Box2D.Common.Math.b2Vec2(t.tools.Convertor.w_to_ws(e.x), t.tools.Convertor.w_to_ws(e.y)), t.tools.Convertor.deg_to_rad(e.rotation));
                var a = new Box2D.Dynamics.b2FixtureDef;
                a.density = this.data.settings.density, a.friction = this.data.settings.friction, a.restitution = this.data.settings.restitution, a.shape = n, a.filter.categoryBits = o.EntityCategory, a.filter.maskBits = t.types.EntityCategory.BIKE_WHEEL | t.types.EntityCategory.BIKE_BODY | t.types.EntityCategory.BIKE_AXLE | t.types.EntityCategory.GAME_OBJECT | t.types.EntityCategory.BIKE_BODY_SENSOR_HEAD, o.PhysicType === t.types.GameObjectPhysicType.DYNAMIC && (a.filter.maskBits = a.filter.maskBits | t.types.EntityCategory.GROUND), a.userData = o, a.isSensor = !0, i.CreateFixture(a)
            }, i.prototype._activatePhysics = function() {
                var t = this.b2BodyList.length,
                    e = 0;
                for (e = 0; e < t; ++e) this.b2BodyList[e].SetActive(!0);
                this.isPhysicsActivated = !0
            }, i.prototype._deactivatePhysics = function() {
                var t = this.b2BodyList.length,
                    e = 0;
                for (e = 0; e < t; ++e) this.b2BodyList[e].SetActive(!1);
                this.isPhysicsActivated = !1
            }, i.prototype.disposePhysics = function() {
                var t = this.b2BodyList.length,
                    e = 0;
                if (t > 0)
                    for (e = 0; e < t; ++e) {
                        var i = this.b2BodyList[e];
                        i.SetActive(!1), this.b2World.DestroyBody(i)
                    }
                this.b2BodyList.length = 0
            }, i.prototype.initData = function() {
                e.prototype.initData.call(this), this.b2BodyList = []
            }, i.prototype.customDispose = function() {
                this.disposePhysics()
            }, i.prototype.resetData = function() {
                e.prototype.resetData.call(this), this.b2BodyList = null, this.isPhysicsActivated = !1, this.isInited = !1, this.isTriggerActive = !1
            }, i
        }(t.game_objects.GameObject);
        e.GOTrigger = i
    }(t.game_objects || (t.game_objects = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(e) {
        var i = function(e) {
            function i(i, s, o, n, a) {
                var r = e.call(this, i, s, o, t.types.GameObjectType.MULTI_TRIGGER, n, a) || this;
                return r.init(), r
            }
            return __extends(i, e), Object.defineProperty(i.prototype, "IsTriggerActive", {
                get: function() {
                    return this.isTriggerActive
                },
                enumerable: !0,
                configurable: !0
            }), i.prototype.activateTrigger = function() {
                !this.isDisposed && this.isInited && (this.isTriggerActive = !1, this.isTriggerProcessActionObjectsListStarted = !0, console.log("trigger activated!"))
            }, i.prototype.updateLogic = function(t) {
                !this.isDisposed && this.isInited && this.updateTriggerLogic(t)
            }, i.prototype.setPositionXY = function(e, i) {
                if (!this.isDisposed && this.isInited) {
                    var s = this.isPhysicsActivated;
                    s && this._deactivatePhysics();
                    var o = t.tools.Convertor.w_to_ws(e),
                        n = t.tools.Convertor.w_to_ws(i),
                        a = this.b2BodyList.length,
                        r = 0;
                    for (r = 0; r < a; ++r) {
                        var h = this.b2BodyList[r],
                            l = h.GetUserData().UserData1;
                        h.SetPosition(new Box2D.Common.Math.b2Vec2(o + l.x, n + l.y))
                    }
                    s && this._activatePhysics()
                }
            }, i.prototype.activatePhysics = function() {
                this.isDisposed || !this.isInited || this.isPhysicsActivated || this._activatePhysics()
            }, i.prototype.deactivatePhysics = function() {
                !this.isDisposed && this.isInited && this.isPhysicsActivated && this._deactivatePhysics()
            }, i.prototype.initTriggerActionObjectsList = function() {
                this.triggerActionObjectsList = [];
                var t, e = this.data.settings.actionObjects,
                    i = e.length;
                for (t = 0; t < i; t++) {
                    var o = e[t],
                        n = new s(o.objectId, o.action, o.waitBefore);
                    this.triggerActionObjectsList.push(n)
                }
            }, i.prototype.init = function() {
                this.createPhysics(), this.isInited = !0
            }, i.prototype.createPhysics = function() {
                var t = this.data.physics,
                    e = t.length,
                    i = 0;
                for (i = 0; i < e; ++i) this.createPhysicItem(t[i]);
                this.isPhysicsActivated = !0, this.isTriggerActive = !0
            }, i.prototype.createPhysicItem = function(e) {
                var i = {};
                i.x = t.tools.Convertor.w_to_ws(e.x), i.y = t.tools.Convertor.w_to_ws(e.x), i.rot = t.tools.Convertor.deg_to_rad(e.rotation);
                var s = t.tools.Convertor.getGameObjectPhysicTypeFromStr(this.data.settings.physicType),
                    o = new t.types.GameObjectData;
                o.Type = t.types.GameObjectType.MULTI_TRIGGER, o.PhysicType = s, o.MaterialType = t.tools.Convertor.getGameObjectMaterialTypeFromStr(this.data.settings.material), o.UserData1 = i, o.UserData2 = this;
                var n = new Box2D.Dynamics.b2BodyDef;
                s === t.types.GameObjectPhysicType.DYNAMIC ? n.type = Box2D.Dynamics.b2Body.b2_dynamicBody : n.type = Box2D.Dynamics.b2Body.b2_staticBody, n.userData = o, n.position.Set(i.x, i.y), n.angle = i.rot;
                var a = this.b2World.CreateBody(n);
                a.SetActive(!1), e.hasOwnProperty("boxes") && this.createPhysicPartBoxes(e, a, o), a.ResetMassData(), a.SetActive(!0), this.b2BodyList.push(a)
            }, i.prototype.createPhysicPartBoxes = function(t, e, i) {
                var s = t.boxes,
                    o = s.length,
                    n = 0;
                for (n = 0; n < o; ++n) this.createPhysicPartBoxesItem(s[n], e, i)
            }, i.prototype.createPhysicPartBoxesItem = function(e, i, s) {
                var o = new t.types.GameObjectData;
                o.Type = s.Type, o.PhysicType = s.PhysicType, o.MaterialType = s.MaterialType, o.UserData2 = s.UserData2, o.EntityCategory = t.types.EntityCategory.GAME_OBJECT;
                var n = new Box2D.Collision.Shapes.b2PolygonShape;
                n.SetAsOrientedBox(t.tools.Convertor.w_to_ws(e.width / 2), t.tools.Convertor.w_to_ws(e.height / 2), new Box2D.Common.Math.b2Vec2(t.tools.Convertor.w_to_ws(e.x), t.tools.Convertor.w_to_ws(e.y)), t.tools.Convertor.deg_to_rad(e.rotation));
                var a = new Box2D.Dynamics.b2FixtureDef;
                a.density = this.data.settings.density, a.friction = this.data.settings.friction, a.restitution = this.data.settings.restitution, a.shape = n, a.filter.categoryBits = o.EntityCategory, a.filter.maskBits = t.types.EntityCategory.BIKE_WHEEL | t.types.EntityCategory.BIKE_BODY | t.types.EntityCategory.BIKE_AXLE | t.types.EntityCategory.GAME_OBJECT | t.types.EntityCategory.BIKE_BODY_SENSOR_HEAD, o.PhysicType === t.types.GameObjectPhysicType.DYNAMIC && (a.filter.maskBits = a.filter.maskBits | t.types.EntityCategory.GROUND), a.userData = o, a.isSensor = !0, i.CreateFixture(a)
            }, i.prototype.updateTriggerLogic = function(t) {
                this.isTriggerProcessActionObjectsListStarted && this.processTriggerActionObjectsList(t)
            }, i.prototype.processTriggerActionObjectsList = function(t) {
                this.elapsedTime += t;
                var e = this.triggerActionObjectsList.length,
                    i = 0,
                    s = 0;
                for (i = 0; i < e; i++) {
                    var o = this.triggerActionObjectsList[i];
                    o.CheckEnabled ? this.elapsedTime >= o.ActionDelay && (console.log("item: " + o.Id + "; " + o.Action + "; after delay: " + o.ActionDelay.toString() + " activated!"), this.activateActionObjectItem(o)) : s++
                }
                s === e && (this.isTriggerProcessActionObjectsListStarted = !1)
            }, i.prototype.activateActionObjectItem = function(e) {
                e.disableChecking();
                var i = new t.types.GameObjectActionData;
                i.Type = this.type, i.Sender = this, i.Action = t.types.GameObjectActions.TRIGGER_ACTION, i.Data = {}, i.Data.objectId = e.Id, i.Data.objectAction = e.Action, this.signalOnAction.dispatch(i)
            }, i.prototype._activatePhysics = function() {
                var t = this.b2BodyList.length,
                    e = 0;
                for (e = 0; e < t; ++e) this.b2BodyList[e].SetActive(!0);
                this.isPhysicsActivated = !0
            }, i.prototype._deactivatePhysics = function() {
                var t = this.b2BodyList.length,
                    e = 0;
                for (e = 0; e < t; ++e) this.b2BodyList[e].SetActive(!1);
                this.isPhysicsActivated = !1
            }, i.prototype.resetTriggerActionObjectsList = function() {
                this.triggerActionObjectsList.length = 0
            }, i.prototype.disposePhysics = function() {
                var t = this.b2BodyList.length,
                    e = 0;
                if (t > 0)
                    for (e = 0; e < t; ++e) {
                        var i = this.b2BodyList[e];
                        i.SetActive(!1), this.b2World.DestroyBody(i)
                    }
                this.b2BodyList.length = 0
            }, i.prototype.initData = function() {
                e.prototype.initData.call(this), this.b2BodyList = [], this.initTriggerActionObjectsList()
            }, i.prototype.customDispose = function() {
                this.resetTriggerActionObjectsList(), this.disposePhysics()
            }, i.prototype.resetData = function() {
                e.prototype.resetData.call(this), this.b2BodyList = null, this.isPhysicsActivated = !1, this.isInited = !1, this.isTriggerActive = !1, this.triggerActionObjectsList = null, this.isTriggerProcessActionObjectsListStarted = !1, this.elapsedTime = 0
            }, i
        }(t.game_objects.GameObject);
        e.GOMultiTrigger = i;
        var s = function() {
            function t(t, e, i) {
                this.resetData(), this.id = t, this.action = e, this.actionDelay = i, this.initData()
            }
            return Object.defineProperty(t.prototype, "Id", {
                get: function() {
                    return this.id
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(t.prototype, "Action", {
                get: function() {
                    return this.action
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(t.prototype, "ActionDelay", {
                get: function() {
                    return this.actionDelay
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(t.prototype, "CheckEnabled", {
                get: function() {
                    return this.checkEnabled
                },
                enumerable: !0,
                configurable: !0
            }), t.prototype.disableChecking = function() {
                this.checkEnabled = !1
            }, t.prototype.initData = function() {
                this.checkEnabled = !0
            }, t.prototype.resetData = function() {
                this.id = null, this.action = null, this.actionDelay = 0, this.checkEnabled = !1
            }, t
        }()
    }(t.game_objects || (t.game_objects = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(e) {
        var i;
        ! function(t) {
            t[t.STOP = 0] = "STOP", t[t.ROTATING_FORWARD = 1] = "ROTATING_FORWARD", t[t.ROTATING_BACKWARD = 2] = "ROTATING_BACKWARD"
        }(i || (i = {}));
        var s;
        ! function(t) {
            t[t.UNKNOWN = 0] = "UNKNOWN", t[t.ROTATE_FORWARD = 1] = "ROTATE_FORWARD", t[t.ROTATE_BACKWARD = 2] = "ROTATE_BACKWARD", t[t.STOP = 3] = "STOP"
        }(s || (s = {}));
        var o;
        ! function(t) {
            t[t.UNKNOWN = 0] = "UNKNOWN", t[t.ROTATE_FORWARD = 1] = "ROTATE_FORWARD", t[t.ROTATE_BACKWARD = 2] = "ROTATE_BACKWARD", t[t.STOP = 3] = "STOP", t[t.IDLE = 4] = "IDLE"
        }(o || (o = {}));
        var n = function(e) {
            function n(i, s, o, n, a) {
                var r = e.call(this, i, s, o, t.types.GameObjectType.ROTATING_OBJECT, n, a) || this;
                return r.init(), r
            }
            return __extends(n, e), n.prototype.updateLogic = function(t) {
                !this.isDisposed && this.isComponentInited && this.checkComponentState(t)
            }, n.prototype.updateGraphics = function(t) {
                !this.isDisposed && this.isGraphicsEnabled && this.isComponentInited && this.updateGraphicsTranslation()
            }, n.prototype.setPositionXY = function(e, i) {
                !this.isDisposed && this.isComponentInited && (this.setPhysicsActiveState(!1), this.componentStartPosition = new Box2D.Common.Math.b2Vec2(t.tools.Convertor.w_to_ws(e), t.tools.Convertor.w_to_ws(i)), this.updateCompomentStartTranslation(), this.setPhysicsActiveState(!0))
            }, n.prototype.startDefaultAction = function() {
                if (!this.isDisposed && this.isComponentInited) {
                    var e = new t.types.GameObjectActionData;
                    e.Type = this.type, e.Sender = this, e.Action = t.types.GameObjectActions.REQUEST_BIKE, this.signalOnAction.dispatch(e), this.componentAction = this.getComponentActionFromStr(this.data.settings.defaultAction), this.startComponentNewAction()
                }
            }, n.prototype.startAction = function(t) {
                !this.isDisposed && this.isComponentInited && (this.componentAction = this.getComponentActionFromStr(t), this.startComponentNewAction())
            }, n.prototype.setBikeRef = function(t) {
                this.isDisposed || (this.bikeRef = t, this.checkComponentActiveState())
            }, n.prototype.init = function() {
                this.createPhysics(), this.createGraphics(), this.updateCompomentStartTranslation(), this.isComponentInited = !0
            }, n.prototype.customInitData = function() {
                this.componentProcessActionsList = [], this.componentStartPosition = new Box2D.Common.Math.b2Vec2(t.tools.Convertor.w_to_ws(this.data.x), t.tools.Convertor.w_to_ws(this.data.y)), this.componentStartRotation = t.tools.Convertor.deg_to_rad(this.data.rotation), this.componentAngularVelocitySet = t.tools.Convertor.deg_to_rad(this.data.settings.anglularVelocity), this.componentState = i.STOP, this.activeDistance = t.tools.Convertor.w_to_ws(4e3), this.activeStateFlag = !0
            }, n.prototype.createPhysics = function() {
                var t = this.data.physics,
                    e = t.length,
                    i = 0;
                for (i = 0; i < e; ++i) this.createPhysicItem(t[i])
            }, n.prototype.createPhysicItem = function(e) {
                var i = {};
                i.x = t.tools.Convertor.w_to_ws(e.x), i.y = t.tools.Convertor.w_to_ws(e.x), i.rot = t.tools.Convertor.deg_to_rad(e.rotation);
                var s = new t.types.GameObjectData;
                s.Type = this.type, s.PhysicType = t.types.GameObjectPhysicType.KINEMATIC, s.MaterialType = t.tools.Convertor.getGameObjectMaterialTypeFromStr(this.data.settings.material), s.UserData1 = i;
                var o = new Box2D.Dynamics.b2BodyDef;
                o.type = Box2D.Dynamics.b2Body.b2_kinematicBody, o.userData = s, o.position.Set(i.x, i.y), o.angle = i.rot, o.fixedRotation = !0;
                var n = this.b2World.CreateBody(o);
                n.SetActive(!1), e.hasOwnProperty("trianglesList") && this.createPhysicPartFromTrianglesList(e, n, s), e.hasOwnProperty("circles") && this.createPhysicPartFromCircles(e, n, s), e.hasOwnProperty("boxes") && this.createPhysicPartFromBoxes(e, n, s), e.hasOwnProperty("triangularPointsList") && this.createPhysicPartFromTriangularPointsList(e, n, s), n.ResetMassData(), n.SetActive(!0), this.b2Body = n
            }, n.prototype.createPhysicPartFromTrianglesList = function(t, e, i) {
                var s = t.trianglesList,
                    o = 0;
                for (o = 0; o < s.length; o++) this.createPhysicPartFromTrianglePointsArr(s[o], e, i)
            }, n.prototype.createPhysicPartFromTrianglePointsArr = function(e, i, s) {
                var o = e,
                    n = o.length;
                if (!(n < 2)) {
                    var a = n,
                        r = 0,
                        h = [],
                        l = o[0],
                        c = o[n - 1];
                    for (Math.abs(c.x - l.x) < .1 && Math.abs(c.y - l.y) < .1 && (a -= 1), r = 0; r < a; r++) {
                        var p = o[r],
                            u = new Box2D.Common.Math.b2Vec2(t.tools.Convertor.w_to_ws(p.x), t.tools.Convertor.w_to_ws(p.y));
                        h.push(u)
                    }
                    if (!(h.length < 2)) {
                        var d = new t.types.GameObjectData;
                        d.Type = s.Type, d.PhysicType = s.PhysicType, d.MaterialType = s.MaterialType, d.EntityCategory = t.types.EntityCategory.GAME_OBJECT;
                        var m = new Box2D.Collision.Shapes.b2PolygonShape;
                        m.SetAsArray(h);
                        var y = new Box2D.Dynamics.b2FixtureDef;
                        y.density = this.data.settings.density, y.friction = this.data.settings.friction, y.restitution = this.data.settings.restitution, y.shape = m, y.filter.categoryBits = d.EntityCategory, y.filter.maskBits = t.types.EntityCategory.BIKE_BODY | t.types.EntityCategory.BIKE_AXLE | t.types.EntityCategory.BIKE_WHEEL | t.types.EntityCategory.GAME_OBJECT | t.types.EntityCategory.BIKE_BODY_SENSOR_BODY | t.types.EntityCategory.BIKE_BODY_SENSOR_HEAD, y.userData = d, i.CreateFixture(y)
                    }
                }
            }, n.prototype.createPhysicPartFromCircles = function(t, e, i) {
                var s = t.circles,
                    o = 0;
                for (o = 0; o < s.length; o++) this.createPhysicPartFromCircleData(s[o], e, i)
            }, n.prototype.createPhysicPartFromCircleData = function(e, i, s) {
                var o = new t.types.GameObjectData;
                o.Type = s.Type, o.PhysicType = s.PhysicType, o.MaterialType = s.MaterialType, o.EntityCategory = t.types.EntityCategory.GAME_OBJECT;
                var n = new Box2D.Collision.Shapes.b2CircleShape(t.tools.Convertor.w_to_ws(e.width / 2));
                n.SetLocalPosition(new Box2D.Common.Math.b2Vec2(t.tools.Convertor.w_to_ws(e.x), t.tools.Convertor.w_to_ws(e.y)));
                var a = new Box2D.Dynamics.b2FixtureDef;
                a.density = this.data.settings.density, a.friction = this.data.settings.friction, a.restitution = this.data.settings.restitution, a.shape = n, a.filter.categoryBits = o.EntityCategory, a.filter.maskBits = t.types.EntityCategory.BIKE_BODY | t.types.EntityCategory.BIKE_AXLE | t.types.EntityCategory.BIKE_WHEEL | t.types.EntityCategory.GAME_OBJECT | t.types.EntityCategory.BIKE_BODY_SENSOR_BODY | t.types.EntityCategory.BIKE_BODY_SENSOR_HEAD, a.userData = o, i.CreateFixture(a)
            }, n.prototype.createPhysicPartFromBoxes = function(t, e, i) {
                var s = t.boxes,
                    o = 0;
                for (o = 0; o < s.length; o++) this.createPhysicPartFromBoxData(s[o], e, i)
            }, n.prototype.createPhysicPartFromBoxData = function(e, i, s) {
                var o = new t.types.GameObjectData;
                o.Type = s.Type, o.PhysicType = s.PhysicType, o.MaterialType = s.MaterialType, o.EntityCategory = t.types.EntityCategory.GAME_OBJECT;
                var n = new Box2D.Collision.Shapes.b2PolygonShape;
                n.SetAsOrientedBox(t.tools.Convertor.w_to_ws(e.width / 2), t.tools.Convertor.w_to_ws(e.height / 2), new Box2D.Common.Math.b2Vec2(t.tools.Convertor.w_to_ws(e.x), t.tools.Convertor.w_to_ws(e.y)), t.tools.Convertor.deg_to_rad(e.rotation));
                var a = new Box2D.Dynamics.b2FixtureDef;
                a.density = this.data.settings.density, a.friction = this.data.settings.friction, a.restitution = this.data.settings.restitution, a.shape = n, a.filter.categoryBits = o.EntityCategory, a.filter.maskBits = t.types.EntityCategory.BIKE_BODY | t.types.EntityCategory.BIKE_AXLE | t.types.EntityCategory.BIKE_WHEEL | t.types.EntityCategory.GAME_OBJECT | t.types.EntityCategory.BIKE_BODY_SENSOR_BODY | t.types.EntityCategory.BIKE_BODY_SENSOR_HEAD, a.userData = o, i.CreateFixture(a)
            }, n.prototype.createPhysicPartFromTriangularPointsList = function(t, e, i) {
                var s = t.triangularPointsList,
                    o = 0;
                for (o = 0; o < s.length; o++) this.createPhysicPartFromTriangularPointsListItem(s[o], e, i)
            }, n.prototype.createPhysicPartFromTriangularPointsListItem = function(e, i, s) {
                var o = e,
                    n = o.length;
                if (!(n < 2)) {
                    var a = o[0],
                        r = o[n - 1],
                        h = n;
                    a.x === r.x && a.y === r.y && (h -= 1);
                    var l = new t.types.GameObjectData;
                    l.Type = s.Type, l.PhysicType = s.PhysicType, l.MaterialType = s.MaterialType, l.EntityCategory = t.types.EntityCategory.GAME_OBJECT;
                    var c = new Box2D.Dynamics.b2FixtureDef;
                    c.density = this.data.settings.density, c.friction = this.data.settings.friction, c.restitution = this.data.settings.restitution, c.userData = l, c.filter.categoryBits = l.EntityCategory, c.filter.maskBits = t.types.EntityCategory.BIKE_BODY | t.types.EntityCategory.BIKE_AXLE | t.types.EntityCategory.BIKE_WHEEL | t.types.EntityCategory.GAME_OBJECT | t.types.EntityCategory.BIKE_BODY_SENSOR_BODY | t.types.EntityCategory.BIKE_BODY_SENSOR_HEAD;
                    var p = 0,
                        u = [];
                    for (p = 0; p < h; p++) {
                        var d = o[p],
                            m = new poly2tri.Point(t.tools.Convertor.w_to_ws(d.x), t.tools.Convertor.w_to_ws(d.y));
                        u.push(m)
                    }
                    var y = new poly2tri.SweepContext(u);
                    y.triangulate();
                    var f = null,
                        g = null,
                        _ = null,
                        v = null,
                        b = y.getTriangles();
                    for (p = 0; p < b.length; p++) {
                        var x = b[p].getPoints();
                        f = new Box2D.Common.Math.b2Vec2(x[0].x, x[0].y), g = new Box2D.Common.Math.b2Vec2(x[1].x, x[1].y), _ = new Box2D.Common.Math.b2Vec2(x[2].x, x[2].y), (v = new Box2D.Collision.Shapes.b2PolygonShape).SetAsArray([f, g, _]), c.shape = v, i.CreateFixture(c)
                    }
                }
            }, n.prototype.createGraphics = function() {
                this.isGraphicsEnabled && (this.graphicsContainer = this.game.add.group(this.parentContainer), this.graphicItem = this.game.add.group(this.graphicsContainer), this.createGraphicItem(this.data.graphics[0], this.graphicItem))
            }, n.prototype.createGraphicItem = function(t, e) {
                var i = t.parts,
                    s = 0;
                for (e.position.set(t.x, t.y), e.angle = t.rotation, s = 0; s < i.length; s++) this.createGraphicItemPart(i[s], e)
            }, n.prototype.createGraphicItemPart = function(e, i) {
                var s = e.x,
                    o = e.y,
                    n = e.rotation,
                    a = e.atlasKey;
                this.game.add.image(s, o, t.settings.GameCommonSettings.getGameLevelStartUpAtlasKey(), a, i).angle = n
            }, n.prototype.createComponentProcessActionItem = function(t, e) {
                void 0 === e && (e = null);
                var i = {};
                return i.id = t, i.data = e, i
            }, n.prototype.startComponentNewAction = function() {
                this.componentAction !== s.UNKNOWN && (this.stopComponentRotating(), this.resetComponentProcessActionsList(), this.setComponentProcessActionsList(), this.startComponentNextProcessAction(!0))
            }, n.prototype.startComponentNextProcessAction = function(t) {
                void 0 === t && (t = !1), 0 !== this.componentProcessActionsList.length && (t || this.componentProcessActionsListIndex++, this.componentProcessActionsListIndex >= this.componentProcessActionsList.length && (this.componentProcessActionsListIndex = 0), this.startComponentProcessAction(this.componentProcessActionsList[this.componentProcessActionsListIndex]))
            }, n.prototype.startComponentProcessAction = function(t) {
                t.id === o.ROTATE_FORWARD ? this.setComponentRotateForwardState() : t.id === o.ROTATE_BACKWARD ? this.setComponentRotateBackwardState() : t.id === o.STOP && this.setComponentStopState()
            }, n.prototype.stopComponentRotating = function() {
                this.componentAngularVelocity = 0, this.setComponentAngularVelocity(this.componentAngularVelocity)
            }, n.prototype.rotateComponentForward = function() {
                this.componentAngularVelocity = this.componentAngularVelocitySet, this.setComponentAngularVelocity(this.componentAngularVelocity)
            }, n.prototype.rotateComponentBackward = function() {
                this.componentAngularVelocity = -this.componentAngularVelocitySet, this.setComponentAngularVelocity(this.componentAngularVelocity)
            }, n.prototype.updateCompomentStartTranslation = function() {
                this.updatePhysicsStartTranslation(), this.updateGraphicsTranslation()
            }, n.prototype.updatePhysicsStartTranslation = function() {
                var t = this.b2Body.GetUserData().UserData1;
                this.b2Body.SetPosition(new Box2D.Common.Math.b2Vec2(this.componentStartPosition.x + t.x, this.componentStartPosition.y + t.y)), this.b2Body.SetAngle(this.componentStartRotation + t.rot)
            }, n.prototype.updateGraphicsTranslation = function() {
                if (this.isGraphicsEnabled) {
                    var e = this.graphicItem,
                        i = this.b2Body.GetPosition(),
                        s = this.b2Body.GetAngle();
                    e.position.x = i.x * t.config.GameConfig.b2WorldScale, e.position.y = i.y * t.config.GameConfig.b2WorldScale, e.rotation = s
                }
            }, n.prototype.setPhysicsActiveState = function(t) {
                this.b2Body.SetActive(t)
            }, n.prototype.setComponentAngularVelocity = function(t) {
                this.b2Body.SetAngularVelocity(t)
            }, n.prototype.setComponentProcessActionsList = function() {
                this.componentAction === s.ROTATE_FORWARD ? this.componentProcessActionsList.push(this.createComponentProcessActionItem(o.ROTATE_FORWARD)) : this.componentAction === s.ROTATE_BACKWARD ? this.componentProcessActionsList.push(this.createComponentProcessActionItem(o.ROTATE_BACKWARD)) : this.componentAction === s.STOP && this.componentProcessActionsList.push(this.createComponentProcessActionItem(o.STOP))
            }, n.prototype.setComponentRotateForwardState = function() {
                this.componentState = i.ROTATING_FORWARD, this.rotateComponentForward()
            }, n.prototype.setComponentRotateBackwardState = function() {
                this.componentState = i.ROTATING_BACKWARD, this.rotateComponentBackward()
            }, n.prototype.setComponentStopState = function() {
                this.componentState = i.STOP, this.stopComponentRotating()
            }, n.prototype.getComponentActionFromStr = function(t) {
                return "rotate_forward" === t ? s.ROTATE_FORWARD : "rotate_backward" === t ? s.ROTATE_BACKWARD : "rotate_stop" === t ? s.STOP : s.UNKNOWN
            }, n.prototype.calcActiveDistances = function() {
                var t = this.bikeRef.getCenterPosition().x;
                this.activeDistanceBack = t - this.activeDistance, this.activeDistanceFront = t + this.activeDistance
            }, n.prototype.checkComponentState = function(t) {
                this.checkComponentActiveState()
            }, n.prototype.checkComponentActiveState = function() {
                if (null !== this.bikeRef) {
                    this.calcActiveDistances();
                    var t = this.b2Body.GetPosition().x,
                        e = t >= this.activeDistanceBack && t <= this.activeDistanceFront;
                    !this.activeStateFlag && e ? (this.activeStateFlag = !0, this.b2Body.IsActive() || this.b2Body.SetActive(!0)) : this.activeStateFlag && !e && (this.activeStateFlag = !1, this.b2Body.IsActive() && this.b2Body.SetActive(!1))
                }
            }, n.prototype.resetComponentProcessActionsList = function() {
                this.componentProcessActionsList.length = 0, this.componentProcessActionsListIndex = 0
            }, n.prototype.customDispose = function() {
                this.resetComponentProcessActionsList(), this.disposePhysics(), this.disposeGraphics()
            }, n.prototype.disposePhysics = function() {
                this.b2Body.SetActive(!1), this.b2World.DestroyBody(this.b2Body)
            }, n.prototype.disposeGraphics = function() {
                null !== this.graphicsContainer && (this.graphicsContainer.removeAll(!0, !0), null !== this.graphicsContainer.parent && this.graphicsContainer.parent.removeChild(this.graphicsContainer))
            }, n.prototype.customResetData = function() {
                this.b2Body = null, this.graphicsContainer = null, this.graphicItem = null, this.componentStartPosition = null, this.componentStartRotation = 0, this.componentAngularVelocitySet = 0, this.componentAngularVelocity = 0, this.componentState = 0, this.componentAction = 0, this.componentProcessActionsList = null, this.componentProcessActionsListIndex = 0, this.bikeRef = null, this.activeStateFlag = !1, this.activeDistance = 0, this.activeDistanceBack = 0, this.activeDistanceFront = 0
            }, n
        }(t.game_objects.GameObject);
        e.GORotatingObject = n
    }(t.game_objects || (t.game_objects = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(e) {
        var i = function(e) {
            function i(i, s, o, n, a) {
                var r = e.call(this, i, s, o, t.types.GameObjectType.FINISH_ZONE, n, a) || this;
                return r.init(), r
            }
            return __extends(i, e), Object.defineProperty(i.prototype, "IsComponentActivated", {
                get: function() {
                    return this.isComponentActivated
                },
                enumerable: !0,
                configurable: !0
            }), i.prototype.setPositionXY = function(e, i) {
                !this.isDisposed && this.isInited && (this.startPosition.x = t.tools.Convertor.w_to_ws(e), this.startPosition.y = t.tools.Convertor.w_to_ws(i))
            }, i.prototype.startDefaultAction = function() {
                !this.isDisposed && this.isInited && this.searchGameObjectsAround()
            }, i.prototype.activateComponent = function() {
                if (!this.isDisposed && this.isInited && !this.isComponentActivated) {
                    this.isComponentActivated = !0;
                    var t = 0;
                    for (t = 0; t < this.goList.length; t++) this.goList[t].startAction(this.goActionStr)
                }
            }, i.prototype.init = function() {
                this.isInited = !0
            }, i.prototype.searchGameObjectsAround = function() {
                var e = this.componentWidth / 2,
                    i = this.componentHeight / 2,
                    s = new Box2D.Collision.b2AABB;
                s.lowerBound = new Box2D.Common.Math.b2Vec2(this.startPosition.x - e, this.startPosition.y - i), s.upperBound = new Box2D.Common.Math.b2Vec2(this.startPosition.x + e, this.startPosition.y + i);
                var o = this.goList,
                    n = !1,
                    a = this;
                this.b2World.QueryAABB(function(e) {
                    var i = e.GetUserData();
                    if (n = !1, null !== i && i.Type === t.types.GameObjectType.DESTRUCTIBLE_OBJECT && (n = !0), n) {
                        var s = e.GetBody().GetUserData();
                        if (null !== s) {
                            var r = s.UserData2;
                            if (null !== r) {
                                var h = {};
                                h.actionArea = a, r.startActionWithData("set_action_area", h), o.push(r)
                            }
                        }
                    }
                    return !0
                }, s)
            }, i.prototype.initData = function() {
                e.prototype.initData.call(this), this.goList = [], this.startPosition = new Box2D.Common.Math.b2Vec2(t.tools.Convertor.w_to_ws(this.data.x), t.tools.Convertor.w_to_ws(this.data.y));
                var i = this.data.physics[0].boxes[0].width,
                    s = this.data.physics[0].boxes[0].height;
                this.componentWidth = t.tools.Convertor.w_to_ws(i), this.componentHeight = t.tools.Convertor.w_to_ws(s), this.goActionStr = this.data.settings.action
            }, i.prototype.resetData = function() {
                e.prototype.resetData.call(this), this.isInited = !1, this.startPosition = null, this.componentWidth = 0, this.componentHeight = 0, this.isComponentActivated = !1, this.goList = null, this.goActionStr = null
            }, i
        }(t.game_objects.GameObject);
        e.GOActionArea = i
    }(t.game_objects || (t.game_objects = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(e) {
        var i;
        ! function(t) {
            t[t.ACTIVATED = 1] = "ACTIVATED", t[t.DEACTIVATING = 2] = "DEACTIVATING", t[t.DEACTIVATED = 3] = "DEACTIVATED", t[t.SET_ACTION_AREA = 4] = "SET_ACTION_AREA", t[t.ACTIVATE_ACTION_AREA = 5] = "ACTIVATE_ACTION_AREA", t[t.PHYSICS_WAIT = 6] = "PHYSICS_WAIT", t[t.GRAPHICS_ANIMATION = 7] = "GRAPHICS_ANIMATION", t[t.DESTROY = 8] = "DESTROY", t[t.DESTROYED = 9] = "DESTROYED"
        }(i || (i = {}));
        var s;
        ! function(t) {
            t[t.UNKNOWN = 0] = "UNKNOWN", t[t.SET_ACTION_AREA = 1] = "SET_ACTION_AREA", t[t.DEACTIVATE_COMPONENT = 2] = "DEACTIVATE_COMPONENT"
        }(s || (s = {}));
        var o;
        ! function(t) {
            t[t.UNKNOWN = 0] = "UNKNOWN", t[t.SET_ACTION_AREA = 1] = "SET_ACTION_AREA", t[t.START_PHYSICS_WAIT = 2] = "START_PHYSICS_WAIT", t[t.DEACTIVATE_COMPONENT = 3] = "DEACTIVATE_COMPONENT", t[t.START_GRAPHICS_ANIMATION = 4] = "START_GRAPHICS_ANIMATION", t[t.ACTIVATE_ACTION_AREA = 5] = "ACTIVATE_ACTION_AREA", t[t.DESTROY = 6] = "DESTROY"
        }(o || (o = {}));
        var n = function(e) {
            function n(i, s, o, n, a) {
                var r = e.call(this, i, s, o, t.types.GameObjectType.DESTRUCTIBLE_OBJECT, n, a) || this;
                return r.init(), r
            }
            return __extends(n, e), Object.defineProperty(n.prototype, "IsComponentActivated", {
                get: function() {
                    return this.isComponentActivated
                },
                enumerable: !0,
                configurable: !0
            }), n.prototype.setPositionXY = function(e, i) {
                !this.isDisposed && this.isComponentInited && (this.setPhysicsActiveState(!1), this.componentStartPosition = new Box2D.Common.Math.b2Vec2(t.tools.Convertor.w_to_ws(e), t.tools.Convertor.w_to_ws(i)), this.updateCompomentStartTranslation(), this.setPhysicsActiveState(!0))
            }, n.prototype.updateLogic = function(t) {
                !this.isDisposed && this.isComponentInited && this.checkComponentLogicState(t)
            }, n.prototype.updateGraphics = function(t) {
                !this.isDisposed && this.isGraphicsEnabled && this.isComponentInited && (this.updateGraphicsTranslation(), this.checkComponentGraphicsState(t))
            }, n.prototype.startAction = function(t) {
                !this.isDisposed && this.isComponentInited && this._startActionWithData(t, null)
            }, n.prototype.startActionWithData = function(t, e) {
                !this.isDisposed && this.isComponentInited && this._startActionWithData(t, e)
            }, n.prototype.deactivateComponent = function() {
                !this.isDisposed && this.isComponentInited && (this.soundManager.playSound(Sounds.Wood), this._startActionWithData("deactivateComponent", null))
            }, n.prototype.init = function() {
                this.createPhysics(), this.createGraphics(), this.updateCompomentStartTranslation(), this.isComponentActivated = !0, this.isComponentInited = !0
            }, n.prototype.createPhysics = function() {
                var t = this.data.physics;
                this.createPhysicItem(t[0])
            }, n.prototype.createPhysicItem = function(e) {
                var i = {};
                i.x = t.tools.Convertor.w_to_ws(e.x), i.y = t.tools.Convertor.w_to_ws(e.x), i.rot = t.tools.Convertor.deg_to_rad(e.rotation);
                var s = new t.types.GameObjectData;
                s.Type = this.type, s.PhysicType = t.types.GameObjectPhysicType.DYNAMIC, s.MaterialType = t.tools.Convertor.getGameObjectMaterialTypeFromStr(this.data.settings.material), s.UserData1 = i, s.UserData2 = this;
                var o = new Box2D.Dynamics.b2BodyDef;
                o.type = Box2D.Dynamics.b2Body.b2_dynamicBody, o.userData = s, o.position.Set(i.x, i.y), o.angle = i.rot;
                var n = this.b2World.CreateBody(o);
                e.hasOwnProperty("boxes") && this.createPhysicPartFromBoxes(e, n, s), n.ResetMassData(), this.b2Body = n
            }, n.prototype.createPhysicPartFromBoxes = function(t, e, i) {
                var s = t.boxes,
                    o = 0;
                for (o = 0; o < s.length; ++o) this.createPhysicPartFromBoxItem(s[o], e, i)
            }, n.prototype.createPhysicPartFromBoxItem = function(e, i, s) {
                var o = new t.types.GameObjectData;
                o.Type = s.Type, o.PhysicType = s.PhysicType, o.MaterialType = s.MaterialType, o.UserData2 = s.UserData2, o.EntityCategory = t.types.EntityCategory.GAME_OBJECT;
                var n = new Box2D.Collision.Shapes.b2PolygonShape;
                n.SetAsOrientedBox(t.tools.Convertor.w_to_ws(e.width / 2), t.tools.Convertor.w_to_ws(e.height / 2), new Box2D.Common.Math.b2Vec2(t.tools.Convertor.w_to_ws(e.x), t.tools.Convertor.w_to_ws(e.y)), t.tools.Convertor.deg_to_rad(e.rotation));
                var a = new Box2D.Dynamics.b2FixtureDef;
                a.density = this.data.settings.density, a.friction = this.data.settings.friction, a.restitution = this.data.settings.restitution, a.shape = n, a.userData = o, a.filter.categoryBits = o.EntityCategory, a.filter.maskBits = this.physicsMaskBits, i.CreateFixture(a)
            }, n.prototype.createGraphics = function() {
                this.isGraphicsEnabled && (this.graphicsContainer = this.game.add.group(this.parentContainer), this.graphicItem = this.game.add.group(this.graphicsContainer), this.createGraphicItem(this.data.graphics[0], this.graphicItem))
            }, n.prototype.createGraphicItem = function(t, e) {
                var i = t.parts,
                    s = 0;
                for (e.position.set(t.x, t.y), e.angle = t.rotation, s = 0; s < i.length; s++) this.createGraphicItemPart(i[s], e)
            }, n.prototype.createGraphicItemPart = function(e, i) {
                var s = e.x,
                    o = e.y,
                    n = e.rotation,
                    a = e.atlasKey;
                this.game.add.image(s, o, t.settings.GameCommonSettings.getGameLevelStartUpAtlasKey(), a, i).angle = n
            }, n.prototype.createComponentProcessActionItem = function(t, e) {
                void 0 === e && (e = null);
                var i = {};
                return i.id = t, i.data = e, i
            }, n.prototype.updateCompomentStartTranslation = function() {
                this.updatePhysicsStartTranslation(), this.updateGraphicsTranslation()
            }, n.prototype.updatePhysicsStartTranslation = function() {
                var t = this.b2Body.GetUserData().UserData1;
                this.b2Body.SetPosition(new Box2D.Common.Math.b2Vec2(this.componentStartPosition.x + t.x, this.componentStartPosition.y + t.y)), this.b2Body.SetAngle(this.componentStartRotation + t.rot)
            }, n.prototype.updateGraphicsTranslation = function() {
                if (this.isGraphicsEnabled) {
                    var e = this.graphicItem,
                        i = this.b2Body.GetPosition(),
                        s = this.b2Body.GetAngle();
                    e.position.x = i.x * t.config.GameConfig.b2WorldScale, e.position.y = i.y * t.config.GameConfig.b2WorldScale, e.rotation = s
                }
            }, n.prototype.checkComponentLogicState = function(t) {
                this.componentState === i.PHYSICS_WAIT ? (this.countWaitTimeCounter(t), this.isWaitTimeReached() && this.startComponentNextProcessAction()) : this.isGraphicsEnabled || this.componentState !== i.DEACTIVATED || (this.componentProcessActionsListIndex += 1, this.startComponentNextProcessAction())
            }, n.prototype.checkComponentGraphicsState = function(t) {
                this.componentState === i.DEACTIVATED && this.startComponentNextProcessAction()
            }, n.prototype._startActionWithData = function(t, e) {
                this.componentAction = this.getComponentActionFromStr(t), this.actionData = e, this.startComponentNewAction()
            }, n.prototype.startComponentNewAction = function() {
                this.componentAction !== s.UNKNOWN && (this.resetComponentProcessActionsList(), this.setComponentProcessActionsList(), this.startComponentNextProcessAction(!0))
            }, n.prototype.startComponentNextProcessAction = function(t) {
                void 0 === t && (t = !1), 0 !== this.componentProcessActionsList.length && (t || this.componentProcessActionsListIndex++, this.componentProcessActionsListIndex >= this.componentProcessActionsList.length && (this.componentProcessActionsListIndex = 0), this.startComponentProcessAction(this.componentProcessActionsList[this.componentProcessActionsListIndex]))
            }, n.prototype.startComponentProcessAction = function(t) {
                t.id === o.SET_ACTION_AREA ? this.setComponentSetActionAreaState(t.data) : t.id === o.ACTIVATE_ACTION_AREA ? this.setComponentActivateActionAreaState() : t.id === o.START_PHYSICS_WAIT ? this.setComponentPhysicsWaitState() : t.id === o.DEACTIVATE_COMPONENT ? this.setComponentDeactivatedState() : t.id === o.START_GRAPHICS_ANIMATION ? this.setComponentGraphicsAnimationState() : t.id === o.DESTROY && this.setComponentDestroyedState()
            }, n.prototype.setPhysicsActiveState = function(t) {
                this.b2Body.SetActive(t)
            }, n.prototype.setComponentProcessActionsList = function() {
                this.componentAction === s.SET_ACTION_AREA ? this.componentProcessActionsList.push(this.createComponentProcessActionItem(o.SET_ACTION_AREA, this.actionData)) : this.componentAction === s.DEACTIVATE_COMPONENT && (null === this.actionAreaRef || this.actionAreaRef.IsComponentActivated ? (this.componentProcessActionsList.push(this.createComponentProcessActionItem(o.START_PHYSICS_WAIT)), this.componentProcessActionsList.push(this.createComponentProcessActionItem(o.DEACTIVATE_COMPONENT)), this.componentProcessActionsList.push(this.createComponentProcessActionItem(o.START_GRAPHICS_ANIMATION)), this.componentProcessActionsList.push(this.createComponentProcessActionItem(o.DESTROY))) : this.componentProcessActionsList.push(this.createComponentProcessActionItem(o.ACTIVATE_ACTION_AREA)))
            }, n.prototype.setComponentSetActionAreaState = function(t) {
                this.componentState = i.SET_ACTION_AREA, null !== t && (this.actionAreaRef = t.actionArea)
            }, n.prototype.setComponentActivateActionAreaState = function() {
                this.componentState = i.ACTIVATE_ACTION_AREA, null !== this.actionAreaRef && this.actionAreaRef.activateComponent()
            }, n.prototype.setComponentPhysicsWaitState = function() {
                this.componentState = i.PHYSICS_WAIT, this.waitTimeMs = 0, this.waitTimeCounter = this.waitPhysicsTimeCounterLimit
            }, n.prototype.setComponentDeactivatedState = function() {
                this.componentState = i.DEACTIVATED, this.createDeactivatedPhysics()
            }, n.prototype.setComponentGraphicsAnimationState = function() {
                this.componentState = i.GRAPHICS_ANIMATION, this.graphicsTween1 = this.game.add.tween(this.graphicItem).to({
                    alpha: 0
                }, 3e3, Phaser.Easing.Linear.None, !1), this.graphicsTween1.onComplete.addOnce(this.onGraphicsTween1Complete, this), this.graphicsTween1.start()
            }, n.prototype.setComponentDestroyedState = function() {
                this.dispose()
            }, n.prototype.getComponentActionFromStr = function(t) {
                return "set_action_area" === t ? s.SET_ACTION_AREA : "deactivateComponent" === t ? s.DEACTIVATE_COMPONENT : s.UNKNOWN
            }, n.prototype.countWaitTimeCounter = function(t) {
                this.waitTimeMs !== this.waitTimeCounter && (this.waitTimeMs += t, this.waitTimeMs >= this.waitTimeCounter && (this.waitTimeMs = this.waitTimeCounter))
            }, n.prototype.isWaitTimeReached = function() {
                return this.waitTimeMs === this.waitTimeCounter
            }, n.prototype.createDeactivatedPhysics = function() {
                var e = this.b2Body.GetPosition().Copy(),
                    i = this.b2Body.GetAngle();
                this.physicsMaskBits = t.types.EntityCategory.GAME_OBJECT | t.types.EntityCategory.GROUND, this.disposePhysics(), this.createPhysics(), this.b2Body.SetActive(!1), this.b2Body.SetPosition(new Box2D.Common.Math.b2Vec2(e.x, e.y)), this.b2Body.SetAngle(i), this.b2Body.SetActive(!0)
            }, n.prototype.resetComponentProcessActionsList = function() {
                this.componentProcessActionsList.length = 0, this.componentProcessActionsListIndex = 0
            }, n.prototype.disposePhysics = function() {
                null !== this.b2Body && (this.b2Body.SetActive(!1), this.b2World.DestroyBody(this.b2Body))
            }, n.prototype.disposeGraphics = function() {
                null !== this.graphicsContainer && (this.graphicsContainer.removeAll(!0, !0), null !== this.graphicsContainer.parent && this.graphicsContainer.parent.removeChild(this.graphicsContainer))
            }, n.prototype.customInitData = function() {
                this.soundManager = BoilerPlate.SoundManager.getInstance(), this.waitPhysicsTimeCounterLimit = .1, this.componentProcessActionsList = [], this.componentStartPosition = new Box2D.Common.Math.b2Vec2(t.tools.Convertor.w_to_ws(this.data.x), t.tools.Convertor.w_to_ws(this.data.y)), this.componentStartRotation = t.tools.Convertor.deg_to_rad(this.data.rotation), this.componentState = i.ACTIVATED, this.physicsMaskBits = t.types.EntityCategory.BIKE_WHEEL | t.types.EntityCategory.BIKE_BODY | t.types.EntityCategory.BIKE_AXLE | t.types.EntityCategory.GAME_OBJECT | t.types.EntityCategory.BIKE_BODY_SENSOR_HEAD | t.types.EntityCategory.GROUND
            }, n.prototype.customDispose = function() {
                this.resetComponentProcessActionsList(), null !== this.graphicsTween1 && this.graphicsTween1.onComplete.removeAll(), this.disposePhysics(), this.disposeGraphics()
            }, n.prototype.customResetData = function() {
                this.b2Body = null, this.graphicsContainer = null, this.graphicItem = null, this.componentStartPosition = null, this.componentStartRotation = 0, this.isComponentActivated = !1, this.componentState = 0, this.componentAction = 0, this.componentProcessActionsList = null, this.componentProcessActionsListIndex = 0, this.actionAreaRef = null, this.actionData = null, this.waitTimeMs = 0, this.waitTimeCounter = 0, this.waitPhysicsTimeCounterLimit = 0, this.graphicsTween1 = null, this.physicsMaskBits = 0, this.soundManager = null
            }, n.prototype.onGraphicsTween1Complete = function() {
                this.startComponentNextProcessAction()
            }, n
        }(t.game_objects.GameObject);
        e.GODestructibleObject = n
    }(t.game_objects || (t.game_objects = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(e) {
        var i = function(e) {
            function i(i, s, o, n, a) {
                var r = e.call(this, i, s, o, t.types.GameObjectType.SURFACE_OBJECT, n, a) || this;
                return r.init(), r
            }
            return __extends(i, e), i.prototype.setPositionXY = function(e, i) {
                !this.isDisposed && this.isInited && (this.startPosition.x = t.tools.Convertor.w_to_ws(e), this.startPosition.y = t.tools.Convertor.w_to_ws(i), this.updateComponentTranslation())
            }, i.prototype.activatePhysics = function() {
                this.isDisposed || !this.isInited || this.isPhysicsActivated || this.setPhysicsActiveState(!0)
            }, i.prototype.deactivatePhysics = function() {
                !this.isDisposed && this.isInited && this.isPhysicsActivated && this.setPhysicsActiveState(!1)
            }, i.prototype.init = function() {
                this.createPhysics(), this.updateComponentTranslation(), this.isInited = !0
            }, i.prototype.createPhysics = function() {
                var t = this.data.physics,
                    e = 0;
                for (e = 0; e < t.length; ++e) this.createPhysicItem(t[e]);
                this.isPhysicsActivated = !0
            }, i.prototype.createPhysicItem = function(e) {
                var i = {};
                i.x = t.tools.Convertor.w_to_ws(e.x), i.y = t.tools.Convertor.w_to_ws(e.x), i.rot = t.tools.Convertor.deg_to_rad(e.rotation);
                var s = new t.types.GameObjectData;
                s.Type = t.types.GameObjectType.SURFACE_OBJECT, s.PhysicType = t.types.GameObjectPhysicType.STATIC, s.MaterialType = t.tools.Convertor.getGameObjectMaterialTypeFromStr(this.data.settings.material), s.UserData1 = i;
                var o = new Box2D.Dynamics.b2BodyDef;
                o.type = Box2D.Dynamics.b2Body.b2_staticBody, o.userData = s, o.position.Set(i.x, i.y), o.angle = i.rot;
                var n = this.b2World.CreateBody(o);
                e.hasOwnProperty("triangularPointsList") && this.createPhysicPartFromTriangularPointsList(e, n, s), n.ResetMassData(), this.b2BodyList.push(n)
            }, i.prototype.createPhysicPartFromTriangularPointsList = function(t, e, i) {
                var s = t.triangularPointsList,
                    o = 0;
                for (o = 0; o < s.length; o++) this.createPhysicPartFromTriangularPointsListItem(s[o], e, i)
            }, i.prototype.createPhysicPartFromTriangularPointsListItem = function(e, i, s) {
                var o = e,
                    n = o.length;
                if (!(n < 2)) {
                    var a = o[0],
                        r = o[n - 1],
                        h = n;
                    a.x === r.x && a.y === r.y && (h -= 1);
                    var l = new t.types.GameObjectData;
                    l.Type = s.Type, l.PhysicType = s.PhysicType, l.MaterialType = s.MaterialType, l.EntityCategory = t.types.EntityCategory.GAME_OBJECT;
                    var c = new Box2D.Dynamics.b2FixtureDef;
                    c.density = this.data.settings.density, c.friction = this.data.settings.friction, c.restitution = this.data.settings.restitution, c.userData = l, c.filter.categoryBits = l.EntityCategory, c.filter.maskBits = t.types.EntityCategory.BIKE_BODY | t.types.EntityCategory.BIKE_AXLE | t.types.EntityCategory.BIKE_WHEEL | t.types.EntityCategory.GAME_OBJECT | t.types.EntityCategory.BIKE_BODY_SENSOR_BODY | t.types.EntityCategory.BIKE_BODY_SENSOR_HEAD;
                    var p = 0,
                        u = [];
                    for (p = 0; p < h; p++) {
                        var d = o[p],
                            m = new poly2tri.Point(t.tools.Convertor.w_to_ws(d.x), t.tools.Convertor.w_to_ws(d.y));
                        u.push(m)
                    }
                    var y = new poly2tri.SweepContext(u);
                    y.triangulate();
                    var f = null,
                        g = null,
                        _ = null,
                        v = null,
                        b = y.getTriangles();
                    for (p = 0; p < b.length; p++) {
                        var x = b[p].getPoints();
                        f = new Box2D.Common.Math.b2Vec2(x[0].x, x[0].y), g = new Box2D.Common.Math.b2Vec2(x[1].x, x[1].y), _ = new Box2D.Common.Math.b2Vec2(x[2].x, x[2].y), (v = new Box2D.Collision.Shapes.b2PolygonShape).SetAsArray([f, g, _]), c.shape = v, i.CreateFixture(c)
                    }
                }
            }, i.prototype.updateComponentTranslation = function() {
                this.updatePhysicsTranslation()
            }, i.prototype.updatePhysicsTranslation = function() {
                var t = this.isPhysicsActivated;
                t && this.setPhysicsActiveState(!1);
                var e = this.b2BodyList.length,
                    i = 0;
                for (i = 0; i < e; ++i) {
                    var s = this.b2BodyList[i],
                        o = s.GetUserData().UserData1;
                    s.SetPosition(new Box2D.Common.Math.b2Vec2(this.startPosition.x + o.x, this.startPosition.y + o.y)), s.SetAngle(this.componentRotation + o.rot)
                }
                t && this.setPhysicsActiveState(!0)
            }, i.prototype.setPhysicsActiveState = function(t) {
                var e = this.b2BodyList.length,
                    i = 0;
                for (i = 0; i < e; ++i) this.b2BodyList[i].SetActive(t);
                this.isPhysicsActivated = t
            }, i.prototype.disposePhysics = function() {
                var t = this.b2BodyList.length,
                    e = 0;
                if (t > 0)
                    for (e = 0; e < t; ++e) {
                        var i = this.b2BodyList[e];
                        i.SetActive(!1), this.b2World.DestroyBody(i)
                    }
                this.b2BodyList.length = 0
            }, i.prototype.initData = function() {
                e.prototype.initData.call(this), this.b2BodyList = [], this.startPosition = new Box2D.Common.Math.b2Vec2(t.tools.Convertor.w_to_ws(this.data.x), t.tools.Convertor.w_to_ws(this.data.y)), this.componentRotation = t.tools.Convertor.deg_to_rad(this.data.rotation)
            }, i.prototype.customDispose = function() {
                this.disposePhysics()
            }, i.prototype.resetData = function() {
                e.prototype.resetData.call(this), this.b2BodyList = null, this.isPhysicsActivated = !1, this.isInited = !1, this.componentRotation = 0, this.startPosition = null
            }, i
        }(t.game_objects.GameObject);
        e.GOSurfaceObject = i
    }(t.game_objects || (t.game_objects = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(e) {
        var i;
        ! function(t) {
            t[t.TOP = 1] = "TOP", t[t.BOTTOM = 2] = "BOTTOM"
        }(i || (i = {}));
        var s;
        ! function(t) {
            t[t.UNKNOWN = 0] = "UNKNOWN", t[t.MOVE_UP = 1] = "MOVE_UP", t[t.MOVE_DOWN = 2] = "MOVE_DOWN", t[t.LOOP = 3] = "LOOP"
        }(s || (s = {}));
        var o;
        ! function(t) {
            t[t.UNKNOWN = 0] = "UNKNOWN", t[t.TOP = 1] = "TOP", t[t.BOTTOM = 2] = "BOTTOM", t[t.WAITING_AT_TOP = 3] = "WAITING_AT_TOP", t[t.WAITING_AT_BOTTOM = 4] = "WAITING_AT_BOTTOM", t[t.MOVING_UP = 5] = "MOVING_UP", t[t.MOVING_DOWN = 6] = "MOVING_DOWN", t[t.ADJUSTING_TOP_POSITION = 7] = "ADJUSTING_TOP_POSITION", t[t.ADJUSTING_BOTTOM_POSITION = 8] = "ADJUSTING_BOTTOM_POSITION", t[t.WAITING_FOR_NEXT_PROCESS_ACTION = 9] = "WAITING_FOR_NEXT_PROCESS_ACTION"
        }(o || (o = {}));
        var n;
        ! function(t) {
            t[t.UNKNOWN = 0] = "UNKNOWN", t[t.MOVE_UP = 1] = "MOVE_UP", t[t.MOVE_DOWN = 2] = "MOVE_DOWN", t[t.WAIT_AT_TOP = 3] = "WAIT_AT_TOP", t[t.WAIT_AT_BOTTOM = 4] = "WAIT_AT_BOTTOM", t[t.STOP = 5] = "STOP"
        }(n || (n = {}));
        var a;
        ! function(t) {
            t[t.UP = 1] = "UP", t[t.DOWN = 2] = "DOWN"
        }(a || (a = {}));
        var r;
        ! function(t) {
            t[t.TOP_STATE = 1] = "TOP_STATE", t[t.BOTTOM_STATE = 2] = "BOTTOM_STATE"
        }(r || (r = {}));
        var h = function(e) {
            function h(i, s, o, n, a) {
                var r = e.call(this, i, s, o, t.types.GameObjectType.PISTON, n, a) || this;
                return r.init(), r
            }
            return __extends(h, e), h.prototype.updateLogic = function(t) {
                !this.isDisposed && this.isComponentInited && this.checkComponentState(t)
            }, h.prototype.updateGraphics = function(t) {
                !this.isDisposed && this.isGraphicsEnabled && this.isComponentInited && this.updateGraphicsTranslation()
            }, h.prototype.setPositionXY = function(e, i) {
                !this.isDisposed && this.isComponentInited && (this.setPhysicsActiveState(!1), this.componentStartPosition = new Box2D.Common.Math.b2Vec2(t.tools.Convertor.w_to_ws(e), t.tools.Convertor.w_to_ws(i)), this.updateCompomentStartTranslation(), this.setPhysicsActiveState(!0))
            }, h.prototype.startDefaultAction = function() {
                !this.isDisposed && this.isComponentInited && (this.componentAction = this.getComponentActionFromStr(this.data.settings.defaultAction), this.startComponentNewAction())
            }, h.prototype.startAction = function(t) {
                !this.isDisposed && this.isComponentInited && (this.componentAction = this.getComponentActionFromStr(t), this.startComponentNewAction())
            }, h.prototype.init = function() {
                this.createPhysics(), this.calcComponentMoveUpVelocity(), this.calcComponentMoveDownVelocity(), this.createGraphics(), this.updateCompomentStartTranslation(), this.isComponentInited = !0
            }, h.prototype.createPhysics = function() {
                this.createPhysicItem(this.data.physics[0])
            }, h.prototype.createPhysicItem = function(e) {
                var i = {};
                i.x = t.tools.Convertor.w_to_ws(e.x), i.y = t.tools.Convertor.w_to_ws(e.x), i.rot = t.tools.Convertor.deg_to_rad(e.rotation);
                var s = new t.types.GameObjectData;
                s.Type = this.type, s.PhysicType = t.types.GameObjectPhysicType.KINEMATIC, s.MaterialType = t.tools.Convertor.getGameObjectMaterialTypeFromStr(this.data.settings.material), s.UserData1 = i;
                var o = new Box2D.Dynamics.b2BodyDef;
                o.type = Box2D.Dynamics.b2Body.b2_kinematicBody, o.userData = s, o.position.Set(i.x, i.y), o.angle = i.rot, o.allowSleep = !1, this.b2Body = this.b2World.CreateBody(o), this.b2Body.SetActive(!1), e.hasOwnProperty("boxes") && this.createPhysicPartFromBoxes(e, this.b2Body, s), this.b2Body.ResetMassData(), this.b2Body.SetActive(!0)
            }, h.prototype.createPhysicPartFromBoxes = function(t, e, i) {
                var s = t.boxes,
                    o = 0;
                for (o = 0; o < s.length; o++) this.createPhysicPartFromBoxData(s[o], e, i)
            }, h.prototype.createPhysicPartFromBoxData = function(e, i, s) {
                var o = new t.types.GameObjectData;
                o.Type = s.Type, o.PhysicType = s.PhysicType, o.MaterialType = s.MaterialType, o.EntityCategory = t.types.EntityCategory.GAME_OBJECT;
                var n = new Box2D.Collision.Shapes.b2PolygonShape;
                n.SetAsOrientedBox(t.tools.Convertor.w_to_ws(e.width / 2), t.tools.Convertor.w_to_ws(e.height / 2), new Box2D.Common.Math.b2Vec2(t.tools.Convertor.w_to_ws(e.x), t.tools.Convertor.w_to_ws(e.y)), t.tools.Convertor.deg_to_rad(e.rotation));
                var a = new Box2D.Dynamics.b2FixtureDef;
                a.density = this.data.settings.density, a.friction = this.data.settings.friction, a.restitution = this.data.settings.restitution, a.shape = n, a.filter.categoryBits = o.EntityCategory, a.filter.maskBits = t.types.EntityCategory.BIKE_BODY | t.types.EntityCategory.BIKE_AXLE | t.types.EntityCategory.BIKE_WHEEL | t.types.EntityCategory.GAME_OBJECT | t.types.EntityCategory.BIKE_BODY_SENSOR_BODY | t.types.EntityCategory.BIKE_BODY_SENSOR_HEAD, a.userData = o, i.CreateFixture(a)
            }, h.prototype.createComponentProcessActionItem = function(t, e) {
                void 0 === e && (e = null);
                var i = {};
                return i.id = t, i.data = e, i
            }, h.prototype.createGraphics = function() {
                if (this.isGraphicsEnabled) {
                    this.graphicsContainer = this.game.add.group(this.parentContainer);
                    var t = this.data.graphics,
                        e = 0;
                    for (e = 0; e < t.length; ++e) this.createGraphicItem(t[e])
                }
            }, h.prototype.createGraphicItem = function(t) {
                var e = t.parts,
                    i = 0,
                    s = this.game.add.group(this.graphicsContainer);
                for (s.position.set(t.x, t.y), s.angle = t.rotation, i = 0; i < e.length; i++) this.createGraphicItemPart(e[i], s)
            }, h.prototype.createGraphicItemPart = function(e, i) {
                var s = e.x,
                    o = e.y,
                    n = e.rotation,
                    a = e.atlasKey;
                this.game.add.image(s, o, t.settings.GameCommonSettings.getGameLevelStartUpAtlasKey(), a, i).angle = n
            }, h.prototype.updateCompomentStartTranslation = function() {
                this.updatePhysicsStartTranslation(), this.updateGraphicsTranslation()
            }, h.prototype.updatePhysicsStartTranslation = function() {
                this.calcPhysicsTopPosition(), this.calcPhysicsBottomPosition();
                var t = this.componentBottomPosition;
                this.componentStartUpState === i.TOP && (t = this.componentTopPosition), this.setPhysicsStartTranslation(t.x, t.y, this.componentStartRotation)
            }, h.prototype.updateGraphicsTranslation = function() {
                if (this.isGraphicsEnabled) {
                    var e = this.graphicsContainer.getChildAt(0),
                        i = this.b2Body.GetPosition(),
                        s = this.b2Body.GetAngle();
                    e.position.x = i.x * t.config.GameConfig.b2WorldScale, e.position.y = i.y * t.config.GameConfig.b2WorldScale, e.rotation = s
                }
            }, h.prototype.calcPhysicsTopPosition = function() {
                this.calcPhysicsStartUpStatePosition(this.componentTopOffset, this.componentTopPosition)
            }, h.prototype.calcPhysicsBottomPosition = function() {
                this.calcPhysicsStartUpStatePosition(this.componentBottomOffset, this.componentBottomPosition)
            }, h.prototype.calcPhysicsStartUpStatePosition = function(e, i) {
                var s = new Box2D.Common.Math.b2Vec2(0, e),
                    o = t.tools.Convertor.getRotatedPositionFor(s, this.componentStartRotation);
                i.x = this.componentStartPosition.x + o.x, i.y = this.componentStartPosition.y + o.y
            }, h.prototype.calcComponentMoveUpVelocity = function() {
                this.calcComponentMoveVelocity(this.componentMoveUpVelocity, this.componentMoveUpVelocitySet)
            }, h.prototype.calcComponentMoveDownVelocity = function() {
                this.calcComponentMoveVelocity(this.componentMoveDownVelocity, this.componentMoveDownVelocitySet)
            }, h.prototype.calcComponentMoveVelocity = function(t, e) {
                t.x = e * Math.sin(this.componentStartRotation), t.y = e * Math.cos(this.componentStartRotation)
            }, h.prototype.calcTriggerSoundState = function() {
                this.componentState === o.TOP ? this.triggerSoundOnState = r.BOTTOM_STATE : this.componentState === o.BOTTOM && (this.triggerSoundOnState = r.TOP_STATE)
            }, h.prototype.setPhysicsStartTranslation = function(t, e, i) {
                var s = this.b2Body.GetUserData().UserData1;
                this.b2Body.SetPosition(new Box2D.Common.Math.b2Vec2(t + s.x, e + s.y)), this.b2Body.SetAngle(i + s.rot)
            }, h.prototype.setPhysicsActiveState = function(t) {
                this.b2Body.SetActive(t)
            }, h.prototype.setComponentMoveVelocity = function(t) {
                this.b2Body.SetLinearVelocity(t)
            }, h.prototype.setComponentProcessActionsList = function() {
                if (this.componentAction === s.MOVE_DOWN) {
                    if (this.componentState === o.BOTTOM) return;
                    this.componentProcessActionsList.push(this.createComponentProcessActionItem(n.MOVE_DOWN)), this.componentProcessActionsList.push(this.createComponentProcessActionItem(n.STOP))
                } else if (this.componentAction === s.MOVE_UP) {
                    if (this.componentState === o.TOP) return;
                    this.componentProcessActionsList.push(this.createComponentProcessActionItem(n.MOVE_UP)), this.componentProcessActionsList.push(this.createComponentProcessActionItem(n.STOP))
                } else this.componentAction === s.LOOP && (this.componentState === o.TOP ? (this.componentProcessActionsList.push(this.createComponentProcessActionItem(n.MOVE_DOWN)), this.componentProcessActionsList.push(this.createComponentProcessActionItem(n.WAIT_AT_BOTTOM)), this.componentProcessActionsList.push(this.createComponentProcessActionItem(n.MOVE_UP)), this.componentProcessActionsList.push(this.createComponentProcessActionItem(n.WAIT_AT_TOP))) : this.componentState === o.BOTTOM && (this.componentProcessActionsList.push(this.createComponentProcessActionItem(n.MOVE_UP)), this.componentProcessActionsList.push(this.createComponentProcessActionItem(n.WAIT_AT_TOP)), this.componentProcessActionsList.push(this.createComponentProcessActionItem(n.MOVE_DOWN)), this.componentProcessActionsList.push(this.createComponentProcessActionItem(n.WAIT_AT_BOTTOM))))
            }, h.prototype.setComponentMoveDownState = function() {
                this.componentState = o.MOVING_DOWN, this.moveComponentDown()
            }, h.prototype.setComponentMoveUpState = function() {
                this.componentState = o.MOVING_UP, this.moveComponentUp()
            }, h.prototype.setComponentWaitAtBottomState = function() {
                this.componentWaitingTime = 0, this.componentState = o.WAITING_AT_BOTTOM
            }, h.prototype.setComponentWaitAtTopState = function() {
                this.componentWaitingTime = 0, this.componentState = o.WAITING_AT_TOP
            }, h.prototype.correctComponentState = function() {
                var t = this.componentState;
                t === o.MOVING_DOWN || t === o.WAITING_AT_TOP || t === o.ADJUSTING_TOP_POSITION ? this.componentState = o.TOP : t === o.MOVING_UP || t === o.WAITING_AT_BOTTOM || t === o.ADJUSTING_BOTTOM_POSITION ? this.componentState = o.BOTTOM : t === o.WAITING_FOR_NEXT_PROCESS_ACTION && (this.componentState = this.componentNextState)
            }, h.prototype.startComponentNewAction = function() {
                this.componentAction !== s.UNKNOWN && (this.stopComponentMoving(), this.correctComponentState(), this.calcTriggerSoundState(), this.resetComponentProcessActionsList(), this.setComponentProcessActionsList(), this.startComponentNextProcessAction(!0))
            }, h.prototype.startComponentNextProcessAction = function(t) {
                void 0 === t && (t = !1), 0 !== this.componentProcessActionsList.length && (t || this.componentProcessActionsListIndex++, this.componentProcessActionsListIndex >= this.componentProcessActionsList.length && (this.componentProcessActionsListIndex = 0), this.startComponentProcessAction(this.componentProcessActionsList[this.componentProcessActionsListIndex]))
            }, h.prototype.startComponentProcessAction = function(t) {
                t.id !== n.STOP && (t.id === n.MOVE_DOWN ? this.setComponentMoveDownState() : t.id === n.MOVE_UP ? this.setComponentMoveUpState() : t.id === n.WAIT_AT_BOTTOM ? this.setComponentWaitAtBottomState() : t.id === n.WAIT_AT_TOP && this.setComponentWaitAtTopState())
            }, h.prototype.stopComponentMoving = function() {
                this.componentMoveVelocity.x = 0, this.componentMoveVelocity.y = 0, this.setComponentMoveVelocity(this.componentMoveVelocity)
            }, h.prototype.moveComponentDown = function() {
                this.componentMoveVelocity.x = -this.componentMoveDownVelocity.x, this.componentMoveVelocity.y = this.componentMoveDownVelocity.y, this.setComponentMoveVelocity(this.componentMoveVelocity)
            }, h.prototype.moveComponentUp = function() {
                this.componentMoveVelocity.x = this.componentMoveUpVelocity.x, this.componentMoveVelocity.y = -this.componentMoveUpVelocity.y, this.setComponentMoveVelocity(this.componentMoveVelocity)
            }, h.prototype.adjustComponentBottomPosition = function() {
                this.adjustComponentStatePosition(this.componentBottomPosition)
            }, h.prototype.adjustComponentTopPosition = function() {
                this.adjustComponentStatePosition(this.componentTopPosition)
            }, h.prototype.adjustComponentStatePosition = function(t) {
                this.b2Body.SetPosition(t.Copy())
            }, h.prototype.resetComponentProcessActionsList = function() {
                this.componentProcessActionsList.length = 0, this.componentProcessActionsListIndex = 0
            }, h.prototype.getComponentStartUpStateFromStr = function(t) {
                return "top" === t ? i.TOP : i.BOTTOM
            }, h.prototype.getComponentActionFromStr = function(t) {
                return "move_up" === t ? s.MOVE_UP : "move_down" === t ? s.MOVE_DOWN : "loop" === t ? s.LOOP : s.UNKNOWN
            }, h.prototype.checkComponentState = function(t) {
                this.componentState === o.MOVING_DOWN && this.isComponentBottomStateReached(t) ? (this.componentState = o.ADJUSTING_BOTTOM_POSITION, this.stopComponentMoving()) : this.componentState === o.MOVING_UP && this.isComponentTopStateReached(t) ? (this.componentState = o.ADJUSTING_TOP_POSITION, this.stopComponentMoving()) : this.componentState === o.ADJUSTING_BOTTOM_POSITION ? (this.componentState = o.WAITING_FOR_NEXT_PROCESS_ACTION, this.componentNextState = o.BOTTOM, this.adjustComponentBottomPosition(), this.triggerSoundOnState === r.BOTTOM_STATE && this.soundManager.playSound(Sounds.Piston)) : this.componentState === o.ADJUSTING_TOP_POSITION ? (this.componentState = o.WAITING_FOR_NEXT_PROCESS_ACTION, this.componentNextState = o.TOP, this.adjustComponentTopPosition(), this.triggerSoundOnState === r.TOP_STATE && this.soundManager.playSound(Sounds.Piston)) : this.componentState === o.WAITING_AT_BOTTOM || this.componentState === o.WAITING_AT_TOP ? (this.componentWaitingTime += t, (this.componentState === o.WAITING_AT_BOTTOM && this.isComponentWaitingAtBottomTimeReached() || this.componentState === o.WAITING_AT_TOP && this.isComponentWaitingAtTopTimeReached()) && (this.componentState === o.WAITING_AT_BOTTOM ? this.componentNextState = o.BOTTOM : this.componentState === o.WAITING_AT_TOP && (this.componentNextState = o.TOP), this.componentState = o.WAITING_FOR_NEXT_PROCESS_ACTION)) : this.componentState === o.WAITING_FOR_NEXT_PROCESS_ACTION && (this.componentState = this.componentNextState, this.startComponentNextProcessAction())
            }, h.prototype.isComponentWaitingAtBottomTimeReached = function() {
                return this.isComponentWaitingAtStateTimeReached(this.componentWaitingAtBottomTime)
            }, h.prototype.isComponentWaitingAtTopTimeReached = function() {
                return this.isComponentWaitingAtStateTimeReached(this.componentWaitingAtTopTime)
            }, h.prototype.isComponentWaitingAtStateTimeReached = function(t) {
                return this.componentWaitingTime >= t
            }, h.prototype.isComponentBottomStateReached = function(t) {
                return this.isComponentPositionStateReached(this.componentBottomPosition, a.DOWN, t)
            }, h.prototype.isComponentTopStateReached = function(t) {
                return this.isComponentPositionStateReached(this.componentTopPosition, a.UP, t)
            }, h.prototype.isComponentPositionStateReached = function(t, e, i) {
                var s = this.b2Body.GetPosition().Copy();
                s.x += this.componentMoveVelocity.x * i, s.y += this.componentMoveVelocity.y * i;
                var o = this.componentStartRotation,
                    n = this.componentRotationSet_0,
                    r = this.componentRotationSet_90,
                    h = this.componentRotationSet_180,
                    l = this.componentRotationSet_270,
                    c = this.componentRotationSet_360;
                return e === a.DOWN && (o >= n && ((o === n || o === c) && s.y >= t.y || o > n && o < r && s.x <= t.x && s.y >= t.y || o === r && s.x <= t.x || o > r && o < h && s.x <= t.x && s.y <= t.y || o === h && s.y <= t.y || o > h && o < l && s.x >= t.x && s.y <= t.y || o === l && s.x >= t.x || o > l && o < c && s.x >= t.x && s.y >= t.y) || o < n && (o === -c && s.y >= t.y || o > -c && o < -l && s.x <= t.x && s.y >= t.y || o === -l && s.x <= t.x || o > -l && o < -h && s.x <= t.x && s.y <= t.y || o === -h && s.y <= t.y || o > -h && o < -r && s.x >= t.x && s.y <= t.y || o === -r && s.x >= t.x || o > -r && o < n && s.x >= t.x && s.y >= t.y)) || e === a.UP && (o >= n && ((o === n || o === c) && s.y <= t.y || o > n && o < r && s.x >= t.x && s.y <= t.y || o === r && s.x >= t.x || o > r && o < h && s.x >= t.x && s.y >= t.y || o === h && s.y >= t.y || o > h && o < l && s.x <= t.x && s.y >= t.y || o === l && s.x <= t.x || o > l && o < c && s.x <= t.x && s.y <= t.y) || o < n && (o === -c && s.y <= t.y || o > -c && o < -l && s.x >= t.x && s.y <= t.y || o === -l && s.x >= t.x || o > -l && o < -h && s.x >= t.x && s.y >= t.y || o === -h && s.y >= t.y || o > -h && o < -r && s.x <= t.x && s.y >= t.y || o === -r && s.x <= t.x || o > -r && o < n && s.x <= t.x && s.y <= t.y))
            }, h.prototype.disposePhysics = function() {
                null !== this.b2Body && (this.b2Body.SetActive(!1), this.b2World.DestroyBody(this.b2Body))
            }, h.prototype.disposeGraphics = function() {
                null !== this.graphicsContainer && (null !== this.graphicsContainer.parent && this.graphicsContainer.parent.removeChild(this.graphicsContainer), this.graphicsContainer.removeAll(!0, !0))
            }, h.prototype.customInitData = function() {
                this.soundManager = BoilerPlate.SoundManager.getInstance(), this.componentProcessActionsList = [], this.componentStartPosition = new Box2D.Common.Math.b2Vec2(t.tools.Convertor.w_to_ws(this.data.x), t.tools.Convertor.w_to_ws(this.data.y)), this.componentStartRotation = t.tools.Convertor.deg_to_rad(this.data.rotation), this.componentTopOffset = t.tools.Convertor.w_to_ws(this.data.states.top.y), this.componentBottomOffset = t.tools.Convertor.w_to_ws(this.data.states.bottom.y), this.componentStartUpState = this.getComponentStartUpStateFromStr(this.data.settings.startUpState), this.componentState = this.componentStartUpState, this.componentNextState = this.componentState, this.calcTriggerSoundState(), this.componentMoveUpVelocitySet = t.tools.Convertor.w_to_ws(this.data.settings.movingUpVelocity), this.componentMoveDownVelocitySet = t.tools.Convertor.w_to_ws(this.data.settings.movingDownVelocity), this.componentRotationSet_0 = t.tools.Convertor.deg_to_rad(0), this.componentRotationSet_90 = t.tools.Convertor.deg_to_rad(90), this.componentRotationSet_180 = t.tools.Convertor.deg_to_rad(180), this.componentRotationSet_270 = t.tools.Convertor.deg_to_rad(270), this.componentRotationSet_360 = t.tools.Convertor.deg_to_rad(360), this.componentWaitingAtBottomTime = this.data.settings.inBottomStateWaitingTime, this.componentWaitingAtTopTime = this.data.settings.inTopStateWaitingTime, this.componentTopPosition = new Box2D.Common.Math.b2Vec2, this.componentBottomPosition = new Box2D.Common.Math.b2Vec2, this.componentMoveVelocity = new Box2D.Common.Math.b2Vec2, this.componentMoveUpVelocity = new Box2D.Common.Math.b2Vec2, this.componentMoveDownVelocity = new Box2D.Common.Math.b2Vec2
            }, h.prototype.customDispose = function() {
                this.disposePhysics(), this.disposeGraphics()
            }, h.prototype.resetData = function() {
                this.componentStartPosition = null, this.componentTopPosition = null, this.componentBottomPosition = null, this.componentStartRotation = 0, this.componentTopOffset = 0, this.componentBottomOffset = 0, this.componentStartUpState = 0, this.componentAction = 0, this.componentState = 0, this.componentNextState = 0, this.componentMoveUpVelocitySet = 0, this.componentMoveDownVelocitySet = 0, this.componentMoveVelocity = null, this.componentMoveUpVelocity = null, this.componentMoveDownVelocity = null, this.componentProcessActionsList = null, this.componentProcessActionsListIndex = 0, this.componentRotationSet_0 = 0, this.componentRotationSet_90 = 0, this.componentRotationSet_180 = 0, this.componentRotationSet_270 = 0, this.componentRotationSet_360 = 0, this.componentWaitingTime = 0, this.componentWaitingAtBottomTime = 0, this.componentWaitingAtTopTime = 0, this.b2Body = null, this.graphicsContainer = null, this.triggerSoundOnState = 0, this.soundManager = null, e.prototype.resetData.call(this)
            }, h
        }(t.game_objects.GameObject);
        e.GOPiston = h
    }(t.game_objects || (t.game_objects = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(e) {
        var i;
        ! function(t) {
            t[t.ACTIVATED = 1] = "ACTIVATED", t[t.BOMB_ACTIVATION = 2] = "BOMB_ACTIVATION", t[t.GRAPHICS_ANIMATION = 3] = "GRAPHICS_ANIMATION", t[t.CAMERA_SHAKING = 4] = "CAMERA_SHAKING", t[t.DEACTIVATED = 5] = "DEACTIVATED"
        }(i || (i = {}));
        var s;
        ! function(t) {
            t[t.UNKNOWN = 0] = "UNKNOWN", t[t.ACTIVATE = 1] = "ACTIVATE"
        }(s || (s = {}));
        var o;
        ! function(t) {
            t[t.UNKNOWN = 0] = "UNKNOWN", t[t.ACTIVATE_BOMB = 1] = "ACTIVATE_BOMB", t[t.START_GRAPHICS_ANIMATION = 2] = "START_GRAPHICS_ANIMATION", t[t.START_CAMERA_SHAKE = 3] = "START_CAMERA_SHAKE", t[t.DEACTIVATE_COMPONENT = 4] = "DEACTIVATE_COMPONENT"
        }(o || (o = {}));
        var n;
        (n || (n = {})).GO_ANIM = "go_anim";
        var a = function(e) {
            function a(i, s, o, n, a, r) {
                var h = e.call(this, i, s, o, t.types.GameObjectType.BOMB, n, a, r) || this;
                return h.init(), h
            }
            return __extends(a, e), a.prototype.setPositionXY = function(e, i) {
                !this.isDisposed && this.isComponentInited && (this.setPhysicsActiveState(!1), this.componentStartPosition = new Box2D.Common.Math.b2Vec2(t.tools.Convertor.w_to_ws(e), t.tools.Convertor.w_to_ws(i)), this.updateCompomentStartTranslation(), this.setPhysicsActiveState(!0))
            }, a.prototype.startAction = function(t) {
                !this.isDisposed && this.isComponentInited && (this.componentAction = this.getComponentActionFromStr(t), this.startComponentNewAction())
            }, a.prototype.init = function() {
                this.createPhysics(), this.createGraphics(), this.updateCompomentStartTranslation(), this.componentState = i.ACTIVATED, this.isComponentInited = !0
            }, a.prototype.createPhysics = function() {
                var t = this.data.physics;
                this.b2Body = this.createPhysicItem(t[0])
            }, a.prototype.createPhysicItem = function(e) {
                var i = {};
                i.x = t.tools.Convertor.w_to_ws(e.x), i.y = t.tools.Convertor.w_to_ws(e.x), i.rot = t.tools.Convertor.deg_to_rad(e.rotation);
                var s = new t.types.GameObjectData;
                s.Type = this.type, s.PhysicType = t.types.GameObjectPhysicType.STATIC, s.MaterialType = t.tools.Convertor.getGameObjectMaterialTypeFromStr(this.data.settings.material), s.UserData1 = i;
                var o = new Box2D.Dynamics.b2BodyDef;
                o.type = Box2D.Dynamics.b2Body.b2_staticBody, o.userData = s, o.position.Set(i.x, i.y), o.angle = i.rot;
                var n = this.b2World.CreateBody(o);
                return n.SetActive(!1), e.hasOwnProperty("boxes") && this.createPhysicPartBoxes(e, n, s), n.ResetMassData(), n.SetActive(!0), n
            }, a.prototype.createPhysicPartBoxes = function(t, e, i) {
                var s = t.boxes,
                    o = s.length,
                    n = 0;
                for (n = 0; n < o; ++n) this.createPhysicPartBoxesItem(s[n], e, i)
            }, a.prototype.createPhysicPartBoxesItem = function(e, i, s) {
                var o = new t.types.GameObjectData;
                o.Type = s.Type, o.MaterialType = s.MaterialType;
                var n = new Box2D.Collision.Shapes.b2PolygonShape;
                n.SetAsOrientedBox(t.tools.Convertor.w_to_ws(e.width / 2), t.tools.Convertor.w_to_ws(e.height / 2), new Box2D.Common.Math.b2Vec2(t.tools.Convertor.w_to_ws(e.x), t.tools.Convertor.w_to_ws(e.y)), t.tools.Convertor.deg_to_rad(e.rotation));
                var a = new Box2D.Dynamics.b2FixtureDef;
                a.density = this.data.settings.density, a.friction = this.data.settings.friction, a.restitution = this.data.settings.restitution, a.shape = n, a.userData = o, a.filter.categoryBits = t.types.EntityCategory.UNKNOWN, a.filter.maskBits = t.types.EntityCategory.UNKNOWN, i.CreateFixture(a)
            }, a.prototype.createGraphics = function() {
                this.isGraphicsEnabled && (this.createGraphicsContainers(), this.createStaticGraphics(), this.createAnimationsGraphics(), this.graphicsStaticContainer.visible = !0, this.graphicsAnimationsContainer.visible = !1)
            }, a.prototype.createGraphicsContainers = function() {
                this.graphicsContainer = this.game.add.group(this.parentContainer), this.graphicsStaticContainer = this.game.add.group(this.graphicsContainer), this.graphicsAnimationsContainer = this.game.add.group(this.graphicsContainer)
            }, a.prototype.createStaticGraphics = function() {
                var t = this.data.animations;
                this.createStaticGraphicsItem(this.graphicsStaticContainer, t[0])
            }, a.prototype.createAnimationsGraphics = function() {
                var t = this.data.animations;
                this.createAnimationGraphicItem(this.graphicsAnimationsContainer, t[0])
            }, a.prototype.createStaticGraphicsItem = function(t, e) {
                var i = e.parts,
                    s = this.game.add.group(t);
                s.position.set(e.x, e.y), s.angle = e.rotation, this.createStaticGraphicsItemPart(i[0], s)
            }, a.prototype.createAnimationGraphicItem = function(t, e) {
                var i = e.parts,
                    s = this.game.add.group(t);
                s.position.set(e.x, e.y), s.angle = e.rotation, this.animationSprite = this.createAnimationGraphicItemPart(i[0], s)
            }, a.prototype.createStaticGraphicsItemPart = function(e, i) {
                var s = e.x,
                    o = e.y,
                    n = e.rotation,
                    a = e.atlasKeys,
                    r = this.game.add.sprite(s, o, t.settings.GameCommonSettings.getGameLevelStartUpAtlasKey(), a[0], i);
                return r.angle = n, r
            }, a.prototype.createAnimationGraphicItemPart = function(t, e) {
                var i = t.x,
                    s = t.y,
                    o = t.rotation,
                    a = ["a_40_explosion_bike_agp_p10000", "a_40_explosion_bike_agp_p10001", "a_40_explosion_bike_agp_p10002", "a_40_explosion_bike_agp_p10003", "a_40_explosion_bike_agp_p10004", "a_40_explosion_bike_agp_p10005", "a_40_explosion_bike_agp_p10006", "a_40_explosion_bike_agp_p10007", "a_40_explosion_bike_agp_p10008", "a_40_explosion_bike_agp_p10009"],
                    r = 3.5,
                    h = this.game.add.sprite(i * r, s * r, this.gameAtlasKey, a[0], e);
                return h.angle = o, h.animations.add(n.GO_ANIM, a), h.scale.set(r, r), h
            }, a.prototype.createComponentProcessActionItem = function(t, e) {
                void 0 === e && (e = null);
                var i = {};
                return i.id = t, i.data = e, i
            }, a.prototype.updateCompomentStartTranslation = function() {
                this.updatePhysicsStartTranslation(), this.updateGraphicsTranslation()
            }, a.prototype.updatePhysicsStartTranslation = function() {
                var t = this.b2Body.GetUserData().UserData1;
                this.b2Body.SetPosition(new Box2D.Common.Math.b2Vec2(this.componentStartPosition.x + t.x, this.componentStartPosition.y + t.y)), this.b2Body.SetAngle(this.componentStartRotation + t.rot)
            }, a.prototype.updateGraphicsTranslation = function() {
                if (this.isGraphicsEnabled) {
                    var e = this.b2Body.GetWorldCenter();
                    this.graphicsContainer.position.x = e.x * t.config.GameConfig.b2WorldScale, this.graphicsContainer.position.y = e.y * t.config.GameConfig.b2WorldScale, this.graphicsContainer.rotation = this.b2Body.GetAngle()
                }
            }, a.prototype.startComponentNewAction = function() {
                this.componentAction !== s.UNKNOWN && (this.resetComponentProcessActionsList(), this.setComponentProcessActionsList(), this.startComponentNextProcessAction(!0))
            }, a.prototype.startComponentNextProcessAction = function(t) {
                void 0 === t && (t = !1), 0 !== this.componentProcessActionsList.length && (t || this.componentProcessActionsListIndex++, this.componentProcessActionsListIndex >= this.componentProcessActionsList.length && (this.componentProcessActionsListIndex = 0), this.startComponentProcessAction(this.componentProcessActionsList[this.componentProcessActionsListIndex]))
            }, a.prototype.startComponentProcessAction = function(t) {
                t.id === o.ACTIVATE_BOMB ? this.setComponentActivateBombState() : t.id === o.START_GRAPHICS_ANIMATION ? this.setComponentGraphicsAnimationState() : t.id === o.START_CAMERA_SHAKE ? this.setComponentCameraShakeState() : t.id === o.DEACTIVATE_COMPONENT && this.setComponentDeactivatedState()
            }, a.prototype.startComponentAnimations = function() {
                this.graphicsStaticContainer.visible = !1, this.graphicsAnimationsContainer.visible = !0, this.animationSprite.animations.play(n.GO_ANIM, 30, !1, !0)
            }, a.prototype.startCameraShake = function() {
                this.game.camera.shake(.005, 500, !0, Phaser.Camera.SHAKE_BOTH, !0), this.game.camera.onShakeComplete.addOnce(this.onCameraShakeComplete, this)
            }, a.prototype.setPhysicsActiveState = function(t) {
                this.b2Body.SetActive(t)
            }, a.prototype.setComponentProcessActionsList = function() {
                this.componentAction === s.ACTIVATE && (this.componentProcessActionsList.push(this.createComponentProcessActionItem(o.ACTIVATE_BOMB)), this.isGraphicsEnabled && (this.componentProcessActionsList.push(this.createComponentProcessActionItem(o.START_GRAPHICS_ANIMATION)), this.componentProcessActionsList.push(this.createComponentProcessActionItem(o.START_CAMERA_SHAKE))), this.componentProcessActionsList.push(this.createComponentProcessActionItem(o.DEACTIVATE_COMPONENT)))
            }, a.prototype.setComponentActivateBombState = function() {
                this.componentState = i.BOMB_ACTIVATION, this.activateBomb(), this.soundManager.playSound(Sounds.Explosion), this.startComponentNextProcessAction()
            }, a.prototype.setComponentGraphicsAnimationState = function() {
                this.componentState = i.GRAPHICS_ANIMATION, this.startComponentAnimations(), this.startComponentNextProcessAction()
            }, a.prototype.setComponentCameraShakeState = function() {
                console.log("setComponentCameraShakeState"), this.componentState = i.CAMERA_SHAKING, this.startCameraShake()
            }, a.prototype.setComponentDeactivatedState = function() {
                this.componentState = i.DEACTIVATED, console.log("setComponentDeactivatedState")
            }, a.prototype.getComponentActionFromStr = function(t) {
                return "activate" === t ? s.ACTIVATE : s.UNKNOWN
            }, a.prototype.activateBomb = function() {
                this.resetFoundBodiesList();
                var e = new Box2D.Collision.b2AABB;
                e.lowerBound = new Box2D.Common.Math.b2Vec2(this.componentStartPosition.x - this.componentBlastRadius, this.componentStartPosition.y - this.componentBlastRadius), e.upperBound = new Box2D.Common.Math.b2Vec2(this.componentStartPosition.x + this.componentBlastRadius, this.componentStartPosition.y + this.componentBlastRadius);
                var i = this.b2FoundBodiesList,
                    s = !1,
                    o = null;
                this.b2World.QueryAABB(function(e) {
                    return s = !1, void 0 !== e && null !== e && ((void 0 !== (o = e.GetUserData()) && null !== o && o.Type === t.types.GameObjectType.BIKE && (o.EntityCategory & t.types.EntityCategory.BIKE_WHEEL) === t.types.EntityCategory.BIKE_WHEEL || o.Type === t.types.GameObjectType.CIRCLE || o.Type === t.types.GameObjectType.DESTRUCTIBLE_OBJECT || o.Type === t.types.GameObjectType.STICK) && (s = !0), s && i.push(e.GetBody())), !0
                }, e);
                var n = i.length,
                    a = 0;
                for (a = 0; a < n; a++) {
                    var r = this.b2FoundBodiesList[a],
                        h = r.GetWorldCenter();
                    new Box2D.Common.Math.b2Vec2(h.x - this.componentStartPosition.x, h.y - this.componentStartPosition.y).Length() >= this.componentBlastRadius || this.applyBlastImpulse(r, this.componentStartPosition, h, 1)
                }
            }, a.prototype.applyBlastImpulse = function(t, e, i, s) {
                var o = new Box2D.Common.Math.b2Vec2(i.x - e.x, i.y - e.y),
                    n = o.Normalize();
                if (0 !== n) {
                    var a = s,
                        r = new Box2D.Common.Math.b2Vec2(a * o.x, a * o.y);
                    t.ApplyImpulse(r, i)
                }
            }, a.prototype.resetFoundBodiesList = function() {
                this.b2FoundBodiesList.length = 0
            }, a.prototype.resetComponentProcessActionsList = function() {
                this.componentProcessActionsList.length = 0, this.componentProcessActionsListIndex = 0
            }, a.prototype.disposePhysics = function() {
                this.b2Body.SetActive(!1), this.b2World.DestroyBody(this.b2Body)
            }, a.prototype.disposeGraphics = function() {
                null !== this.graphicsContainer && (this.graphicsContainer.removeAll(!0, !0), null !== this.graphicsContainer.parent && this.graphicsContainer.parent.removeChild(this.graphicsContainer))
            }, a.prototype.customInitData = function() {
                this.componentProcessActionsList = [], this.b2FoundBodiesList = [], this.componentStartPosition = new Box2D.Common.Math.b2Vec2(t.tools.Convertor.w_to_ws(this.data.x), t.tools.Convertor.w_to_ws(this.data.y)), this.componentStartRotation = t.tools.Convertor.deg_to_rad(this.data.rotation), this.componentBlastRadius = t.tools.Convertor.w_to_ws(this.data.rings.ring1.radius), this.soundManager = BoilerPlate.SoundManager.getInstance()
            }, a.prototype.customDispose = function() {
                this.resetFoundBodiesList(), this.resetComponentProcessActionsList(), this.disposePhysics(), this.disposeGraphics()
            }, a.prototype.customResetData = function() {
                this.b2Body = null, this.b2FoundBodiesList = null, this.componentStartPosition = null, this.componentStartRotation = 0, this.componentBlastRadius = 0, this.componentAction = 0, this.componentState = 0, this.componentProcessActionsList = null, this.componentProcessActionsListIndex = 0, this.graphicsContainer = null, this.graphicsStaticContainer = null, this.graphicsAnimationsContainer = null, this.animationSprite = null, this.soundManager = null
            }, a.prototype.onCameraShakeComplete = function() {
                this.startComponentNextProcessAction()
            }, a
        }(t.game_objects.GameObject);
        e.GOBomb = a
    }(t.game_objects || (t.game_objects = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(e) {
        var i = function(e) {
            function i(i, s, o, n, a) {
                var r = e.call(this, i, s, o, t.types.GameObjectType.FINISH_ZONE, n, a) || this;
                return r.init(), r
            }
            return __extends(i, e), Object.defineProperty(i.prototype, "IsComponentActivated", {
                get: function() {
                    return this.isComponentActivated
                },
                enumerable: !0,
                configurable: !0
            }), i.prototype.setPositionXY = function(e, i) {
                !this.isDisposed && this.isInited && (this.startPosition.x = t.tools.Convertor.w_to_ws(e), this.startPosition.y = t.tools.Convertor.w_to_ws(i), this.updateComponentTranslation())
            }, i.prototype.activatePhysics = function() {
                this.isDisposed || !this.isInited || this.isPhysicsActivated || this.setPhysicsActiveState(!0)
            }, i.prototype.deactivatePhysics = function() {
                !this.isDisposed && this.isInited && this.isPhysicsActivated && this.setPhysicsActiveState(!1)
            }, i.prototype.updateGraphics = function(e) {
                !this.isDisposed && this.isInited && t.config.GameConfig.enableGraphics && this.updateGraphicsTranslation()
            }, i.prototype.init = function() {
                this.createPhysics(), this.createGraphics(), this.updateComponentTranslation(), this.isInited = !0
            }, i.prototype.createPhysics = function() {
                var t = this.data.physics,
                    e = 0;
                for (e = 0; e < t.length; ++e) this.createPhysicItem(t[e]);
                this.isPhysicsActivated = !0
            }, i.prototype.createPhysicItem = function(e) {
                var i = {};
                i.x = t.tools.Convertor.w_to_ws(e.x), i.y = t.tools.Convertor.w_to_ws(e.x), i.rot = t.tools.Convertor.deg_to_rad(e.rotation);
                var s = new t.types.GameObjectData;
                s.Type = t.types.GameObjectType.FINISH_ZONE, s.PhysicType = t.types.GameObjectPhysicType.STATIC, s.MaterialType = t.tools.Convertor.getGameObjectMaterialTypeFromStr(this.data.settings.material), s.UserData1 = i, s.UserData2 = this;
                var o = new Box2D.Dynamics.b2BodyDef;
                o.type = Box2D.Dynamics.b2Body.b2_staticBody, o.userData = s, o.position.Set(i.x, i.y), o.angle = i.rot;
                var n = this.b2World.CreateBody(o);
                e.hasOwnProperty("boxes") && this.createPhysicPartFromBoxes(e, n, s), n.ResetMassData(), this.b2BodyList.push(n)
            }, i.prototype.createPhysicPartFromBoxes = function(t, e, i) {
                var s = t.boxes,
                    o = 0;
                for (o = 0; o < s.length; ++o) this.createPhysicPartFromBoxItem(s[o], e, i)
            }, i.prototype.createPhysicPartFromBoxItem = function(e, i, s) {
                var o = new t.types.GameObjectData;
                o.Type = s.Type, o.PhysicType = s.PhysicType, o.MaterialType = s.MaterialType, o.UserData2 = s.UserData2, o.EntityCategory = t.types.EntityCategory.GAME_OBJECT;
                var n = new Box2D.Collision.Shapes.b2PolygonShape;
                n.SetAsOrientedBox(t.tools.Convertor.w_to_ws(e.width / 2), t.tools.Convertor.w_to_ws(e.height / 2), new Box2D.Common.Math.b2Vec2(t.tools.Convertor.w_to_ws(e.x), t.tools.Convertor.w_to_ws(e.y)), t.tools.Convertor.deg_to_rad(e.rotation));
                var a = new Box2D.Dynamics.b2FixtureDef;
                a.density = this.data.settings.density, a.friction = this.data.settings.friction, a.restitution = this.data.settings.restitution, a.isSensor = !0, a.shape = n, a.userData = o, a.filter.categoryBits = o.EntityCategory, a.filter.maskBits = t.types.EntityCategory.BIKE_WHEEL | t.types.EntityCategory.BIKE_BODY | t.types.EntityCategory.BIKE_AXLE | t.types.EntityCategory.BIKE_BODY_SENSOR_HEAD | t.types.EntityCategory.BIKE_BODY_SENSOR_BODY | t.types.EntityCategory.GAME_OBJECT, i.CreateFixture(a)
            }, i.prototype.createGraphics = function() {
                if (this.graphicsContainer = this.game.add.group(), this.parentContainer.add(this.graphicsContainer), t.config.GameConfig.enableGraphics) {
                    var e = this.data.graphics,
                        i = 0;
                    for (i = 0; i < e.length; ++i) this.createGraphicItem(e[i])
                }
            }, i.prototype.createGraphicItem = function(t) {
                var e = t.parts,
                    i = 0,
                    s = this.game.add.group();
                for (s.position.set(t.x, t.y), s.angle = t.rotation, this.graphicsContainer.add(s), i = 0; i < e.length; i++) this.createGraphicItemPart(e[i], s)
            }, i.prototype.createGraphicItemPart = function(e, i) {
                var s = e.x,
                    o = e.y,
                    n = e.rotation,
                    a = e.atlasKey,
                    r = this.game.add.image(s, o, t.settings.GameCommonSettings.getGameLevelStartUpAtlasKey(), a);
                r.angle = n, i.add(r)
            }, i.prototype.updateComponentTranslation = function() {
                this.updatePhysicsTranslation(), t.config.GameConfig.enableGraphics && this.updateGraphicsTranslation()
            }, i.prototype.updatePhysicsTranslation = function() {
                var t = this.isPhysicsActivated;
                t && this.setPhysicsActiveState(!1);
                var e = this.b2BodyList.length,
                    i = 0;
                for (i = 0; i < e; ++i) {
                    var s = this.b2BodyList[i],
                        o = s.GetUserData().UserData1;
                    s.SetPosition(new Box2D.Common.Math.b2Vec2(this.startPosition.x + o.x, this.startPosition.y + o.y)), s.SetAngle(this.componentRotation + o.rot)
                }
                t && this.setPhysicsActiveState(!0)
            }, i.prototype.updateGraphicsTranslation = function() {
                var e, i = Math.min(this.b2BodyList.length, this.graphicsContainer.children.length);
                for (e = 0; e < i; ++e) {
                    var s = this.b2BodyList[e],
                        o = this.graphicsContainer.getChildAt(e),
                        n = s.GetPosition(),
                        a = s.GetAngle();
                    o.position.x = n.x * t.config.GameConfig.b2WorldScale, o.position.y = n.y * t.config.GameConfig.b2WorldScale, o.rotation = a
                }
            }, i.prototype.setPhysicsActiveState = function(t) {
                var e = this.b2BodyList.length,
                    i = 0;
                for (i = 0; i < e; ++i) this.b2BodyList[i].SetActive(t);
                this.isPhysicsActivated = t
            }, i.prototype.disposePhysics = function() {
                var t = this.b2BodyList.length,
                    e = 0;
                if (t > 0)
                    for (e = 0; e < t; ++e) {
                        var i = this.b2BodyList[e];
                        i.SetActive(!1), this.b2World.DestroyBody(i)
                    }
                this.b2BodyList.length = 0
            }, i.prototype.disposeGraphics = function() {
                null != this.parentContainer && null != this.graphicsContainer && this.parentContainer.remove(this.graphicsContainer, !0, !0)
            }, i.prototype.initData = function() {
                e.prototype.initData.call(this), this.b2BodyList = [], this.isComponentActivated = !0, this.startPosition = new Box2D.Common.Math.b2Vec2(t.tools.Convertor.w_to_ws(this.data.x), t.tools.Convertor.w_to_ws(this.data.y)), this.componentRotation = t.tools.Convertor.deg_to_rad(this.data.rotation)
            }, i.prototype.customDispose = function() {
                this.disposePhysics(), this.disposeGraphics()
            }, i.prototype.resetData = function() {
                e.prototype.resetData.call(this), this.b2BodyList = null, this.isPhysicsActivated = !1, this.isInited = !1, this.startPosition = null, this.componentRotation = 0, this.isComponentActivated = !1, this.graphicsContainer = null
            }, i
        }(t.game_objects.GameObject);
        e.GOFinishZone = i
    }(t.game_objects || (t.game_objects = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(e) {
        var i = function(e) {
            function i(i, s, o, n, a) {
                var r = e.call(this, i, s, o, t.types.GameObjectType.CAMERA_TRIGGER, n, a) || this;
                return r.init(), r
            }
            return __extends(i, e), Object.defineProperty(i.prototype, "IsTriggerActive", {
                get: function() {
                    return this.isTriggerActive
                },
                enumerable: !0,
                configurable: !0
            }), i.prototype.startDefaultAction = function() {
                if (!this.isDisposed && this.isInited) {
                    var e = new t.types.GameObjectActionData;
                    e.Type = this.type, e.Sender = this, e.Action = t.types.GameObjectActions.REQUEST_GAME_CAMERA_CONTROLLER, this.signalOnAction.dispatch(e)
                }
            }, i.prototype.setGameCameraControllerRef = function(t) {
                !this.isDisposed && this.isInited && (this.gameCameraControllerRef = t)
            }, i.prototype.activateTrigger = function() {
                !this.isDisposed && this.isInited && (this.isTriggerActive = !1, this.gameCameraControllerRef.activateZoomId(this.zoomId, this.zoomDuration, this.cameraOffset))
            }, i.prototype.setPositionXY = function(e, i) {
                !this.isDisposed && this.isInited && (this.startPosition.x = t.tools.Convertor.w_to_ws(e), this.startPosition.y = t.tools.Convertor.w_to_ws(i), this.updateComponentTranslation())
            }, i.prototype.activatePhysics = function() {
                this.isDisposed || !this.isInited || this.isPhysicsActivated || this.setPhysicsActiveState(!0)
            }, i.prototype.deactivatePhysics = function() {
                !this.isDisposed && this.isInited && this.isPhysicsActivated && this.setPhysicsActiveState(!1)
            }, i.prototype.init = function() {
                this.createPhysics(), this.updateComponentTranslation(), this.isInited = !0
            }, i.prototype.createPhysics = function() {
                var t = this.data.physics,
                    e = t.length,
                    i = 0;
                for (i = 0; i < e; ++i) this.createPhysicItem(t[i]);
                this.isTriggerActive = !0, this.isPhysicsActivated = !0
            }, i.prototype.createPhysicItem = function(e) {
                var i = {};
                i.x = t.tools.Convertor.w_to_ws(e.x), i.y = t.tools.Convertor.w_to_ws(e.y), i.rot = t.tools.Convertor.deg_to_rad(e.rotation);
                var s = t.tools.Convertor.getGameObjectPhysicTypeFromStr(this.data.settings.physicType),
                    o = new t.types.GameObjectData;
                o.Type = t.types.GameObjectType.CAMERA_TRIGGER, o.PhysicType = s, o.MaterialType = t.tools.Convertor.getGameObjectMaterialTypeFromStr(this.data.settings.material), o.UserData1 = i, o.UserData2 = this;
                var n = new Box2D.Dynamics.b2BodyDef;
                s === t.types.GameObjectPhysicType.DYNAMIC ? n.type = Box2D.Dynamics.b2Body.b2_dynamicBody : n.type = Box2D.Dynamics.b2Body.b2_staticBody, n.userData = o, n.position.Set(i.x, i.y), n.angle = i.rot;
                var a = this.b2World.CreateBody(n);
                a.SetActive(!1), e.hasOwnProperty("boxes") && this.createPhysicPartBoxes(e, a, o), a.ResetMassData(), a.SetActive(!0), this.b2BodyList.push(a)
            }, i.prototype.createPhysicPartBoxes = function(t, e, i) {
                var s = t.boxes,
                    o = s.length,
                    n = 0;
                for (n = 0; n < o; ++n) this.createPhysicPartBoxesItem(s[n], e, i)
            }, i.prototype.createPhysicPartBoxesItem = function(e, i, s) {
                var o = new t.types.GameObjectData;
                o.Type = s.Type, o.PhysicType = s.PhysicType, o.MaterialType = s.MaterialType, o.EntityCategory = t.types.EntityCategory.GAME_OBJECT, o.UserData2 = s.UserData2;
                var n = new Box2D.Collision.Shapes.b2PolygonShape;
                n.SetAsOrientedBox(t.tools.Convertor.w_to_ws(e.width / 2), t.tools.Convertor.w_to_ws(e.height / 2), new Box2D.Common.Math.b2Vec2(t.tools.Convertor.w_to_ws(e.x), t.tools.Convertor.w_to_ws(e.y)), t.tools.Convertor.deg_to_rad(e.rotation));
                var a = new Box2D.Dynamics.b2FixtureDef;
                a.density = this.data.settings.density, a.friction = this.data.settings.friction, a.restitution = this.data.settings.restitution, a.shape = n, a.filter.categoryBits = o.EntityCategory, a.filter.maskBits = t.types.EntityCategory.BIKE_WHEEL | t.types.EntityCategory.BIKE_BODY | t.types.EntityCategory.BIKE_AXLE | t.types.EntityCategory.GAME_OBJECT | t.types.EntityCategory.BIKE_BODY_SENSOR_HEAD, o.PhysicType === t.types.GameObjectPhysicType.DYNAMIC && (a.filter.maskBits = a.filter.maskBits | t.types.EntityCategory.GROUND), a.userData = o, a.isSensor = !0, i.CreateFixture(a)
            }, i.prototype.updateComponentTranslation = function() {
                this.updatePhysicsTranslation(), this.updateComponentCameraOffset()
            }, i.prototype.updatePhysicsTranslation = function() {
                var t = this.isPhysicsActivated;
                t && this.setPhysicsActiveState(!1);
                var e = this.b2BodyList.length,
                    i = 0;
                for (i = 0; i < e; ++i) {
                    var s = this.b2BodyList[i],
                        o = s.GetUserData().UserData1;
                    s.SetPosition(new Box2D.Common.Math.b2Vec2(this.startPosition.x + o.x, this.startPosition.y + o.y)), s.SetAngle(this.componentRotation + o.rot)
                }
                t && this.setPhysicsActiveState(!0)
            }, i.prototype.updateComponentCameraOffset = function() {
                this.data.hasOwnProperty("offsetItem") && (this.cameraOffset.BottomLimit = this.data.offsetItem.offsetY)
            }, i.prototype.setPhysicsActiveState = function(t) {
                var e = this.b2BodyList.length,
                    i = 0;
                for (i = 0; i < e; ++i) this.b2BodyList[i].SetActive(t);
                this.isPhysicsActivated = t
            }, i.prototype.disposePhysics = function() {
                var t = this.b2BodyList.length,
                    e = 0;
                if (t > 0)
                    for (e = 0; e < t; ++e) {
                        var i = this.b2BodyList[e];
                        i.SetActive(!1), this.b2World.DestroyBody(i)
                    }
                this.b2BodyList.length = 0
            }, i.prototype.initData = function() {
                e.prototype.initData.call(this), this.b2BodyList = [], this.startPosition = new Box2D.Common.Math.b2Vec2(t.tools.Convertor.w_to_ws(this.data.x), t.tools.Convertor.w_to_ws(this.data.y)), this.componentRotation = t.tools.Convertor.deg_to_rad(this.data.rotation), this.zoomId = t.tools.Convertor.getGameCameraZoomIdFromStr(this.data.settings.zoomId), this.zoomDuration = this.data.settings.duration, this.cameraOffset = new t.entities.GameCameraOffset, this.cameraOffset.BottomLimit = -1, this.data.settings.hasOwnProperty("bindingType") && (this.cameraOffset.Type = t.tools.Convertor.getCameraOffsetTypeFromStr(this.data.settings.bindingType), this.cameraOffset.ActiveFlag = !0, this.updateComponentCameraOffset())
            }, i.prototype.customDispose = function() {
                this.disposePhysics()
            }, i.prototype.resetData = function() {
                this.b2BodyList = null, this.isPhysicsActivated = !1, this.isInited = !1, this.startPosition = null, this.componentRotation = 0, this.gameCameraControllerRef = null, this.isTriggerActive = !1, this.zoomId = 0, this.zoomDuration = 0, this.cameraOffset = null, e.prototype.resetData.call(this)
            }, i
        }(t.game_objects.GameObject);
        e.GOCameraTrigger = i
    }(t.game_objects || (t.game_objects = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(e) {
        var i;
        ! function(t) {
            t[t.UNKNOWN = 0] = "UNKNOWN", t[t.ANGLE_A = 1] = "ANGLE_A", t[t.ANGLE_B = 2] = "ANGLE_B", t[t.RANDOM = 3] = "RANDOM"
        }(i || (i = {}));
        var s;
        ! function(t) {
            t[t.UNKNOWN = 0] = "UNKNOWN", t[t.ROTATE_LEFT = 1] = "ROTATE_LEFT", t[t.ROTATE_RIGHT = 2] = "ROTATE_RIGHT", t[t.STOP = 3] = "STOP", t[t.LOOP = 4] = "LOOP"
        }(s || (s = {}));
        var o;
        ! function(t) {
            t[t.UNKNOWN = 0] = "UNKNOWN", t[t.ROTATE_LEFT = 1] = "ROTATE_LEFT", t[t.ROTATE_RIGHT = 2] = "ROTATE_RIGHT", t[t.STOP = 3] = "STOP", t[t.WAIT = 4] = "WAIT"
        }(o || (o = {}));
        var n;
        ! function(t) {
            t[t.UNKNOWN = 0] = "UNKNOWN", t[t.ROTATING_LEFT = 1] = "ROTATING_LEFT", t[t.ROTATING_RIGHT = 2] = "ROTATING_RIGHT", t[t.WAITING = 3] = "WAITING", t[t.ANGLE_A = 4] = "ANGLE_A", t[t.ANGLE_B = 5] = "ANGLE_B"
        }(n || (n = {}));
        var a = function(e) {
            function a(i, s, o, n, a) {
                var r = e.call(this, i, s, o, t.types.GameObjectType.DOOR, n, a) || this;
                return r.init(), r
            }
            return __extends(a, e), a.prototype.startDefaultAction = function() {
                if (!this.isDisposed && this.isInited) {
                    var t = this.data.settings.defaultAction;
                    this.startComponentNewAction(this.getComponentActionFromStr(t))
                }
            }, a.prototype.startAction = function(t) {
                !this.isDisposed && this.isInited && this.startComponentNewAction(this.getComponentActionFromStr(t))
            }, a.prototype.setPositionXY = function(e, i) {
                !this.isDisposed && this.isInited && (this.startPosition.x = t.tools.Convertor.w_to_ws(e), this.startPosition.y = t.tools.Convertor.w_to_ws(i), this.updateComponentTranslation())
            }, a.prototype.updateLogic = function(t) {
                !this.isDisposed && this.isInited && this.checkComponentStateAtUpdate(t)
            }, a.prototype.updateGraphics = function(e) {
                !this.isDisposed && this.isInited && (this.checkComponentStateAtRender(), t.config.GameConfig.enableGraphics && this.updateGraphicsTranslation())
            }, a.prototype.activatePhysics = function() {
                this.isDisposed || !this.isInited || this.isPhysicsActivated || this.setPhysicsActiveState(!0)
            }, a.prototype.deactivatePhysics = function() {
                !this.isDisposed && this.isInited && this.isPhysicsActivated && this.setPhysicsActiveState(!1)
            }, a.prototype.init = function() {
                this.createPhysics(), this.createGraphics(), this.setComponentRotationFromStartUpState(this.componentStartUpState), this.updateComponentTranslation(), this.isInited = !0
            }, a.prototype.createPhysics = function() {
                var t = this.data.physics,
                    e = t.length,
                    i = 0;
                for (i = 0; i < e; ++i) this.createPhysicItem(t[i]);
                this.isPhysicsActivated = !0
            }, a.prototype.createPhysicItem = function(e) {
                var i = {};
                i.x = t.tools.Convertor.w_to_ws(e.x), i.y = t.tools.Convertor.w_to_ws(e.y), i.rot = t.tools.Convertor.deg_to_rad(e.rotation);
                var s = t.tools.Convertor.getGameObjectPhysicTypeFromStr(this.data.settings.physicType),
                    o = new t.types.GameObjectData;
                o.Type = t.types.GameObjectType.DOOR, o.PhysicType = s, o.MaterialType = t.tools.Convertor.getGameObjectMaterialTypeFromStr(this.data.settings.material), o.UserData1 = i;
                var n = new Box2D.Dynamics.b2BodyDef;
                n.type = Box2D.Dynamics.b2Body.b2_kinematicBody, n.userData = o, n.position.Set(i.x, i.y), n.angle = i.rot, n.allowSleep = !1;
                var a = this.b2World.CreateBody(n);
                a.SetActive(!1), e.hasOwnProperty("boxes") && this.createPhysicPartBoxes(e, a, o), e.hasOwnProperty("triangularPointsList") && this.createPhysicPartFromTriangularPointsList(e, a, o), a.ResetMassData(), a.SetActive(!0), this.b2BodyList.push(a)
            }, a.prototype.createPhysicPartBoxes = function(t, e, i) {
                var s = t.boxes,
                    o = s.length,
                    n = 0;
                for (n = 0; n < o; ++n) this.createPhysicPartBoxesItem(s[n], e, i)
            }, a.prototype.createPhysicPartFromTriangularPointsList = function(t, e, i) {
                var s = t.triangularPointsList,
                    o = 0;
                for (o = 0; o < s.length; o++) this.createPhysicPartFromTriangularPointsListItem(s[o], e, i)
            }, a.prototype.createPhysicPartBoxesItem = function(e, i, s) {
                var o = new t.types.GameObjectData;
                o.Type = s.Type, o.PhysicType = s.PhysicType, o.MaterialType = s.MaterialType, o.EntityCategory = t.types.EntityCategory.GAME_OBJECT, o.UserData2 = s.UserData2;
                var n = new Box2D.Collision.Shapes.b2PolygonShape;
                n.SetAsOrientedBox(t.tools.Convertor.w_to_ws(e.width / 2), t.tools.Convertor.w_to_ws(e.height / 2), new Box2D.Common.Math.b2Vec2(t.tools.Convertor.w_to_ws(e.x), t.tools.Convertor.w_to_ws(e.y)), t.tools.Convertor.deg_to_rad(e.rotation));
                var a = new Box2D.Dynamics.b2FixtureDef;
                a.density = this.data.settings.density, a.friction = this.data.settings.friction, a.restitution = this.data.settings.restitution, a.shape = n, a.filter.categoryBits = o.EntityCategory, a.filter.maskBits = t.types.EntityCategory.BIKE_WHEEL | t.types.EntityCategory.BIKE_BODY | t.types.EntityCategory.BIKE_AXLE | t.types.EntityCategory.GAME_OBJECT | t.types.EntityCategory.BIKE_BODY_SENSOR_HEAD, a.userData = o, i.CreateFixture(a)
            }, a.prototype.createPhysicPartFromTriangularPointsListItem = function(e, i, s) {
                var o = e,
                    n = o.length;
                if (!(n < 2)) {
                    var a = o[0],
                        r = o[n - 1],
                        h = n;
                    a.x === r.x && a.y === r.y && (h -= 1);
                    var l = new t.types.GameObjectData;
                    l.Type = s.Type, l.PhysicType = s.PhysicType, l.MaterialType = s.MaterialType, l.EntityCategory = t.types.EntityCategory.GAME_OBJECT;
                    var c = new Box2D.Dynamics.b2FixtureDef;
                    c.density = this.data.settings.density, c.friction = this.data.settings.friction, c.restitution = this.data.settings.restitution, c.userData = l, c.filter.categoryBits = l.EntityCategory, c.filter.maskBits = t.types.EntityCategory.BIKE_BODY | t.types.EntityCategory.BIKE_AXLE | t.types.EntityCategory.BIKE_WHEEL | t.types.EntityCategory.GAME_OBJECT | t.types.EntityCategory.BIKE_BODY_SENSOR_BODY | t.types.EntityCategory.BIKE_BODY_SENSOR_HEAD;
                    var p = 0,
                        u = [];
                    for (p = 0; p < h; p++) {
                        var d = o[p],
                            m = new poly2tri.Point(t.tools.Convertor.w_to_ws(d.x), t.tools.Convertor.w_to_ws(d.y));
                        u.push(m)
                    }
                    var y = new poly2tri.SweepContext(u);
                    y.triangulate();
                    var f = null,
                        g = null,
                        _ = null,
                        v = null,
                        b = y.getTriangles();
                    for (p = 0; p < b.length; p++) {
                        var x = b[p].getPoints();
                        f = new Box2D.Common.Math.b2Vec2(x[0].x, x[0].y), g = new Box2D.Common.Math.b2Vec2(x[1].x, x[1].y), _ = new Box2D.Common.Math.b2Vec2(x[2].x, x[2].y), (v = new Box2D.Collision.Shapes.b2PolygonShape).SetAsArray([f, g, _]), c.shape = v, i.CreateFixture(c)
                    }
                }
            }, a.prototype.createGraphics = function() {
                if (this.graphicsContainer = this.game.add.group(this.parentContainer), t.config.GameConfig.enableGraphics) {
                    var e = this.data.graphics,
                        i = 0;
                    for (i = 0; i < e.length; ++i) this.createGraphicItem(e[i])
                }
            }, a.prototype.createGraphicItem = function(t) {
                var e = t.parts,
                    i = 0,
                    s = this.game.add.group(this.graphicsContainer);
                for (s.position.set(t.x, t.y), s.angle = t.rotation, i = 0; i < e.length; i++) this.createGraphicItemPart(e[i], s)
            }, a.prototype.createGraphicItemPart = function(e, i) {
                var s = e.x,
                    o = e.y,
                    n = e.rotation,
                    a = e.atlasKey;
                this.game.add.image(s, o, t.settings.GameCommonSettings.getGameLevelStartUpAtlasKey(), a, i).angle = n
            }, a.prototype.updateComponentTranslation = function() {
                this.updatePhysicsTranslation(), t.config.GameConfig.enableGraphics && this.updateGraphicsTranslation()
            }, a.prototype.updatePhysicsTranslation = function() {
                var t = this.isPhysicsActivated;
                t && this.setPhysicsActiveState(!1);
                var e = this.b2BodyList.length,
                    i = 0;
                for (i = 0; i < e; ++i) {
                    var s = this.b2BodyList[i],
                        o = s.GetUserData().UserData1;
                    s.SetPosition(new Box2D.Common.Math.b2Vec2(this.startPosition.x + o.x, this.startPosition.y + o.y)), s.SetAngle(this.componentRotation + o.rot)
                }
                t && this.setPhysicsActiveState(!0)
            }, a.prototype.updateGraphicsTranslation = function() {
                var e, i = Math.min(this.b2BodyList.length, this.graphicsContainer.children.length);
                for (e = 0; e < i; ++e) {
                    var s = this.b2BodyList[e],
                        o = this.graphicsContainer.getChildAt(e),
                        n = s.GetPosition(),
                        a = s.GetAngle();
                    o.position.x = n.x * t.config.GameConfig.b2WorldScale, o.position.y = n.y * t.config.GameConfig.b2WorldScale, o.rotation = a
                }
            }, a.prototype.checkComponentStateAtUpdate = function(t) {
                this.componentActionRestartingFlag || this.componentActionStopFlag || this.componentNextActionStartedFlag && this.componentProcessState === n.WAITING && this.checkComponentStateWaiting(t)
            }, a.prototype.checkComponentStateAtRender = function() {
                this.componentActionRestartingFlag || this.componentActionStopFlag || (this.componentNextActionStartedFlag ? this.componentProcessState === n.ROTATING_LEFT ? this.checkComponentStateRotatingLeft() : this.componentProcessState === n.ROTATING_RIGHT && this.checkComponentStateRotatingRight() : this.componentNextActionStartingFlag || (this.componentNextActionStartingFlag = !0, this.startComponentNextAction()))
            }, a.prototype.checkComponentStateWaiting = function(t) {
                this.componentWaitTime += t, this.componentWaitTime >= this.componentInStateWaitingTime && (this.componentNextActionStartedFlag = !1)
            }, a.prototype.checkComponentStateRotatingLeft = function() {
                var t = this.b2BodyList.length,
                    e = 0,
                    i = !1;
                for (e = 0; e < t; ++e)
                    if (this.b2BodyList[e].GetAngle() <= this.componentAngleA) {
                        i = !0;
                        break
                    }
                i && (this.setComponentAngularVelocity(0), this.setComponentAtAngle(this.componentAngleA), this.componentNextActionStartedFlag = !1)
            }, a.prototype.checkComponentStateRotatingRight = function() {
                var t = this.b2BodyList.length,
                    e = 0,
                    i = !1;
                for (e = 0; e < t; ++e)
                    if (this.b2BodyList[e].GetAngle() >= this.componentAngleB) {
                        i = !0;
                        break
                    }
                i && (this.setComponentAngularVelocity(0), this.setComponentAtAngle(this.componentAngleB), this.componentNextActionStartedFlag = !1)
            }, a.prototype.startComponentNewAction = function(t) {
                this.componentActionRestartingFlag = !0, this.stopComponentAction(), this.resetComponentProcessActionsList(), this.setComponentProcessActionsListFromAction(t), this.componentActionStopFlag = !1, this.componentActionRestartingFlag = !1
            }, a.prototype.startComponentNextAction = function() {
                var t = this.componentProcessActionsListIndex,
                    e = this.componentProcessActionsList[t];
                this.componentProcessActionsListIndex += 1, this.componentProcessActionsListIndex >= this.componentProcessActionsList.length && (this.componentProcessActionsListIndex = 0), this.startComponentAction(e) ? (this.componentNextActionStartingFlag = !1, this.componentNextActionStartedFlag = !0) : (this.componentNextActionStartingFlag = !1, this.componentActionStopFlag = !0)
            }, a.prototype.startComponentAction = function(t) {
                var e = !0;
                return t === o.ROTATE_LEFT ? this.setComponentStateRotatingLeft() : t === o.WAIT ? this.setComponentStateWaiting() : t === o.ROTATE_RIGHT ? this.setComponentStateRotatingRight() : t === o.STOP ? this.setComponentStateStop() : e = !1, e
            }, a.prototype.stopComponentAction = function() {
                this.componentActionStopFlag = !0, this.setComponentAngularVelocity(0)
            }, a.prototype.getComponentStartUpStateFromStr = function(t) {
                return "angleA" === t ? i.ANGLE_A : "angleB" === t ? i.ANGLE_B : "random" === t ? i.RANDOM : i.UNKNOWN
            }, a.prototype.getComponentActionFromStr = function(t) {
                return "rotate_left" === t ? s.ROTATE_LEFT : "rotate_right" === t ? s.ROTATE_RIGHT : "loop" === t ? s.LOOP : "stop" === t ? s.STOP : s.UNKNOWN
            }, a.prototype.setComponentStateRotatingLeft = function() {
                this.componentProcessState = n.ROTATING_LEFT, this.soundManager.playSound(Sounds.Turn), this.setComponentAngularVelocity(-this.componentAngularVelocity)
            }, a.prototype.setComponentStateRotatingRight = function() {
                this.componentProcessState = n.ROTATING_RIGHT, this.soundManager.playSound(Sounds.Turn), this.setComponentAngularVelocity(this.componentAngularVelocity)
            }, a.prototype.setComponentStateWaiting = function() {
                this.componentWaitTime = 0, this.componentProcessState = n.WAITING
            }, a.prototype.setComponentStateStop = function() {
                this.stopComponentAction(), this.componentProcessState = n.UNKNOWN, this.componentNextActionStartedFlag = !1, this.componentNextActionStartingFlag = !1
            }, a.prototype.setComponentRotationFromStartUpState = function(t) {
                t === i.ANGLE_A ? this.componentRotation = this.componentAngleA : t === i.ANGLE_B && (this.componentRotation = this.componentAngleB)
            }, a.prototype.setComponentAngularVelocity = function(t) {
                var e = this.b2BodyList.length,
                    i = 0;
                for (i = 0; i < e; ++i) this.b2BodyList[i].SetAngularVelocity(t)
            }, a.prototype.setComponentAtAngle = function(t) {
                var e = this.isPhysicsActivated;
                e && this.setPhysicsActiveState(!1);
                var i = this.b2BodyList.length,
                    s = 0;
                for (s = 0; s < i; ++s) {
                    var o = this.b2BodyList[s],
                        n = o.GetUserData().UserData1;
                    o.SetAngle(t + n.rot)
                }
                e && this.setPhysicsActiveState(!0)
            }, a.prototype.setComponentProcessActionsListFromAction = function(t) {
                t === s.LOOP ? (this.componentProcessActionsList.push(o.ROTATE_LEFT), this.componentProcessActionsList.push(o.WAIT), this.componentProcessActionsList.push(o.ROTATE_RIGHT), this.componentProcessActionsList.push(o.WAIT)) : t === s.ROTATE_LEFT ? (this.componentProcessActionsList.push(o.ROTATE_LEFT), this.componentProcessActionsList.push(o.STOP)) : t === s.ROTATE_RIGHT ? (this.componentProcessActionsList.push(o.ROTATE_RIGHT), this.componentProcessActionsList.push(o.STOP)) : t === s.STOP && this.componentProcessActionsList.push(o.STOP)
            }, a.prototype.setPhysicsActiveState = function(t) {
                var e = this.b2BodyList.length,
                    i = 0;
                for (i = 0; i < e; ++i) this.b2BodyList[i].SetActive(t);
                this.isPhysicsActivated = t
            }, a.prototype.resetComponentProcessActionsList = function() {
                this.componentProcessActionsList.length = 0, this.componentProcessActionsListIndex = 0
            }, a.prototype.disposePhysics = function() {
                var t = this.b2BodyList.length,
                    e = 0;
                if (t > 0)
                    for (e = 0; e < t; ++e) {
                        var i = this.b2BodyList[e];
                        i.SetActive(!1), this.b2World.DestroyBody(i)
                    }
                this.b2BodyList.length = 0
            }, a.prototype.disposeGraphics = function() {
                null != this.parentContainer && null != this.graphicsContainer && this.parentContainer.remove(this.graphicsContainer, !0, !0)
            }, a.prototype.initData = function() {
                e.prototype.initData.call(this), this.soundManager = BoilerPlate.SoundManager.getInstance(), this.b2BodyList = [], this.startPosition = new Box2D.Common.Math.b2Vec2(t.tools.Convertor.w_to_ws(this.data.x), t.tools.Convertor.w_to_ws(this.data.y)), this.componentRotation = t.tools.Convertor.deg_to_rad(this.data.rotation), this.componentAngularVelocity = t.tools.Convertor.deg_to_rad(this.data.settings.movingVelocity), this.componentInStateWaitingTime = this.data.settings.inStateWaitingTime, this.componentAngleA = t.tools.Convertor.deg_to_rad(this.data.angleA), this.componentAngleB = t.tools.Convertor.deg_to_rad(this.data.angleB), this.componentStartUpState = this.getComponentStartUpStateFromStr(this.data.settings.startUpState), this.componentProcessActionsList = [], this.componentActionStopFlag = !0
            }, a.prototype.customDispose = function() {
                this.disposePhysics(), this.disposeGraphics()
            }, a.prototype.resetData = function() {
                this.b2BodyList = null, this.isPhysicsActivated = !1, this.isInited = !1, this.graphicsContainer = null, this.startPosition = null, this.componentRotation = 0, this.componentAngularVelocity = 0, this.componentInStateWaitingTime = 0, this.componentAngleA = 0, this.componentAngleB = 0, this.componentStartUpState = 0, this.componentProcessActionsList = null, this.componentProcessActionsListIndex = 0, this.componentActionStopFlag = !1, this.componentActionRestartingFlag = !1, this.componentNextActionStartedFlag = !1, this.componentNextActionStartingFlag = !1, this.componentProcessState = 0, this.componentWaitTime = 0, this.soundManager = null, e.prototype.resetData.call(this)
            }, a
        }(t.game_objects.GameObject);
        e.GODoor = a
    }(t.game_objects || (t.game_objects = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(e) {
        var i;
        ! function(t) {
            t[t.UNKNOWN = 0] = "UNKNOWN", t[t.LEFT = 1] = "LEFT", t[t.RIGHT = 2] = "RIGHT"
        }(i || (i = {}));
        var s;
        ! function(t) {
            t[t.UNKNOWN = 0] = "UNKNOWN", t[t.MOVE_LEFT = 1] = "MOVE_LEFT", t[t.MOVE_RIGHT = 2] = "MOVE_RIGHT", t[t.STOP = 3] = "STOP", t[t.LOOP = 4] = "LOOP"
        }(s || (s = {}));
        var o;
        ! function(t) {
            t[t.UNKNOWN = 0] = "UNKNOWN", t[t.MOVE_LEFT = 1] = "MOVE_LEFT", t[t.MOVE_RIGHT = 2] = "MOVE_RIGHT", t[t.STOP = 3] = "STOP", t[t.WAIT = 4] = "WAIT"
        }(o || (o = {}));
        var n;
        ! function(t) {
            t[t.UNKNOWN = 0] = "UNKNOWN", t[t.MOVING_LEFT = 1] = "MOVING_LEFT", t[t.MOVING_RIGHT = 2] = "MOVING_RIGHT", t[t.WAITING = 3] = "WAITING"
        }(n || (n = {}));
        var a = function(e) {
            function a(i, s, o, n, a) {
                var r = e.call(this, i, s, o, t.types.GameObjectType.HORIZONTAL_LIFT, n, a) || this;
                return r.init(), r
            }
            return __extends(a, e), a.prototype.startDefaultAction = function() {
                if (!this.isDisposed && this.isInited) {
                    var t = this.data.settings.defaultAction;
                    this.startComponentNewAction(this.getComponentActionFromStr(t))
                }
            }, a.prototype.startAction = function(t) {
                !this.isDisposed && this.isInited && this.startComponentNewAction(this.getComponentActionFromStr(t))
            }, a.prototype.setPositionXY = function(e, i) {
                !this.isDisposed && this.isInited && (this.startPosition.x = t.tools.Convertor.w_to_ws(e), this.startPosition.y = t.tools.Convertor.w_to_ws(i), this.calcComponentLRStopPos(), this.updateComponentTranslation())
            }, a.prototype.updateLogic = function(t) {
                !this.isDisposed && this.isInited && this.checkComponentStateAtUpdate(t)
            }, a.prototype.updateGraphics = function(e) {
                !this.isDisposed && this.isInited && (this.checkComponentStateAtRender(), t.config.GameConfig.enableGraphics && this.updateGraphicsTranslation())
            }, a.prototype.activatePhysics = function() {
                this.isDisposed || !this.isInited || this.isPhysicsActivated || this.setPhysicsActiveState(!0)
            }, a.prototype.deactivatePhysics = function() {
                !this.isDisposed && this.isInited && this.isPhysicsActivated && this.setPhysicsActiveState(!1)
            }, a.prototype.init = function() {
                this.createPhysics(), this.createGraphics(), this.calcComponentLRStopPos(), this.setComponentStatePosition(this.componentStartUpState), this.updateComponentTranslation(), this.isInited = !0
            }, a.prototype.createPhysics = function() {
                var t = this.data.physics,
                    e = t.length,
                    i = 0;
                for (i = 0; i < e; ++i) this.createPhysicItem(t[i]);
                this.isPhysicsActivated = !0
            }, a.prototype.createPhysicItem = function(e) {
                var i = {};
                i.x = t.tools.Convertor.w_to_ws(e.x), i.y = t.tools.Convertor.w_to_ws(e.y), i.rot = t.tools.Convertor.deg_to_rad(e.rotation);
                var s = t.tools.Convertor.getGameObjectPhysicTypeFromStr(this.data.settings.physicType),
                    o = new t.types.GameObjectData;
                o.Type = t.types.GameObjectType.HORIZONTAL_LIFT, o.PhysicType = s, o.MaterialType = t.tools.Convertor.getGameObjectMaterialTypeFromStr(this.data.settings.material), o.UserData1 = i;
                var n = new Box2D.Dynamics.b2BodyDef;
                n.type = Box2D.Dynamics.b2Body.b2_kinematicBody, n.userData = o, n.position.Set(i.x, i.y), n.angle = i.rot, n.allowSleep = !1;
                var a = this.b2World.CreateBody(n);
                a.SetActive(!1), e.hasOwnProperty("boxes") && this.createPhysicPartBoxes(e, a, o), a.ResetMassData(), a.SetActive(!0), this.b2BodyList.push(a)
            }, a.prototype.createPhysicPartBoxes = function(t, e, i) {
                var s = t.boxes,
                    o = s.length,
                    n = 0;
                for (n = 0; n < o; ++n) this.createPhysicPartBoxesItem(s[n], e, i)
            }, a.prototype.createPhysicPartBoxesItem = function(e, i, s) {
                var o = new t.types.GameObjectData;
                o.Type = s.Type, o.PhysicType = s.PhysicType, o.MaterialType = s.MaterialType, o.EntityCategory = t.types.EntityCategory.GAME_OBJECT, o.UserData2 = s.UserData2;
                var n = new Box2D.Collision.Shapes.b2PolygonShape;
                n.SetAsOrientedBox(t.tools.Convertor.w_to_ws(e.width / 2), t.tools.Convertor.w_to_ws(e.height / 2), new Box2D.Common.Math.b2Vec2(t.tools.Convertor.w_to_ws(e.x), t.tools.Convertor.w_to_ws(e.y)), t.tools.Convertor.deg_to_rad(e.rotation));
                var a = new Box2D.Dynamics.b2FixtureDef;
                a.density = this.data.settings.density, a.friction = this.data.settings.friction, a.restitution = this.data.settings.restitution, a.shape = n, a.filter.categoryBits = o.EntityCategory, a.filter.maskBits = t.types.EntityCategory.BIKE_WHEEL | t.types.EntityCategory.BIKE_BODY | t.types.EntityCategory.BIKE_AXLE | t.types.EntityCategory.GAME_OBJECT | t.types.EntityCategory.BIKE_BODY_SENSOR_HEAD, a.userData = o, i.CreateFixture(a)
            }, a.prototype.createGraphics = function() {
                if (this.graphicsContainer = this.game.add.group(this.parentContainer), t.config.GameConfig.enableGraphics) {
                    var e = this.data.graphics,
                        i = 0;
                    for (i = 0; i < e.length; ++i) this.createGraphicItem(e[i])
                }
            }, a.prototype.createGraphicItem = function(t) {
                var e = t.parts,
                    i = 0,
                    s = this.game.add.group(this.graphicsContainer);
                for (s.position.set(t.x, t.y), s.angle = t.rotation, i = 0; i < e.length; i++) this.createGraphicItemPart(e[i], s)
            }, a.prototype.createGraphicItemPart = function(e, i) {
                var s = e.x,
                    o = e.y,
                    n = e.rotation,
                    a = e.atlasKey;
                this.game.add.image(s, o, t.settings.GameCommonSettings.getGameLevelStartUpAtlasKey(), a, i).angle = n
            }, a.prototype.updateComponentTranslation = function() {
                this.updatePhysicsTranslation(), t.config.GameConfig.enableGraphics && this.updateGraphicsTranslation()
            }, a.prototype.updatePhysicsTranslation = function() {
                var t = this.isPhysicsActivated;
                t && this.setPhysicsActiveState(!1);
                var e = this.b2BodyList.length,
                    i = 0;
                for (i = 0; i < e; ++i) {
                    var s = this.b2BodyList[i],
                        o = s.GetUserData().UserData1;
                    s.SetPosition(new Box2D.Common.Math.b2Vec2(this.startPosition.x + this.statePosition.x + o.x, this.startPosition.y + this.statePosition.y + o.y)), s.SetAngle(this.componentRotation + o.rot)
                }
                t && this.setPhysicsActiveState(!0)
            }, a.prototype.updateGraphicsTranslation = function() {
                var e, i = Math.min(this.b2BodyList.length, this.graphicsContainer.children.length);
                for (e = 0; e < i; ++e) {
                    var s = this.b2BodyList[e],
                        o = this.graphicsContainer.getChildAt(e),
                        n = s.GetPosition(),
                        a = s.GetAngle();
                    o.position.x = n.x * t.config.GameConfig.b2WorldScale, o.position.y = n.y * t.config.GameConfig.b2WorldScale, o.rotation = a
                }
            }, a.prototype.checkComponentStateAtUpdate = function(t) {
                this.componentActionRestartingFlag || this.componentActionStopFlag || this.componentNextActionStartedFlag && this.componentProcessState === n.WAITING && this.checkComponentStateWaiting(t)
            }, a.prototype.checkComponentStateAtRender = function() {
                this.componentActionRestartingFlag || this.componentActionStopFlag || (this.componentNextActionStartedFlag ? this.componentProcessState === n.MOVING_LEFT ? this.checkComponentStateMovingLeft() : this.componentProcessState === n.MOVING_RIGHT && this.checkComponentStateMovingRight() : this.componentNextActionStartingFlag || (this.componentNextActionStartingFlag = !0, this.startComponentNextAction()))
            }, a.prototype.checkComponentStateWaiting = function(t) {
                this.componentWaitTime += t, this.componentWaitTime >= this.componentInStateWaitingTime && (this.componentNextActionStartedFlag = !1)
            }, a.prototype.checkComponentStateMovingLeft = function() {
                var t = this.b2BodyList.length,
                    e = 0,
                    i = !1;
                for (e = 0; e < t; ++e)
                    if (this.b2BodyList[e].GetPosition().x <= this.componentLeftStopPos.x) {
                        i = !0;
                        break
                    }
                i && (this.setComponentMovingVelocity(0), this.setComponentAtPosition(this.componentLeftStopPos), this.componentNextActionStartedFlag = !1)
            }, a.prototype.checkComponentStateMovingRight = function() {
                var t = this.b2BodyList.length,
                    e = 0,
                    i = !1;
                for (e = 0; e < t; ++e)
                    if (this.b2BodyList[e].GetPosition().x >= this.componentRightStopPos.x) {
                        i = !0;
                        break
                    }
                i && (this.setComponentMovingVelocity(0), this.setComponentAtPosition(this.componentRightStopPos), this.componentNextActionStartedFlag = !1)
            }, a.prototype.startComponentNewAction = function(t) {
                this.componentActionRestartingFlag = !0, this.stopComponentAction(), this.resetComponentProcessActionsList(), this.setComponentProcessActionsListFromAction(t), this.componentActionStopFlag = !1, this.componentActionRestartingFlag = !1
            }, a.prototype.startComponentNextAction = function() {
                var t = this.componentProcessActionsListIndex,
                    e = this.componentProcessActionsList[t];
                this.componentProcessActionsListIndex += 1, this.componentProcessActionsListIndex >= this.componentProcessActionsList.length && (this.componentProcessActionsListIndex = 0), this.startComponentAction(e) ? (this.componentNextActionStartingFlag = !1, this.componentNextActionStartedFlag = !0) : (this.componentNextActionStartingFlag = !1, this.componentActionStopFlag = !0)
            }, a.prototype.startComponentAction = function(t) {
                var e = !0;
                return t === o.MOVE_LEFT ? this.setComponentStateMovingLeft() : t === o.WAIT ? this.setComponentStateWaiting() : t === o.MOVE_RIGHT ? this.setComponentStateMovingRight() : t === o.STOP ? this.setComponentStateStop() : e = !1, e
            }, a.prototype.stopComponentAction = function() {
                this.componentActionStopFlag = !0, this.setComponentMovingVelocity(0)
            }, a.prototype.getComponentStartUpStateFromStr = function(t) {
                return "left" === t ? i.LEFT : "right" === t ? i.RIGHT : i.UNKNOWN
            }, a.prototype.getComponentActionFromStr = function(t) {
                return "move_left" === t ? s.MOVE_LEFT : "move_right" === t ? s.MOVE_RIGHT : "loop" === t ? s.LOOP : "stop" === t ? s.STOP : s.UNKNOWN
            }, a.prototype.setComponentStateMovingLeft = function() {
                this.componentProcessState = n.MOVING_LEFT, this.setComponentMovingVelocity(-this.componentMovingVelocity.x)
            }, a.prototype.setComponentStateMovingRight = function() {
                this.componentProcessState = n.MOVING_RIGHT, this.setComponentMovingVelocity(this.componentMovingVelocity.x)
            }, a.prototype.setComponentStateWaiting = function() {
                this.componentWaitTime = 0, this.componentProcessState = n.WAITING
            }, a.prototype.setComponentStateStop = function() {
                this.stopComponentAction(), this.componentProcessState = n.UNKNOWN, this.componentNextActionStartedFlag = !1, this.componentNextActionStartingFlag = !1
            }, a.prototype.setComponentMovingVelocity = function(t) {
                var e = this.b2BodyList.length,
                    i = 0;
                for (this.moveVelocity.x = t, i = 0; i < e; ++i) this.b2BodyList[i].SetLinearVelocity(this.moveVelocity)
            }, a.prototype.setComponentStatePosition = function(t) {
                t === i.LEFT ? (this.statePosition.x = this.componentLeftStop.x, this.statePosition.y = this.componentLeftStop.y) : t === i.RIGHT ? (this.statePosition.x = this.componentRightStop.x, this.statePosition.y = this.componentRightStop.y) : (this.statePosition.x = 0, this.statePosition.y = 0)
            }, a.prototype.setComponentAtPosition = function(t) {
                var e = this.isPhysicsActivated;
                e && this.setPhysicsActiveState(!1);
                var i = this.b2BodyList.length,
                    s = 0;
                for (s = 0; s < i; ++s) {
                    var o = this.b2BodyList[s],
                        n = o.GetUserData().UserData1;
                    o.SetPosition(new Box2D.Common.Math.b2Vec2(t.x + n.x, t.y + n.y))
                }
                e && this.setPhysicsActiveState(!0)
            }, a.prototype.setComponentProcessActionsListFromAction = function(t) {
                t === s.LOOP ? (this.componentProcessActionsList.push(o.MOVE_LEFT), this.componentProcessActionsList.push(o.WAIT), this.componentProcessActionsList.push(o.MOVE_RIGHT), this.componentProcessActionsList.push(o.WAIT)) : t === s.MOVE_LEFT ? (this.componentProcessActionsList.push(o.MOVE_LEFT), this.componentProcessActionsList.push(o.STOP)) : t === s.MOVE_RIGHT ? (this.componentProcessActionsList.push(o.MOVE_RIGHT), this.componentProcessActionsList.push(o.STOP)) : t === s.STOP && this.componentProcessActionsList.push(o.STOP)
            }, a.prototype.setPhysicsActiveState = function(t) {
                var e = this.b2BodyList.length,
                    i = 0;
                for (i = 0; i < e; ++i) this.b2BodyList[i].SetActive(t);
                this.isPhysicsActivated = t
            }, a.prototype.calcComponentLRStopPos = function() {
                this.componentLeftStopPos.x = this.startPosition.x + this.componentLeftStop.x, this.componentLeftStopPos.y = this.startPosition.y + this.componentLeftStop.y, this.componentRightStopPos.x = this.startPosition.x + this.componentRightStop.x, this.componentRightStopPos.y = this.startPosition.y + this.componentRightStop.y
            }, a.prototype.resetComponentProcessActionsList = function() {
                this.componentProcessActionsList.length = 0, this.componentProcessActionsListIndex = 0
            }, a.prototype.disposePhysics = function() {
                var t = this.b2BodyList.length,
                    e = 0;
                if (t > 0)
                    for (e = 0; e < t; ++e) {
                        var i = this.b2BodyList[e];
                        i.SetActive(!1), this.b2World.DestroyBody(i)
                    }
                this.b2BodyList.length = 0
            }, a.prototype.disposeGraphics = function() {
                null != this.parentContainer && null != this.graphicsContainer && this.parentContainer.remove(this.graphicsContainer, !0, !0)
            }, a.prototype.initData = function() {
                e.prototype.initData.call(this), this.b2BodyList = [], this.startPosition = new Box2D.Common.Math.b2Vec2(t.tools.Convertor.w_to_ws(this.data.x), t.tools.Convertor.w_to_ws(this.data.y)), this.statePosition = new Box2D.Common.Math.b2Vec2(0, 0), this.componentRotation = t.tools.Convertor.deg_to_rad(this.data.rotation), this.componentLeftStop = new Box2D.Common.Math.b2Vec2(t.tools.Convertor.w_to_ws(this.data.states.left.x), t.tools.Convertor.w_to_ws(this.data.states.left.y)), this.componentRightStop = new Box2D.Common.Math.b2Vec2(t.tools.Convertor.w_to_ws(this.data.states.right.x), t.tools.Convertor.w_to_ws(this.data.states.right.y)), this.componentLeftStopPos = new Box2D.Common.Math.b2Vec2(0, 0), this.componentRightStopPos = new Box2D.Common.Math.b2Vec2(0, 0), this.componentMovingVelocity = new Box2D.Common.Math.b2Vec2(t.tools.Convertor.w_to_ws(this.data.settings.movingVelocity), 0), this.componentInStateWaitingTime = this.data.settings.inStateWaitingTime, this.componentStartUpState = this.getComponentStartUpStateFromStr(this.data.settings.startUpState), this.componentProcessActionsList = [], this.moveVelocity = new Box2D.Common.Math.b2Vec2(0, 0), this.componentActionStopFlag = !0
            }, a.prototype.customDispose = function() {
                this.disposePhysics(), this.disposeGraphics()
            }, a.prototype.resetData = function() {
                this.b2BodyList = null, this.isPhysicsActivated = !1, this.isInited = !1, this.graphicsContainer = null, this.startPosition = null, this.statePosition = null, this.componentRotation = 0, this.componentLeftStop = null, this.componentRightStop = null, this.componentLeftStopPos = null, this.componentRightStopPos = null, this.componentMovingVelocity = null, this.componentInStateWaitingTime = 0, this.componentStartUpState = 0, this.componentProcessActionsList = null, this.componentProcessActionsListIndex = 0, this.componentActionStopFlag = !1, this.componentActionRestartingFlag = !1, this.componentNextActionStartedFlag = !1, this.componentNextActionStartingFlag = !1, this.componentProcessState = 0, this.componentWaitTime = 0, this.moveVelocity = null, e.prototype.resetData.call(this)
            }, a
        }(t.game_objects.GameObject);
        e.GOHorizontalLift = a
    }(t.game_objects || (t.game_objects = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(e) {
        var i = function() {
            function e() {}
            return e.createGameObject = function(e, i, s, o, n, a, r) {
                return o === t.types.GameObjectType.CHECK_POINT ? new t.game_objects.GOCheckPoint(e, i, s, n, a, r) : o === t.types.GameObjectType.STICK ? new t.game_objects.GOStick(e, i, s, n, a) : o === t.types.GameObjectType.CIRCLE ? new t.game_objects.GOCircle(e, i, s, n, a) : o === t.types.GameObjectType.VERTICAL_LIFT ? new t.game_objects.GOVerticalLift(e, i, s, n, a) : o === t.types.GameObjectType.TRIGGER ? new t.game_objects.GOTrigger(e, i, s, n, a) : o === t.types.GameObjectType.MULTI_TRIGGER ? new t.game_objects.GOMultiTrigger(e, i, s, n, a) : o === t.types.GameObjectType.ROTATING_OBJECT ? new t.game_objects.GORotatingObject(e, i, s, n, a) : o === t.types.GameObjectType.DESTRUCTIBLE_OBJECT ? new t.game_objects.GODestructibleObject(e, i, s, n, a) : o === t.types.GameObjectType.SURFACE_OBJECT ? new t.game_objects.GOSurfaceObject(e, i, s, n, a) : o === t.types.GameObjectType.PISTON ? new t.game_objects.GOPiston(e, i, s, n, a) : o === t.types.GameObjectType.BOMB ? new t.game_objects.GOBomb(e, i, s, n, a, r) : o === t.types.GameObjectType.ACTION_AREA ? new t.game_objects.GOActionArea(e, i, s, n, a) : o === t.types.GameObjectType.FINISH_ZONE ? new t.game_objects.GOFinishZone(e, i, s, n, a) : o === t.types.GameObjectType.CAMERA_TRIGGER ? new t.game_objects.GOCameraTrigger(e, i, s, n, a) : o === t.types.GameObjectType.DOOR ? new t.game_objects.GODoor(e, i, s, n, a) : o === t.types.GameObjectType.HORIZONTAL_LIFT ? new t.game_objects.GOHorizontalLift(e, i, s, n, a) : null
            }, e
        }();
        e.GameObjectFactory = i
    }(t.factories || (t.factories = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(e) {
        var i = function() {
            function e(t, e, i, s, o) {
                this.resetData(), this.game = e, this.b2World = i, this.parentContainer = t, this.gameSettings = s, this.gameAtlasKey = o, this.initData(), this.isDisposed = !1
            }
            return Object.defineProperty(e.prototype, "SignalOnGOAction", {
                get: function() {
                    return this.signalOnGOAction
                },
                enumerable: !0,
                configurable: !0
            }), e.prototype.createGameObject = function(e, i, s) {
                if (!this.isDisposed && e.hasOwnProperty("settings")) {
                    var o = e.settings,
                        n = t.tools.Convertor.getGameObjectTypeFromStr(o.type),
                        a = i + e.x,
                        r = s + e.y,
                        h = t.factories.GameObjectFactory.createGameObject(this.game, this.b2World, this.parentContainer, n, e, this.gameSettings, this.gameAtlasKey);
                    null != h && (h.setRotation(e.rotation), h.setPositionXY(a, r), h.SignalOnAction.add(this.onGOAction, this), this.gameObjectsList.push(h))
                }
            }, e.prototype.addTriggerAction = function(t, e) {
                if (!this.isDisposed && this.isInited) {
                    var i = {};
                    i.id = t, i.action = e, this.triggerActionsList.push(i)
                }
            }, e.prototype.updateLogic = function(t) {
                if (!this.isDisposed && this.isInited) {
                    var e = 0;
                    for (e = 0; e < this.gameObjectsList.length; e++) {
                        var i = this.gameObjectsList[e];
                        i.Type;
                        i.updateLogic(t)
                    }
                    this.processTriggerActionsList()
                }
            }, e.prototype.updateGraphics = function(t) {
                if (!this.isDisposed && this.isInited) {
                    var e = 0;
                    for (e = 0; e < this.gameObjectsList.length; e++) {
                        var i = this.gameObjectsList[e];
                        i.Type;
                        i.updateGraphics(t)
                    }
                }
            }, e.prototype.init = function() {
                if (!this.isDisposed && !this.isInited) {
                    var t = 0;
                    for (t = 0; t < this.gameObjectsList.length; t++) this.gameObjectsList[t].startDefaultAction();
                    this.isInited = !0
                }
            }, e.prototype.dispose = function() {
                this.isDisposed || (this.disposeTriggerActionsList(), this.disposeGameObjects(), this.disposeSignals(), this.resetData(), this.isDisposed = !0)
            }, e.prototype.initData = function() {
                this.signalOnGOAction = new Phaser.Signal, this.gameObjectsList = [], this.triggerActionsList = []
            }, e.prototype.processTriggerActionsList = function() {
                var t = [],
                    e = 0;
                for (e = 0; e < this.triggerActionsList.length; e++) this.processTriggerActionItem(this.triggerActionsList[e]) && t.push(e);
                for (e = 0; e < t.length; e++) {
                    var i = t[e];
                    this.triggerActionsList.splice(i, 1)
                }
            }, e.prototype.processTriggerActionItem = function(t) {
                var e = this.findGameObjectWithId(t.id);
                return null != e && (e.startAction(t.action), !0)
            }, e.prototype.findGameObjectWithId = function(t) {
                var e = null,
                    i = 0;
                for (i = 0; i < this.gameObjectsList.length; i++) {
                    var s = this.gameObjectsList[i];
                    if (s.Id === t) {
                        e = s;
                        break
                    }
                }
                return e
            }, e.prototype.disposeTriggerActionsList = function() {
                if (null !== this.triggerActionsList) {
                    var t = 0;
                    for (t = 0; t < this.triggerActionsList.length; t++) this.triggerActionsList[t] = null;
                    this.triggerActionsList.length = 0
                }
            }, e.prototype.disposeGameObjects = function() {
                if (null !== this.gameObjectsList) {
                    var t = 0;
                    for (t = 0; t < this.gameObjectsList.length; t++) this.gameObjectsList[t].IsDisposed || (this.gameObjectsList[t].SignalOnAction.removeAll(), this.gameObjectsList[t].dispose());
                    this.gameObjectsList.length = 0
                }
            }, e.prototype.disposeSignals = function() {
                null !== this.signalOnGOAction && this.signalOnGOAction.removeAll()
            }, e.prototype.resetData = function() {
                this.game = null, this.b2World = null, this.gameSettings = null, this.parentContainer = null, this.isInited = !1, this.signalOnGOAction = null, this.gameObjectsList = null, this.triggerActionsList = null, this.gameAtlasKey = null
            }, e.prototype.onGOAction = function(t) {
                this.signalOnGOAction.dispatch(t)
            }, e
        }();
        e.GameObjectsController = i
    }(t.controllers || (t.controllers = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(e) {
        var i = function(e) {
            function i() {
                var t = e.call(this) || this;
                return t.resetData(), t.initData(), t
            }
            return __extends(i, e), Object.defineProperty(i.prototype, "OnBikeWithGameObjectBeginContact", {
                get: function() {
                    return this.onBikeWithGameObjectBeginContact
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(i.prototype, "OnBikeWithGameObjectEndContact", {
                get: function() {
                    return this.onBikeWithGameObjectEndContact
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(i.prototype, "OnBikeWithGroundBeginContact", {
                get: function() {
                    return this.onBikeWithGroundBeginContact
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(i.prototype, "OnBikeWithGroundEndContact", {
                get: function() {
                    return this.onBikeWithGroundEndContact
                },
                enumerable: !0,
                configurable: !0
            }), i.prototype.BeginContact = function(e) {
                var i = t.tools.Convertor.getGameObjectDataFromData(e.GetFixtureA().GetUserData()),
                    s = t.tools.Convertor.getGameObjectDataFromData(e.GetFixtureB().GetUserData());
                this.checkBikeWithGroundBeginContact(e, i, s), this.checkBikeWithGameObjectBeginContact(e, i, s)
            }, i.prototype.EndContact = function(e) {
                var i = t.tools.Convertor.getGameObjectDataFromData(e.GetFixtureA().GetUserData()),
                    s = t.tools.Convertor.getGameObjectDataFromData(e.GetFixtureB().GetUserData());
                this.checkBikeWithGroundEndContact(e, i, s), this.checkBikeWithGameObjectEndContact(e, i, s)
            }, i.prototype.initData = function() {
                this.onBikeWithGameObjectBeginContact = new Phaser.Signal, this.onBikeWithGameObjectEndContact = new Phaser.Signal, this.onBikeWithGroundBeginContact = new Phaser.Signal, this.onBikeWithGroundEndContact = new Phaser.Signal
            }, i.prototype.checkBikeWithGroundBeginContact = function(t, e, i) {
                this.checkBikeWithGroundContact(t, e, i, 0)
            }, i.prototype.checkBikeWithGameObjectBeginContact = function(t, e, i) {
                this.checkBikeWithGameObjectContact(t, e, i, 0)
            }, i.prototype.checkBikeWithGroundEndContact = function(t, e, i) {
                this.checkBikeWithGroundContact(t, e, i, 1)
            }, i.prototype.checkBikeWithGameObjectEndContact = function(t, e, i) {
                this.checkBikeWithGameObjectContact(t, e, i, 1)
            }, i.prototype.checkBikeWithGroundContact = function(e, i, s, o) {
                var n = this.getBikeData(i, s),
                    a = this.getGroundData(i, s),
                    r = null;
                null != n && null != a && ((r = new t.types.Box2DContactListenerData).dataA = n, r.dataB = a, r.contact = e, 0 === o ? this.onBikeWithGroundBeginContact.dispatch(r) : 1 === o && this.onBikeWithGroundEndContact.dispatch(r))
            }, i.prototype.checkBikeWithGameObjectContact = function(e, i, s, o) {
                var n = this.getBikeData(i, s),
                    a = this.getGameObjectData(i, s),
                    r = null;
                null != n && null != a && ((r = new t.types.Box2DContactListenerData).dataA = n, r.dataB = a, r.contact = e, 0 === o ? this.onBikeWithGameObjectBeginContact.dispatch(r) : 1 === o && this.onBikeWithGameObjectEndContact.dispatch(r))
            }, i.prototype.getBikeData = function(e, i) {
                return this.checkGameObjectDataType(e, t.types.GameObjectType.BIKE) ? e : this.checkGameObjectDataType(i, t.types.GameObjectType.BIKE) ? i : null
            }, i.prototype.getGroundData = function(e, i) {
                return this.checkGameObjectDataType(e, t.types.GameObjectType.ROAD_SURFACE) ? e : this.checkGameObjectDataType(i, t.types.GameObjectType.ROAD_SURFACE) ? i : null
            }, i.prototype.getGameObjectData = function(e, i) {
                return this.checkGameObjectDataEntityCategory(e, t.types.EntityCategory.GAME_OBJECT) ? e : this.checkGameObjectDataEntityCategory(i, t.types.EntityCategory.GAME_OBJECT) ? i : null
            }, i.prototype.checkGameObjectDataType = function(t, e, i) {
                return void 0 === i && (i = !0), !(i && (!i || null == t) || e !== t.Type)
            }, i.prototype.checkGameObjectDataEntityCategory = function(t, e, i) {
                return void 0 === i && (i = !0), !(i && (!i || null == t) || e !== t.EntityCategory)
            }, i.prototype.resetData = function() {
                this.onBikeWithGameObjectBeginContact = null, this.onBikeWithGameObjectEndContact = null, this.onBikeWithGroundBeginContact = null, this.onBikeWithGroundEndContact = null
            }, i
        }(Box2D.Dynamics.b2ContactListener);
        e.Box2DContactListener = i
    }(t.listeners || (t.listeners = {}))
}(GameSrc || (GameSrc = {}));
var Images = function() {
        function t() {}
        return t.preloadList = [], t.list = [], t
    }(),
    GameSrc;
! function(t) {
    ! function(t) {
        var e = function() {
                function t(t) {
                    this.resetData(), this.name = t, this.initData()
                }
                return t.prototype.updateTimeStart = function(t) {
                    this.startMs = t, this.counter += 1
                }, t.prototype.updateTimeEnd = function(t) {
                    this.endMs = t;
                    var e = this.getTimeDiff();
                    this.calcMinMs(e), this.calcMaxMs(e), this.firstTime && (this.firstTime = !1)
                }, t.prototype.reportElapsedTime = function() {
                    this.calcMidMs();
                    var t = "Elapsed time for " + (null === this.name ? "<unknown>" : this.name) + ": min: " + this.minMs.toString() + " ms; max: " + this.maxMs.toString() + " ms; mid: " + this.midMs.toString();
                    console.log(t)
                }, t.prototype.reset = function() {
                    this.resetData(), this.initData()
                }, t.prototype.calcMinMs = function(t) {
                    this.firstTime ? this.minMs = t : t < this.minMs && (this.minMs = t)
                }, t.prototype.calcMaxMs = function(t) {
                    this.firstTime ? this.maxMs = t : t > this.maxMs && (this.maxMs = t)
                }, t.prototype.calcMidMs = function() {
                    this.midMs = Math.round((this.maxMs - this.minMs) / 2)
                }, t.prototype.getTimeDiff = function() {
                    return this.endMs - this.startMs
                }, t.prototype.initData = function() {
                    this.firstTime = !0
                }, t.prototype.resetData = function() {
                    this.minMs = 0, this.maxMs = 0, this.midMs = 0, this.startMs = 0, this.endMs = 0, this.counter = 0, this.firstTime = !1
                }, t
            }(),
            i = function() {
                function t() {
                    this.resetData(), this.initData()
                }
                return t.getInstance = function() {
                    return null === t.instance && (t.instance = new t), t.instance
                }, t.prototype.addKey = function(t) {
                    this.checkObject[t] = new e(t)
                }, t.prototype.updateTimeStart = function(t, e) {
                    this.checkObject[t].updateTimeStart(e)
                }, t.prototype.updateTimeEnd = function(t, e) {
                    this.checkObject[t].updateTimeEnd(e)
                }, t.prototype.reportElapsedTime = function(t) {
                    this.checkObject[t].reportElapsedTime()
                }, t.prototype.reset = function(t) {
                    this.checkObject[t].reset()
                }, t.prototype.initData = function() {
                    this.checkObject = {}
                }, t.prototype.resetData = function() {
                    this.checkObject = null
                }, t.instance = null, t
            }();
        t.ElapsedTimeMeter = i
    }(t.entities || (t.entities = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(e) {
        var i = function() {
            function i(t) {
                this.t_bike_cont = null, this.t_bike_graph = null, this.t_is_bike_points_drawn = !1, this.testLvPos = new Box2D.Common.Math.b2Vec2, this.cheatsCamPos = null, this.cheatsCamPosDeltaX = 10, this.cheatsCamPosDeltaY = 10, this.cheatsCamUserMoveFlag = !1, this.cheatsCamPosChangedFlag = !1, this.resetData(), this.isDisposed = !1, this.game = t, this.initData()
            }
            return i.prototype.startGame = function() {
                if (!this.gameStartedFlag) {
                    this.setGameSettings(), this.curLevelId = t.settings.GameCommonSettings.getLevelId(), this.createGameAtlasKeys(), this.createGameLayers(), this.createGameCamera(), this.createGameSky(), this.createGameBackGround(), this.createGUI(), this.createInputManager(), this.createPhysicsWorld(), this.createPhysicsDebugDraw(), this.createGameObjectsController(), this.createLevel(), this.createBike(), this.createCameraController(), this.initCameraController(), this.initGameObjectsController(), this.createBox2DContactListener(), this.registerSignalHandlers(), this.game.analytics.game.addEvent(new GA.Events.Progression("Start:Level" + this.curLevelId)), console.log("started level " + this.curLevelId + " sending to game analytics."), console.log("play advertisement if possible."), this.game.analytics.google.sendScreenView("advertisement"), this.gameTimerMS = 0, this.guiController.showGameLevel(this.curLevelId), this.guiController.resetGameTimer();
                    this.userProfile.getLevelStarsItemWithLevelId(this.curLevelId);
                    this.gameStartedFlag = !0, this.userProfile.GameState = t.types.GameStates.RESUMED, this.resize(), this.logGameState()
                }
            }, i.prototype.resize = function() {
                this.gameStartedFlag && this.userProfile.GameState !== t.types.GameStates.UNKNOWN && this.userProfile.GameState !== t.types.GameStates.EXIT && (t.config.GameConfig.calcGameScale = Phaser.Math.min(this.game.width / Constants.GAME_WIDTH, this.game.height / Constants.GAME_HEIGHT), this.resizeBgSky(), this.guiController.resize(), this.resizeBg())
            }, i.prototype.update = function(t) {
                this.gameStartedFlag && (this.checkUserInput(), this.checkGameExitState() || this.checkGameResetState() || this.checkGameStartNextLevelState() || this.checkGamePausedState() || this.checkGameFinishedState() || (this.checkGameResumedState(), this.isBikeMoved ? this.updateGameTimer(t) : (this.gameTimerMS = 0, this.updateGameTimer(0)), this.updatePhysicsWorld(t), this.checkInput(), this.bike.updateLogic(t), this.gameObjectsController.updateLogic(t), this.gameCameraController.render(this.bike.BikeBody.GetPosition(), t)))
            }, i.prototype.render = function(e) {
                !this.gameStartedFlag || this.isGameExitState() || this.isGameResetState() || this.isGameStartNextLevelState() || this.isGamePausedState() || this.isGameFinishedState() || this.userProfile.GameState === t.types.GameStates.RESUME_PREPARE || (this.guiController.showGameTimerFromMS(this.gameTimerMS), this.bike.updateGraphics(e), this.gameObjectsController.updateGraphics(e))
            }, i.prototype.renderPhysDebugDraw = function() {
                this.renderDebugDraw()
            }, i.prototype.dispose = function() {
                this.isDisposed || (this.disposeSignalHandlers(), this.cleanBox2DContactListener(), this.disposeFlipLabelsTweens(), this.disposeFlipLabels(), this.disposeGameObjectsController(), this.disposeBike(), this.disposeLevel(), this.disposeCameraController(), this.disposeBox2DContactListener(), null !== this.inputManager && this.inputManager.dispose(), null !== this.guiController && this.guiController.dispose(), null !== this.background && null !== this.background.parent && this.background.parent.removeChild(this.background), null !== this.backgroundLayer && this.backgroundLayer.removeAll(!0, !0), null !== this.levelLayer && this.levelLayer.removeAll(!0, !0), null !== this.guiLayer && this.guiLayer.removeAll(!0, !0), null !== this.gameCamera && this.gameCamera.dispose(), null !== this.scaleLayer && this.scaleLayer.removeAll(!0, !0), null !== this.staticLayer && this.staticLayer.removeAll(!0, !0), null !== this.mainLayer && this.mainLayer.removeAll(!0, !0), null !== this.b2World && this.b2World.SetDebugDraw(null), this.game.camera.reset(), this.resetData(), this.isDisposed = !0)
            }, i.prototype.initData = function() {
                this.isMobileDevice = t.config.GameConfig.isOnMobileDevice, this.isKeyboardEnabled = this.game.device.desktop && this.game.input.keyboard.enabled, this.gameSettings = t.settings.GameSettings.createFromJSON(this.game, t.settings.GameCommonSettings.getGameLevelStartUpDataKey()), this.userProfile = t.settings.UserProfileSettings.getInstance(), this.stateManager = t.managers.StateManager.getInstance(), this.appFocusManager = t.managers.AppFocusManager.getInstance(), this.saveManager = BoilerPlate.Save.Game.getInstance(), this.soundManager = BoilerPlate.SoundManager.getInstance()
            }, i.prototype.setGameSettings = function() {
                console.log("level size: " + this.gameSettings.worldBounds.width + "; " + this.gameSettings.worldBounds.height), console.log("player start popsition: " + this.gameSettings.playerStartPosition.x + "; " + this.gameSettings.playerStartPosition.y), console.log("context start offset: " + this.gameSettings.context2DStartPosition.x + "; " + this.gameSettings.context2DStartPosition.y)
            }, i.prototype.createGameLayers = function() {
                this.createMainLayer(), this.createStaticLayer(), this.createSkyLayer(), this.createGameBackGroundLayer(), this.createBottomLayer(), this.createScaleLayer(), this.createGameLevelLayer(), this.createGameGUILayer()
            }, i.prototype.createMainLayer = function() {
                this.mainLayer = this.game.add.group()
            }, i.prototype.createStaticLayer = function() {
                this.staticLayer = this.game.add.group(this.mainLayer)
            }, i.prototype.createBottomLayer = function() {
                this.bottomLayer = this.game.add.group(this.mainLayer)
            }, i.prototype.createScaleLayer = function() {
                this.scaleLayer = this.game.add.group(this.bottomLayer)
            }, i.prototype.createSkyLayer = function() {
                this.skyLayer = this.game.add.group(this.staticLayer)
            }, i.prototype.createGameBackGroundLayer = function() {
                this.backgroundLayer = this.game.add.group(this.staticLayer)
            }, i.prototype.createGameLevelLayer = function() {
                this.levelLayer = this.game.add.group(), this.scaleLayer2 = this.game.add.group(this.scaleLayer), this.scaleLayer2.addChild(this.levelLayer)
            }, i.prototype.createGameGUILayer = function() {
                this.guiLayer = this.game.add.group(this.mainLayer)
            }, i.prototype.createGameCamera = function() {
                this.gameCamera = new t.entities.GameCamera(this.game, this.levelLayer), this.gameCamera.setSettings(this.gameSettings)
            }, i.prototype.createGameSky = function() {
                this.bgSkyImage = this.game.add.image(0, 0, this.gameAtlasKey, "a_24_sky_agp_p10000", this.skyLayer)
            }, i.prototype.createGameAtlasKeys = function() {
                this.guiAtlasKey = Atlases.GUI_GENERAL;
                var e = t.settings.GameCommonSettings.getGameLevelStartUpBackgroundKey();
                "lv_bg_setting_1" === e ? (this.gameAtlasKey = Atlases.GUI_GAME_SET1, this.gameBgFrameKey = "a_42_lbgsu_agp_p10000") : "lv_bg_setting_2" === e ? (this.gameAtlasKey = Atlases.GUI_GAME_SET2, this.gameBgFrameKey = "a_43_lbgsp_agp_p10000") : "lv_bg_setting_3" === e && (this.gameAtlasKey = Atlases.GUI_GAME_SET3, this.gameBgFrameKey = "a_44_lbgwi_agp_p10000")
            }, i.prototype.createGameBackGround = function() {
                this.background = this.game.add.image(0, 0, this.gameAtlasKey, this.gameBgFrameKey, this.backgroundLayer)
            }, i.prototype.createGUI = function() {
                this.guiController = new t.controllers.GameGUIController(this.guiLayer, this.mainLayer, this.game, this.gameAtlasKey), this.guiController.OnGamePausedResumeGameSignal.add(this.onGamePausedResumeGame, this), this.guiController.OnGamePausedExitGameSignal.add(this.onGamePausedExitGame, this), this.guiController.OnGamePausedRestartLevelSignal.add(this.onGamePausedRestartLevel, this), this.guiController.OnGamePausedMusicOnSignal.add(this.onGamePausedMusicOn, this), this.guiController.OnGamePausedMusicOffSignal.add(this.onGamePausedMusicOff, this), this.guiController.OnGameFinishedExitGameSignal.add(this.onGameFinishedExitGame, this), this.guiController.OnGameFinishedRestartLevelSignal.add(this.onGameFinishedRestartLevel, this), this.guiController.OnGameFinishedNextLevelSignal.add(this.onGameFinishedNextLevel, this), this.guiController.init(), this.guiController.buttonPauseGame.Button.onInputUp.add(this.onGUIGamepadPause, this)
            }, i.prototype.createInputManager = function() {
                this.inputManager = new t.managers.InputManager(this.game), this.game.device.desktop || (this.inputManager.registerButtonKey(this.guiController.buttonTiltLeft.Button, t.types.UserInputKeys.TILT_BACK), this.inputManager.registerButtonKey(this.guiController.buttonTiltRight.Button, t.types.UserInputKeys.TILT_FORWARD), this.inputManager.registerButtonKey(this.guiController.buttonMoveLeft.Button, t.types.UserInputKeys.MOVE_BACK), this.inputManager.registerButtonKey(this.guiController.buttonMoveRight.Button, t.types.UserInputKeys.MOVE_FORWARD))
            }, i.prototype.createPhysicsWorld = function() {
                this.b2World = new Box2D.Dynamics.b2World(new Box2D.Common.Math.b2Vec2(0, t.config.GameConfig.verticalGravity), !0)
            }, i.prototype.createPhysicsDebugDraw = function() {
                if (!t.config.GameConfig.enableBox2DDebugDraw || this.game.renderType !== Phaser.CANVAS) {
                    var e = " of unknown reason.";
                    return t.config.GameConfig.enableBox2DDebugDraw ? this.game.renderType !== Phaser.CANVAS && (e = " of Phaser renderer type is not Canvas.") : e = " it is switched off in configuration file.", void console.log("The Debug Draw cannot be enabled because" + e)
                }
                this.b2DebugDraw = new Box2D.Dynamics.b2DebugDraw, this.b2DebugDraw.SetAlpha(0), this.b2DebugDraw.SetFillAlpha(.8), this.b2DebugDraw.SetFlags(Box2D.Dynamics.b2DebugDraw.e_shapeBit | Box2D.Dynamics.b2DebugDraw.e_jointBit), this.b2DebugDraw.SetSprite(this.game.canvas.getContext("2d")), this.b2DebugDraw.SetLineThickness(.01), this.b2DebugDraw.SetDrawScale(t.config.GameConfig.b2Scale), this.b2World.SetDebugDraw(this.b2DebugDraw), this.isB2DebugDrawEnabled = !0
            }, i.prototype.createGameObjectsController = function() {
                this.gameObjectsController = new t.controllers.GameObjectsController(this.levelLayer, this.game, this.b2World, this.gameSettings, this.gameAtlasKey), this.gameObjectsController.SignalOnGOAction.add(this.onGameObjectAction, this)
            }, i.prototype.createLevel = function() {
                this.levelController = new t.controllers.LevelController(this.levelLayer, this.game, this.b2World, this.gameSettings), this.levelController.SignalOnGameObjectCreate.add(this.onLevelGameObjectCreate, this), this.levelController.init()
            }, i.prototype.createBike = function() {
                this.bike = new t.game_objects.Bike(this.game, this.b2World, this.levelLayer, new Phaser.Point(this.gameSettings.playerStartPosition.x, this.gameSettings.playerStartPosition.y), this.gameAtlasKey), this.bike.OnBikeDeadSignal.add(this.onBikeDead, this), this.bike.OnBikeFlipSignal.add(this.onBikeFlip, this), this.bike.OnBikeFalloutSignal.add(this.onBikeFallout, this), this.bike.init();
                var e = this.bike.getCenterPosition();
                this.context2DStartX = t.tools.Convertor.ws_to_w(e.x), this.context2DStartY = t.tools.Convertor.ws_to_w(e.y)
            }, i.prototype.createBox2DContactListener = function() {
                this.b2ContactListener = new t.listeners.Box2DContactListener, this.b2ContactListener.OnBikeWithGameObjectBeginContact.add(this.onBikeWithGameObjectBeginContact, this), this.b2ContactListener.OnBikeWithGameObjectEndContact.add(this.onBikeWithGameObjectEndContact, this), this.b2ContactListener.OnBikeWithGroundBeginContact.add(this.onBikeWithGroundBeginContact, this), this.b2ContactListener.OnBikeWithGroundEndContact.add(this.onBikeWithGroundEndContact, this), this.b2World.SetContactListener(this.b2ContactListener)
            }, i.prototype.createCameraController = function() {
                this.gameCameraController = new e.GameCameraController(this.game)
            }, i.prototype.resizeBgSky = function() {
                this.bgSkyImage.x = -100, this.bgSkyImage.y = -100, this.bgSkyImage.width = this.game.width + 200, this.bgSkyImage.height = this.game.height + 200
            }, i.prototype.resizeBg = function() {
                this.backgroundLayer.scale.set(this.game.width / Constants.GAME_WIDTH), this.backgroundLayer.y = this.game.height - this.backgroundLayer.height, this.scaleLayer.scale.set(t.config.GameConfig.calcGameScale), this.scaleLayer.y = this.game.height - Constants.GAME_HEIGHT * t.config.GameConfig.calcGameScale
            }, i.prototype.initGameObjectsController = function() {
                this.gameObjectsController.init()
            }, i.prototype.initCameraController = function() {
                this.gameCameraController.setB2DebugDrawRef(this.b2DebugDraw), this.gameCameraController.setCameraRef(this.gameCamera), this.gameCameraController.init()
            }, i.prototype.registerSignalHandlers = function() {
                this.appFocusManager.OnFocusIn.add(this.onAppFocusIn, this), this.appFocusManager.OnFocusOut.add(this.onAppFocusOut, this)
            }, i.prototype.finishGame = function() {
                this.guiController.showGameTimerFromMS(this.gameTimerMS), this.blockGamePad(), this.game.analytics.game.addEvent(new GA.Events.Progression("Complete:Level" + this.curLevelId)), console.log("finished level " + this.curLevelId + " sending to game analytics"), this.guiController.buttonPauseGame.Button.inputEnabled = !1, this.guiController.buttonPauseGame.Button.visible = !1;
                var t = !1,
                    e = !1,
                    i = this.curLevelStarsItem.getStarsCountForTime(this.curLevelStarsItem.LevelPassedTime),
                    s = this.curLevelStarsItem.LastLevelPassedTime.clone();
                e = s.ActiveFlag, this.curLevelStarsItem.LevelPassedTime.ActiveFlag || (this.curLevelStarsItem.LevelPassedTime.ActiveFlag = !0), (!this.curLevelStarsItem.BestTime.ActiveFlag || this.curLevelStarsItem.BestTime.ActiveFlag && this.curLevelStarsItem.isLevelPassedTimeLessToBestTime()) && (this.curLevelStarsItem.BestTime.ActiveFlag && (t = !0), this.curLevelStarsItem.updateBestTimeToLevelPassedTime()), (!this.curLevelStarsItem.LastLevelPassedTime.ActiveFlag || this.curLevelStarsItem.LastLevelPassedTime.ActiveFlag && this.curLevelStarsItem.isLevelPassedTimeLessToLastLevelPassedTime()) && this.curLevelStarsItem.updateLastLevelPassedTime(), this.userProfile.saveData(), console.log("=======Finish========"), console.log("level id: " + this.curLevelId.toString()), console.log("level best time: " + this.curLevelStarsItem.BestTime.getTimeAsString()), console.log("to get 1 star time: " + this.curLevelStarsItem.StarsList[0].Time.getTimeAsString()), console.log("to get 2 stars time: " + this.curLevelStarsItem.StarsList[1].Time.getTimeAsString()), console.log("to get 3 stars time: " + this.curLevelStarsItem.StarsList[2].Time.getTimeAsString()), e && (console.log("player last level passed time: " + s.getTimeAsString()), console.log("player last level passed given stars: " + this.curLevelStarsItem.getStarsCountForTime(s).toString())), console.log("player level passed time: " + this.curLevelStarsItem.LevelPassedTime.getTimeAsString()), console.log("player level passed given stars: " + i.toString()), t && console.log("Congratulations! Player finished the level in less than best time!"), this.guiController.showGameFinishedWindow(this.curLevelId, i, [this.curLevelStarsItem.StarsList[0].Time.Seconds, this.curLevelStarsItem.StarsList[1].Time.Seconds, this.curLevelStarsItem.StarsList[2].Time.Seconds], t), this.soundManager.playSound(Sounds.FinishGame)
            }, i.prototype.pauseGame = function() {
                console.log("game paused"), this.blockGamePad(), this.guiController.showGamePausedWindow()
            }, i.prototype.resumeGame = function() {
                console.log("game resumed"), this.guiController.hideGamePausedWindow(), this.unblockGamePad()
            }, i.prototype.resetGame = function() {
                console.log("resetGame"), this.cleanBox2DContactListener(), this.disposeFlipLabelsTweens(), this.disposeFlipLabels(), this.resetFlipLabelsTweens(), this.resetFlipLabels(), this.disposeGameObjectsController(), this.disposeBike(), this.disposeLevel(), this.disposeBox2DContactListener(), this.inputManager.reset(), this.isFlipTweensStarted = !1, this.gameSettings.updatePlayerStartPosition(), this.game.camera.reset(), this.gameCameraController.reset(), this.createGameObjectsController(), this.createLevel(), this.createBike(), this.initGameObjectsController(), this.createBox2DContactListener(), this.userProfile.GameState = t.types.GameStates.RESUMED
            }, i.prototype.exitGame = function() {
                console.log("exitGame"), this.stateManager.switchToState(BoilerPlate.GameMap.Name)
            }, i.prototype.startNextLevel = function() {
                if (console.log("startNextLevel"), console.log("play advertisement if possible."), this.game.analytics.google.sendScreenView("advertisement"), this.curLevelId === this.userProfile.MaxLevels) this.stateManager.switchToState(BoilerPlate.GameMap.Name);
                else {
                    var e = this.curLevelId + 1;
                    t.settings.GameCommonSettings.setStartUpLevelData(e), this.game.state.start("gameplay")
                }
            }, i.prototype.blockGamePad = function() {
                this.setGamePadBlockedState(!1)
            }, i.prototype.unblockGamePad = function() {
                this.setGamePadBlockedState(!0)
            }, i.prototype.setGamePadBlockedState = function(t) {
                this.game.device.desktop || (this.guiController.buttonTiltLeft.Button.inputEnabled = t, this.guiController.buttonTiltRight.Button.inputEnabled = t, this.guiController.buttonMoveLeft.Button.inputEnabled = t, this.guiController.buttonMoveRight.Button.inputEnabled = t), this.guiController.buttonPauseGame.Button.inputEnabled = t
            }, i.prototype.updateGameTimer = function(t) {
                this.bike.isAlive() && (this.gameTimerMS += 1e3 * t)
            }, i.prototype.updatePhysicsWorld = function(t) {
                this.b2World.Step(t, 10, 10)
            }, i.prototype.updatePhysicsCamera = function() {
                if (this.isB2DebugDrawEnabled) {
                    var e = this.bike.getCenterPosition();
                    this.context2DOffsetX = t.tools.Convertor.b2s_to_w(e.x) - this.context2DStartX, this.context2DOffsetY = t.tools.Convertor.b2s_to_w(e.y) - this.context2DStartY
                }
            }, i.prototype.checkUserInput = function() {
                this.isKeyboardEnabled && (this.game.input.keyboard.isDown(Phaser.KeyCode.SPACEBAR) || this.game.input.keyboard.isDown(Phaser.KeyCode.ENTER)) && (this.userProfile.GameState === t.types.GameStates.FINISHED ? this.userProfile.GameState = t.types.GameStates.START_NEXT_LEVEL_PREPARE : this.bike.isAlive() || (this.userProfile.GameState = t.types.GameStates.RESET_PREPARE, "part1" === this.gameSettings.startPartName && (this.isBikeMoved = !1, this.gameTimerMS = 0, this.guiController.showGameTimerFromMS(this.gameTimerMS))))
            }, i.prototype.checkInput = function() {
                this.checkCheatsInput(), this.checkBikeMovementInput(), this.checkBikeTiltInput()
            }, i.prototype.checkCheatsInput = function() {
                this.checkCheatsGameInput()
            }, i.prototype.checkCheatsGameInput = function() {
                this.game.input.keyboard.enabled && t.config.GameConfig.enableGameCameraCheats && (!this.isGameResetState() && this.game.input.keyboard.isDown(Phaser.KeyCode.R) && (console.log("reset"), this.gameTimerMS = 0, this.gameSettings.startPartName = "part1", this.isBikeMoved = !1, this.userProfile.GameState = t.types.GameStates.RESET_PREPARE), !this.isGameExitState() && this.game.input.keyboard.isDown(Phaser.KeyCode.ESC) && (console.log("menu"), this.userProfile.GameState = t.types.GameStates.PAUSE_PREPARE), !this.isGameFinishedState() && this.game.input.keyboard.isDown(Phaser.KeyCode.M) && (console.log("test finished state"), null === this.curLevelStarsItem && (this.curLevelStarsItem = this.userProfile.getLevelStarsItemWithLevelId(this.curLevelId), this.curLevelStarsItem.LevelPassedTime.setValuesFromTotalMs(this.gameTimerMS)), this.userProfile.GameState = t.types.GameStates.FINISH_PREPARE))
            }, i.prototype.checkGameExitState = function() {
                return !!this.isGameExitState() && (this.userProfile.GameState === t.types.GameStates.EXIT_PREPARE && (this.userProfile.GameState = t.types.GameStates.EXIT, this.exitGame()), !0)
            }, i.prototype.checkGameResetState = function() {
                return !!this.isGameResetState() && (this.userProfile.GameState === t.types.GameStates.RESET_PREPARE && (this.userProfile.GameState = t.types.GameStates.RESET, this.resetGame()), !0)
            }, i.prototype.checkGamePausedState = function() {
                return !!this.isGamePausedState() && (this.userProfile.GameState === t.types.GameStates.PAUSE_PREPARE && (this.userProfile.GameState = t.types.GameStates.PAUSED, this.pauseGame()), !0)
            }, i.prototype.checkGameResumedState = function() {
                return !!this.isGameResumedState() && (this.userProfile.GameState === t.types.GameStates.RESUME_PREPARE && (this.resumeGame(), this.userProfile.GameState = t.types.GameStates.RESUMED), !0)
            }, i.prototype.checkGameFinishedState = function() {
                return !!this.isGameFinishedState() && (this.userProfile.GameState === t.types.GameStates.FINISH_PREPARE && (this.userProfile.GameState = t.types.GameStates.FINISHED, this.finishGame()), !0)
            }, i.prototype.checkGameStartNextLevelState = function() {
                return !!this.isGameStartNextLevelState() && (this.userProfile.GameState === t.types.GameStates.START_NEXT_LEVEL_PREPARE && (this.userProfile.GameState = t.types.GameStates.START_NEXT_LEVEL, this.startNextLevel()), !0)
            }, i.prototype.checkBikeMovementInput = function() {
                if (this.bike.isAlive()) {
                    var e = this.inputManager.isInputDown(t.types.UserInputKeys.MOVE_FORWARD),
                        i = this.inputManager.isInputDown(t.types.UserInputKeys.MOVE_BACK);
                    !e && !i || e && i ? this.bike.idle() : e ? (this.bike.accelerate(), this.isBikeMoved = !0) : i && (this.bike.brake(), this.isBikeMoved = !0)
                }
            }, i.prototype.checkBikeTiltInput = function() {
                if (this.bike.isAlive()) {
                    var e = this.inputManager.isInputDown(t.types.UserInputKeys.TILT_BACK),
                        i = this.inputManager.isInputDown(t.types.UserInputKeys.TILT_FORWARD);
                    !e && !i || e && i ? this.bike.tiltStop() : e ? this.bike.tiltLeft() : i && this.bike.tiltRight()
                }
            }, i.prototype.reduceGameTimer = function(t) {
                this.gameTimerMS -= t
            }, i.prototype.startFlipLabelTween = function(e) {
                var i = "FLIP",
                    s = "-" + e.toString() + "  sec";
                if (e > 1 && (i += "  X" + e.toString()), null === this.flipLabel) {
                    var o = {
                        font: "QuickExpress",
                        fontSize: "50px",
                        fill: "#ffffff",
                        boundsAlignH: "center",
                        boundsAlignV: "middle"
                    };
                    this.flipLabel = this.game.add.text(640 * t.config.GameConfig.calcGameScale, 150, i, o, this.guiLayer), this.flipLabel.stroke = "#243A68", this.flipLabel.strokeThickness = 5
                } else this.flipLabel.setText(i);
                if (this.flipLabel.setTextBounds(-this.flipLabel.width / 2, -this.flipLabel.height / 2, this.flipLabel.width, this.flipLabel.height), this.flipLabel.scale.set(0, 0), null === this.flipLabelTime) {
                    var n = {
                        font: "QuickExpress",
                        fontSize: "20px",
                        fill: "#ffffff",
                        boundsAlignH: "center",
                        boundsAlignV: "middle"
                    };
                    this.flipLabelTime = this.game.add.text(640 * t.config.GameConfig.calcGameScale, 190, s, n, this.guiLayer), this.flipLabelTime.stroke = "#243A68", this.flipLabelTime.strokeThickness = 5, this.flipLabelTime.scale.set(0, 0)
                } else this.flipLabelTime.setText(s);
                if (this.flipLabelTime.setTextBounds(-this.flipLabelTime.width / 2, -this.flipLabelTime.height / 2, this.flipLabelTime.width, this.flipLabelTime.height), !this.isFlipTweensStarted) {
                    null !== this.flipLabelTween2 && (this.flipLabelTween2.onComplete.removeAll(), this.flipLabelTween2.stop(), this.flipLabelTween2 = null), null !== this.flipLabelTimeTween2 && (this.flipLabelTimeTween2.onComplete.removeAll(), this.flipLabelTimeTween2.stop(), this.flipLabelTimeTween2 = null), this.isFlipTweensStarted = !0;
                    var a = {};
                    a.tweensCounter = 2, this.flipLabelTween1 = this.game.add.tween(this.flipLabel.scale).to({
                        x: 1.25,
                        y: 1.25
                    }, 200, Phaser.Easing.Linear.None, !1).to({
                        x: .75,
                        y: .75
                    }, 80, Phaser.Easing.Linear.None, !1).to({
                        x: 1,
                        y: 1
                    }, 80, Phaser.Easing.Linear.None, !1).to({
                        x: 1,
                        y: 1
                    }, 10, Phaser.Easing.Linear.None, !1, 1e3), this.flipLabelTween1.onComplete.addOnce(this.onFlipLabelTween1Complete, this, 0, a), this.flipLabelTimeTween1 = this.game.add.tween(this.flipLabelTime.scale).to({
                        x: 1.25,
                        y: 1.25
                    }, 200, Phaser.Easing.Linear.None, !1).to({
                        x: .75,
                        y: .75
                    }, 80, Phaser.Easing.Linear.None, !1).to({
                        x: 1,
                        y: 1
                    }, 80, Phaser.Easing.Linear.None, !1).to({
                        x: 1,
                        y: 1
                    }, 10, Phaser.Easing.Linear.None, !1, 1e3), this.flipLabelTimeTween1.onComplete.addOnce(this.onFlipLabelTween1Complete, this, 0, a), this.flipLabelTween1.start(), this.flipLabelTimeTween1.start()
                }
            }, i.prototype.isGameExitState = function() {
                return this.userProfile.GameState === t.types.GameStates.EXIT || this.userProfile.GameState === t.types.GameStates.EXIT_PREPARE
            }, i.prototype.isGameResetState = function() {
                return this.userProfile.GameState === t.types.GameStates.RESET || this.userProfile.GameState === t.types.GameStates.RESET_PREPARE
            }, i.prototype.isGamePausedState = function() {
                return this.userProfile.GameState === t.types.GameStates.PAUSED || this.userProfile.GameState === t.types.GameStates.PAUSE_PREPARE
            }, i.prototype.isGameResumedState = function() {
                return this.userProfile.GameState === t.types.GameStates.RESUMED || this.userProfile.GameState === t.types.GameStates.RESUME_PREPARE
            }, i.prototype.isGameFinishedState = function() {
                return this.userProfile.GameState === t.types.GameStates.FINISHED || this.userProfile.GameState === t.types.GameStates.FINISH_PREPARE
            }, i.prototype.isGameStartNextLevelState = function() {
                return this.userProfile.GameState === t.types.GameStates.START_NEXT_LEVEL || this.userProfile.GameState === t.types.GameStates.START_NEXT_LEVEL_PREPARE
            }, i.prototype.renderDebugDraw = function() {
                if (this.isB2DebugDrawEnabled) {
                    var t = this.game.canvas.getContext("2d");
                    t.save(), t.clearRect(0, 0, this.gameSettings.worldBounds.width, this.gameSettings.worldBounds.height), t.translate(-this.gameSettings.context2DStartPosition.x - this.context2DOffsetX, -this.gameSettings.context2DStartPosition.y - this.context2DOffsetY), this.b2World.DrawDebugData(), t.restore()
                }
            }, i.prototype.logGameState = function() {
                var e = this.userProfile.GameState,
                    i = "UNKNOWN";
                e === t.types.GameStates.RESUMED ? i = "RESUMED" : e === t.types.GameStates.PAUSED ? i = "PAUSED" : e === t.types.GameStates.FINISHED ? i = "FINISHED" : e === t.types.GameStates.EXIT && (i = "EXIT"), console.log("Game state: " + i)
            }, i.prototype.cleanBox2DContactListener = function() {
                this.b2ContactListener.OnBikeWithGameObjectBeginContact.removeAll(), this.b2ContactListener.OnBikeWithGameObjectEndContact.removeAll(), this.b2ContactListener.OnBikeWithGroundBeginContact.removeAll(), this.b2ContactListener.OnBikeWithGroundEndContact.removeAll()
            }, i.prototype.disposeSignalHandlers = function() {
                this.appFocusManager.OnFocusIn.remove(this.onAppFocusIn, this), this.appFocusManager.OnFocusOut.remove(this.onAppFocusOut, this)
            }, i.prototype.disposeFlipLabelsTweens = function() {
                null != this.flipLabelTween1 && (this.flipLabelTween1.onComplete.removeAll(), this.flipLabelTween1.stop()), null != this.flipLabelTween2 && (this.flipLabelTween2.onComplete.removeAll(), this.flipLabelTween2.stop()), null != this.flipLabelTimeTween1 && (this.flipLabelTimeTween1.onComplete.removeAll(), this.flipLabelTimeTween1.stop()), null != this.flipLabelTimeTween2 && (this.flipLabelTimeTween2.onComplete.removeAll(), this.flipLabelTimeTween2.stop())
            }, i.prototype.disposeFlipLabels = function() {
                null !== this.flipLabel && null !== this.flipLabel.parent && this.flipLabel.parent.removeChild(this.flipLabel), null !== this.flipLabelTime && null !== this.flipLabelTime.parent && this.flipLabelTime.parent.removeChild(this.flipLabelTime)
            }, i.prototype.disposeBox2DContactListener = function() {
                this.b2World.SetContactListener(new Box2D.Dynamics.b2ContactListener), this.b2ContactListener = null
            }, i.prototype.disposeGameObjectsController = function() {
                this.gameObjectsController.SignalOnGOAction.removeAll(), this.gameObjectsController.dispose(), this.gameObjectsController = null
            }, i.prototype.disposeBike = function() {
                null != this.bike && (this.bike.OnBikeDeadSignal.removeAll(), this.bike.OnBikeFlipSignal.removeAll(), this.bike.OnBikeFalloutSignal.removeAll(), this.bike.dispose(), this.bike = null)
            }, i.prototype.disposeLevel = function() {
                null != this.levelController && (this.levelController.SignalOnGameObjectCreate.removeAll(), this.levelController.dispose(), this.levelController = null)
            }, i.prototype.disposeCameraController = function() {
                null !== this.gameCameraController && this.gameCameraController.dispose()
            }, i.prototype.resetData = function() {
                this.isBikeMoved = !1, this.gameStartedFlag = !1, this.gameSettings = null, this.game = null, this.b2World = null, this.isB2DebugDrawEnabled = !1, this.isMobileDevice = !1, this.isKeyboardEnabled = !1, this.b2DebugDraw = null, this.context2DStartX = 0, this.context2DStartY = 0, this.context2DOffsetX = 0, this.context2DOffsetY = 0, this.gameObjectsController = null, this.levelController = null, this.mainLayer = null, this.staticLayer = null, this.bottomLayer = null, this.scaleLayer = null, this.guiController = null, this.skyLayer = null, this.backgroundLayer = null, this.levelLayer = null, this.guiLayer = null, this.bgSkyImage = null, this.inputManager = null, this.stateManager = null, this.appFocusManager = null, this.background = null, this.bike = null, this.b2ContactListener = null, this.gameCameraController = null, this.gameCamera = null, this.gameTimerMS = 0, this.curLevelId = 0, this.userProfile = null, this.curLevelStarsItem = null, this.saveManager = null, this.soundManager = null, this.resetFlipLabels(), this.resetFlipLabelsTweens(), this.isFlipTweensStarted = !1, this.flipLabelTween1 = null, this.flipLabelTween2 = null, this.flipLabelTimeTween1 = null, this.flipLabelTimeTween2 = null, this.guiAtlasKey = null, this.gameAtlasKey = null, this.gameBgFrameKey = null
            }, i.prototype.resetFlipLabels = function() {
                this.flipLabel = null, this.flipLabelTime = null
            }, i.prototype.resetFlipLabelsTweens = function() {
                this.flipLabelTween1 = null, this.flipLabelTween2 = null, this.flipLabelTimeTween1 = null, this.flipLabelTimeTween2 = null
            }, i.prototype.onLevelGameObjectCreate = function(t, e, i) {
                this.gameObjectsController.createGameObject(t, e, i)
            }, i.prototype.onGameObjectAction = function(e) {
                if (this.bike.isAlive() && (e.Action === t.types.GameObjectActions.REQUEST_BIKE && (e.Type === t.types.GameObjectType.CHECK_POINT && (i = e.Sender).setBikeRef(this.bike), e.Type === t.types.GameObjectType.ROTATING_OBJECT && e.Sender.setBikeRef(this.bike)), e.Action === t.types.GameObjectActions.CHANGE_START_UP_LEVEL_PART && e.Type === t.types.GameObjectType.CHECK_POINT && (this.gameSettings.startPartName = e.Data.startPartName), e.Action === t.types.GameObjectActions.TRIGGER_ACTION && (e.Type !== t.types.GameObjectType.TRIGGER && e.Type !== t.types.GameObjectType.MULTI_TRIGGER || this.gameObjectsController.addTriggerAction(e.Data.objectId, e.Data.objectAction)), e.Action === t.types.GameObjectActions.REQUEST_GAME_CAMERA_CONTROLLER && (e.Type === t.types.GameObjectType.CAMERA_TRIGGER && e.Sender.setGameCameraControllerRef(this.gameCameraController), e.Type === t.types.GameObjectType.CHECK_POINT))) {
                    var i = e.Sender;
                    i.setGameCameraControllerRef(this.gameCameraController)
                }
            }, i.prototype.onBikeWithGameObjectBeginContact = function(e) {
                if (this.bike.isAlive()) {
                    if (e.dataB.MaterialType === t.types.GameObjectMaterialType.THORNS && this.bike.die(), e.dataA.EntityCategory !== t.types.EntityCategory.BIKE_BODY_SENSOR_HEAD && e.dataA.EntityCategory !== t.types.EntityCategory.BIKE_BODY_SENSOR_BODY || e.dataB.Type !== t.types.GameObjectType.PISTON && e.dataB.Type !== t.types.GameObjectType.CIRCLE && e.dataB.Type !== t.types.GameObjectType.STICK && e.dataB.Type !== t.types.GameObjectType.ROTATING_OBJECT && e.dataB.Type !== t.types.GameObjectType.VERTICAL_LIFT && e.dataB.Type !== t.types.GameObjectType.HORIZONTAL_LIFT && e.dataB.Type !== t.types.GameObjectType.DOOR || this.bike.die(), e.dataB.Type === t.types.GameObjectType.TRIGGER && null != (i = e.dataB.UserData2) && i.IsTriggerActive && (this.soundManager.playSound(Sounds.Trigger), i.activateTrigger()), e.dataB.Type === t.types.GameObjectType.MULTI_TRIGGER) {
                        var i = e.dataB.UserData2;
                        null != i && i.IsTriggerActive && (this.soundManager.playSound(Sounds.Trigger), i.activateTrigger())
                    }
                    if (e.dataB.Type === t.types.GameObjectType.CAMERA_TRIGGER) {
                        var s = e.dataB.UserData2;
                        null !== s && s.activateTrigger()
                    }
                    if (e.dataB.Type === t.types.GameObjectType.DESTRUCTIBLE_OBJECT) {
                        var o = e.dataB.UserData2;
                        null != o && o.IsComponentActivated && o.deactivateComponent()
                    }
                    e.dataB.Type === t.types.GameObjectType.FINISH_ZONE && (this.isGameFinishedState() || (this.curLevelStarsItem = this.userProfile.getLevelStarsItemWithLevelId(this.curLevelId), this.curLevelStarsItem.LevelPassedTime.setValuesFromTotalMs(this.gameTimerMS), this.curLevelId !== this.userProfile.MaxLevels && this.userProfile.setLevelOpened(this.curLevelId + 1), this.userProfile.GameState = t.types.GameStates.FINISH_PREPARE)), e.dataB.EntityCategory !== t.types.EntityCategory.GAME_OBJECT || e.dataB.Type !== t.types.GameObjectType.CIRCLE && e.dataB.Type !== t.types.GameObjectType.DOOR && e.dataB.Type !== t.types.GameObjectType.HORIZONTAL_LIFT && e.dataB.Type !== t.types.GameObjectType.PISTON && e.dataB.Type !== t.types.GameObjectType.ROTATING_OBJECT && e.dataB.Type !== t.types.GameObjectType.VERTICAL_LIFT || ((e.dataA.EntityCategory & t.types.EntityCategory.BIKE_WHEEL_REAR) === t.types.EntityCategory.BIKE_WHEEL_REAR ? this.bike.addRearWheelRefCounter() : (e.dataA.EntityCategory & t.types.EntityCategory.BIKE_WHEEL_FRONT) === t.types.EntityCategory.BIKE_WHEEL_FRONT && this.bike.addFrontWheelRefCounter())
                }
            }, i.prototype.onBikeWithGameObjectEndContact = function(e) {
                this.bike.isAlive() && (e.dataB.EntityCategory !== t.types.EntityCategory.GAME_OBJECT || e.dataB.Type !== t.types.GameObjectType.CIRCLE && e.dataB.Type !== t.types.GameObjectType.DOOR && e.dataB.Type !== t.types.GameObjectType.HORIZONTAL_LIFT && e.dataB.Type !== t.types.GameObjectType.PISTON && e.dataB.Type !== t.types.GameObjectType.ROTATING_OBJECT && e.dataB.Type !== t.types.GameObjectType.VERTICAL_LIFT || ((e.dataA.EntityCategory & t.types.EntityCategory.BIKE_WHEEL_REAR) === t.types.EntityCategory.BIKE_WHEEL_REAR ? this.bike.subRearWheelRefCounter() : (e.dataA.EntityCategory & t.types.EntityCategory.BIKE_WHEEL_FRONT) === t.types.EntityCategory.BIKE_WHEEL_FRONT && this.bike.subFrontWheelRefCounter()))
            }, i.prototype.onBikeWithGroundBeginContact = function(e) {
                this.bike.isAlive() && (e.dataB.Type !== t.types.GameObjectType.ROAD_SURFACE || e.dataA.EntityCategory !== t.types.EntityCategory.BIKE_BODY_SENSOR_BODY && e.dataA.EntityCategory !== t.types.EntityCategory.BIKE_BODY_SENSOR_HEAD ? e.dataB.Type === t.types.GameObjectType.ROAD_SURFACE && ((e.dataA.EntityCategory & t.types.EntityCategory.BIKE_WHEEL_REAR) === t.types.EntityCategory.BIKE_WHEEL_REAR ? this.bike.addRearWheelRefCounter() : (e.dataA.EntityCategory & t.types.EntityCategory.BIKE_WHEEL_FRONT) === t.types.EntityCategory.BIKE_WHEEL_FRONT && this.bike.addFrontWheelRefCounter()) : this.bike.die())
            }, i.prototype.onBikeWithGroundEndContact = function(e) {
                this.bike.isAlive() && e.dataB.Type === t.types.GameObjectType.ROAD_SURFACE && ((e.dataA.EntityCategory & t.types.EntityCategory.BIKE_WHEEL_REAR) === t.types.EntityCategory.BIKE_WHEEL_REAR ? this.bike.subRearWheelRefCounter() : (e.dataA.EntityCategory & t.types.EntityCategory.BIKE_WHEEL_FRONT) === t.types.EntityCategory.BIKE_WHEEL_FRONT && this.bike.subFrontWheelRefCounter())
            }, i.prototype.onBikeDead = function() {
                this.userProfile.GameState = t.types.GameStates.RESET_PREPARE, "part1" === this.gameSettings.startPartName && (this.isBikeMoved = !1, this.game.analytics.game.addEvent(new GA.Events.Progression("Fail:Level" + this.curLevelId)), console.log("failed at level " + this.curLevelId + ". sending it to game analytics."), this.gameTimerMS = 0, this.guiController.showGameTimerFromMS(this.gameTimerMS))
            }, i.prototype.onBikeFlip = function(t) {
                this.soundManager.playSound(Sounds.BikeFlip), this.reduceGameTimer(1e3 * t), this.guiController.showGameTimerFromMS(this.gameTimerMS), this.startFlipLabelTween(t)
            }, i.prototype.onBikeFallout = function() {
                this.isGameExitState() || this.isGameResetState() || this.isGamePausedState() || this.isGameFinishedState() || (this.userProfile.GameState = t.types.GameStates.EXIT_PREPARE)
            }, i.prototype.onFlipLabelTween1Complete = function(t, e, i) {
                if (i.tweensCounter -= 1, !(i.tweensCounter > 0)) {
                    this.flipLabelTween1 = null, this.flipLabelTimeTween1 = null;
                    var s = {};
                    s.tweensCounter = 2, this.flipLabelTween2 = this.game.add.tween(this.flipLabel.scale).to({
                        x: 1.25,
                        y: 1.25
                    }, 80, Phaser.Easing.Linear.None, !1).to({
                        x: 0,
                        y: 0
                    }, 200, Phaser.Easing.Linear.None, !1), this.flipLabelTween2.onComplete.addOnce(this.onFlipLabelTween2Complete, this, 0, s), this.flipLabelTimeTween2 = this.game.add.tween(this.flipLabelTime.scale).to({
                        x: 1.25,
                        y: 1.25
                    }, 80, Phaser.Easing.Linear.None, !1).to({
                        x: 0,
                        y: 0
                    }, 200, Phaser.Easing.Linear.None, !1), this.flipLabelTween2.start(), this.flipLabelTimeTween2.start(), this.isFlipTweensStarted = !1
                }
            }, i.prototype.onFlipLabelTween2Complete = function(t, e, i) {
                i.tweensCounter > 0 || (this.flipLabelTween2 = null, this.flipLabelTimeTween2 = null, this.disposeFlipLabels(), this.resetFlipLabels())
            }, i.prototype.onGUIGamepadPause = function() {
                this.soundManager.playSound(Sounds.ButtonClick), this.userProfile.GameState = t.types.GameStates.PAUSE_PREPARE
            }, i.prototype.onGamePausedResumeGame = function() {
                this.soundManager.playSound(Sounds.ButtonClick), this.userProfile.GameState = t.types.GameStates.RESUME_PREPARE
            }, i.prototype.onGamePausedExitGame = function() {
                this.soundManager.playSound(Sounds.ButtonClick), this.userProfile.GameState = t.types.GameStates.EXIT_PREPARE
            }, i.prototype.onGamePausedRestartLevel = function() {
                this.soundManager.playSound(Sounds.ButtonClick), this.gameSettings.startPartName = "part1", this.gameTimerMS = 0, this.isBikeMoved = !1, this.game.analytics.game.addEvent(new GA.Events.Progression("Fail:Level" + this.curLevelId)), console.log("Restarted level " + this.curLevelId + ". Counts as a fail and will be send to game analytics."), console.log("play advertisement if possible."), this.game.analytics.google.sendScreenView("advertisement"), this.resumeGame(), this.userProfile.GameState = t.types.GameStates.RESET_PREPARE
            }, i.prototype.onGamePausedMusicOn = function() {
                this.userProfile.IsMusicOn = !0, this.userProfile.saveData(), this.soundManager.unmuteMusic(), this.soundManager.unmuteSounds(), this.soundManager.playSound(Sounds.ButtonClick)
            }, i.prototype.onGamePausedMusicOff = function() {
                this.userProfile.IsMusicOn = !1, this.userProfile.saveData(), this.soundManager.muteMusic(), this.soundManager.muteSounds()
            }, i.prototype.onGameFinishedExitGame = function() {
                this.soundManager.playSound(Sounds.ButtonClick), this.userProfile.GameState = t.types.GameStates.EXIT_PREPARE
            }, i.prototype.onGameFinishedRestartLevel = function() {
                this.soundManager.playSound(Sounds.ButtonClick), console.log("play advertisement if possible."), this.game.analytics.google.sendScreenView("advertisement"), this.gameSettings.startPartName = "part1", this.gameTimerMS = 0, this.isBikeMoved = !1, this.guiController.hideGameFinishedWindow(), this.guiController.buttonPauseGame.Button.inputEnabled = !0, this.guiController.buttonPauseGame.Button.visible = !0, this.unblockGamePad(), this.bike.resumeAnimation(), this.userProfile.GameState = t.types.GameStates.RESET_PREPARE
            }, i.prototype.onGameFinishedNextLevel = function() {
                this.soundManager.playSound(Sounds.ButtonClick), this.userProfile.GameState = t.types.GameStates.START_NEXT_LEVEL_PREPARE
            }, i.prototype.onAppFocusIn = function() {}, i.prototype.onAppFocusOut = function() {
                this.gameStartedFlag && this.isGameResumedState() && (this.userProfile.GameState = t.types.GameStates.PAUSED, this.pauseGame())
            }, i
        }();
        e.GameController = i
    }(t.controllers || (t.controllers = {}))
}(GameSrc || (GameSrc = {}));
var BoilerPlate;
! function(t) {
    var e = function(t) {
        function e() {
            var i = t.call(this) || this;
            return i.name = e.Name, i.loopsCount = 0, i.resetData(), i
        }
        return __extends(e, t), e.prototype.init = function() {
            t.prototype.init.call(this), this.game.world.removeAll(!0, !0), this.game.time.advancedTiming = !0, this.initData()
        }, e.prototype.create = function() {
            t.prototype.create.call(this), this.game.analytics.google.sendScreenView("gameplay"), this.createGameController(), this.startGame(), this.resize()
        }, e.prototype.update = function() {
            if (this.isFirstUpdate) return this.isFirstUpdate = !1, this.timeAcc = 0, void(this.prevTimeMS = Date.now());
            for (t.prototype.update.call(this), this.currTimeMS = Date.now(), this.deltaTime = (this.currTimeMS - this.prevTimeMS) / 1e3, this.prevTimeMS = this.currTimeMS, this.deltaTime > e.MAX_FRAME_TIME && (this.deltaTime = e.MAX_FRAME_TIME), this.timeAcc += this.deltaTime, this.loopsCount = 0; this.timeAcc >= e.DESIRED_FRAME_TIME;) this.loopsCount++, this.updateGameController(e.DESIRED_FRAME_TIME), this.timeAcc -= e.DESIRED_FRAME_TIME;
            this.renderGameController(this.deltaTime), this.updateLabelFPS()
        }, e.prototype.postUpdate = function() {
            console.log("postUpdate")
        }, e.prototype.render = function() {
            t.prototype.render.call(this), this.gameController.renderPhysDebugDraw()
        }, e.prototype.resize = function() {
            GameSrc.config.GameConfig.calcGameScale = this.game.width / Constants.GAME_WIDTH, this.gameController.resize()
        }, e.prototype.shutdown = function() {
            console.log("Gameplay: shutdown"), this.disposeGameController(), this.resetData(), t.prototype.shutdown.call(this)
        }, e.prototype.initData = function() {
            this.isFirstUpdate = !0
        }, e.prototype.createGameController = function() {
            this.gameController = new GameSrc.controllers.GameController(this.game)
        }, e.prototype.startGame = function() {
            this.gameController.startGame()
        }, e.prototype.updateGameController = function(t) {
            this.gameController.update(t)
        }, e.prototype.updateLabelFPS = function() {}, e.prototype.renderGameController = function(t) {
            this.gameController.render(t)
        }, e.prototype.disposeGameController = function() {
            null !== this.gameController && this.gameController.dispose()
        }, e.prototype.resetData = function() {
            this.gameController = null, this.prevTimeMS = 0, this.currTimeMS = 0, this.deltaTime = 0, this.timeAcc = 0, this.isFirstUpdate = !1
        }, e.Name = "gameplay", e.pause = !1, e.MAX_FRAME_TIME = .1, e.DESIRED_FRAME_TIME = 1 / 60, e
    }(Phaser.State);
    t.Gameplay = e
}(BoilerPlate || (BoilerPlate = {}));
var GameSrc;
! function(t) {
    ! function(e) {
        var i = function() {
            function e(t) {
                this.resetData(), this.isDisposed = !1, this.game = t, this.initData()
            }
            return e.prototype.init = function() {
                this.loadData(), this.setData(), this.initSoundManager(), this.createGraphics()
            }, e.prototype.resize = function() {
                this.isDisposed || (this.resizeBgSky(), this.isOnMobileDevice && this.resizeBg())
            }, e.prototype.dispose = function() {
                this.isDisposed || (this.disposeMapButtons(), this.disposeGraphicsContainer(), this.resetData(), this.isDisposed = !0)
            }, e.prototype.initData = function() {
                this.isOnMobileDevice = t.config.GameConfig.isOnMobileDevice, this.gameMapButtons = [], this.stateManager = t.managers.StateManager.getInstance(), this.userProfile = t.settings.UserProfileSettings.getInstance(), this.atlasKey = Atlases.GUI_GENERAL
            }, e.prototype.loadData = function() {
                this.data = this.game.cache.getJSON(Settings.GameMap)
            }, e.prototype.setData = function() {
                this.userProfile.MaxLevels = this.data.max_levels
            }, e.prototype.initSoundManager = function() {
                this.soundManager = BoilerPlate.SoundManager.getInstance()
            }, e.prototype.createGraphics = function() {
                this.graphicsContainer = this.game.add.group(), this.skyLayer = this.game.add.group(this.graphicsContainer), this.bottomLayer = this.game.add.group(this.graphicsContainer), this.createBackground(), this.createMapButtons()
            }, e.prototype.createBackground = function() {
                this.createBGSky(), this.createBG()
            }, e.prototype.createBGSky = function() {
                this.bgSkyImage = this.game.add.image(0, 0, this.atlasKey, "a_17_bg_sky_agp_p10000", this.skyLayer)
            }, e.prototype.createBG = function() {
                this.bgImage = this.game.add.image(0, -311, this.atlasKey, "a_01_bg_scr_map_agp_p10000", this.bottomLayer), this.bottomLayer.y = this.game.height - (this.bottomLayer.height - 311)
            }, e.prototype.createMapButtons = function() {
                var t, e = this.data.map_buttons;
                for (t = 0; t < e.length; t++) {
                    var i = e[t],
                        s = i.levelId,
                        o = this.userProfile.isLevelOpened(s);
                    this.gameMapButtons.push(this.createMapButtonItem(i.x, i.y, i.rotation, s, o))
                }
            }, e.prototype.createCheatsButtons = function() {
                var e = new t.entities.GameMapButtonS(this.game, this.bottomLayer, 945, 128, 0, 13, !0);
                e.OnButtonUpSignal.add(this.onGameMapButtonUp, this), e.init(), this.gameMapButtons.push(e)
            }, e.prototype.createMapButtonItem = function(e, i, s, o, n) {
                var a = new t.entities.GameMapButtonS(this.game, this.bottomLayer, e, i, s, o, n);
                if (a.OnButtonUpSignal.add(this.onGameMapButtonUp, this), a.init(), n) {
                    var r = this.userProfile.getLevelStarsItemWithLevelId(o);
                    null !== r && r.LastLevelPassedTime.ActiveFlag && a.setGivenStars(r.getStarsCountForTime(r.LastLevelPassedTime))
                }
                return a
            }, e.prototype.resizeBgSky = function() {
                this.bgSkyImage.x = -100, this.bgSkyImage.y = -100, this.bgSkyImage.width = this.game.width + 200, this.bgSkyImage.height = this.game.height + 200
            }, e.prototype.resizeBg = function() {
                var e = t.config.GameConfig.calcGameScale;
                this.bottomLayer.scale.set(e), this.game.height / this.game.width < Constants.GAME_HEIGHT / Constants.GAME_WIDTH ? this.bottomLayer.y = this.game.height - (this.bottomLayer.height - 411 * e) : this.bottomLayer.y = this.game.height - (this.bottomLayer.height - 311 * e)
            }, e.prototype.disposeGraphicsContainer = function() {
                null !== this.graphicsContainer && (this.graphicsContainer.removeAll(!0, !0), null !== this.graphicsContainer.parent && this.graphicsContainer.parent.removeChild(this.graphicsContainer))
            }, e.prototype.disposeMapButtons = function() {
                var t = 0;
                for (t = 0; t < this.gameMapButtons.length; t++) this.gameMapButtons[t].dispose()
            }, e.prototype.resetData = function() {
                this.game = null, this.isOnMobileDevice = !1, this.data = null, this.graphicsContainer = null, this.skyLayer = null, this.bottomLayer = null, this.bgSkyImage = null, this.bgImage = null, this.gameMapButtons = null, this.stateManager = null, this.soundManager = null, this.userProfile = null, this.atlasKey = null
            }, e.prototype.onGameMapButtonUp = function(e) {
                this.soundManager.playSound(Sounds.ButtonClick);
                var i = e.sender;
                t.settings.GameCommonSettings.setStartUpLevelData(i.LevelId), this.stateManager.switchToState(BoilerPlate.Gameplay.Name)
            }, e
        }();
        e.GameMapController = i
    }(t.controllers || (t.controllers = {}))
}(GameSrc || (GameSrc = {}));
var BoilerPlate;
! function(t) {
    var e = function(t) {
        function e() {
            var i = t.call(this) || this;
            return i.name = e.Name, i.resetData(), i
        }
        return __extends(e, t), e.prototype.init = function() {
            this.game.world.removeAll(!0, !0)
        }, e.prototype.create = function() {
            t.prototype.create.call(this), this.createGameMapController(), this.game.analytics.google.sendScreenView("level_select"), this.resize()
        }, e.prototype.resize = function() {
            GameSrc.config.GameConfig.calcGameScale = this.game.width / Constants.GAME_WIDTH, this.gameMapController.resize()
        }, e.prototype.shutdown = function() {
            console.log("Gamemap: shutdown"), this.disposeGameMapController(), this.resetData(), t.prototype.shutdown.call(this)
        }, e.prototype.createGameMapController = function() {
            this.gameMapController = new GameSrc.controllers.GameMapController(this.game), this.gameMapController.init()
        }, e.prototype.disposeGameMapController = function() {
            null !== this.gameMapController && this.gameMapController.dispose()
        }, e.prototype.resetData = function() {
            this.gameMapController = null, this.labelVersion = null
        }, e.Name = "gameMap", e
    }(Phaser.State);
    t.GameMap = e
}(BoilerPlate || (BoilerPlate = {}));
var GameSrc;
! function(t) {
    ! function(e) {
        var i = function() {
            function e(t) {
                this.resetData(), this.isDisposed = !1, this.game = t, this.initData()
            }
            return e.prototype.startInit = function() {
                this.atlasKey = Atlases.GUI_GENERAL, this.createGraphicsContainer(), this.createBackground(), this.createButtons()
            }, e.prototype.continueInit = function() {
                this.setSavedDataSettings(), this.initSoundManager(), this.showButtons(), this.playMusic()
            }, e.prototype.resize = function() {
                this.isDisposed || (this.resizeBgSky(), this.isOnMobileDevice && this.resizeBg())
            }, e.prototype.dispose = function() {
                this.isDisposed || (this.disposeButtons(), this.disposeGraphicsContainer(), this.resetData(), this.isDisposed = !0)
            }, e.prototype.initData = function() {
                this.isOnMobileDevice = t.config.GameConfig.isOnMobileDevice, this.userProfile = t.settings.UserProfileSettings.getInstance(), this.stateManager = t.managers.StateManager.getInstance()
            }, e.prototype.createGraphicsContainer = function() {
                this.graphicsContainer = this.game.add.group(), this.bgSkyLayer = this.game.add.group(this.graphicsContainer), this.bottomLayer = this.game.add.group(this.graphicsContainer), this.topLayer = this.game.add.group(this.graphicsContainer)
            }, e.prototype.createBackground = function() {
                this.createBGSky(), this.createBG(), this.createTitle()
            }, e.prototype.createBGSky = function() {
                this.bgSkyImage = this.game.add.image(0, 0, this.atlasKey, "a_17_bg_sky_agp_p10000", this.bgSkyLayer)
            }, e.prototype.createBG = function() {
                this.bgImage = this.game.add.image(0, 0, this.atlasKey, "a_12_bg_scr_start_agp_p10000", this.bottomLayer), this.bottomLayer.y = this.game.height - 700;
                var t = Fabrique.Branding.getLogoWithLink(this.game, "extreme-bikers");
                t.y = this.game.height - 100, this.game.add.existing(t)
            }, e.prototype.createTitle = function() {
                this.titleImage = this.game.add.image(603.95, 34.8, this.atlasKey, "a_12_bg_scr_start_agp_p20000", this.topLayer)
            }, e.prototype.createButtons = function() {
                this.createStartButton(), this.createMusicOnButton(), this.createMusicOffButton(), this.createToggleMusicButton()
            }, e.prototype.createStartButton = function() {
                this.btnStart = this.createButton(1028.9, 513.3, this.bottomLayer, "a_13_btn_start_scr_start_agp_p10000", "a_13_btn_start_scr_start_agp_p10001", "a_13_btn_start_scr_start_agp_p10002"), this.btnStart.OnButtonUpSignal.add(this.onButtonStart, this), this.btnStart.init(), this.btnStart.Visible = !1
            }, e.prototype.createMusicOnButton = function() {
                this.btnMusicOn = this.createButton(74.65, 63.3, this.topLayer, "a_15_btn_music_on_scr_start_agp_p10000", "a_15_btn_music_on_scr_start_agp_p10001", "a_15_btn_music_on_scr_start_agp_p10002"), this.btnMusicOn.init()
            }, e.prototype.createMusicOffButton = function() {
                this.btnMusicOff = this.createButton(74.65, 63.3, this.topLayer, "a_14_btn_music_off_scr_start_agp_p10000", "a_14_btn_music_off_scr_start_agp_p10001", "a_14_btn_music_off_scr_start_agp_p10002"), this.btnMusicOff.init()
            }, e.prototype.createButton = function(e, i, s, o, n, a) {
                return new t.entities.GameGUIButtonS(this.game, s, e, i, 0, "none", this.atlasKey, o, n, a)
            }, e.prototype.createToggleMusicButton = function() {
                this.btnToggleMusic = new t.entities.GameGUIToggleButtonS(this.btnMusicOn, this.btnMusicOff, t.entities.GameGUIToggleButtonS.STATE_ON), this.btnToggleMusic.OnButtonOnUpSignal.add(this.onMusicOn, this), this.btnToggleMusic.OnButtonOffUpSignal.add(this.onMusicOff, this), this.btnToggleMusic.init(), this.btnToggleMusic.Visible = !1
            }, e.prototype.initSoundManager = function() {
                this.soundManager = BoilerPlate.SoundManager.getInstance()
            }, e.prototype.setSavedDataSettings = function() {
                this.userProfile.IsMusicOn ? this.btnToggleMusic.on() : this.btnToggleMusic.off()
            }, e.prototype.playMusic = function() {
                this.soundManager.playMusic(Sounds.GameMusic, .2)
            }, e.prototype.showButtons = function() {
                this.btnStart.Visible = !0, this.btnToggleMusic.Visible = !0
            }, e.prototype.resizeBgSky = function() {
                this.bgSkyImage.x = -100, this.bgSkyImage.y = -100, this.bgSkyImage.width = this.game.width + 200, this.bgSkyImage.height = this.game.height + 200
            }, e.prototype.resizeBg = function() {
                var e = t.config.GameConfig.calcGameScale,
                    i = window.devicePixelRatio,
                    s = window.innerHeight * i;
                this.bottomLayer.scale.set(e), this.topLayer.scale.set(e), this.bottomLayer.y = this.game.height - 700 * e, this.titleImage.y = 34.8, s < 625 && (this.bgImage.y = 100, this.titleImage.y = 15, this.btnStart.Button.y = 570)
            }, e.prototype.disposeButtons = function() {
                null !== this.btnStart && this.btnStart.dispose(), null !== this.btnToggleMusic && this.btnToggleMusic.dispose(), null !== this.btnMusicOn && this.btnMusicOn.dispose(), null !== this.btnMusicOff && this.btnMusicOff.dispose()
            }, e.prototype.disposeGraphicsContainer = function() {
                null !== this.graphicsContainer && (this.graphicsContainer.removeAll(!0, !0), null !== this.graphicsContainer.parent && this.graphicsContainer.parent.removeChild(this.graphicsContainer))
            }, e.prototype.resetData = function() {
                this.isOnMobileDevice = !1, this.game = null, this.userProfile = null, this.atlasKey = null, this.graphicsContainer = null, this.bgSkyLayer = null, this.topLayer = null, this.bottomLayer = null, this.bgSkyImage = null, this.bgImage = null, this.btnStart = null, this.btnMusicOn = null, this.btnMusicOff = null, this.btnToggleMusic = null, this.soundManager = null, this.stateManager = null
            }, e.prototype.onButtonStart = function(t) {
                console.log("start the game map"), this.soundManager.playSound(Sounds.ButtonClick), this.stateManager.switchToState(BoilerPlate.GameMap.Name)
            }, e.prototype.onMusicOn = function(t) {
                this.userProfile.IsMusicOn = !0, this.userProfile.saveData(), this.soundManager.unmuteMusic(), this.soundManager.unmuteSounds(), this.soundManager.playSound(Sounds.ButtonClick)
            }, e.prototype.onMusicOff = function(t) {
                this.userProfile.IsMusicOn = !1, this.userProfile.saveData(), this.soundManager.muteMusic(), this.soundManager.muteSounds()
            }, e
        }();
        e.GameTitleController = i
    }(t.controllers || (t.controllers = {}))
}(GameSrc || (GameSrc = {}));
var BoilerPlate;
! function(t) {
    var e = function(e) {
        function i() {
            var t = e.call(this) || this;
            return t.name = i.Name, t.resetData(), t
        }
        return __extends(i, e), i.prototype.init = function() {
            e.prototype.init.call(this), this.game.world.removeAll(!0, !0, !0), t.Save.Game.getInstance(this.game, this.onSaveDataLoad, this, !1)
        }, i.prototype.create = function() {
            e.prototype.create.call(this), this.game.analytics.google.sendScreenView("menu"), GameSrc.settings.LevelStarsSettings.init(this.game), GameSrc.settings.UserProfileSettings.init(this.game, t.Save.Game.getInstance()), this.createGameTitleController(), this.labelVersion = new t.Label(this.game, 0, 0, GameSrc.config.GameConfig.gameBuildVersion, {
                font: "bold " + 20 * Constants.GAME_SCALE + "px Arial",
                fill: "#ffffff"
            }), this.labelVersion.y = this.game.height - this.labelVersion.height, this.resize()
        }, i.prototype.resize = function() {
            GameSrc.config.GameConfig.calcGameScale = this.game.width / Constants.GAME_WIDTH, this.labelVersion.scale.set(GameSrc.config.GameConfig.calcGameScale), this.labelVersion.y = this.game.height - this.labelVersion.height, this.gameTitleController.resize()
        }, i.prototype.shutdown = function() {
            console.log("GameTitle: shutdown"), this.disposeGameTitleController(), this.resetData(), e.prototype.shutdown.call(this)
        }, i.prototype.createGameTitleController = function() {
            this.gameTitleController = new GameSrc.controllers.GameTitleController(this.game), this.gameTitleController.startInit()
        }, i.prototype.disposeGameTitleController = function() {
            null !== this.gameTitleController && this.gameTitleController.dispose()
        }, i.prototype.resetData = function() {
            this.gameTitleController = null
        }, i.prototype.onSaveDataLoad = function() {
            console.log("onSaveDataLoad"), t.SoundManager.getInstance(this.game), GameSrc.settings.UserProfileSettings.getInstance().loadSavedData(), this.gameTitleController.continueInit()
        }, i.Name = "gameTitle", i
    }(Phaser.State);
    t.GameTitle = e
}(BoilerPlate || (BoilerPlate = {}));
var Fabrique;
! function(t) {
    var e = function() {
        function t() {}
        return t.show = function() {
            var t = document.getElementById("loader");
            t && (t.style.display = "block")
        }, t.hide = function() {
            var t = document.getElementById("loader");
            t && (t.style.display = "none")
        }, t
    }();
    t.LoaderHelper = e
}(Fabrique || (Fabrique = {}));
var BoilerPlate;
! function(t) {
    var e = function(e) {
        function i() {
            var t = e.call(this) || this;
            return t.name = i.Name, t
        }
        return __extends(i, e), i.prototype.init = function() {
            var t = this;
            this.focusManager = GameSrc.managers.AppFocusManager.getInstance(), this.game.analytics.game.setup(Constants.GAME_KEY, Constants.SECRET_KEY, version, this.game.analytics.game.createUser());
            var e = Date.now();
            window.addEventListener("beforeunload", function() {
                t.game.analytics.game.addEvent(new GA.Events.SessionEnd((Date.now() - e) / 1e3)), t.game.analytics.game.sendEvents()
            }), this.game.analytics.google.setup(Constants.GOOGLE_ID, Constants.GOOGLE_APP_NAME, version), this.game.analytics.google.sendScreenView("boot"), this.game.input.maxPointers = 2, this.game.input.addPointer(), this.game.canvas.oncontextmenu = function(t) {
                t.preventDefault()
            }, this.game.ads.setAdProvider(new PhaserAds.AdProvider.GameDistributionAds(this.game, Constants.GAMEDISTRIBUTION_ID, Constants.GAMEDISTRIBUTION_USER)), this.game.device.desktop ? (this.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL, this.scale.pageAlignHorizontally = !0, this.game.scale.windowConstraints.bottom = "visual", this.game.onBlur.add(function(e) {
                t.focusManager.focusOut()
            }), this.game.onFocus.add(function(e) {
                t.focusManager.focusIn()
            })) : (GameSrc.config.GameConfig.isOnMobileDevice = !0, this.scale.scaleMode = Phaser.ScaleManager.USER_SCALE, this.scale.fullScreenScaleMode = Phaser.ScaleManager.USER_SCALE, window.addEventListener("resize", function(e) {
                return i.mobileResizeCallback(t.game.scale)
            }), this.game.scale.onSizeChange.add(function() {
                Constants.LANDSCAPE_LOCKED ? t.game.width > t.game.height ? t.handleCorrect() : t.handleIncorrect() : Constants.PORTRAIT_LOCKED && (t.game.width < t.game.height ? t.handleCorrect() : t.handleIncorrect()), t.game.state.getCurrentState().resize()
            }, this), i.mobileResizeCallback(this.game.scale), Fabrique.Utils.isOnDevice(this.game) ? (document.addEventListener("pause", function() {
                t.focusManager.focusOut()
            }), document.addEventListener("resume", function() {
                t.focusManager.focusIn()
            })) : (this.stage.disableVisibilityChange = !1, this.game.onPause.add(function(e) {
                t.focusManager.focusOut()
            }), this.game.onResume.add(function(e) {
                t.focusManager.focusIn()
            })))
        }, i.mobileResizeCallback = function(t) {
            var e = Math.max(window.innerWidth, document.documentElement.clientWidth),
                s = Math.max(window.innerHeight, document.documentElement.clientHeight);
            i.setScaling(t.game);
            var o = Constants.GAME_WIDTH * Constants.GAME_SCALE,
                n = Constants.GAME_HEIGHT * Constants.GAME_SCALE,
                a = 1;
            a /= e > s ? s / n : s / o, Constants.CALCULATED_WIDTH = Math.ceil(e * a), Constants.CALCULATED_HEIGHT = Math.ceil(s * a), t.setGameSize(Constants.CALCULATED_WIDTH, Constants.CALCULATED_HEIGHT), t.setUserScale(1 / a, 1 / a), Constants.LANDSCAPE_LOCKED && (t.game.width > t.game.height ? (document.getElementById("orientation").style.display = "none", document.getElementById("content").style.display = "block") : (document.getElementById("orientation").style.display = "block", document.getElementById("content").style.display = "none"))
        }, i.setScaling = function(t) {
            Constants.GAME_SCALE = 1
        }, i.prototype.preload = function() {
            var t = this;
            this.game.load.cacheBuster = "undefined" == typeof version ? null : version;
            var e = "x" + Constants.GAME_SCALE + "/";
            Images.preloadList.forEach(function(i) {
                t.game.load.image(i, "assets/images/" + e + i + ".png")
            }), Atlases.preloadList.forEach(function(i) {
                t.game.load.atlas(i, "assets/atlases/" + e + i + ".png", "assets/atlases/" + e + i + ".json")
            }), Sounds.preloadList.forEach(function(e) {
                t.game.device.iOS ? t.game.load.audio(e, ["assets/sounds/" + e + ".m4a"]) : t.game.load.audio(e, ["assets/sounds/" + e + ".ogg", "assets/sounds/" + e + ".mp3"])
            })
        }, i.prototype.create = function() {
            var e = this;
            Fabrique.LoaderHelper.hide(), this.game.analytics.google.sendScreenView("splash"), this.game.state.start(Fabrique.SplashScreen.Preloader.Name, !0, !1, {
                nextState: t.GameTitle.Name,
                mobilePlayClickhandler: function() {
                    Fabrique.LoaderHelper.show(), e.game.ads.onContentPaused.addOnce(function() {
                        Fabrique.LoaderHelper.hide(), e.game.analytics.google.sendScreenView("advertisement")
                    }), e.game.ads.onContentResumed.addOnce(function() {
                        Fabrique.LoaderHelper.hide(), e.game.state.start(t.GameTitle.Name), e.game.ads.onContentPaused.removeAll(), e.game.ads.onContentResumed.removeAll()
                    }), e.game.ads.showAd()
                },
                preloadHandler: function() {
                    e.game.sound.muteOnPause = !0;
                    var t = "x" + Constants.GAME_SCALE + "/";
                    Images.list.forEach(function(i) {
                        e.game.load.image(i, "assets/images/" + t + i + ".png")
                    }), Atlases.list.forEach(function(i) {
                        e.game.load.atlas(i, "assets/atlases/" + t + i + ".png", "assets/atlases/" + t + i + ".json")
                    }), Settings.list.forEach(function(t) {
                        e.game.load.json(t.key, t.path)
                    }), Sounds.list.forEach(function(t) {
                        e.game.device.iOS ? e.game.load.audio(t, ["assets/sounds/" + t + ".m4a"]) : e.game.load.audio(t, ["assets/sounds/" + t + ".ogg", "assets/sound/" + t + ".mp3"])
                    }), Fabrique.Branding.preloadImages(e.game)
                }
            })
        }, i.prototype.handleCorrect = function() {
            this.wasPaused || (t.Gameplay.pause = !1), document.getElementById("orientation").style.display = "none", document.getElementById("content").style.display = "block"
        }, i.prototype.handleIncorrect = function() {
            this.wasPaused = t.Gameplay.pause, this.wasPaused || (t.Gameplay.pause = !0), document.getElementById("orientation").style.display = "block", document.getElementById("content").style.display = "none"
        }, i.Name = "boot", i
    }(Phaser.State);
    t.Boot = e
}(BoilerPlate || (BoilerPlate = {}));
var BoilerPlate;
! function(t) {
    var e = function(e) {
        function i() {
            var t = e.call(this, {
                enableDebug: GameSrc.config.GameConfig.enablePhaserDebug,
                width: Constants.GAME_WIDTH,
                height: Constants.GAME_HEIGHT,
                renderer: GameSrc.config.GameConfig.phaserRenderType,
                parent: "content",
                transparent: !0,
                antialias: !0,
                preserveDrawingBuffer: !1,
                physicsConfig: null,
                seed: "",
                state: null,
                forceSetTimeOut: !1
            }) || this;
            return t.clearBeforeRender = !1, GameSrc.config.GameConfig.init(), Phaser.Device.whenReady(function() {
                t.stage.disableVisibilityChange = !0;
                var e = t.device.desktop ? "click" : "touchstart";
                document.getElementById("content").addEventListener(e, function(e) {
                    t.gameResumed(e)
                })
            }), t.state.add("game", {
                create: t.stateCreator.bind(t),
                preload: t.statePreloader.bind(t)
            }, !0), t
        }
        return __extends(i, e), i.prototype.statePreloader = function() {
            var t = this;
            libs.forEach(function(e) {
                t.load.script(e, e)
            }), this.state.game.load.json(GameSrc.settings.GameCommonSettings.DataKey, GameSrc.config.GameConfig.startUpGameCommonSettingsDataPath)
        }, i.prototype.stateCreator = function() {
            var e = this;
            GameSrc.managers.AppFocusManager.init(this.state.game), GameSrc.managers.StateManager.init(this.state.game), GameSrc.settings.GameCommonSettings.init(this.state.game), this.plugins.add(Fabrique.Plugins.GameEvents), this.plugins.add(Fabrique.Plugins.GoogleAnalytics), this.plugins.add(Fabrique.Plugins.GameAnalytics), this.plugins.add(PhaserAds.AdManager), this.plugins.add(PhaserSuperStorage.StoragePlugin), this.plugins.add(PhaserCachebuster.CacheBuster), this.plugins.add(PhaserSpine.SpinePlugin), this.storage.forcePromises = !0, this.state.add(t.Boot.Name, t.Boot, !1), this.state.add(Fabrique.SplashScreen.Preloader.Name, Fabrique.SplashScreen.Preloader, !1), this.state.add(t.GameTitle.Name, t.GameTitle, !1), this.state.add(t.GameMap.Name, t.GameMap, !1), this.state.add(t.Gameplay.Name, t.Gameplay, !1);
            var i = function() {
                e.recursiveUpdateText(e.stage)
            };
            WebFont.load({
                custom: {
                    families: ["Aller Display", "QuickExpress"],
                    urls: ["assets/css/AllerDisplay.css", "assets/css/QuickExpress.css"]
                },
                active: i,
                inactive: i
            }), this.state.start(t.Boot.Name), this.state.remove("game")
        }, i.prototype.recursiveUpdateText = function(t) {
            var e = this;
            t instanceof Phaser.Text && (t.dirty = !0), t.children && t.children.length > 0 && t.children.forEach(function(t) {
                e.recursiveUpdateText(t)
            })
        }, i
    }(Phaser.Game);
    t.Game = e
}(BoilerPlate || (BoilerPlate = {}));
var BoilerPlate;
! function(t) {
    var e = function() {
        function t() {
            this.gameover = !1, this.score = 0, this.success = !1
        }
        return t.prototype.generateResponse = function() {
            return {
                score: this.score,
                gameover: this.gameover,
                success: this.success,
                config: {}
            }
        }, t
    }();
    t.Backend = e
}(BoilerPlate || (BoilerPlate = {}));
var Fabrique;
! function(t) {
    ! function(t) {
        var e = function(t) {
            function e(e, i, s) {
                void 0 === s && (s = null);
                var o = t.call(this, e) || this;
                o.beginFill(i, 1), o.drawRect(0, 0, o.game.width, o.game.height), e.add.group(o, "white", !0).add(o);
                var n = o.game.add.tween(o);
                return n.to({
                    alpha: 0
                }, 100), n.onComplete.add(function() {
                    null !== s && s()
                }), n.start(), o
            }
            return __extends(e, t), e
        }(Phaser.Graphics);
        t.FadeFromColor = e
    }(t.Effects || (t.Effects = {}))
}(Fabrique || (Fabrique = {}));
var Fabrique;
! function(t) {
    ! function(t) {
        var e = function(t) {
            function e(e, i, s, o) {
                var n = t.call(this, e) || this;
                n.alpha = 0, n.beginFill(i, 1), n.drawRect(0, 0, n.game.width, n.game.height), e.add.existing(n);
                var a = n.game.add.tween(n);
                return a.to({
                    alpha: 1
                }, 100), a.onComplete.add(function() {
                    e.state.start(s, !0, !1, o)
                }), a.start(), n
            }
            return __extends(e, t), e
        }(Phaser.Graphics);
        t.FadeToColor = e
    }(t.Effects || (t.Effects = {}))
}(Fabrique || (Fabrique = {}));
var Fabrique;
! function(t) {
    ! function(t) {
        var e = function() {
            function t() {}
            return t.fromTop = function(e, i) {
                t.boundsSet || t.setBounds(e), e.world.cacheAsBitmap = !0, e.add.tween(e.camera).from({
                    y: e.height
                }, t.SlideTime, t.EaseIn, !0).onComplete.add(function() {
                    void 0 !== i && i(), e.world.cacheAsBitmap = !1
                })
            }, t.toRight = function(e, i) {
                t.boundsSet || t.setBounds(e), e.world.cacheAsBitmap = !0, e.add.tween(e.camera).to({
                    x: -e.width
                }, t.SlideTime, t.EaseOut, !0).onComplete.add(function() {
                    void 0 !== i && i(), e.world.cacheAsBitmap = !1
                })
            }, t.fromRight = function(e, i) {
                t.boundsSet || t.setBounds(e), e.world.cacheAsBitmap = !0, e.add.tween(e.camera).from({
                    x: -e.width
                }, t.SlideTime, t.EaseIn, !0).onComplete.add(function() {
                    void 0 !== i && i(), e.world.cacheAsBitmap = !1
                })
            }, t.toLeft = function(e, i) {
                t.boundsSet || t.setBounds(e), e.world.cacheAsBitmap = !0, e.add.tween(e.camera).to({
                    x: e.width
                }, t.SlideTime, t.EaseOut, !0).onComplete.add(function() {
                    void 0 !== i && i(), e.world.cacheAsBitmap = !1
                })
            }, t.fromLeft = function(e, i) {
                t.boundsSet || t.setBounds(e), e.world.cacheAsBitmap = !0, e.add.tween(e.camera).from({
                    x: e.width
                }, t.SlideTime, t.EaseIn, !0).onComplete.add(function() {
                    void 0 !== i && i(), e.world.cacheAsBitmap = !1
                })
            }, t.setBounds = function(e) {
                e.world.setBounds(-e.width, -e.height, 3 * e.width, 3 * e.height), t.boundsSet = !0
            }, t.SlideTime = 250, t.EaseIn = Phaser.Easing.Quartic.Out, t.EaseOut = Phaser.Easing.Quartic.In, t.boundsSet = !1, t
        }();
        t.SlideState = e
    }(t.Effects || (t.Effects = {}))
}(Fabrique || (Fabrique = {}));
var BoilerPlate;
! function(t) {
    var e = function(e) {
        function i(i, s, o, n, a, r, h, l, c) {
            var p = e.call(this, i, s, o, Atlases.GUI_GENERAL, r, h) || this;
            return p.anchor.set(.5), p.maxWidth = l || p.width, p.maxHeight = c || p.height, p.label = new t.Label(p.game, 0, 2 * Constants.GAME_SCALE, n, a, p.maxWidth, p.maxHeight), p.label.anchor.set(.5), p.addChild(p.label), p.game.add.existing(p), p
        }
        return __extends(i, e), i.prototype.createTexture = function(t) {
            var e = this.game.make.graphics(0, 0);
            e.beginFill(0, .3).drawRoundedRect(5, 5 * Constants.GAME_SCALE, this.maxWidth - 10 * Constants.GAME_SCALE, this.maxHeight, 15 * Constants.GAME_SCALE).beginFill(t).drawRoundedRect(0, 0, this.maxWidth, this.maxHeight, 15 * Constants.GAME_SCALE).lineStyle(3, 16777215).drawRoundedRect(0, 0, this.maxWidth - 2, this.maxHeight - 2, 15 * Constants.GAME_SCALE).endFill(), this.texture = e.generateTexture(), e.destroy(!0)
        }, i.prototype.setText = function(t) {
            this.label.setText(t)
        }, i.prototype.updateScaling = function(t) {
            this.scale.set(t), this.label.setMaxSize(.9 * this.width, .98 * this.height), this.label.setText(this.label.text)
        }, i.prototype.destroy = function(t) {
            this.label.destroy(t), this.id = null, this.label = null, e.prototype.destroy.call(this, t)
        }, i
    }(Phaser.Button);
    t.LabeledButton = e
}(BoilerPlate || (BoilerPlate = {}));
var GameSrc;
! function(t) {
    ! function(t) {
        ! function(t) {
            ! function(t) {
                var e = function() {
                    function t(t, e) {
                        this.resetData(), this.key = t, this.item = e
                    }
                    return Object.defineProperty(t.prototype, "Key", {
                        get: function() {
                            return this.key
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "Item", {
                        get: function() {
                            return this.item
                        },
                        set: function(t) {
                            this.item = t
                        },
                        enumerable: !0,
                        configurable: !0
                    }), t.prototype.dispose = function() {
                        this.resetData()
                    }, t.prototype.resetData = function() {
                        this.key = 0, this.item = null
                    }, t
                }();
                t.DictionaryItem = e
            }(t.number || (t.number = {}))
        }(t.dictionary || (t.dictionary = {}))
    }(t.types || (t.types = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(t) {
        ! function(t) {
            ! function(t) {
                var e = function() {
                    function e() {
                        this.count = 0, this.resetData(), this.initData(), this.isDisposed = !1
                    }
                    return Object.defineProperty(e.prototype, "Count", {
                        get: function() {
                            return this.count
                        },
                        enumerable: !0,
                        configurable: !0
                    }), e.prototype.hasItem = function(t) {
                        var e = 0,
                            i = this.items.length;
                        for (e = 0; e < i; e++)
                            if (this.items[e].Key === t) return !0;
                        return !1
                    }, e.prototype.getItem = function(t) {
                        var e = 0,
                            i = this.items.length;
                        for (e = 0; e < i; e++) {
                            var s = this.items[e];
                            if (s.Key === t) return s.Item
                        }
                        return null
                    }, e.prototype.getItemIndex = function(t) {
                        var e = 0,
                            i = this.items.length;
                        for (e = 0; e < i; e++)
                            if (this.items[e].Key === t) return e;
                        return -1
                    }, e.prototype.getItemWithIndex = function(t) {
                        return t < 0 || t >= this.count ? null : this.items[t].Item
                    }, e.prototype.addItem = function(e, i) {
                        if (this.hasItem(e)) {
                            var s = this.getItemIndex(e);
                            this.items[s].Item = i
                        } else {
                            var o = new t.DictionaryItem(e, i);
                            this.items.push(o), this.count += 1
                        }
                    }, e.prototype.dispose = function() {
                        this.isDisposed || (this.disposeItems(), this.resetData(), this.isDisposed = !0)
                    }, e.prototype.initData = function() {
                        this.items = new Array
                    }, e.prototype.disposeItems = function() {
                        var t = 0,
                            e = this.items.length;
                        for (t = 0; t < e; t++) this.items[t].dispose();
                        this.items.length = 0
                    }, e.prototype.resetData = function() {
                        this.count = 0, this.items = null
                    }, e
                }();
                t.Dictionary = e
            }(t.number || (t.number = {}))
        }(t.dictionary || (t.dictionary = {}))
    }(t.types || (t.types = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(e) {
        var i = function() {
            function e(t) {
                this.resetData(), this.isDisposed = !1, this.game = t, this.initData()
            }
            return e.prototype.registerButton = function(t, e) {
                var i = new s(t);
                i.butId = e, this.itemsDic.addItem(e, i)
            }, e.prototype.isButtonDown = function(t) {
                return !!this.itemsDic.hasItem(t) && this.itemsDic.getItem(t).IsButtonDown
            }, e.prototype.dispose = function() {
                if (!this.isDisposed) {
                    if (null !== this.itemsDic) {
                        var t = 0;
                        for (t = 0; t < this.itemsDic.Count; t++) this.itemsDic.getItemWithIndex(t).dispose();
                        this.itemsDic.dispose()
                    }
                    this.resetData(), this.isDisposed = !0
                }
            }, e.prototype.initData = function() {
                this.itemsDic = new t.types.dictionary.number.Dictionary
            }, e.prototype.resetData = function() {
                this.game = null, this.itemsDic = null
            }, e
        }();
        e.GamepadInput = i;
        var s = function(t) {
            function e(e) {
                var i = t.call(this) || this;
                return i.resetData(), i.buttonRef = e, i.isDisposed = !1, i.isButtonDown = !1, e.onInputDown.add(function() {
                    this.isButtonDown = !0
                }, i), e.onInputUp.add(function() {
                    this.isButtonDown = !1
                }, i), i
            }
            return __extends(e, t), Object.defineProperty(e.prototype, "IsButtonDown", {
                get: function() {
                    return this.isButtonDown
                },
                enumerable: !0,
                configurable: !0
            }), e.prototype.dispose = function() {
                this.isDisposed || (null !== this.buttonRef && (this.buttonRef.onInputDown.removeAll(), this.buttonRef.onInputUp.removeAll()), this.resetData(), this.isDisposed = !0)
            }, e.prototype.resetData = function() {
                this.butId = 0, this.isButtonDown = !1, this.buttonRef = null
            }, e
        }(t.types.dictionary.number.DictionaryItemObject)
    }(t.input || (t.input = {}))
}(GameSrc || (GameSrc = {}));
var GameSrc;
! function(t) {
    ! function(t) {
        var e = function() {
            function t(t) {
                this.resetData(), this.isDisposed = !1, this.game = t, this.init()
            }
            return Object.defineProperty(t.prototype, "Enabled", {
                get: function() {
                    return this.enabled
                },
                enumerable: !0,
                configurable: !0
            }), t.prototype.isKeyDown = function(t) {
                return !!this.enabled && this.game.input.keyboard.isDown(t)
            }, t.prototype.dispose = function() {
                this.isDisposed || (this.resetData(), this.isDisposed = !0)
            }, t.prototype.init = function() {
                this.game.input.keyboard.enabled && (this.enabled = !0)
            }, t.prototype.resetData = function() {
                this.game = null, this.enabled = !1
            }, t
        }();
        t.KeyboardInput = e
    }(t.input || (t.input = {}))
}(GameSrc || (GameSrc = {}));